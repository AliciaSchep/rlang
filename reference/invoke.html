<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Invoke a function with a list of arguments — invoke • rlang</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Invoke a function with a list of arguments — invoke" />
<meta property="og:description" content="
Normally, you invoke a R function by typing arguments manually. A
powerful alternative is to call a function with a list of arguments
assembled programmatically. This is the purpose of invoke()." />
<meta name="twitter:card" content="summary" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115082821-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-115082821-1');
</script>


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rlang</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.4.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../reference/lifecycle.html">Life cycle</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    News
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Release notes</li>
    <li>
      <a href="https://www.tidyverse.org/articles/2019/06/rlang-0-4-0/">Version 0.4.0</a>
    </li>
    <li>
      <a href="https://www.tidyverse.org/articles/2019/01/rlang-0-3-1/">Version 0.3.1</a>
    </li>
    <li>
      <a href="https://www.tidyverse.org/articles/2018/10/rlang-0-3-0/">Version 0.3.0</a>
    </li>
    <li>
      <a href="https://www.tidyverse.org/articles/2018/03/rlang-0.2.0/">Version 0.2.0</a>
    </li>
    <li class="divider"></li>
    <li>
      <a href="../news/index.html">Change log</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/r-lib/rlang">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Invoke a function with a list of arguments</h1>
    <small class="dont-index">Source: <a href='https://github.com/r-lib/rlang/blob/master/R/eval.R'><code>R/eval.R</code></a></small>
    <div class="hidden name"><code>invoke.Rd</code></div>
    </div>

    <div class="ref-description">
    <p><img src='figures/lifecycle-soft-deprecated.svg' alt='Soft-deprecated lifecycle' /></p>
<p>Normally, you invoke a R function by typing arguments manually. A
powerful alternative is to call a function with a list of arguments
assembled programmatically. This is the purpose of <code>invoke()</code>.</p>
    </div>

    <pre class="usage"><span class='fu'>invoke</span>(<span class='no'>.fn</span>, <span class='kw'>.args</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(), <span class='no'>...</span>, <span class='kw'>.env</span> <span class='kw'>=</span> <span class='fu'><a href='caller_env.html'>caller_env</a></span>(),
  <span class='kw'>.bury</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>".fn"</span>, <span class='st'>""</span>))</pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>.fn</th>
      <td><p>A function to invoke. Can be a function object or the
name of a function in scope of <code>.env</code>.</p></td>
    </tr>
    <tr>
      <th>.args, ...</th>
      <td><p>List of arguments (possibly named) to be passed to
<code>.fn</code>.</p></td>
    </tr>
    <tr>
      <th>.env</th>
      <td><p>The environment in which to call <code>.fn</code>.</p></td>
    </tr>
    <tr>
      <th>.bury</th>
      <td><p>A character vector of length 2. The first string
specifies which name should the function have in the call
recorded in the evaluation stack. The second string specifies a
prefix for the argument names. Set <code>.bury</code> to <code>NULL</code> if you
prefer to inline the function and its arguments in the call.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>Technically, <code>invoke()</code> is basically a version of <code><a href='https://rdrr.io/r/base/do.call.html'>base::do.call()</a></code>
that creates cleaner call traces because it does not inline the
function and the arguments in the call (see examples). To achieve
this, <code>invoke()</code> creates a child environment of <code>.env</code> with <code>.fn</code>
and all arguments bound to new symbols (see <code><a href='env_bury.html'>env_bury()</a></code>). It then
uses the same strategy as <code><a href='eval_bare.html'>eval_bare()</a></code> to evaluate with minimal
noise.</p>
    <h2 class="hasAnchor" id="life-cycle"><a class="anchor" href="#life-cycle"></a>Life cycle</h2>

    


<p><code>invoke()</code> is soft-deprecated in favour of <code><a href='exec.html'>exec()</a></code>. Now that we
understand better the interaction between unquoting and dots
capture, we can take a simpler approach in <code><a href='exec.html'>exec()</a></code>.</p>
<p>If you need finer control over the generated call, you should construct
an environment and call yourself, manually burying large objects
or complex expressions.</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># invoke() has the same purpose as do.call():</span>
<span class='fu'>invoke</span>(<span class='no'>paste</span>, <span class='no'>letters</span>)</div><div class='output co'>#&gt; <span class='warning'>Warning: `invoke()` is deprecated as of rlang 0.4.0.</span>
#&gt; <span class='warning'>Please use `exec()` or `eval(expr())`instead.</span>
#&gt; <span class='warning'><span style='color: #555555;'>This warning is displayed once per session.</span><span></span></div><div class='output co'>#&gt; [1] "a b c d e f g h i j k l m n o p q r s t u v w x y z"</div><div class='input'>
<span class='co'># But it creates much cleaner calls:</span>
<span class='fu'>invoke</span>(<span class='no'>call_inspect</span>, <span class='no'>mtcars</span>)</div><div class='output co'>#&gt; .fn(mpg = `1`, cyl = `2`, disp = `3`, hp = `4`, drat = `5`, wt = `6`, 
#&gt;     qsec = `7`, vs = `8`, am = `9`, gear = `10`, carb = `11`)</div><div class='input'>
<span class='co'># and stacktraces:</span>
<span class='no'>fn</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>...</span>) <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>sys.calls</a></span>()
<span class='fu'>invoke</span>(<span class='no'>fn</span>, <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(<span class='no'>mtcars</span>))</div><div class='output co'>#&gt; [[1]]
#&gt; tryCatch(withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/tmp/RtmpGSP0ZP/file4f5888a103c")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try({
#&gt;         pxlib &lt;- as.environment("tools:callr")$`__callr_data__`$pxlib
#&gt;         if (is.null(e$code)) 
#&gt;             e$code &lt;- "301"
#&gt;         msg &lt;- paste0("base64::", pxlib$base64_encode(serialize(e, 
#&gt;             NULL)))
#&gt;         data &lt;- paste(e$code, msg, "\n")
#&gt;         pxlib$write_fd(3L, data)
#&gt;         if (!is.null(findRestart("muffleMessage"))) {
#&gt;             invokeRestart("muffleMessage")
#&gt;         }
#&gt;     })
#&gt; }), error = function(e) {
#&gt;     NULL
#&gt;     try(stop(e))
#&gt; }, interrupt = function(e) {
#&gt;     NULL
#&gt;     e
#&gt; })
#&gt; 
#&gt; [[2]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[3]]
#&gt; tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
#&gt;     names[nh], parentenv, handlers[[nh]])
#&gt; 
#&gt; [[4]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[5]]
#&gt; tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
#&gt; 
#&gt; [[6]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[7]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[8]]
#&gt; withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/tmp/RtmpGSP0ZP/file4f5888a103c")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try({
#&gt;         pxlib &lt;- as.environment("tools:callr")$`__callr_data__`$pxlib
#&gt;         if (is.null(e$code)) 
#&gt;             e$code &lt;- "301"
#&gt;         msg &lt;- paste0("base64::", pxlib$base64_encode(serialize(e, 
#&gt;             NULL)))
#&gt;         data &lt;- paste(e$code, msg, "\n")
#&gt;         pxlib$write_fd(3L, data)
#&gt;         if (!is.null(findRestart("muffleMessage"))) {
#&gt;             invokeRestart("muffleMessage")
#&gt;         }
#&gt;     })
#&gt; })
#&gt; 
#&gt; [[9]]
#&gt; saveRDS(do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/tmp/RtmpGSP0ZP/file4f5888a103c")
#&gt; 
#&gt; [[10]]
#&gt; do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv)
#&gt; 
#&gt; [[11]]
#&gt; (function (what, args, quote = FALSE, envir = parent.frame()) 
#&gt; {
#&gt;     if (!is.list(args)) 
#&gt;         stop("second argument must be a list")
#&gt;     if (quote) 
#&gt;         args &lt;- lapply(args, enquote)
#&gt;     .Internal(do.call(what, args, envir))
#&gt; })(function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; }, list(pkg = list(package = "rlang", version = list(c(0L, 4L, 
#&gt; 1L)), src_path = "/home/travis/build/r-lib/rlang", dst_path = "/tmp/RtmpGSP0ZP/file4f58692244b4", 
#&gt;     github_url = "https://github.com/r-lib/rlang", desc = &lt;environment&gt;, 
#&gt;     meta = list(url = "https://rlang.r-lib.org", template = list(
#&gt;         params = list(ganalytics = "UA-115082821-1")), home = list(
#&gt;         links = list(list(text = "The tidy eval bookdown", href = "https://tidyeval.tidyverse.org"))), 
#&gt;         navbar = list(structure = list(left = c("home", "reference", 
#&gt;         "lifecycle", "news"), right = "github"), components = list(
#&gt;             lifecycle = list(text = "Life cycle", href = "reference/lifecycle.html"), 
#&gt;             news = list(text = "News", menu = list(list(text = "Release notes"), 
#&gt;                 list(text = "Version 0.4.0", href = "https://www.tidyverse.org/articles/2019/06/rlang-0-4-0/"), 
#&gt;                 list(text = "Version 0.3.1", href = "https://www.tidyverse.org/articles/2019/01/rlang-0-3-1/"), 
#&gt;                 list(text = "Version 0.3.0", href = "https://www.tidyverse.org/articles/2018/10/rlang-0-3-0/"), 
#&gt;                 list(text = "Version 0.2.0", href = "https://www.tidyverse.org/articles/2018/03/rlang-0.2.0/"), 
#&gt;                 list(text = "------------------"), list(text = "Change log", 
#&gt;                   href = "news/index.html"))))), reference = list(
#&gt;             list(title = "Tidy evaluation", desc = "Quote arguments and expressions with unquoting support. The quosure variants wrap an environment with the expression.\n", 
#&gt;                 contents = c("quo", "quos", "enquo", "enquos", 
#&gt;                 "expr", "exprs", "enexpr", "enexprs", "quasiquotation", 
#&gt;                 "as_label", "as_name")), list(title = "Tidy dots", 
#&gt;                 desc = "Collect arguments contained in `...` with `!!!` and name-unquoting support.\n", 
#&gt;                 contents = c("list2", "dots_list", "pairlist2"
#&gt;                 )), list(title = "Errors, conditions, and backtraces", 
#&gt;                 contents = c("abort", "warn", "inform", "signal", 
#&gt;                 "trace_back", "with_abort", "entrace", "cnd_signal", 
#&gt;                 "last_error", "rlang_backtrace_on_error", "catch_cnd"
#&gt;                 )), list(title = "Evaluate expressions", contents = c("eval_tidy", 
#&gt;             "eval_bare", "exec")), list(title = "Symbols", contents = c("sym", 
#&gt;             "syms", "is_symbol", "as_string")), list(title = "Calls", 
#&gt;                 contents = c("starts_with(\"call_\")", "call2", 
#&gt;                 "is_call")), list(title = "Expressions", contents = c("starts_with(\"expr_\")", 
#&gt;             "starts_with(\"exprs_\")", "starts_with(\"parse_\")", 
#&gt;             "is_expression", "is_symbolic", "expr_text", "expr_label", 
#&gt;             "expr_name", "set_expr", "get_expr")), list(title = "Quosures", 
#&gt;                 contents = c("starts_with(\"quo_\")", "new_quosure", 
#&gt;                 "is_quosure", "as_quosure", "is_quosures", "quos_auto_name"
#&gt;                 )), list(title = "Formulas", contents = c("starts_with(\"f_\")", 
#&gt;             "new_formula", "is_formula", "is_bare_formula")), 
#&gt;             list(title = "Functions", contents = c("starts_with(\"fn_\")", 
#&gt;             "new_function", "is_function", "is_closure", "is_primitive", 
#&gt;             "as_function", "as_closure")), list(title = "Environments", 
#&gt;                 contents = c("env", "new_environment", "env_print", 
#&gt;                 "env_parent", "env_tail", "env_parents", "env_depth", 
#&gt;                 "get_env", "set_env", "env_clone", "env_inherits", 
#&gt;                 "is_environment", "is_bare_environment", "as_environment", 
#&gt;                 "caller_env")), list(title = "Environment bindings", 
#&gt;                 contents = c("env_bind", "env_bind_lazy", "env_bind_active", 
#&gt;                 "env_unbind", "with_bindings", "scoped_bindings", 
#&gt;                 "env_has", "env_get", "env_get_list", "env_names", 
#&gt;                 "env_length", "env_poke")), list(title = "Search path and namespaces", 
#&gt;                 contents = c("search_envs", "search_env", "base_env", 
#&gt;                 "global_env", "empty_env", "is_installed", "is_namespace", 
#&gt;                 "ns_env", "pkg_env", "env_name", "env_label")), 
#&gt;             list(title = "S3", contents = c("inherits_any", "inherits_all", 
#&gt;             "inherits_only", "new_box", "is_box", "as_box", "as_box_if", 
#&gt;             "unbox", "zap", "is_zap", "done")), list(title = "Create vectors", 
#&gt;                 desc = "Atomic vector constructors have implicit splicing (i.e. splice lists automatically), while the list constructor has explicit splicing.\n", 
#&gt;                 contents = c("lgl", "int", "dbl", "cpl", "chr", 
#&gt;                 "list2", "rep_along", "rep_named", "seq2", "seq2_along"
#&gt;                 )), list(title = "Attributes", contents = c("set_names", 
#&gt;             "names2", "has_name", "is_named")), list(title = "Type predicates", 
#&gt;                 contents = c("is_list", "is_atomic", "is_vector", 
#&gt;                 "is_integer", "is_double", "is_character", "is_logical", 
#&gt;                 "is_raw", "is_bytes", "is_scalar_list", "is_scalar_atomic", 
#&gt;                 "is_scalar_vector", "is_scalar_integer", "is_scalar_double", 
#&gt;                 "is_scalar_character", "is_scalar_logical", "is_scalar_raw", 
#&gt;                 "is_scalar_bytes", "is_bare_list", "is_bare_atomic", 
#&gt;                 "is_bare_vector", "is_bare_double", "is_bare_integer", 
#&gt;                 "is_bare_numeric", "is_bare_character", "is_bare_logical", 
#&gt;                 "is_bare_raw", "is_bare_bytes", "is_empty", "is_integerish", 
#&gt;                 "is_bare_integerish", "is_scalar_integerish", 
#&gt;                 "is_null", "is_true", "is_false", "is_string", 
#&gt;                 "is_bool", "is_bare_string")), list(title = "Operators", 
#&gt;                 contents = c("`%||%`", "`%|%`", "`%@%`")), list(
#&gt;                 title = "Function arguments", contents = c("arg_match", 
#&gt;                 "missing_arg", "is_missing", "maybe_missing")), 
#&gt;             list(title = "Create tidy evaluation APIs", desc = "Create data masking APIs à-la dplyr or tidyr. These functions are meant for developers rather than users.\n", 
#&gt;                 contents = c("`tidyeval-data`", "eval_tidy", 
#&gt;                 "as_data_mask", "new_data_mask", "as_data_pronoun"
#&gt;                 )), list(title = "Condition handlers", contents = c("with_handlers", 
#&gt;             "calling")), list(title = "Session state", contents = c("matches(\"interactive\")", 
#&gt;             "matches(\"option\")")), list(title = "Weak references", 
#&gt;                 contents = c("matches(\"weakref\")", "matches(\"wref\")"
#&gt;                 ))), destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     figures = list(dev = "grDevices::png", dpi = 96L, dev.args = list(), 
#&gt;         fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, 
#&gt;         fig.retina = 2L, fig.asp = 0.618046971569839), development = list(
#&gt;         destination = "dev", mode = "release", version_label = "default", 
#&gt;         version_tooltip = "Released version", in_dev = FALSE), 
#&gt;     topics = list(name = c("abort", "are_na", "arg_match", "as_box", 
#&gt;     "as_bytes", "as_data_mask", "as_env", "as_environment", "as_function", 
#&gt;     "as_label", "as_name", "as_overscope", "as_pairlist", "as_quosure", 
#&gt;     "as_string", "as_utf8_character", "bare-type-predicates", 
#&gt;     "box", "call2", "call_args", "call_fn", "call_inspect", "call_modify", 
#&gt;     "call_name", "call_standardise", "caller_env", "caller_fn", 
#&gt;     "caller_frame", "catch_cnd", "chr_unserialise_unicode", "error_cnd", 
#&gt;     "cnd_message", "cnd_muffle", "cnd_signal", "cnd_type", "done", 
#&gt;     "dots_definitions", "dots_n", "dots_values", "duplicate", 
#&gt;     "empty_env", "entrace", "env", "env_bind", "env_bind_exprs", 
#&gt;     "env_binding_are_active", "env_binding_lock", "env_bury", 
#&gt;     "env_clone", "env_depth", "env_get", "env_has", "env_inherits", 
#&gt;     "env_lock", "env_name", "env_names", "env_parent", "env_poke", 
#&gt;     "env_print", "env_unbind", "env_unlock", "eval_bare", "eval_tidy", 
#&gt;     "exec", "exiting", "expr_interp", "expr_label", "expr_print", 
#&gt;     "exprs_auto_name", "f_rhs", "f_text", "flatten", "fn_body", 
#&gt;     "fn_env", "fn_fmls", "frame_position", "friendly_type", "get_env", 
#&gt;     "has_length", "has_name", "inherits_any", "invoke", "is_call", 
#&gt;     "is_callable", "is_condition", "is_copyable", "is_empty", 
#&gt;     "is_env", "is_environment", "is_expr", "is_expression", "is_formula", 
#&gt;     "is_frame", "is_function", "is_installed", "is_integerish", 
#&gt;     "is_interactive", "is_lang", "is_named", "is_namespace", 
#&gt;     "is_pairlist", "is_reference", "is_stack", "is_symbol", "is_true", 
#&gt;     "is_weakref", "lang", "lang_head", "lang_modify", "last_error", 
#&gt;     "lifecycle", "missing", "missing_arg", "mut_node_car", "names2", 
#&gt;     "new-vector-along-retired", "new-vector", "new_call", "new_formula", 
#&gt;     "new_function", "new_node", "new_quosures", "new_weakref", 
#&gt;     "ns_env", "op-definition", "op-get-attr", "op-na-default", 
#&gt;     "op-null-default", "overscope_eval_next", "pairlist2", "parse_expr", 
#&gt;     "parse_quosure", "prepend", "prim_name", "quasiquotation", 
#&gt;     "quo_expr", "quo_label", "quo_squash", "quosure", "quotation", 
#&gt;     "rep_along", "restarting", "return_from", "rlang_backtrace_on_error", 
#&gt;     "rst_abort", "rst_list", "scalar-type-predicates", "scoped_bindings", 
#&gt;     "scoped_env", "scoped_options", "search_envs", "seq2", "set_attrs", 
#&gt;     "set_expr", "set_names", "splice", "stack", "stack_trim", 
#&gt;     "string", "switch_type", "sym", "tidy-dots", "tidyeval-data", 
#&gt;     "trace_back", "type-predicates", "type_of", "vec_poke_n", 
#&gt;     "vector-coercion", "vector-construction", "node", "with_abort", 
#&gt;     "with_env", "with_handlers", "with_restarts", "wref_key", 
#&gt;     "zap"), file_in = c("abort.Rd", "are_na.Rd", "arg_match.Rd", 
#&gt;     "as_box.Rd", "as_bytes.Rd", "as_data_mask.Rd", "as_env.Rd", 
#&gt;     "as_environment.Rd", "as_function.Rd", "as_label.Rd", "as_name.Rd", 
#&gt;     "as_overscope.Rd", "as_pairlist.Rd", "as_quosure.Rd", "as_string.Rd", 
#&gt;     "as_utf8_character.Rd", "bare-type-predicates.Rd", "box.Rd", 
#&gt;     "call2.Rd", "call_args.Rd", "call_fn.Rd", "call_inspect.Rd", 
#&gt;     "call_modify.Rd", "call_name.Rd", "call_standardise.Rd", 
#&gt;     "caller_env.Rd", "caller_fn.Rd", "caller_frame.Rd", "catch_cnd.Rd", 
#&gt;     "chr_unserialise_unicode.Rd", "cnd.Rd", "cnd_message.Rd", 
#&gt;     "cnd_muffle.Rd", "cnd_signal.Rd", "cnd_type.Rd", "done.Rd", 
#&gt;     "dots_definitions.Rd", "dots_n.Rd", "dots_values.Rd", "duplicate.Rd", 
#&gt;     "empty_env.Rd", "entrace.Rd", "env.Rd", "env_bind.Rd", "env_bind_exprs.Rd", 
#&gt;     "env_binding_are_active.Rd", "env_binding_lock.Rd", "env_bury.Rd", 
#&gt;     "env_clone.Rd", "env_depth.Rd", "env_get.Rd", "env_has.Rd", 
#&gt;     "env_inherits.Rd", "env_lock.Rd", "env_name.Rd", "env_names.Rd", 
#&gt;     "env_parent.Rd", "env_poke.Rd", "env_print.Rd", "env_unbind.Rd", 
#&gt;     "env_unlock.Rd", "eval_bare.Rd", "eval_tidy.Rd", "exec.Rd", 
#&gt;     "exiting.Rd", "expr_interp.Rd", "expr_label.Rd", "expr_print.Rd", 
#&gt;     "exprs_auto_name.Rd", "f_rhs.Rd", "f_text.Rd", "flatten.Rd", 
#&gt;     "fn_body.Rd", "fn_env.Rd", "fn_fmls.Rd", "frame_position.Rd", 
#&gt;     "friendly_type.Rd", "get_env.Rd", "has_length.Rd", "has_name.Rd", 
#&gt;     "inherits_any.Rd", "invoke.Rd", "is_call.Rd", "is_callable.Rd", 
#&gt;     "is_condition.Rd", "is_copyable.Rd", "is_empty.Rd", "is_env.Rd", 
#&gt;     "is_environment.Rd", "is_expr.Rd", "is_expression.Rd", "is_formula.Rd", 
#&gt;     "is_frame.Rd", "is_function.Rd", "is_installed.Rd", "is_integerish.Rd", 
#&gt;     "is_interactive.Rd", "is_lang.Rd", "is_named.Rd", "is_namespace.Rd", 
#&gt;     "is_pairlist.Rd", "is_reference.Rd", "is_stack.Rd", "is_symbol.Rd", 
#&gt;     "is_true.Rd", "is_weakref.Rd", "lang.Rd", "lang_head.Rd", 
#&gt;     "lang_modify.Rd", "last_error.Rd", "lifecycle.Rd", "missing.Rd", 
#&gt;     "missing_arg.Rd", "mut_node_car.Rd", "names2.Rd", "new-vector-along-retired.Rd", 
#&gt;     "new-vector.Rd", "new_call.Rd", "new_formula.Rd", "new_function.Rd", 
#&gt;     "new_node.Rd", "new_quosures.Rd", "new_weakref.Rd", "ns_env.Rd", 
#&gt;     "op-definition.Rd", "op-get-attr.Rd", "op-na-default.Rd", 
#&gt;     "op-null-default.Rd", "overscope_eval_next.Rd", "pairlist2.Rd", 
#&gt;     "parse_expr.Rd", "parse_quosure.Rd", "prepend.Rd", "prim_name.Rd", 
#&gt;     "quasiquotation.Rd", "quo_expr.Rd", "quo_label.Rd", "quo_squash.Rd", 
#&gt;     "quosure.Rd", "quotation.Rd", "rep_along.Rd", "restarting.Rd", 
#&gt;     "return_from.Rd", "rlang_backtrace_on_error.Rd", "rst_abort.Rd", 
#&gt;     "rst_list.Rd", "scalar-type-predicates.Rd", "scoped_bindings.Rd", 
#&gt;     "scoped_env.Rd", "scoped_options.Rd", "search_envs.Rd", "seq2.Rd", 
#&gt;     "set_attrs.Rd", "set_expr.Rd", "set_names.Rd", "splice.Rd", 
#&gt;     "stack.Rd", "stack_trim.Rd", "string.Rd", "switch_type.Rd", 
#&gt;     "sym.Rd", "tidy-dots.Rd", "tidyeval-data.Rd", "trace_back.Rd", 
#&gt;     "type-predicates.Rd", "type_of.Rd", "vec_poke_n.Rd", "vector-coercion.Rd", 
#&gt;     "vector-construction.Rd", "vector-old-ctors.Rd", "with_abort.Rd", 
#&gt;     "with_env.Rd", "with_handlers.Rd", "with_restarts.Rd", "wref_key.Rd", 
#&gt;     "zap.Rd"), file_out = c("abort.html", "are_na.html", "arg_match.html", 
#&gt;     "as_box.html", "as_bytes.html", "as_data_mask.html", "as_env.html", 
#&gt;     "as_environment.html", "as_function.html", "as_label.html", 
#&gt;     "as_name.html", "as_overscope.html", "as_pairlist.html", 
#&gt;     "as_quosure.html", "as_string.html", "as_utf8_character.html", 
#&gt;     "bare-type-predicates.html", "box.html", "call2.html", "call_args.html", 
#&gt;     "call_fn.html", "call_inspect.html", "call_modify.html", 
#&gt;     "call_name.html", "call_standardise.html", "caller_env.html", 
#&gt;     "caller_fn.html", "caller_frame.html", "catch_cnd.html", 
#&gt;     "chr_unserialise_unicode.html", "cnd.html", "cnd_message.html", 
#&gt;     "cnd_muffle.html", "cnd_signal.html", "cnd_type.html", "done.html", 
#&gt;     "dots_definitions.html", "dots_n.html", "dots_values.html", 
#&gt;     "duplicate.html", "empty_env.html", "entrace.html", "env.html", 
#&gt;     "env_bind.html", "env_bind_exprs.html", "env_binding_are_active.html", 
#&gt;     "env_binding_lock.html", "env_bury.html", "env_clone.html", 
#&gt;     "env_depth.html", "env_get.html", "env_has.html", "env_inherits.html", 
#&gt;     "env_lock.html", "env_name.html", "env_names.html", "env_parent.html", 
#&gt;     "env_poke.html", "env_print.html", "env_unbind.html", "env_unlock.html", 
#&gt;     "eval_bare.html", "eval_tidy.html", "exec.html", "exiting.html", 
#&gt;     "expr_interp.html", "expr_label.html", "expr_print.html", 
#&gt;     "exprs_auto_name.html", "f_rhs.html", "f_text.html", "flatten.html", 
#&gt;     "fn_body.html", "fn_env.html", "fn_fmls.html", "frame_position.html", 
#&gt;     "friendly_type.html", "get_env.html", "has_length.html", 
#&gt;     "has_name.html", "inherits_any.html", "invoke.html", "is_call.html", 
#&gt;     "is_callable.html", "is_condition.html", "is_copyable.html", 
#&gt;     "is_empty.html", "is_env.html", "is_environment.html", "is_expr.html", 
#&gt;     "is_expression.html", "is_formula.html", "is_frame.html", 
#&gt;     "is_function.html", "is_installed.html", "is_integerish.html", 
#&gt;     "is_interactive.html", "is_lang.html", "is_named.html", "is_namespace.html", 
#&gt;     "is_pairlist.html", "is_reference.html", "is_stack.html", 
#&gt;     "is_symbol.html", "is_true.html", "is_weakref.html", "lang.html", 
#&gt;     "lang_head.html", "lang_modify.html", "last_error.html", 
#&gt;     "lifecycle.html", "missing.html", "missing_arg.html", "mut_node_car.html", 
#&gt;     "names2.html", "new-vector-along-retired.html", "new-vector.html", 
#&gt;     "new_call.html", "new_formula.html", "new_function.html", 
#&gt;     "new_node.html", "new_quosures.html", "new_weakref.html", 
#&gt;     "ns_env.html", "op-definition.html", "op-get-attr.html", 
#&gt;     "op-na-default.html", "op-null-default.html", "overscope_eval_next.html", 
#&gt;     "pairlist2.html", "parse_expr.html", "parse_quosure.html", 
#&gt;     "prepend.html", "prim_name.html", "quasiquotation.html", 
#&gt;     "quo_expr.html", "quo_label.html", "quo_squash.html", "quosure.html", 
#&gt;     "quotation.html", "rep_along.html", "restarting.html", "return_from.html", 
#&gt;     "rlang_backtrace_on_error.html", "rst_abort.html", "rst_list.html", 
#&gt;     "scalar-type-predicates.html", "scoped_bindings.html", "scoped_env.html", 
#&gt;     "scoped_options.html", "search_envs.html", "seq2.html", "set_attrs.html", 
#&gt;     "set_expr.html", "set_names.html", "splice.html", "stack.html", 
#&gt;     "stack_trim.html", "string.html", "switch_type.html", "sym.html", 
#&gt;     "tidy-dots.html", "tidyeval-data.html", "trace_back.html", 
#&gt;     "type-predicates.html", "type_of.html", "vec_poke_n.html", 
#&gt;     "vector-coercion.html", "vector-construction.html", "vector-old-ctors.html", 
#&gt;     "with_abort.html", "with_env.html", "with_handlers.html", 
#&gt;     "with_restarts.html", "wref_key.html", "zap.html"), alias = list(
#&gt;         abort.Rd = c("abort", "warn", "inform", "signal", "interrupt"
#&gt;         ), are_na.Rd = c("are_na", "is_na", "is_lgl_na", "is_int_na", 
#&gt;         "is_dbl_na", "is_chr_na", "is_cpl_na"), arg_match.Rd = "arg_match", 
#&gt;         as_box.Rd = c("as_box", "as_box_if"), as_bytes.Rd = "as_bytes", 
#&gt;         as_data_mask.Rd = c("as_data_mask", "as_data_pronoun", 
#&gt;         "new_data_mask"), as_env.Rd = "as_env", as_environment.Rd = "as_environment", 
#&gt;         as_function.Rd = c("as_function", "is_lambda", "as_closure"
#&gt;         ), as_label.Rd = "as_label", as_name.Rd = "as_name", 
#&gt;         as_overscope.Rd = c("as_overscope", "new_overscope", 
#&gt;         "overscope_clean"), as_pairlist.Rd = "as_pairlist", as_quosure.Rd = c("as_quosure", 
#&gt;         "new_quosure"), as_string.Rd = "as_string", as_utf8_character.Rd = "as_utf8_character", 
#&gt;         `bare-type-predicates.Rd` = c("bare-type-predicates", 
#&gt;         "is_bare_list", "is_bare_atomic", "is_bare_vector", "is_bare_double", 
#&gt;         "is_bare_integer", "is_bare_numeric", "is_bare_character", 
#&gt;         "is_bare_logical", "is_bare_raw", "is_bare_string", "is_bare_bytes"
#&gt;         ), box.Rd = c("box", "new_box", "is_box", "unbox"), call2.Rd = "call2", 
#&gt;         call_args.Rd = c("call_args", "call_args_names"), call_fn.Rd = "call_fn", 
#&gt;         call_inspect.Rd = "call_inspect", call_modify.Rd = "call_modify", 
#&gt;         call_name.Rd = c("call_name", "call_ns"), call_standardise.Rd = "call_standardise", 
#&gt;         caller_env.Rd = c("caller_env", "current_env"), caller_fn.Rd = c("caller_fn", 
#&gt;         "current_fn"), caller_frame.Rd = "caller_frame", catch_cnd.Rd = "catch_cnd", 
#&gt;         chr_unserialise_unicode.Rd = "chr_unserialise_unicode", 
#&gt;         cnd.Rd = c("error_cnd", "cnd", "warning_cnd", "message_cnd"
#&gt;         ), cnd_message.Rd = c("cnd_message", "cnd_issue", "cnd_bullets", 
#&gt;         "format_bullets"), cnd_muffle.Rd = "cnd_muffle", cnd_signal.Rd = "cnd_signal", 
#&gt;         cnd_type.Rd = "cnd_type", done.Rd = c("done", "is_done_box"
#&gt;         ), dots_definitions.Rd = "dots_definitions", dots_n.Rd = "dots_n", 
#&gt;         dots_values.Rd = "dots_values", duplicate.Rd = "duplicate", 
#&gt;         empty_env.Rd = "empty_env", entrace.Rd = c("entrace", 
#&gt;         "cnd_entrace"), env.Rd = c("env", "child_env", "new_environment"
#&gt;         ), env_bind.Rd = c("env_bind", "env_bind_lazy", "env_bind_active"
#&gt;         ), env_bind_exprs.Rd = c("env_bind_exprs", "env_bind_fns"
#&gt;         ), env_binding_are_active.Rd = c("env_binding_are_active", 
#&gt;         "env_binding_are_lazy"), env_binding_lock.Rd = c("env_binding_lock", 
#&gt;         "env_binding_unlock", "env_binding_are_locked"), env_bury.Rd = "env_bury", 
#&gt;         env_clone.Rd = "env_clone", env_depth.Rd = "env_depth", 
#&gt;         env_get.Rd = c("env_get", "env_get_list"), env_has.Rd = "env_has", 
#&gt;         env_inherits.Rd = "env_inherits", env_lock.Rd = c("env_lock", 
#&gt;         "env_is_locked"), env_name.Rd = c("env_name", "env_label"
#&gt;         ), env_names.Rd = c("env_names", "env_length"), env_parent.Rd = c("env_parent", 
#&gt;         "env_tail", "env_parents"), env_poke.Rd = "env_poke", 
#&gt;         env_print.Rd = "env_print", env_unbind.Rd = "env_unbind", 
#&gt;         env_unlock.Rd = "env_unlock", eval_bare.Rd = "eval_bare", 
#&gt;         eval_tidy.Rd = "eval_tidy", exec.Rd = "exec", exiting.Rd = "exiting", 
#&gt;         expr_interp.Rd = "expr_interp", expr_label.Rd = c("expr_label", 
#&gt;         "expr_name", "expr_text"), expr_print.Rd = c("expr_print", 
#&gt;         "expr_deparse"), exprs_auto_name.Rd = c("exprs_auto_name", 
#&gt;         "quos_auto_name"), f_rhs.Rd = c("f_rhs", "f_rhs&lt;-", "f_lhs", 
#&gt;         "f_lhs&lt;-", "f_env", "f_env&lt;-"), f_text.Rd = c("f_text", 
#&gt;         "f_name", "f_label"), flatten.Rd = c("flatten", "flatten_lgl", 
#&gt;         "flatten_int", "flatten_dbl", "flatten_cpl", "flatten_chr", 
#&gt;         "flatten_raw", "squash", "squash_lgl", "squash_int", 
#&gt;         "squash_dbl", "squash_cpl", "squash_chr", "squash_raw", 
#&gt;         "flatten_if", "squash_if"), fn_body.Rd = c("fn_body", 
#&gt;         "fn_body&lt;-"), fn_env.Rd = c("fn_env", "fn_env&lt;-"), fn_fmls.Rd = c("fn_fmls", 
#&gt;         "fn_fmls_names", "fn_fmls_syms", "fn_fmls&lt;-", "fn_fmls_names&lt;-"
#&gt;         ), frame_position.Rd = "frame_position", friendly_type.Rd = "friendly_type", 
#&gt;         get_env.Rd = c("get_env", "set_env", "env_poke_parent"
#&gt;         ), has_length.Rd = "has_length", has_name.Rd = "has_name", 
#&gt;         inherits_any.Rd = c("inherits_any", "inherits_all", "inherits_only"
#&gt;         ), invoke.Rd = "invoke", is_call.Rd = "is_call", is_callable.Rd = "is_callable", 
#&gt;         is_condition.Rd = "is_condition", is_copyable.Rd = "is_copyable", 
#&gt;         is_empty.Rd = "is_empty", is_env.Rd = c("is_env", "is_bare_env"
#&gt;         ), is_environment.Rd = c("is_environment", "is_bare_environment"
#&gt;         ), is_expr.Rd = "is_expr", is_expression.Rd = c("is_expression", 
#&gt;         "is_syntactic_literal", "is_symbolic"), is_formula.Rd = c("is_formula", 
#&gt;         "is_bare_formula"), is_frame.Rd = "is_frame", is_function.Rd = c("is_function", 
#&gt;         "is_closure", "is_primitive", "is_primitive_eager", "is_primitive_lazy"
#&gt;         ), is_installed.Rd = "is_installed", is_integerish.Rd = c("is_integerish", 
#&gt;         "is_bare_integerish", "is_scalar_integerish"), is_interactive.Rd = c("is_interactive", 
#&gt;         "scoped_interactive", "with_interactive"), is_lang.Rd = c("is_lang", 
#&gt;         "is_unary_lang", "is_binary_lang", "quo_is_lang"), is_named.Rd = c("is_named", 
#&gt;         "is_dictionaryish", "have_name"), is_namespace.Rd = "is_namespace", 
#&gt;         is_pairlist.Rd = c("is_pairlist", "is_node", "is_node_list"
#&gt;         ), is_reference.Rd = "is_reference", is_stack.Rd = c("is_stack", 
#&gt;         "is_eval_stack", "is_call_stack"), is_symbol.Rd = "is_symbol", 
#&gt;         is_true.Rd = c("is_true", "is_false"), is_weakref.Rd = "is_weakref", 
#&gt;         lang.Rd = c("lang", "new_language"), lang_head.Rd = c("lang_head", 
#&gt;         "lang_tail"), lang_modify.Rd = c("lang_modify", "lang_standardise", 
#&gt;         "lang_fn", "lang_name", "lang_args", "lang_args_names"
#&gt;         ), last_error.Rd = c("last_error", "last_trace"), lifecycle.Rd = "lifecycle", 
#&gt;         missing.Rd = c("missing", "na_lgl", "na_int", "na_dbl", 
#&gt;         "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg", 
#&gt;         "is_missing", "maybe_missing"), mut_node_car.Rd = c("mut_node_car", 
#&gt;         "mut_node_cdr", "mut_node_caar", "mut_node_cadr", "mut_node_cdar", 
#&gt;         "mut_node_cddr", "mut_node_tag"), names2.Rd = "names2", 
#&gt;         `new-vector-along-retired.Rd` = c("new-vector-along-retired", 
#&gt;         "new_logical_along", "new_integer_along", "new_double_along", 
#&gt;         "new_character_along", "new_complex_along", "new_raw_along", 
#&gt;         "new_list_along"), `new-vector.Rd` = c("new-vector", 
#&gt;         "new_logical", "new_integer", "new_double", "new_character", 
#&gt;         "new_complex", "new_raw", "new_list"), new_call.Rd = "new_call", 
#&gt;         new_formula.Rd = "new_formula", new_function.Rd = "new_function", 
#&gt;         new_node.Rd = c("new_node", "node_car", "node_cdr", "node_caar", 
#&gt;         "node_cadr", "node_cdar", "node_cddr", "node_poke_car", 
#&gt;         "node_poke_cdr", "node_poke_caar", "node_poke_cadr", 
#&gt;         "node_poke_cdar", "node_poke_cddr", "node_tag", "node_poke_tag"
#&gt;         ), new_quosures.Rd = c("new_quosures", "as_quosures", 
#&gt;         "is_quosures"), new_weakref.Rd = "new_weakref", ns_env.Rd = c("ns_env", 
#&gt;         "ns_imports_env", "ns_env_name"), `op-definition.Rd` = c("op-definition", 
#&gt;         "is_definition", "new_definition", "is_formulaish"), 
#&gt;         `op-get-attr.Rd` = c("op-get-attr", "%@%", "%@%&lt;-"), 
#&gt;         `op-na-default.Rd` = c("op-na-default", "%|%"), `op-null-default.Rd` = c("op-null-default", 
#&gt;         "%||%"), overscope_eval_next.Rd = "overscope_eval_next", 
#&gt;         pairlist2.Rd = "pairlist2", parse_expr.Rd = c("parse_expr", 
#&gt;         "parse_exprs", "parse_quo", "parse_quos"), parse_quosure.Rd = c("parse_quosure", 
#&gt;         "parse_quosures"), prepend.Rd = c("prepend", "modify"
#&gt;         ), prim_name.Rd = "prim_name", quasiquotation.Rd = c("quasiquotation", 
#&gt;         "UQ", "UQS", "{{}}", "{{", "!!", "!!!", ":=", "qq_show"
#&gt;         ), quo_expr.Rd = "quo_expr", quo_label.Rd = c("quo_label", 
#&gt;         "quo_text", "quo_name"), quo_squash.Rd = "quo_squash", 
#&gt;         quosure.Rd = c("quosure", "is_quosure", "quo_is_missing", 
#&gt;         "quo_is_symbol", "quo_is_call", "quo_is_symbolic", "quo_is_null", 
#&gt;         "quo_get_expr", "quo_get_env", "quo_set_expr", "quo_set_env"
#&gt;         ), quotation.Rd = c("quotation", "expr", "enexpr", "exprs", 
#&gt;         "enexprs", "ensym", "ensyms", "quo", "enquo", "quos", 
#&gt;         "enquos"), rep_along.Rd = c("rep_along", "rep_named"), 
#&gt;         restarting.Rd = "restarting", return_from.Rd = c("return_from", 
#&gt;         "return_to"), rlang_backtrace_on_error.Rd = c("rlang_backtrace_on_error", 
#&gt;         "add_backtrace"), rst_abort.Rd = "rst_abort", rst_list.Rd = c("rst_list", 
#&gt;         "rst_exists", "rst_jump", "rst_maybe_jump"), `scalar-type-predicates.Rd` = c("scalar-type-predicates", 
#&gt;         "is_scalar_list", "is_scalar_atomic", "is_scalar_vector", 
#&gt;         "is_scalar_integer", "is_scalar_double", "is_scalar_character", 
#&gt;         "is_scalar_logical", "is_scalar_raw", "is_string", "is_scalar_bytes", 
#&gt;         "is_bool"), scoped_bindings.Rd = c("scoped_bindings", 
#&gt;         "with_bindings"), scoped_env.Rd = c("scoped_env", "is_scoped", 
#&gt;         "scoped_envs", "scoped_names"), scoped_options.Rd = c("scoped_options", 
#&gt;         "with_options", "push_options", "peek_options", "peek_option"
#&gt;         ), search_envs.Rd = c("search_envs", "search_env", "pkg_env", 
#&gt;         "pkg_env_name", "is_attached", "base_env", "global_env"
#&gt;         ), seq2.Rd = c("seq2", "seq2_along"), set_attrs.Rd = c("set_attrs", 
#&gt;         "mut_attrs"), set_expr.Rd = c("set_expr", "get_expr"), 
#&gt;         set_names.Rd = "set_names", splice.Rd = c("splice", "is_spliced", 
#&gt;         "is_spliced_bare", "dots_splice"), stack.Rd = c("stack", 
#&gt;         "global_frame", "current_frame", "ctxt_frame", "call_frame", 
#&gt;         "ctxt_depth", "call_depth", "ctxt_stack", "call_stack"
#&gt;         ), stack_trim.Rd = "stack_trim", string.Rd = "string", 
#&gt;         switch_type.Rd = c("switch_type", "coerce_type", "switch_class", 
#&gt;         "coerce_class"), sym.Rd = c("sym", "syms"), `tidy-dots.Rd` = c("tidy-dots", 
#&gt;         "dots_list", "list2"), `tidyeval-data.Rd` = c("tidyeval-data", 
#&gt;         ".data"), trace_back.Rd = c("trace_back", "trace_length"
#&gt;         ), `type-predicates.Rd` = c("type-predicates", "is_list", 
#&gt;         "is_atomic", "is_vector", "is_integer", "is_double", 
#&gt;         "is_character", "is_logical", "is_raw", "is_bytes", "is_null"
#&gt;         ), type_of.Rd = "type_of", vec_poke_n.Rd = c("vec_poke_n", 
#&gt;         "vec_poke_range"), `vector-coercion.Rd` = c("vector-coercion", 
#&gt;         "as_logical", "as_integer", "as_double", "as_complex", 
#&gt;         "as_character", "as_list"), `vector-construction.Rd` = c("vector-construction", 
#&gt;         "lgl", "int", "dbl", "cpl", "chr", "bytes", "ll"), `vector-old-ctors.Rd` = c("node", 
#&gt;         "vector-old-ctors", "lgl_len", "int_len", "dbl_len", 
#&gt;         "chr_len", "cpl_len", "raw_len", "bytes_len", "list_len", 
#&gt;         "lgl_along", "int_along", "dbl_along", "chr_along", "cpl_along", 
#&gt;         "raw_along", "bytes_along", "list_along"), with_abort.Rd = "with_abort", 
#&gt;         with_env.Rd = c("with_env", "locally"), with_handlers.Rd = c("with_handlers", 
#&gt;         "calling"), with_restarts.Rd = "with_restarts", wref_key.Rd = c("wref_key", 
#&gt;         "wref_value"), zap.Rd = c("zap", "is_zap")), funs = list(
#&gt;         abort.Rd = c("abort()", "warn()", "inform()", "signal()", 
#&gt;         "interrupt()"), are_na.Rd = c("are_na()", "is_na()", 
#&gt;         "is_lgl_na()", "is_int_na()", "is_dbl_na()", "is_chr_na()", 
#&gt;         "is_cpl_na()"), arg_match.Rd = "arg_match()", as_box.Rd = c("as_box()", 
#&gt;         "as_box_if()"), as_bytes.Rd = "as_bytes()", as_data_mask.Rd = c("as_data_mask()", 
#&gt;         "as_data_pronoun()", "new_data_mask()"), as_env.Rd = "as_env()", 
#&gt;         as_environment.Rd = "as_environment()", as_function.Rd = c("as_function()", 
#&gt;         "is_lambda()", "as_closure()"), as_label.Rd = "as_label()", 
#&gt;         as_name.Rd = "as_name()", as_overscope.Rd = c("as_overscope()", 
#&gt;         "new_overscope()", "overscope_clean()"), as_pairlist.Rd = "as_pairlist()", 
#&gt;         as_quosure.Rd = c("as_quosure()", "new_quosure()"), as_string.Rd = "as_string()", 
#&gt;         as_utf8_character.Rd = "as_utf8_character()", `bare-type-predicates.Rd` = c("is_bare_list()", 
#&gt;         "is_bare_atomic()", "is_bare_vector()", "is_bare_double()", 
#&gt;         "is_bare_integer()", "is_bare_numeric()", "is_bare_character()", 
#&gt;         "is_bare_logical()", "is_bare_raw()", "is_bare_string()", 
#&gt;         "is_bare_bytes()"), box.Rd = c("new_box()", "is_box()", 
#&gt;         "unbox()"), call2.Rd = "call2()", call_args.Rd = c("call_args()", 
#&gt;         "call_args_names()"), call_fn.Rd = "call_fn()", call_inspect.Rd = "call_inspect()", 
#&gt;         call_modify.Rd = "call_modify()", call_name.Rd = c("call_name()", 
#&gt;         "call_ns()"), call_standardise.Rd = "call_standardise()", 
#&gt;         caller_env.Rd = c("caller_env()", "current_env()"), caller_fn.Rd = c("caller_fn()", 
#&gt;         "current_fn()"), caller_frame.Rd = "caller_frame()", 
#&gt;         catch_cnd.Rd = "catch_cnd()", chr_unserialise_unicode.Rd = "chr_unserialise_unicode()", 
#&gt;         cnd.Rd = c("error_cnd()", "cnd()", "warning_cnd()", "message_cnd()"
#&gt;         ), cnd_message.Rd = c("cnd_message()", "cnd_issue()", 
#&gt;         "cnd_bullets()", "format_bullets()"), cnd_muffle.Rd = "cnd_muffle()", 
#&gt;         cnd_signal.Rd = "cnd_signal()", cnd_type.Rd = "cnd_type()", 
#&gt;         done.Rd = c("done()", "is_done_box()"), dots_definitions.Rd = "dots_definitions()", 
#&gt;         dots_n.Rd = "dots_n()", dots_values.Rd = "dots_values()", 
#&gt;         duplicate.Rd = "duplicate()", empty_env.Rd = "empty_env()", 
#&gt;         entrace.Rd = c("entrace()", "cnd_entrace()"), env.Rd = c("env()", 
#&gt;         "child_env()", "new_environment()"), env_bind.Rd = c("env_bind()", 
#&gt;         "env_bind_lazy()", "env_bind_active()"), env_bind_exprs.Rd = c("env_bind_exprs()", 
#&gt;         "env_bind_fns()"), env_binding_are_active.Rd = c("env_binding_are_active()", 
#&gt;         "env_binding_are_lazy()"), env_binding_lock.Rd = c("env_binding_lock()", 
#&gt;         "env_binding_unlock()", "env_binding_are_locked()"), 
#&gt;         env_bury.Rd = "env_bury()", env_clone.Rd = "env_clone()", 
#&gt;         env_depth.Rd = "env_depth()", env_get.Rd = c("env_get()", 
#&gt;         "env_get_list()"), env_has.Rd = "env_has()", env_inherits.Rd = "env_inherits()", 
#&gt;         env_lock.Rd = c("env_lock()", "env_is_locked()"), env_name.Rd = c("env_name()", 
#&gt;         "env_label()"), env_names.Rd = c("env_names()", "env_length()"
#&gt;         ), env_parent.Rd = c("env_parent()", "env_tail()", "env_parents()"
#&gt;         ), env_poke.Rd = "env_poke()", env_print.Rd = "env_print()", 
#&gt;         env_unbind.Rd = "env_unbind()", env_unlock.Rd = "env_unlock()", 
#&gt;         eval_bare.Rd = "eval_bare()", eval_tidy.Rd = "eval_tidy()", 
#&gt;         exec.Rd = "exec()", exiting.Rd = "exiting()", expr_interp.Rd = "expr_interp()", 
#&gt;         expr_label.Rd = c("expr_label()", "expr_name()", "expr_text()"
#&gt;         ), expr_print.Rd = c("expr_print()", "expr_deparse()"
#&gt;         ), exprs_auto_name.Rd = c("exprs_auto_name()", "quos_auto_name()"
#&gt;         ), f_rhs.Rd = c("f_rhs()", "`f_rhs&lt;-`()", "f_lhs()", 
#&gt;         "`f_lhs&lt;-`()", "f_env()", "`f_env&lt;-`()"), f_text.Rd = c("f_text()", 
#&gt;         "f_name()", "f_label()"), flatten.Rd = c("flatten()", 
#&gt;         "flatten_lgl()", "flatten_int()", "flatten_dbl()", "flatten_cpl()", 
#&gt;         "flatten_chr()", "flatten_raw()", "squash()", "squash_lgl()", 
#&gt;         "squash_int()", "squash_dbl()", "squash_cpl()", "squash_chr()", 
#&gt;         "squash_raw()", "flatten_if()", "squash_if()"), fn_body.Rd = c("fn_body()", 
#&gt;         "`fn_body&lt;-`()"), fn_env.Rd = c("fn_env()", "`fn_env&lt;-`()"
#&gt;         ), fn_fmls.Rd = c("fn_fmls()", "fn_fmls_names()", "fn_fmls_syms()", 
#&gt;         "`fn_fmls&lt;-`()", "`fn_fmls_names&lt;-`()"), frame_position.Rd = "frame_position()", 
#&gt;         friendly_type.Rd = "friendly_type()", get_env.Rd = c("get_env()", 
#&gt;         "set_env()", "env_poke_parent()"), has_length.Rd = "has_length()", 
#&gt;         has_name.Rd = "has_name()", inherits_any.Rd = c("inherits_any()", 
#&gt;         "inherits_all()", "inherits_only()"), invoke.Rd = "invoke()", 
#&gt;         is_call.Rd = "is_call()", is_callable.Rd = "is_callable()", 
#&gt;         is_condition.Rd = "is_condition()", is_copyable.Rd = "is_copyable()", 
#&gt;         is_empty.Rd = "is_empty()", is_env.Rd = c("is_env()", 
#&gt;         "is_bare_env()"), is_environment.Rd = c("is_environment()", 
#&gt;         "is_bare_environment()"), is_expr.Rd = "is_expr()", is_expression.Rd = c("is_expression()", 
#&gt;         "is_syntactic_literal()", "is_symbolic()"), is_formula.Rd = c("is_formula()", 
#&gt;         "is_bare_formula()"), is_frame.Rd = "is_frame()", is_function.Rd = c("is_function()", 
#&gt;         "is_closure()", "is_primitive()", "is_primitive_eager()", 
#&gt;         "is_primitive_lazy()"), is_installed.Rd = "is_installed()", 
#&gt;         is_integerish.Rd = c("is_integerish()", "is_bare_integerish()", 
#&gt;         "is_scalar_integerish()"), is_interactive.Rd = c("is_interactive()", 
#&gt;         "scoped_interactive()", "with_interactive()"), is_lang.Rd = c("is_lang()", 
#&gt;         "is_unary_lang()", "is_binary_lang()", "quo_is_lang()"
#&gt;         ), is_named.Rd = c("is_named()", "is_dictionaryish()", 
#&gt;         "have_name()"), is_namespace.Rd = "is_namespace()", is_pairlist.Rd = c("is_pairlist()", 
#&gt;         "is_node()", "is_node_list()"), is_reference.Rd = "is_reference()", 
#&gt;         is_stack.Rd = c("is_stack()", "is_eval_stack()", "is_call_stack()"
#&gt;         ), is_symbol.Rd = "is_symbol()", is_true.Rd = c("is_true()", 
#&gt;         "is_false()"), is_weakref.Rd = "is_weakref()", lang.Rd = c("lang()", 
#&gt;         "new_language()"), lang_head.Rd = c("lang_head()", "lang_tail()"
#&gt;         ), lang_modify.Rd = c("lang_modify()", "lang_standardise()", 
#&gt;         "lang_fn()", "lang_name()", "lang_args()", "lang_args_names()"
#&gt;         ), last_error.Rd = c("last_error()", "last_trace()"), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = c("na_lgl", 
#&gt;         "na_int", "na_dbl", "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg()", 
#&gt;         "is_missing()", "maybe_missing()"), mut_node_car.Rd = c("mut_node_car()", 
#&gt;         "mut_node_cdr()", "mut_node_caar()", "mut_node_cadr()", 
#&gt;         "mut_node_cdar()", "mut_node_cddr()", "mut_node_tag()"
#&gt;         ), names2.Rd = "names2()", `new-vector-along-retired.Rd` = c("new_logical_along()", 
#&gt;         "new_integer_along()", "new_double_along()", "new_character_along()", 
#&gt;         "new_complex_along()", "new_raw_along()", "new_list_along()"
#&gt;         ), `new-vector.Rd` = c("new_logical()", "new_integer()", 
#&gt;         "new_double()", "new_character()", "new_complex()", "new_raw()", 
#&gt;         "new_list()"), new_call.Rd = "new_call()", new_formula.Rd = "new_formula()", 
#&gt;         new_function.Rd = "new_function()", new_node.Rd = c("new_node()", 
#&gt;         "node_car()", "node_cdr()", "node_caar()", "node_cadr()", 
#&gt;         "node_cdar()", "node_cddr()", "node_poke_car()", "node_poke_cdr()", 
#&gt;         "node_poke_caar()", "node_poke_cadr()", "node_poke_cdar()", 
#&gt;         "node_poke_cddr()", "node_tag()", "node_poke_tag()"), 
#&gt;         new_quosures.Rd = c("new_quosures()", "as_quosures()", 
#&gt;         "is_quosures()"), new_weakref.Rd = "new_weakref()", ns_env.Rd = c("ns_env()", 
#&gt;         "ns_imports_env()", "ns_env_name()"), `op-definition.Rd` = c("is_definition()", 
#&gt;         "new_definition()", "is_formulaish()"), `op-get-attr.Rd` = c("`%@%`", 
#&gt;         "`%@%&lt;-`()"), `op-na-default.Rd` = "`%|%`", `op-null-default.Rd` = "`%||%`", 
#&gt;         overscope_eval_next.Rd = "overscope_eval_next()", pairlist2.Rd = "pairlist2()", 
#&gt;         parse_expr.Rd = c("parse_expr()", "parse_exprs()", "parse_quo()", 
#&gt;         "parse_quos()"), parse_quosure.Rd = c("parse_quosure()", 
#&gt;         "parse_quosures()"), prepend.Rd = c("prepend()", "modify()"
#&gt;         ), prim_name.Rd = "prim_name()", quasiquotation.Rd = "qq_show()", 
#&gt;         quo_expr.Rd = "quo_expr()", quo_label.Rd = c("quo_label()", 
#&gt;         "quo_text()", "quo_name()"), quo_squash.Rd = "quo_squash()", 
#&gt;         quosure.Rd = c("is_quosure()", "quo_is_missing()", "quo_is_symbol()", 
#&gt;         "quo_is_call()", "quo_is_symbolic()", "quo_is_null()", 
#&gt;         "quo_get_expr()", "quo_get_env()", "quo_set_expr()", 
#&gt;         "quo_set_env()"), quotation.Rd = c("expr()", "enexpr()", 
#&gt;         "exprs()", "enexprs()", "ensym()", "ensyms()", "quo()", 
#&gt;         "enquo()", "quos()", "enquos()"), rep_along.Rd = c("rep_along()", 
#&gt;         "rep_named()"), restarting.Rd = "restarting()", return_from.Rd = c("return_from()", 
#&gt;         "return_to()"), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = "rst_abort()", rst_list.Rd = c("rst_list()", 
#&gt;         "rst_exists()", "rst_jump()", "rst_maybe_jump()"), `scalar-type-predicates.Rd` = c("is_scalar_list()", 
#&gt;         "is_scalar_atomic()", "is_scalar_vector()", "is_scalar_integer()", 
#&gt;         "is_scalar_double()", "is_scalar_character()", "is_scalar_logical()", 
#&gt;         "is_scalar_raw()", "is_string()", "is_scalar_bytes()", 
#&gt;         "is_bool()"), scoped_bindings.Rd = c("scoped_bindings()", 
#&gt;         "with_bindings()"), scoped_env.Rd = c("scoped_env()", 
#&gt;         "is_scoped()", "scoped_envs()", "scoped_names()"), scoped_options.Rd = c("scoped_options()", 
#&gt;         "with_options()", "push_options()", "peek_options()", 
#&gt;         "peek_option()"), search_envs.Rd = c("search_envs()", 
#&gt;         "search_env()", "pkg_env()", "pkg_env_name()", "is_attached()", 
#&gt;         "base_env()", "global_env()"), seq2.Rd = c("seq2()", 
#&gt;         "seq2_along()"), set_attrs.Rd = c("set_attrs()", "mut_attrs()"
#&gt;         ), set_expr.Rd = c("set_expr()", "get_expr()"), set_names.Rd = "set_names()", 
#&gt;         splice.Rd = c("splice()", "is_spliced()", "is_spliced_bare()", 
#&gt;         "dots_splice()"), stack.Rd = c("global_frame()", "current_frame()", 
#&gt;         "ctxt_frame()", "call_frame()", "ctxt_depth()", "call_depth()", 
#&gt;         "ctxt_stack()", "call_stack()"), stack_trim.Rd = "stack_trim()", 
#&gt;         string.Rd = "string()", switch_type.Rd = c("switch_type()", 
#&gt;         "coerce_type()", "switch_class()", "coerce_class()"), 
#&gt;         sym.Rd = c("sym()", "syms()"), `tidy-dots.Rd` = c("dots_list()", 
#&gt;         "list2()"), `tidyeval-data.Rd` = ".data", trace_back.Rd = c("trace_back()", 
#&gt;         "trace_length()"), `type-predicates.Rd` = c("is_list()", 
#&gt;         "is_atomic()", "is_vector()", "is_integer()", "is_double()", 
#&gt;         "is_character()", "is_logical()", "is_raw()", "is_bytes()", 
#&gt;         "is_null()"), type_of.Rd = "type_of()", vec_poke_n.Rd = c("vec_poke_n()", 
#&gt;         "vec_poke_range()"), `vector-coercion.Rd` = c("as_logical()", 
#&gt;         "as_integer()", "as_double()", "as_complex()", "as_character()", 
#&gt;         "as_list()"), `vector-construction.Rd` = c("lgl()", "int()", 
#&gt;         "dbl()", "cpl()", "chr()", "bytes()"), `vector-old-ctors.Rd` = c("node()", 
#&gt;         "lgl_len()", "int_len()", "dbl_len()", "chr_len()", "cpl_len()", 
#&gt;         "raw_len()", "bytes_len()", "list_len()", "lgl_along()", 
#&gt;         "int_along()", "dbl_along()", "chr_along()", "cpl_along()", 
#&gt;         "raw_along()", "bytes_along()", "list_along()"), with_abort.Rd = "with_abort()", 
#&gt;         with_env.Rd = c("with_env()", "locally()"), with_handlers.Rd = c("with_handlers()", 
#&gt;         "calling()"), with_restarts.Rd = "with_restarts()", wref_key.Rd = c("wref_key()", 
#&gt;         "wref_value()"), zap.Rd = c("zap()", "is_zap()")), title = c("Signal an error, warning, or message", 
#&gt;     "Test for missing values", "Match an argument to a character vector", 
#&gt;     "Convert object to a box", "Coerce to a raw vector", "Create a data mask", 
#&gt;     "Coerce to an environment", "Coerce to an environment", "Convert to function or closure", 
#&gt;     "Create a default name for an R object", "Extract names from symbols", 
#&gt;     "Create an overscope", "Coerce to pairlist", "Coerce object to quosure", 
#&gt;     "Cast symbol to string", "Coerce to a character vector and attempt encoding conversion", 
#&gt;     "Bare type predicates", "Box a value", "Create a call", "Extract arguments from a call", 
#&gt;     "Extract function from a call", "Inspect a call", "Modify the arguments of a call", 
#&gt;     "Extract function name or namespaced of a call", "Standardise a call", 
#&gt;     "Get the current or caller environment", "Get properties of the current or caller frame", 
#&gt;     "Get caller frame", "Catch a condition", "Translate unicode points to UTF-8", 
#&gt;     "Create a condition object", "Build an error message from a main issue and bullet messages", 
#&gt;     "Muffle a condition", "Signal a condition object", "What type is a condition?", 
#&gt;     "Box a final value for early termination", "Capture definition objects", 
#&gt;     "How many arguments are currently forwarded in dots?", "Evaluate dots with preliminary splicing", 
#&gt;     "Duplicate an R object", "Get the empty environment", "Add backtrace from error handler", 
#&gt;     "Create a new environment", "Bind symbols to objects in an environment", 
#&gt;     "Bind a promise or active binding", "What kind of environment binding?", 
#&gt;     "Lock or unlock environment bindings", "Mask bindings by defining symbols deeper in a scope", 
#&gt;     "Clone an environment", "Depth of an environment chain", 
#&gt;     "Get an object in an environment", "Does an environment have or see bindings?", 
#&gt;     "Does environment inherit from another environment?", "Lock an environment", 
#&gt;     "Label of an environment", "Names and numbers of symbols bound in an environment", 
#&gt;     "Get parent environments", "Poke an object in an environment", 
#&gt;     "Pretty-print an environment", "Remove bindings from an environment", 
#&gt;     "Unlock an environment", "Evaluate an expression in an environment", 
#&gt;     "Evaluate an expression with quosures and pronoun support", 
#&gt;     "Execute a function", "Exiting handler", "Process unquote operators in a captured expression", 
#&gt;     "Turn an expression to a label", "Print an expression", "Ensure that all elements of a list of expressions are named", 
#&gt;     "Get or set formula components", "Turn RHS of formula into a string or label", 
#&gt;     "Flatten or squash a list of lists into a simpler vector", 
#&gt;     "Get or set function body", "Return the closure environment of a function", 
#&gt;     "Extract arguments from a function", "Find the position or distance of a frame on the evaluation stack", 
#&gt;     "Format a type for error messages", "Get or set the environment of an object", 
#&gt;     "How long is an object?", "Does an object have an element with this name?", 
#&gt;     "Does an object inherit from a set of classes?", "Invoke a function with a list of arguments", 
#&gt;     "Is object a call?", "Is an object callable?", "Is object a condition?", 
#&gt;     "Is an object copyable?", "Is object an empty vector or NULL?", 
#&gt;     "Is an object an environment?", "Is object an environment?", 
#&gt;     "Is an object an expression?", "Is an object an expression?", 
#&gt;     "Is object a formula?", "Is object a frame?", "Is object a function?", 
#&gt;     "Is a package installed in the library?", "Is a vector integer-like?", 
#&gt;     "Is R running interactively?", "Is object a call?", "Is object named?", 
#&gt;     "Is an object a namespace environment?", "Is object a node or pairlist?", 
#&gt;     "Is an object referencing another?", "Is object a stack?", 
#&gt;     "Is object a symbol?", "Is object identical to TRUE or FALSE?", 
#&gt;     "Is object a weak reference?", "Create a call", "Return the head or tail of a call", 
#&gt;     "Manipulate or access a call", "Last &lt;code&gt;abort()&lt;/code&gt; error", 
#&gt;     "Life cycle of the rlang package", "Missing values", "Generate or handle a missing argument", 
#&gt;     "Mutate node components", "Get names of a vector", "Create vectors matching the length of a given vector", 
#&gt;     "Create vectors matching a given length", "Create a new call from components", 
#&gt;     "Create a formula", "Create a function", "Helpers for pairlist and language nodes", 
#&gt;     "Create a list of quosures", "Create a weak reference", "Get the namespace of a package", 
#&gt;     "Definition operator", "Infix attribute accessor and setter", 
#&gt;     "Replace missing values", "Default value for &lt;code&gt;NULL&lt;/code&gt;", 
#&gt;     "Evaluate next quosure in a data mask", "Create pairlists with splicing support", 
#&gt;     "Parse R code", "Parse text into a quosure", "Prepend a vector", 
#&gt;     "Name of a primitive function", "Quasiquotation of an expression", 
#&gt;     "Squash a quosure", "Format quosures for printing or labelling", 
#&gt;     "Squash a quosure", "Quosure getters, setters and testers", 
#&gt;     "Quotation", "Create vectors matching the length of a given vector", 
#&gt;     "Create a restarting handler", "Jump to or from a frame", 
#&gt;     "Display backtrace on error", "Jump to the abort restart", 
#&gt;     "Restarts utilities", "Scalar type predicates", "Temporarily change bindings of an environment", 
#&gt;     "Retired &lt;code&gt;scoped&lt;/code&gt; functions", "Change global options", 
#&gt;     "Search path environments", "Increasing sequence of integers in an interval", 
#&gt;     "Add attributes to an object", "Set and get an expression", 
#&gt;     "Set names of a vector", "Splice lists", "Call stack information", 
#&gt;     "Trim top call layers from the evaluation stack", "Create a string", 
#&gt;     "Dispatch on base types", "Create a symbol or list of symbols", 
#&gt;     "Collect dots as lists", "Data pronoun for tidy evaluation", 
#&gt;     "Capture a backtrace", "Type predicates", "Base type of an object", 
#&gt;     "Poke values into a vector", "Coerce an object to a base type", 
#&gt;     "Create vectors", "Retired vector construction by length", 
#&gt;     "Promote all errors to rlang errors", "Evaluate an expression within a given environment", 
#&gt;     "Establish handlers on the stack", "Establish a restart point on the stack", 
#&gt;     "Get key/value from a weak reference object", "Create zap objects"
#&gt;     ), rd = list(abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/cnd-abort.R, R/cnd-signal.R", 
#&gt;         "\n", list("abort"), "\n", list("abort"), "\n", list(
#&gt;             "warn"), "\n", list("inform"), "\n", list("signal"), 
#&gt;         "\n", list("interrupt"), "\n", list("Signal an error, warning, or message"), 
#&gt;         "\n", list("\n", "abort(message = \"\", .subclass = NULL, ..., trace = NULL,\n", 
#&gt;             "  call = NULL, parent = NULL, msg, type)\n", "\n", 
#&gt;             "warn(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "inform(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "signal(message, .subclass, ...)\n", "\n", 
#&gt;             "interrupt()\n"), "\n", list("\n", list(list("message"), 
#&gt;             list("The message to display.\n", "\n", "Experimental: Can also be a named character vector, in which case\n", 
#&gt;                 "the message is assembled as a list of bullets. See\n", 
#&gt;                 list(list("cnd_message()")), " to learn how names control the bulleted output.")), 
#&gt;             "\n", "\n", list(list(".subclass"), list("Subclass of the condition. This allows your users\n", 
#&gt;                 "to selectively handle the conditions signalled by your functions.")), 
#&gt;             "\n", "\n", list(list("..."), list("Additional data to be stored in the condition object.")), 
#&gt;             "\n", "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                 " object created by ", list(list("trace_back()")), 
#&gt;                 ".")), "\n", "\n", list(list("call"), list("Defunct as of rlang 0.4.0. Storing the full\n", 
#&gt;                 "backtrace is now preferred to storing a simple call.")), 
#&gt;             "\n", "\n", list(list("parent"), list("A parent condition object created by ", 
#&gt;                 list(list("abort()")), ".")), "\n", "\n", list(
#&gt;                 list("msg, type"), list("These arguments were renamed to ", 
#&gt;                   list("message"), " and\n", list(".subclass"), 
#&gt;                   " and are defunct as of rlang 0.4.0.")), "\n"), 
#&gt;         "\n", list("\n", "These functions are equivalent to base functions ", 
#&gt;             list(list("base::stop()")), ",\n", list(list("base::warning()")), 
#&gt;             " and ", list(list("base::message()")), ", but make it easy to supply\n", 
#&gt;             "condition metadata:\n", list("\n", list(), " Supply ", 
#&gt;                 list(".subclass"), " to create a classed condition. Typed\n", 
#&gt;                 "conditions can be captured or handled selectively, allowing for\n", 
#&gt;                 "finer-grained error handling.\n", list(), " Supply metadata with named ", 
#&gt;                 list("..."), " arguments. This data will be\n", 
#&gt;                 "stored in the condition object and can be examined by handlers.\n"), 
#&gt;             "\n", "\n", list("interrupt()"), " allows R code to simulate a user interrupt of the\n", 
#&gt;             "kind that is signalled with ", list("Ctrl-C"), ". It is currently not possible\n", 
#&gt;             "to create custom interrupt condition objects.\n"), 
#&gt;         "\n", list(list("Backtrace"), list("\n", "\n", "\n", 
#&gt;             "Unlike ", list("stop()"), " and ", list("warning()"), 
#&gt;             ", these functions don't include call\n", "information by default. This saves you from typing ", 
#&gt;             list("call. = FALSE"), "\n", "and produces cleaner error messages.\n", 
#&gt;             "\n", "A backtrace is always saved into error objects. You can print a\n", 
#&gt;             "simplified backtrace of the last error by calling ", 
#&gt;             list(list("last_error()")), "\n", "and a full backtrace with ", 
#&gt;             list("summary(last_error())"), ".\n", "\n", "You can also display a backtrace with the error message by setting\n", 
#&gt;             "the option ", list("rlang_backtrace_on_error"), 
#&gt;             ". It supports the following\n", "values:\n", list(
#&gt;                 "\n", list(), " ", list("\"reminder\""), ": Invite users to call ", 
#&gt;                 list("rlang::last_error()"), " to see a\n", "backtrace.\n", 
#&gt;                 list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                 list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                 list(), " ", list("\"full\""), ": Display a full backtrace tree.\n", 
#&gt;                 list(), " ", list("\"none\""), ": Display nothing.\n"), 
#&gt;             "\n")), "\n", "\n", list(list("Mufflable conditions"), 
#&gt;             list("\n", "\n", "\n", "Signalling a condition with ", 
#&gt;                 list("inform()"), " or ", list("warn()"), " causes a message\n", 
#&gt;                 "to be displayed in the console. These messages can be muffled with\n", 
#&gt;                 list(list("base::suppressMessages()")), " or ", 
#&gt;                 list(list("base::suppressWarnings()")), ".\n", 
#&gt;                 "\n", "On recent R versions (&gt;= R 3.5.0), interrupts are typically\n", 
#&gt;                 "signalled with a ", list("\"resume\""), " restart. This is however not\n", 
#&gt;                 "guaranteed.\n")), "\n", "\n", list(list("Lifecycle"), 
#&gt;             list("\n", "\n", "\n", "These functions were changed in rlang 0.3.0 to take condition\n", 
#&gt;                 "metadata with ", list("..."), ". Consequently:\n", 
#&gt;                 list("\n", list(), " All arguments were renamed to be prefixed with a dot, except for\n", 
#&gt;                   list("type"), " which was renamed to ", list(
#&gt;                     ".subclass"), ".\n", list(), " ", list(".call"), 
#&gt;                   " (previously ", list("call"), ") can no longer be passed positionally.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# These examples are guarded to avoid throwing errors\n", 
#&gt;             "if (FALSE) {\n", "\n", "# Signal an error with a message just like stop():\n", 
#&gt;             "abort(\"Something bad happened\")\n", "\n", "# Give a class to the error:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\")\n", 
#&gt;             "\n", "# This will allow your users to handle the error selectively\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    warn(err$message) # Demote the error to a warning\n", 
#&gt;             "    NA                # Return an alternative value\n", 
#&gt;             "  }\n", ")\n", "\n", "# You can also specify metadata that will be stored in the condition:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\", data = 1:10)\n", 
#&gt;             "\n", "# This data can then be consulted by user handlers:\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    # Compute an alternative return value with the data:\n", 
#&gt;             "    recover_error(err$data)\n", "  }\n", ")\n", 
#&gt;             "\n", "# If you call low-level APIs it is good practice to catch technical\n", 
#&gt;             "# errors and rethrow them with a more meaningful message. Pass on\n", 
#&gt;             "# the caught error as `parent` to get a nice decomposition of\n", 
#&gt;             "# errors and backtraces:\n", "file &lt;- \"http://foo.bar/baz\"\n", 
#&gt;             "tryCatch(\n", "  download(file),\n", "  error = function(err) {\n", 
#&gt;             "    msg &lt;- sprintf(\"Can't download `%s`\", file)\n", 
#&gt;             "    abort(msg, parent = err)\n", "})\n", "\n", "# Unhandled errors are saved automatically by `abort()` and can be\n", 
#&gt;             "# retrieved with `last_error()`. The error prints with a simplified\n", 
#&gt;             "# backtrace:\n", "abort(\"Saved error?\")\n", "last_error()\n", 
#&gt;             "\n", "# Use `summary()` to print the full backtrace and the condition fields:\n", 
#&gt;             "summary(last_error())\n", "\n", "}\n"), "\n", list(
#&gt;             "\n", list(list("with_abort()")), " to convert all errors to rlang errors.\n"), 
#&gt;         "\n"), are_na.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/vec-na.R", "\n", 
#&gt;         list("are_na"), "\n", list("are_na"), "\n", list("is_na"), 
#&gt;         "\n", list("is_lgl_na"), "\n", list("is_int_na"), "\n", 
#&gt;         list("is_dbl_na"), "\n", list("is_chr_na"), "\n", list(
#&gt;             "is_cpl_na"), "\n", list("Test for missing values"), 
#&gt;         "\n", list("\n", "are_na(x)\n", "\n", "is_na(x)\n", "\n", 
#&gt;             "is_lgl_na(x)\n", "\n", "is_int_na(x)\n", "\n", "is_dbl_na(x)\n", 
#&gt;             "\n", "is_chr_na(x)\n", "\n", "is_cpl_na(x)\n"), 
#&gt;         "\n", list("\n", list(list("x"), list("An object to test")), 
#&gt;             "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;             "\n", "\n", list("are_na()"), " checks for missing values in a vector and is equivalent\n", 
#&gt;             "to ", list(list("base::is.na()")), ". It is a vectorised predicate, meaning that its\n", 
#&gt;             "output is always the same length as its input. On the other hand,\n", 
#&gt;             list("is_na()"), " is a scalar predicate and always returns a scalar\n", 
#&gt;             "boolean, ", list("TRUE"), " or ", list("FALSE"), 
#&gt;             ". If its input is not scalar, it returns\n", list(
#&gt;                 "FALSE"), ". Finally, there are typed versions that check for\n", 
#&gt;             "particular ", list("missing types"), ".\n"), "\n", 
#&gt;         list("\n", "The scalar predicates accept non-vector inputs. They are equivalent\n", 
#&gt;             "to ", list(list("is_null()")), " in that respect. In contrast the vectorised\n", 
#&gt;             "predicate ", list("are_na()"), " requires a vector input since it is defined\n", 
#&gt;             "over vector values.\n"), "\n", list(list("Life cycle"), 
#&gt;             list("\n", "\n", "\n", "These functions might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;         "\n", "\n", list("\n", "# are_na() is vectorised and works regardless of the type\n", 
#&gt;             "are_na(c(1, 2, NA))\n", "are_na(c(1L, NA, 3L))\n", 
#&gt;             "\n", "# is_na() checks for scalar input and works for all types\n", 
#&gt;             "is_na(NA)\n", "is_na(na_dbl)\n", "is_na(character(0))\n", 
#&gt;             "\n", "# There are typed versions as well:\n", "is_lgl_na(NA)\n", 
#&gt;             "is_lgl_na(na_dbl)\n"), "\n", list("internal"), "\n"), 
#&gt;         arg_match.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("arg_match"), "\n", list("arg_match"), "\n", 
#&gt;             list("Match an argument to a character vector"), 
#&gt;             "\n", list("\n", "arg_match(arg, values = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("arg"), list("A symbol referring to an argument accepting strings.")), 
#&gt;                 "\n", "\n", list(list("values"), list("The possible values that ", 
#&gt;                   list("arg"), " can take. If ", list("NULL"), 
#&gt;                   ",\n", "the values are taken from the function definition of the ", 
#&gt;                   list("caller frame"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "The string supplied to ", list("arg"), 
#&gt;                 ".\n"), "\n", list("\n", "This is equivalent to ", 
#&gt;                 list(list("base::match.arg()")), " with a few differences:\n", 
#&gt;                 list("\n", list(), " Partial matches trigger an error.\n", 
#&gt;                   list(), " Error messages are a bit more informative and obey the tidyverse\n", 
#&gt;                   "standards.\n"), "\n"), "\n", list("\n", "fn &lt;- function(x = c(\"foo\", \"bar\")) arg_match(x)\n", 
#&gt;                 "fn(\"bar\")\n", "\n", "# This would throw an informative error if run:\n", 
#&gt;                 "# fn(\"b\")\n", "# fn(\"baz\")\n"), "\n"), as_box.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "as_box"), "\n", list("as_box"), "\n", list("as_box_if"), 
#&gt;             "\n", list("Convert object to a box"), "\n", list(
#&gt;                 "\n", "as_box(x, class = NULL)\n", "\n", "as_box_if(.x, .p, .class = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("class, .class"), list(
#&gt;                   "A box class. If the input is already a box of\n", 
#&gt;                   "that class, it is returned as is. If the input needs to be boxed,\n", 
#&gt;                   list("class"), " is passed to ", list(list(
#&gt;                     "new_box()")), ".")), "\n", "\n", list(list(
#&gt;                   ".x"), list("An R object.")), "\n", "\n", list(
#&gt;                   list(".p"), list("A predicate function.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed to ", 
#&gt;                   list(".p"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("as_box()"), " boxes its input only if it is not already a box. The\n", 
#&gt;                   "class is also checked if supplied.\n", list(), 
#&gt;                   " ", list("as_box_if()"), " boxes its input only if it not already a box, or if\n", 
#&gt;                   "the predicate ", list(".p"), " returns ", 
#&gt;                   list("TRUE"), ".\n"), "\n"), "\n"), as_bytes.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_bytes"), "\n", list("as_bytes"), "\n", 
#&gt;             list("Coerce to a raw vector"), "\n", list("\n", 
#&gt;                 "as_bytes(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("A string.")), "\n"), "\n", list("\n", 
#&gt;                 "A raw vector of bytes.\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This currently only works with strings, and returns its hexadecimal\n", 
#&gt;                 "representation.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "Raw vector functions are experimental.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_data_mask.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/eval-tidy.R", "\n", 
#&gt;             list("as_data_mask"), "\n", list("as_data_mask"), 
#&gt;             "\n", list("as_data_pronoun"), "\n", list("new_data_mask"), 
#&gt;             "\n", list("Create a data mask"), "\n", list("\n", 
#&gt;                 "as_data_mask(data, parent = NULL)\n", "\n", 
#&gt;                 "as_data_pronoun(data)\n", "\n", "new_data_mask(bottom, top = bottom, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("Deprecated. This argument no longer has any effect.\n", 
#&gt;                   "The parent of the data mask is determined from either:\n", 
#&gt;                   list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                     list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"))), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "A data mask that you can supply to ", 
#&gt;                 list(list("eval_tidy()")), ".\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "A data mask is an environment (or possibly multiple environments\n", 
#&gt;                 "forming an ancestry) containing user-supplied objects. Objects in\n", 
#&gt;                 "the mask have precedence over objects in the environment (i.e. they\n", 
#&gt;                 "mask those objects). Many R functions evaluate quoted expressions\n", 
#&gt;                 "in a data mask so these expressions can refer to objects within the\n", 
#&gt;                 "user data.\n", "\n", "These functions let you construct a tidy eval data mask manually.\n", 
#&gt;                 "They are meant for developers of tidy eval interfaces rather than\n", 
#&gt;                 "for end users.\n"), "\n", list(list("Why build a data mask?"), 
#&gt;                 list("\n", "\n", "\n", "Most of the time you can just call ", 
#&gt;                   list(list("eval_tidy()")), " with a list or a\n", 
#&gt;                   "data frame and the data mask will be constructed automatically.\n", 
#&gt;                   "There are three main use cases for manual creation of data masks:\n", 
#&gt;                   list("\n", list(), " When ", list(list("eval_tidy()")), 
#&gt;                     " is called with the same data in a tight loop.\n", 
#&gt;                     "Because there is some overhead to creating tidy eval data masks,\n", 
#&gt;                     "constructing the mask once and reusing it for subsequent\n", 
#&gt;                     "evaluations may improve performance.\n", 
#&gt;                     list(), " When several expressions should be evaluated in the exact same\n", 
#&gt;                     "environment because a quoted expression might create new objects\n", 
#&gt;                     "that can be referred in other quoted expressions evaluated at a\n", 
#&gt;                     "later time. One example of this is ", list(
#&gt;                       "tibble::lst()"), " where new\n", "columns can refer to previous ones.\n", 
#&gt;                     list(), " When your data mask requires special features. For instance the\n", 
#&gt;                     "data frame columns in dplyr data masks are implemented with\n", 
#&gt;                     list("active bindings"), ".\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Building your own data mask"), 
#&gt;                 list("\n", "\n", "\n", "Unlike ", list(list("base::eval()")), 
#&gt;                   " which takes any kind of environments as data\n", 
#&gt;                   "mask, ", list(list("eval_tidy()")), " has specific requirements in order to support\n", 
#&gt;                   list("quosures"), ". For this reason you can't supply bare\n", 
#&gt;                   "environments.\n", "\n", "There are two ways of constructing an rlang data mask manually:\n", 
#&gt;                   list("\n", list(), " ", list("as_data_mask()"), 
#&gt;                     " transforms a list or data frame to a data mask.\n", 
#&gt;                     "It automatically installs the data pronoun ", 
#&gt;                     list(list(".data")), ".\n", list(), " ", 
#&gt;                     list("new_data_mask()"), " is a bare bones data mask constructor for\n", 
#&gt;                     "environments. You can supply a bottom and a top environment in\n", 
#&gt;                     "case your data mask comprises multiple environments (see section\n", 
#&gt;                     "below).\n", "\n", "Unlike ", list("as_data_mask()"), 
#&gt;                     " it does not install the ", list(".data"), 
#&gt;                     " pronoun\n", "so you need to provide one yourself. You can provide a pronoun\n", 
#&gt;                     "constructed with ", list("as_data_pronoun()"), 
#&gt;                     " or your own pronoun class.\n", "\n", list(
#&gt;                       "as_data_pronoun()"), " will create a pronoun from a list, an\n", 
#&gt;                     "environment, or an rlang data mask. In the latter case, the whole\n", 
#&gt;                     "ancestry is looked up from the bottom to the top of the mask.\n", 
#&gt;                     "Functions stored in the mask are bypassed by the pronoun.\n"), 
#&gt;                   "\n", "\n", "Once you have built a data mask, simply pass it to ", 
#&gt;                   list(list("eval_tidy()")), " as\n", "the ", 
#&gt;                   list("data"), " argument. You can repeat this as many times as\n", 
#&gt;                   "needed. Note that any objects created there (perhaps because of a\n", 
#&gt;                   "call to ", list("&lt;-"), ") will persist in subsequent evaluations.\n")), 
#&gt;             "\n", "\n", list(list("Top and bottom of data mask"), 
#&gt;                 list("\n", "\n", "\n", "In some cases you'll need several levels in your data mask. One\n", 
#&gt;                   "good reason is when you include functions in the mask. It's a good\n", 
#&gt;                   "idea to keep data objects one level lower than function objects, so\n", 
#&gt;                   "that the former cannot override the definitions of the latter (see\n", 
#&gt;                   "examples).\n", "\n", "In that case, set up all your environments and keep track of the\n", 
#&gt;                   "bottom child and the top parent. You'll need to pass both to\n", 
#&gt;                   list("new_data_mask()"), ".\n", "\n", "Note that the parent of the top environment is completely\n", 
#&gt;                   "undetermined, you shouldn't expect it to remain the same at all\n", 
#&gt;                   "times. This parent is replaced during evaluation by ", 
#&gt;                   list(list("eval_tidy()")), "\n", "to one of the following environments:\n", 
#&gt;                   list("\n", list(), " The default environment passed as the ", 
#&gt;                     list("env"), " argument of ", list("eval_tidy()"), 
#&gt;                     ".\n", list(), " The environment of the current quosure being evaluated, if applicable.\n"), 
#&gt;                   "\n", "\n", "Consequently, all masking data should be contained between the\n", 
#&gt;                   "bottom and top environment of the data mask.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "The ", list("parent"), " argument no longer has any effect and is defunct as of\n", 
#&gt;                 "rlang 0.4.0. The parent of the data mask is determined from either:\n", 
#&gt;                 list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                   list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"), 
#&gt;                 "\n", "\n", "Passing environments to ", list(
#&gt;                   "as_data_mask()"), " is deprecated as of rlang\n", 
#&gt;                 "0.3.0. Please use ", list("new_data_mask()"), 
#&gt;                 " instead.\n", "\n", list("rlang 0.2.0"), "\n", 
#&gt;                 "\n", "In early versions of rlang data masks were called overscopes. We\n", 
#&gt;                 "think data mask is a more natural name in R. It makes reference to\n", 
#&gt;                 "masking in the search path which occurs through the same mechanism\n", 
#&gt;                 "(in technical terms, lexical scoping with hierarchically nested\n", 
#&gt;                 "environments). We say that objects from user data mask objects\n", 
#&gt;                 "in the current environment.\n", "\n", "Following this change in terminology, ", 
#&gt;                 list("as_overscope()"), " and\n", list("new_overscope()"), 
#&gt;                 " were deprecated in rlang 0.2.0 in favour of\n", 
#&gt;                 list("as_data_mask()"), " and ", list("new_data_mask()"), 
#&gt;                 ".\n")), "\n", "\n", list("\n", "# Evaluating in a tidy evaluation environment enables all tidy\n", 
#&gt;                 "# features:\n", "mask &lt;- as_data_mask(mtcars)\n", 
#&gt;                 "eval_tidy(quo(letters), mask)\n", "\n", "# You can install new pronouns in the mask:\n", 
#&gt;                 "mask$.pronoun &lt;- as_data_pronoun(list(foo = \"bar\", baz = \"bam\"))\n", 
#&gt;                 "eval_tidy(quo(.pronoun$foo), mask)\n", "\n", 
#&gt;                 "# In some cases the data mask can leak to the user, for example if\n", 
#&gt;                 "# a function or formula is created in the data mask environment:\n", 
#&gt;                 "cyl &lt;- \"user variable from the context\"\n", 
#&gt;                 "fn &lt;- eval_tidy(quote(function() cyl), mask)\n", 
#&gt;                 "fn()\n", "\n", "# If new objects are created in the mask, they persist in the\n", 
#&gt;                 "# subsequent calls:\n", "eval_tidy(quote(new &lt;- cyl + am), mask)\n", 
#&gt;                 "eval_tidy(quote(new * 2), mask)\n", "\n", "\n", 
#&gt;                 "# In some cases your data mask is a whole chain of environments\n", 
#&gt;                 "# rather than a single environment. You'll have to use\n", 
#&gt;                 "# `new_data_mask()` and let it know about the bottom of the mask\n", 
#&gt;                 "# (the last child of the environment chain) and the topmost parent.\n", 
#&gt;                 "\n", "# A common situation where you'll want a multiple-environment mask\n", 
#&gt;                 "# is when you include functions in your mask. In that case you'll\n", 
#&gt;                 "# put functions in the top environment and data in the bottom. This\n", 
#&gt;                 "# will prevent the data from overwriting the functions.\n", 
#&gt;                 "top &lt;- new_environment(list(`+` = base::paste, c = base::paste))\n", 
#&gt;                 "\n", "# Let's add a middle environment just for sport:\n", 
#&gt;                 "middle &lt;- env(top)\n", "\n", "# And finally the bottom environment containing data:\n", 
#&gt;                 "bottom &lt;- env(middle, a = \"a\", b = \"b\", c = \"c\")\n", 
#&gt;                 "\n", "# We can now create a mask by supplying the top and bottom\n", 
#&gt;                 "# environments:\n", "mask &lt;- new_data_mask(bottom, top = top)\n", 
#&gt;                 "\n", "# This data mask can be passed to eval_tidy() instead of a list or\n", 
#&gt;                 "# data frame:\n", "eval_tidy(quote(a + b + c), data = mask)\n", 
#&gt;                 "\n", "# Note how the function `c()` and the object `c` are looked up\n", 
#&gt;                 "# properly because of the multi-level structure:\n", 
#&gt;                 "eval_tidy(quote(c(a, b, c)), data = mask)\n", 
#&gt;                 "\n", "# new_data_mask() does not create data pronouns, but\n", 
#&gt;                 "# data pronouns can be added manually:\n", "mask$.fns &lt;- as_data_pronoun(top)\n", 
#&gt;                 "\n", "# The `.data` pronoun should generally be created from the\n", 
#&gt;                 "# mask. This will ensure data is looked up throughout the whole\n", 
#&gt;                 "# ancestry. Only non-function objects are looked up from this\n", 
#&gt;                 "# pronoun:\n", "mask$.data &lt;- as_data_pronoun(mask)\n", 
#&gt;                 "mask$.data$c\n", "\n", "# Now we can reference the values with the pronouns:\n", 
#&gt;                 "eval_tidy(quote(c(.data$a, .data$b, .data$c)), data = mask)\n"), 
#&gt;             "\n"), as_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_env"), "\n", list("as_env"), "\n", 
#&gt;             list("Coerce to an environment"), "\n", list("\n", 
#&gt;                 "as_env(x, parent = NULL)\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated as it was renamed to ", 
#&gt;                 list(list("as_environment()")), "\n", "in rlang 0.2.0.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "as_environment"), "\n", list("as_environment"), 
#&gt;             "\n", list("Coerce to an environment"), "\n", list(
#&gt;                 "\n", "as_environment(x, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("A parent environment, ", 
#&gt;                   list(list("empty_env()")), " by default. This\n", 
#&gt;                   "argument is only used when ", list("x"), " is data actually coerced to an\n", 
#&gt;                   "environment (as opposed to data representing an environment, like\n", 
#&gt;                   list("NULL"), " representing the empty environment).")), 
#&gt;                 "\n"), "\n", list("\n", list("as_environment()"), 
#&gt;                 " coerces named vectors (including lists) to an\n", 
#&gt;                 "environment. The names must be unique. If supplied an unnamed\n", 
#&gt;                 "string, it returns the corresponding package environment (see\n", 
#&gt;                 list(list("pkg_env()")), ").\n"), "\n", list(
#&gt;                 "\n", "If ", list("x"), " is an environment and ", 
#&gt;                 list("parent"), " is not ", list("NULL"), ", the\n", 
#&gt;                 "environment is duplicated before being set a new parent. The return\n", 
#&gt;                 "value is therefore a different environment than ", 
#&gt;                 list("x"), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("as_env()"), " was soft-deprecated and renamed to ", 
#&gt;                   list("as_environment()"), " in\n", "rlang 0.2.0. This is for consistency as type predicates should not\n", 
#&gt;                   "be abbreviated.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Coerce a named vector to an environment:\n", 
#&gt;                 "env &lt;- as_environment(mtcars)\n", "\n", "# By default it gets the empty environment as parent:\n", 
#&gt;                 "identical(env_parent(env), empty_env())\n", 
#&gt;                 "\n", "\n", "# With strings it is a handy shortcut for pkg_env():\n", 
#&gt;                 "as_environment(\"base\")\n", "as_environment(\"rlang\")\n", 
#&gt;                 "\n", "# With NULL it returns the empty environment:\n", 
#&gt;                 "as_environment(NULL)\n"), "\n"), as_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "as_function"), "\n", list("as_function"), "\n", 
#&gt;             list("is_lambda"), "\n", list("as_closure"), "\n", 
#&gt;             list("Convert to function or closure"), "\n", list(
#&gt;                 "\n", "as_function(x, env = caller_env())\n", 
#&gt;                 "\n", "is_lambda(x)\n", "\n", "as_closure(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function or formula.\n", 
#&gt;                 "\n", "If a ", list("function"), ", it is used as is.\n", 
#&gt;                 "\n", "If a ", list("formula"), ", e.g. ", list(
#&gt;                   "~ .x + 2"), ", it is converted to a function\n", 
#&gt;                 "with up to two arguments: ", list(".x"), " (single argument) or ", 
#&gt;                 list(".x"), " and ", list(".y"), "\n", "(two arguments). The ", 
#&gt;                 list("."), " placeholder can be used instead of ", 
#&gt;                 list(".x"), ".\n", "This allows you to create very compact anonymous functions (lambdas) with up\n", 
#&gt;                 "to two inputs. Functions created from formulas have a special\n", 
#&gt;                 "class. Use ", list("is_lambda()"), " to test for it.\n", 
#&gt;                 "\n", "Lambdas currently do not support ", list(
#&gt;                   "quasiquotation"), ",\n", "due to the way the arguments are handled internally.")), 
#&gt;                 "\n", "\n", list(list("env"), list("Environment in which to fetch the function in case ", 
#&gt;                   list("x"), "\n", "is a string.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("as_function()"), 
#&gt;                   " transforms a one-sided formula into a function.\n", 
#&gt;                   "This powers the lambda syntax in packages like purrr.\n", 
#&gt;                   list(), " ", list("as_closure()"), " first passes its argument to ", 
#&gt;                   list("as_function()"), ". If\n", "the result is a primitive function, it regularises it to a proper\n", 
#&gt;                   list("closure"), " (see ", list(list("is_function()")), 
#&gt;                   " about primitive functions). Some\n", "special control flow primitives like ", 
#&gt;                   list("if"), ", ", list("for"), ", or ", list(
#&gt;                     "break"), "\n", "can't be coerced to a closure.\n"), 
#&gt;                 "\n"), "\n", list("\n", "f &lt;- as_function(~ .x + 1)\n", 
#&gt;                 "f(10)\n", "\n", "g &lt;- as_function(~ -1 * .)\n", 
#&gt;                 "g(4)\n", "\n", "h &lt;- as_function(~ .x - .y)\n", 
#&gt;                 "h(6, 3)\n", "\n", "# Functions created from a formula have a special class:\n", 
#&gt;                 "is_lambda(f)\n", "is_lambda(as_function(function() \"foo\"))\n", 
#&gt;                 "\n", "# Primitive functions are regularised as closures\n", 
#&gt;                 "as_closure(list)\n", "as_closure(\"list\")\n", 
#&gt;                 "\n", "# Operators have `.x` and `.y` as arguments, just like lambda\n", 
#&gt;                 "# functions created with the formula syntax:\n", 
#&gt;                 "as_closure(`+`)\n", "as_closure(`~`)\n", "\n", 
#&gt;                 "# Use a regular function for tidy evaluation, also when calling functions\n", 
#&gt;                 "# that use tidy evaluation:\n", "## Bad:\n", 
#&gt;                 "e &lt;- as_function(~ as_label(ensym(.x)))\n", 
#&gt;                 "## Good:\n", "e &lt;- as_function(function(x) as_label(ensym(x)))\n", 
#&gt;                 "\n", "e(y)\n"), "\n"), as_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/deparse.R", 
#&gt;             "\n", list("as_label"), "\n", list("as_label"), "\n", 
#&gt;             list("Create a default name for an R object"), "\n", 
#&gt;             list("\n", "as_label(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object.")), "\n"), "\n", 
#&gt;             list("\n", list("as_label()"), " transforms R objects into a short, human-readable\n", 
#&gt;                 "description. You can use labels to:\n", list(
#&gt;                   "\n", list(), " Display an object in a concise way, for example to labellise axes\n", 
#&gt;                   "in a graphical plot.\n", list(), " Give default names to columns in a data frame. In this case,\n", 
#&gt;                   "labelling is the first step before name repair.\n"), 
#&gt;                 "\n", "\n", "See also ", list(list("as_name()")), 
#&gt;                 " for transforming symbols back to a\n", "string. Unlike ", 
#&gt;                 list("as_label()"), ", ", list("as_string()"), 
#&gt;                 " is a well defined\n", "operation that guarantees the roundtrip symbol -&gt; string -&gt;\n", 
#&gt;                 "symbol.\n", "\n", "In general, if you don't know for sure what kind of object you're\n", 
#&gt;                 "dealing with (a call, a symbol, an unquoted constant), use\n", 
#&gt;                 list("as_label()"), " and make no assumption about the resulting string. If\n", 
#&gt;                 "you know you have a symbol and need the name of the object it\n", 
#&gt;                 "refers to, use ", list(list("as_string()")), 
#&gt;                 ". For instance, use ", list("as_label()"), " with\n", 
#&gt;                 "objects captured with ", list("enquo()"), " and ", 
#&gt;                 list("as_string()"), " with symbols\n", "captured with ", 
#&gt;                 list("ensym()"), ".\n"), "\n", list(list("Transformation to string"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Quosures are ", 
#&gt;                   list("squashed"), " before being labelled.\n", 
#&gt;                   list(), " Symbols are transformed to string with ", 
#&gt;                   list("as_string()"), ".\n", list(), " Calls are abbreviated.\n", 
#&gt;                   list(), " Numbers are represented as such.\n", 
#&gt;                   list(), " Other constants are represented by their type, such as ", 
#&gt;                   list("&lt;dbl&gt;"), "\n", "or ", list("&lt;data.frame&gt;"), 
#&gt;                   ".\n"), "\n", "\n", "Note that simple symbols should generally be transformed to strings\n", 
#&gt;                   "with ", list(list("as_name()")), ". Labelling is not a well defined operation and\n", 
#&gt;                   "no assumption should be made about how the label is created. On the\n", 
#&gt;                   "other hand, ", list("as_name()"), " only works with symbols and is a well\n", 
#&gt;                   "defined, deterministic operation.\n")), "\n", 
#&gt;             "\n", list("\n", "# as_label() is useful with quoted expressions:\n", 
#&gt;                 "as_label(expr(foo(bar)))\n", "as_label(expr(foobar))\n", 
#&gt;                 "\n", "# It works with any R object. This is also useful for quoted\n", 
#&gt;                 "# arguments because the user might unquote constant objects:\n", 
#&gt;                 "as_label(1:3)\n", "as_label(base::list)\n"), 
#&gt;             "\n", list("\n", list(list("as_name()")), " for transforming symbols back to a string\n", 
#&gt;                 "deterministically.\n"), "\n"), as_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/deparse.R", "\n", 
#&gt;             list("as_name"), "\n", list("as_name"), "\n", list(
#&gt;                 "Extract names from symbols"), "\n", list("\n", 
#&gt;                 "as_name(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("A string or symbol, possibly wrapped in a ", 
#&gt;                   list("quosure"), ".\n", "If a string, the attributes are removed, if any.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of length 1.\n"), 
#&gt;             "\n", list("\n", list("as_name()"), " converts ", 
#&gt;                 list("symbols"), " to character strings. The\n", 
#&gt;                 "conversion is deterministic. That is, the roundtrip symbol -&gt; name\n", 
#&gt;                 "-&gt; symbol always gets the same result.\n", list(
#&gt;                   "\n", list(), " Use ", list("as_name()"), " when you need to transform a symbol to a string\n", 
#&gt;                   "to ", list("refer"), " to an object by its name.\n", 
#&gt;                   list(), " Use ", list(list("as_label()")), 
#&gt;                   " when you need to transform any kind of object to\n", 
#&gt;                   "a string to ", list("represent"), " that object with a short description.\n"), 
#&gt;                 "\n", "\n", "Expect ", list("as_name()"), " to gain\n", 
#&gt;                 list(list("https://principles.tidyverse.org/names-attribute.html#minimal-unique-universal"), 
#&gt;                   list("name-repairing")), "\n", "features in the future.\n", 
#&gt;                 "\n", "Note that ", list("rlang::as_name()"), 
#&gt;                 " is the ", list("opposite"), " of\n", list(list(
#&gt;                   "base::as.name()")), ". If you're writing base R code, we recommend\n", 
#&gt;                 "using ", list(list("base::as.symbol()")), " which is an alias of ", 
#&gt;                 list("as.name()"), " that\n", "follows a more modern terminology (R types instead of S modes).\n"), 
#&gt;             "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_name() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_name(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_name(bar))\n", "\n", "# as_name() unwraps quosured symbols automatically:\n", 
#&gt;                 "as_name(quo(foo))\n"), "\n", list("\n", list(
#&gt;                 list("as_label()")), " for converting any object to a single string\n", 
#&gt;                 "suitable as a label. ", list(list("as_string()")), 
#&gt;                 " for a lower-level version that\n", "doesn't unwrap quosures.\n"), 
#&gt;             "\n"), as_overscope.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_overscope"), "\n", list("as_overscope"), 
#&gt;             "\n", list("new_overscope"), "\n", list("overscope_clean"), 
#&gt;             "\n", list("Create an overscope"), "\n", list("\n", 
#&gt;                 "as_overscope(quo, data = NULL)\n", "\n", "new_overscope(bottom, top = NULL, enclosure = NULL)\n", 
#&gt;                 "\n", "overscope_clean(overscope)\n"), "\n", 
#&gt;             list("\n", list(list("quo"), list("A ", list("quosure"), 
#&gt;                 ".")), "\n", "\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n", "\n", list(list("enclosure"), 
#&gt;                   list("The ", list("parent"), " argument of ", 
#&gt;                     list(list("new_data_mask()")), ".")), "\n", 
#&gt;                 "\n", list(list("overscope"), list("A data mask.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions have been deprecated in rlang 0.2.0. Please use\n", 
#&gt;                 list(list("as_data_mask()")), " and ", list(list(
#&gt;                   "new_data_mask()")), " instead. We no longer\n", 
#&gt;                 "require the mask to be cleaned up so ", list(
#&gt;                   "overscope_clean()"), " does not\n", "have a replacement.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_pairlist.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/node.R", "\n", 
#&gt;             list("as_pairlist"), "\n", list("as_pairlist"), "\n", 
#&gt;             list("Coerce to pairlist"), "\n", list("\n", "as_pairlist(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", "This transforms vector objects to a linked pairlist of nodes. See\n", 
#&gt;                 "the ", list("pairlist"), " type help page.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("as_pairlist()"), " is experimental because we are still figuring out\n", 
#&gt;                 "the naming scheme for pairlists and node-like objects.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "as_quosure"), "\n", list("as_quosure"), "\n", 
#&gt;             list("new_quosure"), "\n", list("Coerce object to quosure"), 
#&gt;             "\n", list("\n", "as_quosure(x, env = NULL)\n", "\n", 
#&gt;                 "new_quosure(expr, env = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to convert. Either an ", 
#&gt;                 list("expression"), " or a\n", "formula.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which the expression should be\n", 
#&gt;                   "evaluated. Only used for symbols and calls. This should typically\n", 
#&gt;                   "be the environment in which the expression was created.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("The expression wrapped by the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "While ", list("new_quosure()"), 
#&gt;                 " wraps any R object (including expressions,\n", 
#&gt;                 "formulas, or other quosures) into a quosure, ", 
#&gt;                 list("as_quosure()"), "\n", "converts formulas and quosures and does not double-wrap.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("as_quosure()"), " now requires an explicit default environment for\n", 
#&gt;                 "creating quosures from symbols and calls.\n", 
#&gt;                 list(), " ", list("as_quosureish()"), " is deprecated as of rlang 0.2.0. This function\n", 
#&gt;                 "assumes that quosures are formulas which is currently true but\n", 
#&gt;                 "might not be in the future.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "# as_quosure() converts expressions or any R object to a validly\n", 
#&gt;                 "# scoped quosure:\n", "env &lt;- env(var = \"thing\")\n", 
#&gt;                 "as_quosure(quote(var), env)\n", "\n", "\n", 
#&gt;                 "# The environment is ignored for formulas:\n", 
#&gt;                 "as_quosure(~foo, env)\n", "as_quosure(~foo)\n", 
#&gt;                 "\n", "# However you must supply it for symbols and calls:\n", 
#&gt;                 "try(as_quosure(quote(var)))\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), ", ", list(list("is_quosure()")), 
#&gt;                 "\n"), "\n"), as_string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("as_string"), "\n", list("as_string"), "\n", 
#&gt;             list("Cast symbol to string"), "\n", list("\n", "as_string(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or symbol. If a string, the attributes are\n", 
#&gt;                 "removed, if any.")), "\n"), "\n", list("\n", 
#&gt;                 "A character vector of length 1.\n"), "\n", list(
#&gt;                 "\n", list("as_string()"), " converts ", list(
#&gt;                   "symbols"), " to character strings.\n"), "\n", 
#&gt;             list(list("Unicode tags"), list("\n", "\n", "\n", 
#&gt;                 "Unlike ", list(list("base::as.symbol()")), " and ", 
#&gt;                 list(list("base::as.name()")), ", ", list("as_string()"), 
#&gt;                 "\n", "automatically transforms unicode tags such as ", 
#&gt;                 list("\"&lt;U+5E78&gt;\""), " to the\n", "proper UTF-8 character. This is important on Windows because:\n", 
#&gt;                 list("\n", list(), " R on Windows has no UTF-8 support, and uses native encoding instead.\n", 
#&gt;                   list(), " The native encodings do not cover all Unicode characters. For\n", 
#&gt;                   "example, Western encodings do not support CKJ characters.\n", 
#&gt;                   list(), " When a lossy UTF-8 -&gt; native transformation occurs, uncovered\n", 
#&gt;                   "characters are transformed to an ASCII unicode tag like ", 
#&gt;                   list("\"&lt;U+5E78&gt;\""), ".\n", list(), " Symbols are always encoded in native. This means that\n", 
#&gt;                   "transforming the column names of a data frame to symbols might be\n", 
#&gt;                   "a lossy operation.\n", list(), " This operation is very common in the tidyverse because of data\n", 
#&gt;                   "masking APIs like dplyr where data frames are transformed to\n", 
#&gt;                   "environments. While the names of a data frame are stored as a\n", 
#&gt;                   "character vector, the bindings of environments are stored as\n", 
#&gt;                   "symbols.\n"), "\n", "\n", "Because it reencodes the ASCII unicode tags to their UTF-8\n", 
#&gt;                 "representation, the string -&gt; symbol -&gt; string roundtrip is\n", 
#&gt;                 "more stable with ", list("as_string()"), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_string() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_string(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_string(bar))\n"), "\n", list("\n", 
#&gt;                 list(list("as_name()")), " for a higher-level variant of ", 
#&gt;                 list("as_string()"), "\n", "that automatically unwraps quosures.\n"), 
#&gt;             "\n"), as_utf8_character.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_utf8_character"), "\n", list("as_utf8_character"), 
#&gt;             "\n", list("Coerce to a character vector and attempt encoding conversion"), 
#&gt;             "\n", list("\n", "as_utf8_character(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Unlike specifying the ", list("encoding"), 
#&gt;                 " argument in ", list("as_string()"), " and\n", 
#&gt;                 list("as_character()"), ", which is only declarative, these functions\n", 
#&gt;                 "actually attempt to convert the encoding of their input. There are\n", 
#&gt;                 "two possible cases:\n", list("\n", list(), " The string is tagged as UTF-8 or latin1, the only two encodings\n", 
#&gt;                   "for which R has specific support. In this case, converting to the\n", 
#&gt;                   "same encoding is a no-op, and converting to native always works\n", 
#&gt;                   "as expected, as long as the native encoding, the one specified by\n", 
#&gt;                   "the ", list("LC_CTYPE"), " locale has support for all characters occurring in\n", 
#&gt;                   "the strings. Unrepresentable characters are serialised as unicode\n", 
#&gt;                   "points: \"&lt;U+xxxx&gt;\".\n", list(), " The string is not tagged. R assumes that it is encoded in the\n", 
#&gt;                   "native encoding. Conversion to native is a no-op, and conversion\n", 
#&gt;                   "to UTF-8 should work as long as the string is actually encoded in\n", 
#&gt;                   "the locale codeset.\n"), "\n", "\n", "When translating to UTF-8, the strings are parsed for serialised\n", 
#&gt;                 "unicode points (e.g. strings looking like \"U+xxxx\") with\n", 
#&gt;                 list(list("chr_unserialise_unicode()")), ". This helps to alleviate the effects of\n", 
#&gt;                 "character-to-symbol-to-character roundtrips on systems with\n", 
#&gt;                 "non-UTF-8 native encoding.\n"), "\n", list("\n", 
#&gt;                 "# Let's create a string marked as UTF-8 (which is guaranteed by the\n", 
#&gt;                 "# Unicode escaping in the string):\n", "utf8 &lt;- \"caf\\uE9\"\n", 
#&gt;                 "Encoding(utf8)\n", "as_bytes(utf8)\n"), "\n", 
#&gt;             list("internal"), "\n"), `bare-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("bare-type-predicates"), "\n", list("bare-type-predicates"), 
#&gt;             "\n", list("is_bare_list"), "\n", list("is_bare_atomic"), 
#&gt;             "\n", list("is_bare_vector"), "\n", list("is_bare_double"), 
#&gt;             "\n", list("is_bare_integer"), "\n", list("is_bare_numeric"), 
#&gt;             "\n", list("is_bare_character"), "\n", list("is_bare_logical"), 
#&gt;             "\n", list("is_bare_raw"), "\n", list("is_bare_string"), 
#&gt;             "\n", list("is_bare_bytes"), "\n", list("Bare type predicates"), 
#&gt;             "\n", list("\n", "is_bare_list(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_atomic(x, n = NULL)\n", "\n", "is_bare_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_double(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_integer(x, n = NULL)\n", "\n", "is_bare_numeric(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_bare_logical(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_raw(x, n = NULL)\n", "\n", "is_bare_string(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_bytes(x, n = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check for a given type but only return ", 
#&gt;                 list("TRUE"), " for\n", "bare R objects. Bare objects have no class attributes. For example,\n", 
#&gt;                 "a data frame is a list, but not a bare list.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " The predicates for vectors include the ", 
#&gt;                 list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                 list(), " Like ", list(list("is_atomic()")), 
#&gt;                 " and unlike base R ", list("is.atomic()"), ",\n", 
#&gt;                 list("is_bare_atomic()"), " does not return ", 
#&gt;                 list("TRUE"), " for ", list("NULL"), ".\n", list(), 
#&gt;                 " Unlike base R ", list("is.numeric()"), ", ", 
#&gt;                 list("is_bare_double()"), " only returns\n", 
#&gt;                 list("TRUE"), " for floating point numbers.\n"), 
#&gt;                 "\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("scalar-type-predicates"), "\n"), 
#&gt;             "\n"), box.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("box"), "\n", list("box"), "\n", list("new_box"), 
#&gt;             "\n", list("is_box"), "\n", list("unbox"), "\n", 
#&gt;             list("Box a value"), "\n", list("\n", "new_box(.x, class = NULL, ...)\n", 
#&gt;                 "\n", "is_box(x, class = NULL)\n", "\n", "unbox(box)\n"), 
#&gt;             "\n", list("\n", list(list("class"), list("For ", 
#&gt;                 list("new_box()"), ", an additional class for the\n", 
#&gt;                 "boxed value (in addition to ", list("rlang_box"), 
#&gt;                 "). For ", list("is_box()"), ", a class\n", "or vector of classes passed to ", 
#&gt;                 list(list("inherits_all()")), ".")), "\n", "\n", 
#&gt;                 list(list("..."), list("Additional attributes passed to ", 
#&gt;                   list(list("base::structure()")), ".")), "\n", 
#&gt;                 "\n", list(list("x, .x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("box"), list("A boxed value to unbox.")), 
#&gt;                 "\n"), "\n", list("\n", list("new_box()"), " is similar to ", 
#&gt;                 list(list("base::I()")), " but it protects a value by\n", 
#&gt;                 "wrapping it in a scalar list rather than by adding an attribute.\n", 
#&gt;                 list("unbox()"), " retrieves the boxed value. ", 
#&gt;                 list("is_box()"), " tests whether an\n", "object is boxed with optional class. ", 
#&gt;                 list("as_box()"), " ensures that a\n", "value is wrapped in a box. ", 
#&gt;                 list("as_box_if()"), " does the same but only if\n", 
#&gt;                 "the value matches a predicate.\n"), "\n", list(
#&gt;                 "\n", "boxed &lt;- new_box(letters, \"mybox\")\n", 
#&gt;                 "is_box(boxed)\n", "is_box(boxed, \"mybox\")\n", 
#&gt;                 "is_box(boxed, \"otherbox\")\n", "\n", "unbox(boxed)\n", 
#&gt;                 "\n", "# as_box() avoids double-boxing:\n", "boxed2 &lt;- as_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed2\n", "unbox(boxed2)\n", "\n", "# Compare to:\n", 
#&gt;                 "boxed_boxed &lt;- new_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed_boxed\n", "unbox(unbox(boxed_boxed))\n", 
#&gt;                 "\n", "# Use `as_box_if()` with a predicate if you need to ensure a box\n", 
#&gt;                 "# only for a subset of values:\n", "as_box_if(NULL, is_null, \"null_box\")\n", 
#&gt;                 "as_box_if(\"foo\", is_null, \"null_box\")\n"), 
#&gt;             "\n"), call2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call2"), "\n", list("call2"), "\n", list(
#&gt;                 "Create a call"), "\n", list("\n", "call2(.fn, ..., .ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Quoted function calls are one of the two types of\n", 
#&gt;                 list("symbolic"), " objects in R. They represent the action of\n", 
#&gt;                 "calling a function, possibly with arguments. There are two ways of\n", 
#&gt;                 "creating a quoted call:\n", list("\n", list(), 
#&gt;                   " By ", list("quoting"), " it. Quoting prevents functions from being\n", 
#&gt;                   "called. Instead, you get the description of the function call as\n", 
#&gt;                   "an R object. That is, a quoted function call.\n", 
#&gt;                   list(), " By constructing it with ", list(list(
#&gt;                     "base::call()")), ", ", list(list("base::as.call()")), 
#&gt;                   ", or\n", list("call2()"), ". In this case, you pass the call elements (the function\n", 
#&gt;                   "to call and the arguments to call it with) separately.\n"), 
#&gt;                 "\n", "\n", "See section below for the difference between ", 
#&gt;                 list("call2()"), " and the base\n", "constructors.\n"), 
#&gt;             "\n", list(list("Difference with base constructors"), 
#&gt;                 list("\n", "\n", "\n", list("call2()"), " is more flexible and convenient than ", 
#&gt;                   list("base::call()"), ":\n", list("\n", list(), 
#&gt;                     " The function to call can be a string or a ", 
#&gt;                     list("callable"), "\n", "object: a symbol, another call (e.g. a ", 
#&gt;                     list("$"), " or ", list("[["), " call), or a\n", 
#&gt;                     "function to inline. ", list("base::call()"), 
#&gt;                     " only supports strings and you\n", "need to use ", 
#&gt;                     list("base::as.call()"), " to construct a call with a callable\n", 
#&gt;                     "object.", list("call2(list, 1, 2)\n", "\n", 
#&gt;                       "as.call(list(list, 1, 2))\n"), "\n", list(), 
#&gt;                     " The ", list(".ns"), " argument is convenient for creating namespaced calls.", 
#&gt;                     list("call2(\"list\", 1, 2, .ns = \"base\")\n", 
#&gt;                       "\n", "ns_call &lt;- as.call(list(as.name(\"::\"), as.name(\"list\"), as.name(\"base\")))\n", 
#&gt;                       "as.call(list(ns_call, 1, 2))\n"), "\n", 
#&gt;                     list(), " ", list("call2()"), " has ", list(
#&gt;                       "tidy dots"), " support and you can splice lists\n", 
#&gt;                     "of arguments with ", list("!!!"), ". With base R, you need to use ", 
#&gt;                     list("as.call()"), "\n", "instead of ", list(
#&gt;                       "call()"), " if the arguments are in a list.", 
#&gt;                     list("args &lt;- list(na.rm = TRUE, trim = 0)\n", 
#&gt;                       "\n", "call2(\"mean\", 1:10, !!!args)\n", 
#&gt;                       "\n", "as.call(c(list(as.name(\"mean\"), 1:10), args))\n"), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "In rlang 0.2.0 ", list(
#&gt;                   "lang()"), " was soft-deprecated and renamed to\n", 
#&gt;                   list("call2()"), ".\n", "\n", "In early versions of rlang calls were called \"language\" objects in\n", 
#&gt;                   "order to follow the R type nomenclature as returned by\n", 
#&gt;                   list(list("base::typeof()")), ". The goal was to avoid adding to the confusion\n", 
#&gt;                   "between S modes and R types. With hindsight we find it is better to\n", 
#&gt;                   "use more meaningful type names.\n")), "\n", 
#&gt;             "\n", list("\n", "# fn can either be a string, a symbol or a call\n", 
#&gt;                 "call2(\"f\", a = 1)\n", "call2(quote(f), a = 1)\n", 
#&gt;                 "call2(quote(f()), a = 1)\n", "\n", "#' Can supply arguments individually or in a list\n", 
#&gt;                 "call2(quote(f), a = 1, b = 2)\n", "call2(quote(f), !!!list(a = 1, b = 2))\n", 
#&gt;                 "\n", "# Creating namespaced calls is easy:\n", 
#&gt;                 "call2(\"fun\", arg = quote(baz), .ns = \"mypkg\")\n", 
#&gt;                 "\n", "# Empty arguments are preserved:\n", "call2(\"[\", quote(x), , drop = )\n"), 
#&gt;             "\n", list("\n", "call_modify\n"), "\n"), call_args.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_args"), "\n", list("call_args"), "\n", 
#&gt;             list("call_args_names"), "\n", list("Extract arguments from a call"), 
#&gt;             "\n", list("\n", "call_args(call)\n", "\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A named list of arguments.\n"), 
#&gt;             "\n", list("\n", "Extract arguments from a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_args()"), " and ", 
#&gt;                 list("lang_args_names()"), " were\n", "deprecated and renamed to ", 
#&gt;                 list("call_args()"), " and ", list("call_args_names()"), 
#&gt;                 ".\n", "See lifecycle section in ", list(list(
#&gt;                   "call2()")), " for more about this change.\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(f(a, b))\n", 
#&gt;                 "\n", "# Subsetting a call returns the arguments converted to a language\n", 
#&gt;                 "# object:\n", "call[-1]\n", "\n", "# On the other hand, call_args() returns a regular list that is\n", 
#&gt;                 "# often easier to work with:\n", "str(call_args(call))\n", 
#&gt;                 "\n", "# When the arguments are unnamed, a vector of empty strings is\n", 
#&gt;                 "# supplied (rather than NULL):\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("fn_fmls()")), " and ", 
#&gt;                 list(list("fn_fmls_names()")), "\n"), "\n"), 
#&gt;         call_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_fn"), "\n", list("call_fn"), "\n", 
#&gt;             list("Extract function from a call"), "\n", list(
#&gt;                 "\n", "call_fn(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "If a frame or formula, the function will be retrieved from the\n", 
#&gt;                 "associated environment. Otherwise, it is looked up in the calling\n", 
#&gt;                 "frame.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", "In rlang 0.2.0, ", list("lang_fn()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_fn()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about this\n", "change.\n")), "\n", 
#&gt;             "\n", list("\n", "# Extract from a quoted call:\n", 
#&gt;                 "call_fn(quote(matrix()))\n", "call_fn(quo(matrix()))\n", 
#&gt;                 "\n", "# Extract the calling function\n", "test &lt;- function() call_fn(call_frame())\n", 
#&gt;                 "test()\n"), "\n", list("\n", list(list("call_name()")), 
#&gt;                 "\n"), "\n"), call_inspect.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("call_inspect"), "\n", list("call_inspect"), 
#&gt;             "\n", list("Inspect a call"), "\n", list("\n", "call_inspect(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Arguments to display in the returned call.")), 
#&gt;                 "\n"), "\n", list("\n", "This function is useful for quick testing and debugging when you\n", 
#&gt;                 "manipulate expressions and calls. It lets you check that a function\n", 
#&gt;                 "is called with the right arguments. This can be useful in unit\n", 
#&gt;                 "tests for instance. Note that this is just a simple wrapper around\n", 
#&gt;                 list(list("base::match.call()")), ".\n"), "\n", 
#&gt;             list("\n", "call_inspect(foo(bar), \"\" %&gt;% identity())\n"), 
#&gt;             "\n"), call_modify.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_modify"), "\n", list("call_modify"), 
#&gt;             "\n", list("Modify the arguments of a call"), "\n", 
#&gt;             list("\n", "call_modify(.call, ..., .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),\n", 
#&gt;                 "  .standardise = NULL, .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".call"), list("Can be a call, a formula quoting a call in the\n", 
#&gt;                 "right-hand side, or a frame object from which to extract the call\n", 
#&gt;                 "expression.")), "\n", "\n", list(list("..."), 
#&gt;                 list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                 list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".standardise, .env"), 
#&gt;                   list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n"), "\n", list("\n", "A quosure if ", 
#&gt;                 list(".call"), " is a quosure, a call otherwise.\n"), 
#&gt;             "\n", list("\n", "If you are working with a user-supplied call, make sure the\n", 
#&gt;                 "arguments are standardised with ", list(list(
#&gt;                   "call_standardise()")), " before\n", "modifying the call.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " The ", list(".standardise"), 
#&gt;                 " argument is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " In rlang 0.2.0, ", list("lang_modify()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_modify()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about\n", "this change.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(mean(x, na.rm = TRUE))\n", 
#&gt;                 "\n", "# Modify an existing argument\n", "call_modify(call, na.rm = FALSE)\n", 
#&gt;                 "call_modify(call, x = quote(y))\n", "\n", "# Remove an argument\n", 
#&gt;                 "call_modify(call, na.rm = zap())\n", "\n", "# Add a new argument\n", 
#&gt;                 "call_modify(call, trim = 0.1)\n", "\n", "# Add an explicit missing argument:\n", 
#&gt;                 "call_modify(call, na.rm = )\n", "\n", "# Supply a list of new arguments with `!!!`\n", 
#&gt;                 "newargs &lt;- list(na.rm = NULL, trim = 0.1)\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "# Remove multiple arguments by splicing zaps:\n", 
#&gt;                 "newargs &lt;- rep_named(c(\"na.rm\", \"trim\"), list(zap()))\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "\n", "# Modify the `...` arguments as if it were a named argument:\n", 
#&gt;                 "call &lt;- call_modify(call, ... = )\n", "call\n", 
#&gt;                 "\n", "call &lt;- call_modify(call, ... = zap())\n", 
#&gt;                 "call\n", "\n", "\n", "# When you're working with a user-supplied call, standardise it\n", 
#&gt;                 "# beforehand because it might contain unmatched arguments:\n", 
#&gt;                 "user_call &lt;- quote(matrix(x, nc = 3))\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "# Standardising applies the usual argument matching rules:\n", 
#&gt;                 "user_call &lt;- call_standardise(user_call)\n", 
#&gt;                 "user_call\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "\n", "# You can also modify quosures inplace:\n", 
#&gt;                 "f &lt;- quo(matrix(bar))\n", "call_modify(f, quote(foo))\n", 
#&gt;                 "\n", "\n", "# By default, arguments with the same name are kept. This has\n", 
#&gt;                 "# subtle implications, for instance you can move an argument to\n", 
#&gt;                 "# last position by removing it and remapping it:\n", 
#&gt;                 "call &lt;- quote(foo(bar = , baz))\n", "call_modify(call, bar = NULL, bar = missing_arg())\n", 
#&gt;                 "\n", "# You can also choose to keep only the first or last homonym\n", 
#&gt;                 "# arguments:\n", "args &lt;-  list(bar = NULL, bar = missing_arg())\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"first\")\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"last\")\n"), 
#&gt;             "\n"), call_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_name"), "\n", list("call_name"), 
#&gt;             "\n", list("call_ns"), "\n", list("Extract function name or namespaced of a call"), 
#&gt;             "\n", list("\n", "call_name(call)\n", "\n", "call_ns(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A string with the function name, or ", 
#&gt;                 list("NULL"), " if the function\n", "is anonymous.\n"), 
#&gt;             "\n", list("\n", "Extract function name or namespaced of a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_name()"), " was deprecated and renamed to\n", 
#&gt;                 list("call_name()"), ". See lifecycle section in ", 
#&gt;                 list(list("call2()")), " for more about\n", "this change.\n")), 
#&gt;             "\n", "\n", list("\n", "# Extract the function name from quoted calls:\n", 
#&gt;                 "call_name(quote(foo(bar)))\n", "call_name(quo(foo(bar)))\n", 
#&gt;                 "\n", "# Namespaced calls are correctly handled:\n", 
#&gt;                 "call_name(~base::matrix(baz))\n", "\n", "# Anonymous and subsetted functions return NULL:\n", 
#&gt;                 "call_name(quote(foo$bar()))\n", "call_name(quote(foo[[bar]]()))\n", 
#&gt;                 "call_name(quote(foo()()))\n", "\n", "# Extract namespace of a call with call_ns():\n", 
#&gt;                 "call_ns(quote(base::bar()))\n", "\n", "# If not namespaced, call_ns() returns NULL:\n", 
#&gt;                 "call_ns(quote(bar()))\n"), "\n", list("\n", 
#&gt;                 list(list("call_fn()")), "\n"), "\n"), call_standardise.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_standardise"), "\n", list("call_standardise"), 
#&gt;             "\n", list("Standardise a call"), "\n", list("\n", 
#&gt;                 "call_standardise(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure if ", list(
#&gt;                 "call"), " is a quosure, a raw call otherwise.\n"), 
#&gt;             "\n", list("\n", "This is essentially equivalent to ", 
#&gt;                 list(list("base::match.call()")), ", but with\n", 
#&gt;                 "experimental handling of primitive functions.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_standardise()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_standardise()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more\n", "about this change.\n")), "\n", 
#&gt;             "\n"), caller_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("caller_env"), "\n", list("caller_env"), 
#&gt;             "\n", list("current_env"), "\n", list("Get the current or caller environment"), 
#&gt;             "\n", list("\n", "caller_env(n = 1)\n", "\n", "current_env()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " The current environment is the execution environment of the\n", 
#&gt;                 "current function (the one currently being evaluated).\n", 
#&gt;                 list(), " The caller environment is the execution environment of the\n", 
#&gt;                 "function that called the current function.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Let's create a function that returns its current environment and\n", 
#&gt;                 "# its caller environment:\n", "fn &lt;- function() list(current = current_env(), caller = caller_env())\n", 
#&gt;                 "\n", "# The current environment is an unique execution environment\n", 
#&gt;                 "# created when `fn()` was called. The caller environment is the\n", 
#&gt;                 "# global env because that's where we called `fn()`.\n", 
#&gt;                 "fn()\n", "\n", "# Let's call `fn()` again but this time within a function:\n", 
#&gt;                 "g &lt;- function() fn()\n", "\n", "# Now the caller environment is also an unique execution environment.\n", 
#&gt;                 "# This is the exec env created by R for our call to g():\n", 
#&gt;                 "g()\n"), "\n", list("\n", list(list("caller_frame()")), 
#&gt;                 " and ", list(list("current_frame()")), "\n"), 
#&gt;             "\n"), caller_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("caller_fn"), "\n", list("caller_fn"), 
#&gt;             "\n", list("current_fn"), "\n", list("Get properties of the current or caller frame"), 
#&gt;             "\n", list("\n", "caller_fn(n = 1)\n", "\n", "current_fn()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The number of generations to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("\n", list(), " The current frame is the execution context of the function that\n", 
#&gt;                   "is currently being evaluated.\n", list(), 
#&gt;                   " The caller frame is the execution context of the function that\n", 
#&gt;                   "called the function currently being evaluated.\n"), 
#&gt;                 "\n", "\n", "See the ", list("call stack"), " topic for more information.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental.\n")), "\n", 
#&gt;             "\n", list("\n", list(list("caller_env()")), " and ", 
#&gt;                 list(list("current_env()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), caller_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("caller_frame"), "\n", list("caller_frame"), 
#&gt;             "\n", list("Get caller frame"), "\n", list("\n", 
#&gt;                 "caller_frame(n = 1)\n"), "\n", list("\n", list(
#&gt;                 list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), catch_cnd.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("catch_cnd"), "\n", list("catch_cnd"), 
#&gt;             "\n", list("Catch a condition"), "\n", list("\n", 
#&gt;                 "catch_cnd(expr, classes = \"condition\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("Expression to be evaluated with a catching condition\n", 
#&gt;                 "handler.")), "\n", "\n", list(list("classes"), 
#&gt;                 list("A character vector of condition classes to catch. By\n", 
#&gt;                   "default, catches all conditions.")), "\n"), 
#&gt;             "\n", list("\n", "A condition if any was signalled, ", 
#&gt;                 list("NULL"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This is a small wrapper around ", list("tryCatch()"), 
#&gt;                 " that captures any\n", "condition signalled while evaluating its argument. It is useful for\n", 
#&gt;                 "situations where you expect a specific condition to be signalled,\n", 
#&gt;                 "for debugging, and for unit testing.\n"), "\n", 
#&gt;             list("\n", "catch_cnd(10)\n", "catch_cnd(abort(\"an error\"))\n", 
#&gt;                 "catch_cnd(cnd_signal(\"my_condition\", .msg = \"a condition\"))\n"), 
#&gt;             "\n"), chr_unserialise_unicode.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("chr_unserialise_unicode"), "\n", list(
#&gt;                 "chr_unserialise_unicode"), "\n", list("Translate unicode points to UTF-8"), 
#&gt;             "\n", list("\n", "chr_unserialise_unicode(chr)\n"), 
#&gt;             "\n", list("\n", list(list("chr"), list("A character vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "For historical reasons, R translates strings to the native encoding\n", 
#&gt;                 "when they are converted to symbols. This string-to-symbol\n", 
#&gt;                 "conversion is not a rare occurrence and happens for instance to the\n", 
#&gt;                 "names of a list of arguments converted to a call by ", 
#&gt;                 list("do.call()"), ".\n", "\n", "If the string contains unicode characters that cannot be\n", 
#&gt;                 "represented in the native encoding, R serialises those as an ASCII\n", 
#&gt;                 "sequence representing the unicode point. This is why Windows users\n", 
#&gt;                 "with western locales often see strings looking like ", 
#&gt;                 list("&lt;U+xxxx&gt;"), ". To\n", "alleviate some of the pain, rlang parses strings and looks for\n", 
#&gt;                 "serialised unicode points to translate them back to the proper\n", 
#&gt;                 "UTF-8 representation. This transformation occurs automatically in\n", 
#&gt;                 "functions like ", list(list("env_names()")), 
#&gt;                 " and can be manually triggered with\n", list(
#&gt;                   "as_utf8_character()"), " and ", list("chr_unserialise_unicode()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "This function is experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "ascii &lt;- \"&lt;U+5E78&gt;\"\n", 
#&gt;                 "chr_unserialise_unicode(ascii)\n", "\n", "identical(chr_unserialise_unicode(ascii), \"\\u5e78\")\n"), 
#&gt;             "\n", list("internal"), "\n"), cnd.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-error.R, R/cnd.R", 
#&gt;             "\n", list("error_cnd"), "\n", list("error_cnd"), 
#&gt;             "\n", list("cnd"), "\n", list("warning_cnd"), "\n", 
#&gt;             list("message_cnd"), "\n", list("Create a condition object"), 
#&gt;             "\n", list("\n", "error_cnd(.subclass = NULL, ..., message = \"\", trace = NULL,\n", 
#&gt;                 "  parent = NULL)\n", "\n", "cnd(.subclass, ..., message = \"\")\n", 
#&gt;                 "\n", "warning_cnd(.subclass = NULL, ..., message = \"\")\n", 
#&gt;                 "\n", "message_cnd(.subclass = NULL, ..., message = \"\")\n"), 
#&gt;             "\n", list("\n", list(list(".subclass"), list("The condition subclass.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named data fields stored inside the condition\n", 
#&gt;                   "object. These dots are evaluated with ", list(
#&gt;                     "explicit splicing"), ".")), "\n", "\n", 
#&gt;                 list(list("message"), list("A default message to inform the user about the\n", 
#&gt;                   "condition when it is signalled.")), "\n", 
#&gt;                 "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                   " object created by ", list(list("trace_back()")), 
#&gt;                   ".")), "\n", "\n", list(list("parent"), list(
#&gt;                   "A parent condition object created by ", list(
#&gt;                     list("abort()")), ".")), "\n"), "\n", list(
#&gt;                 "\n", "These constructors make it easy to create subclassed conditions.\n", 
#&gt;                 "Conditions are objects that power the error system in R. They can\n", 
#&gt;                 "also be used for passing messages to pre-established handlers.\n"), 
#&gt;             "\n", list("\n", list("cnd()"), " creates objects inheriting from ", 
#&gt;                 list("condition"), ". Conditions\n", "created with ", 
#&gt;                 list("error_cnd()"), ", ", list("warning_cnd()"), 
#&gt;                 " and ", list("message_cnd()"), "\n", "inherit from ", 
#&gt;                 list("error"), ", ", list("warning"), " or ", 
#&gt;                 list("message"), ".\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "The ", list(".type"), 
#&gt;                   " and ", list(".msg"), " arguments have been renamed to ", 
#&gt;                   list(".subclass"), "\n", "and ", list("message"), 
#&gt;                   ". They are deprecated as of rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "# Create a condition inheriting from the s3 type \"foo\":\n", 
#&gt;                 "cnd &lt;- cnd(\"foo\")\n", "\n", "# Signal the condition to potential handlers. Since this is a bare\n", 
#&gt;                 "# condition the signal has no effect if no handlers are set up:\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# When a relevant handler is set up, the signal causes the handler\n", 
#&gt;                 "# to be called:\n", "with_handlers(cnd_signal(cnd), foo = exiting(function(c) \"caught!\"))\n", 
#&gt;                 "\n", "# Handlers can be thrown or executed inplace. See with_handlers()\n", 
#&gt;                 "# documentation for more on this.\n", "\n", 
#&gt;                 "# Signalling an error condition aborts the current computation:\n", 
#&gt;                 "err &lt;- error_cnd(\"foo\", message = \"I am an error\")\n", 
#&gt;                 "try(cnd_signal(err))\n"), "\n", list("\n", list(
#&gt;                 list("cnd_signal()")), ", ", list(list("with_handlers()")), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), cnd_message.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-message.R", 
#&gt;             "\n", list("cnd_message"), "\n", list("cnd_message"), 
#&gt;             "\n", list("cnd_issue"), "\n", list("cnd_bullets"), 
#&gt;             "\n", list("format_bullets"), "\n", list("Build an error message from a main issue and bullet messages"), 
#&gt;             "\n", list("\n", "cnd_message(cnd)\n", "\n", "cnd_issue(cnd, ...)\n", 
#&gt;                 "\n", "cnd_bullets(cnd, ...)\n", "\n", "format_bullets(x)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A named character vector of messages. Elements named as\n", 
#&gt;                   list("x"), " or ", list("i"), " are prefixed with the corresponding bullet.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " assembles an error message from two components:\n", 
#&gt;                 list("\n", list(), " The ", list("cnd_issue()"), 
#&gt;                   " generic. Methods should return a single line.\n", 
#&gt;                   list(), " The ", list("cnd_bullets()"), " generic. Methods should return a named vector\n", 
#&gt;                   "of lines. These lines are automatically prefixed with a bullet by\n", 
#&gt;                   list("cnd_message()"), " (see the section on error statements).\n"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " is automatically called by the ", 
#&gt;                 list("conditionMessage()"), "\n", "for rlang errors so that errors thrown with ", 
#&gt;                 list(list("abort()")), " only need to\n", "implement ", 
#&gt;                 list("cnd_issue()"), " and ", list("cnd_bullets()"), 
#&gt;                 ". It can also be called\n", "in custom ", list(
#&gt;                   "conditionMessage()"), " methods.\n", "\n", 
#&gt;                 "Note that if you pass a named character vector to ", 
#&gt;                 list(list("abort()")), ", you\n", "get the same formatting behaviour as ", 
#&gt;                 list("cnd_message()"), ".\n"), "\n", list(list(
#&gt;                 "Error statements"), list("\n", "\n", "\n", "This experimental infrastructure is based on the idea that\n", 
#&gt;                 "sentences in error messages are best kept short and simple. From\n", 
#&gt;                 "this point of view, the best way to present the information is as a\n", 
#&gt;                 "bullet list of simple sentences containing a single clause.\n", 
#&gt;                 list("cnd_message()"), " helps following this structure by building an error\n", 
#&gt;                 "message from two parts: the ", list("issue"), 
#&gt;                 " and the ", list("bullets"), ".\n", "\n", list(
#&gt;                   "cnd_issue()"), " is the generic for the main error message. It should\n", 
#&gt;                 "be as generic as possible, but since it is a generic it is easy to\n", 
#&gt;                 "override by error subclasses.\n", "\n", "The ", 
#&gt;                 list("cnd_bullets()"), " methods should return a character vector of\n", 
#&gt;                 "sentences. These are automatically prefixed with bullets by\n", 
#&gt;                 list("cnd_message()"), ", according to the following scheme:\n", 
#&gt;                 list("\n", list(), " Elements named ", list("\"i\""), 
#&gt;                   " are prefixed with a blue \"info\" symbol.\n", 
#&gt;                   list(), " Elements named ", list("\"x\""), 
#&gt;                   " are prefixed with a red \"cross\" symbol.\n", 
#&gt;                   list(), " Unnamed elements are prefixed with a \"*\" symbol.\n"), 
#&gt;                 "\n", "\n", "While you are free to lay out the bullets in the order that you\n", 
#&gt;                 "like, \"x\" bullets should usually precede \"i\" bullets.\n")), 
#&gt;             "\n", "\n", list(list("Overriding ", list("cnd_bullets()")), 
#&gt;                 list("\n", "\n", "\n", "Sometimes the generation of an error message depends on the state\n", 
#&gt;                   "of the type checking. In that case, it can be tricky to lazily\n", 
#&gt;                   "generate error messages with ", list("cnd_bullets()"), 
#&gt;                   ": you can either\n", "overspecify your error class hierarchies with one class per state,\n", 
#&gt;                   "or replicate the type-checking control flow within the\n", 
#&gt;                   list("cnd_bullets()"), " method. None of these options are ideal.\n", 
#&gt;                   "\n", "A better option is to define a ", list(
#&gt;                     "cnd_bullets"), " field in your error\n", 
#&gt;                   "object. This should be a function (or a lambda-formula which will\n", 
#&gt;                   "be passed to ", list(list("as_function()")), 
#&gt;                   ") with the same signature as\n", list("cnd_bullets()"), 
#&gt;                   " methods. This function overrides the\n", 
#&gt;                   list("cnd_bullets()"), " generic and can generate an error message tailored\n", 
#&gt;                   "to the state in which the error was constructed.\n", 
#&gt;                   "\n", "Note that as a rule, ", list("cnd_issue()"), 
#&gt;                   " should be a general thematic\n", "issues that does not depend on state. For this reason, it isn't\n", 
#&gt;                   "possible to define an overriding method in the condition object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "This infrastructure is experimental. In particular, the output of\n", 
#&gt;                 list("cnd_message()"), " is likely to change in the future and you shouldn't\n", 
#&gt;                 "test it verbatim in a way that makes R CMD check fail. Instead, use\n", 
#&gt;                 list(list("testthat::verify_output()")), " to monitor the output without causing\n", 
#&gt;                 "CRAN check failures when it changes.\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), cnd_muffle.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("cnd_muffle"), "\n", list("cnd_muffle"), 
#&gt;             "\n", list("Muffle a condition"), "\n", list("\n", 
#&gt;                 "cnd_muffle(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition to muffle.")), "\n"), 
#&gt;             "\n", list("\n", "Unlike ", list(list("exiting()")), 
#&gt;                 " handlers, ", list(list("calling()")), " handlers must be explicit\n", 
#&gt;                 "that they have handled a condition to stop it from propagating to\n", 
#&gt;                 "other handlers. Use ", list("cnd_muffle()"), 
#&gt;                 " within a calling handler (or as\n", "a calling handler, see examples) to prevent any other handlers from\n", 
#&gt;                 "being called for that condition.\n"), "\n", 
#&gt;             list(list("Mufflable conditions"), list("\n", "\n", 
#&gt;                 "\n", "Most conditions signalled by base R are muffable, although the name\n", 
#&gt;                 "of the restart varies. cnd_muffle() will automatically call the\n", 
#&gt;                 "correct restart for you. It is compatible with the following\n", 
#&gt;                 "conditions:\n", list("\n", list(), " ", list(
#&gt;                   "warning"), " and ", list("message"), " conditions. In this case ", 
#&gt;                   list("cnd_muffle()"), "\n", "is equivalent to ", 
#&gt;                   list(list("base::suppressMessages()")), " and\n", 
#&gt;                   list(list("base::suppressWarnings()")), ".\n", 
#&gt;                   list(), " Bare conditions signalled with ", 
#&gt;                   list("signal()"), " or ", list(list("cnd_signal()")), 
#&gt;                   ". Note\n", "that conditions signalled with ", 
#&gt;                   list(list("base::signalCondition()")), " are not\n", 
#&gt;                   "mufflable.\n", list(), " Interrupts are sometimes signalled with a ", 
#&gt;                   list("resume"), " restart on\n", "recent R versions. When this is the case, you can muffle the\n", 
#&gt;                   "interrupt with ", list("cnd_muffle()"), ". Check if a restart is available\n", 
#&gt;                   "with ", list("base::findRestart(\"resume\")"), 
#&gt;                   ".\n"), "\n", "\n", "If you call ", list("cnd_muffle()"), 
#&gt;                 " with a condition that is not mufflable\n", 
#&gt;                 "you will cause a new error to be signalled.\n", 
#&gt;                 list("\n", list(), " Errors are not mufflable since they are signalled in critical\n", 
#&gt;                   "situations where execution cannot continue safely.\n", 
#&gt;                   list(), " Conditions captured with ", list(
#&gt;                     list("base::tryCatch()")), ", ", list(list(
#&gt;                     "with_handlers()")), " or\n", list(list("catch_cnd()")), 
#&gt;                   " are no longer mufflable. Muffling restarts ", 
#&gt;                   list("must"), "\n", "be called from a ", list(
#&gt;                     "calling"), " handler.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() {\n", "  inform(\"Beware!\", \"my_particular_msg\")\n", 
#&gt;                 "  inform(\"On your guard!\")\n", "  \"foobar\"\n", 
#&gt;                 "}\n", "\n", "# Let's install a muffling handler for the condition thrown by `fn()`.\n", 
#&gt;                 "# This will suppress all `my_particular_wng` warnings but let other\n", 
#&gt;                 "# types of warnings go through:\n", "with_handlers(fn(),\n", 
#&gt;                 "  my_particular_msg = calling(function(cnd) {\n", 
#&gt;                 "    inform(\"Dealt with this particular message\")\n", 
#&gt;                 "    cnd_muffle(cnd)\n", "  })\n", ")\n", "\n", 
#&gt;                 "# Note how execution of `fn()` continued normally after dealing\n", 
#&gt;                 "# with that particular message.\n", "\n", "# cnd_muffle() can also be passed to with_handlers() as a calling\n", 
#&gt;                 "# handler:\n", "with_handlers(fn(),\n", "  my_particular_msg = calling(cnd_muffle)\n", 
#&gt;                 ")\n"), "\n", list("internal"), "\n"), cnd_signal.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-signal.R", 
#&gt;             "\n", list("cnd_signal"), "\n", list("cnd_signal"), 
#&gt;             "\n", list("Signal a condition object"), "\n", list(
#&gt;                 "\n", "cnd_signal(cnd, .cnd, .mufflable)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object (see ", 
#&gt;                 list(list("cnd()")), ").")), "\n", "\n", list(
#&gt;                 list(".cnd, .mufflable"), list("These arguments are deprecated.")), 
#&gt;                 "\n"), "\n", list("\n", "The type of signal depends on the class of the condition:\n", 
#&gt;                 list("\n", list(), " A message is signalled if the condition inherits from\n", 
#&gt;                   list("\"message\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("inform()")), " or\n", list(list(
#&gt;                     "base::message()")), ".\n", list(), " A warning is signalled if the condition inherits from\n", 
#&gt;                   list("\"warning\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("warn()")), " or\n", list(list("base::warning()")), 
#&gt;                   ".\n", list(), " An error is signalled if the condition inherits from\n", 
#&gt;                   list("\"error\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("abort()")), " or\n", list(list("base::stop()")), 
#&gt;                   ".\n", list(), " An interrupt is signalled if the condition inherits from\n", 
#&gt;                   list("\"interrupt\""), ". This is equivalent to signalling with\n", 
#&gt;                   list(list("interrupt()")), ".\n"), "\n", "\n", 
#&gt;                 "Use ", list(list("cnd_type()")), " to determine the type of a condition.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list(".cnd"), " has been renamed to ", 
#&gt;                 list("cnd"), " and is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " The ", list(".mufflable"), " argument is deprecated as of rlang 0.3.0 and no\n", 
#&gt;                 "longer has any effect. Non-critical conditions are always\n", 
#&gt;                 "signalled with a muffle restart.\n", list(), 
#&gt;                 " Creating a condition object with ", list(list(
#&gt;                   "cnd_signal()")), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                 list(list("signal()")), " instead.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# The type of signal depends on the class. If the condition\n", 
#&gt;                 "# inherits from \"warning\", a warning is issued:\n", 
#&gt;                 "cnd &lt;- warning_cnd(\"my_warning_class\", message = \"This is a warning\")\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# If it inherits from \"error\", an error is raised:\n", 
#&gt;                 "cnd &lt;- error_cnd(\"my_error_class\", message = \"This is an error\")\n", 
#&gt;                 "try(cnd_signal(cnd))\n"), "\n", list("\n", list(
#&gt;                 list("abort()")), ", ", list(list("warn()")), 
#&gt;                 " and ", list(list("inform()")), " for creating and\n", 
#&gt;                 "signalling structured R conditions. See ", list(
#&gt;                   list("with_handlers()")), " for\n", "establishing condition handlers.\n"), 
#&gt;             "\n"), cnd_type.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("cnd_type"), "\n", list("cnd_type"), "\n", list(
#&gt;                 "What type is a condition?"), "\n", list("\n", 
#&gt;                 "cnd_type(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition object.")), "\n"), 
#&gt;             "\n", list("\n", "A string, either ", list("\"condition\""), 
#&gt;                 ", ", list("\"message\""), ", ", list("\"warning\""), 
#&gt;                 ",\n", list("\"error\""), " or ", list("\"interrupt\""), 
#&gt;                 ".\n"), "\n", list("\n", "Use ", list("cnd_type()"), 
#&gt;                 " to check what type a condition is.\n"), "\n", 
#&gt;             list("\n", "cnd_type(catch_cnd(abort(\"Abort!\")))\n", 
#&gt;                 "cnd_type(catch_cnd(interrupt()))\n"), "\n", 
#&gt;             list("internal"), "\n"), done.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("done"), "\n", list("done"), "\n", list("is_done_box"), 
#&gt;             "\n", list("Box a final value for early termination"), 
#&gt;             "\n", list("\n", "done(x)\n", "\n", "is_done_box(x, empty = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("For ", list(
#&gt;                 "done()"), ", a value to box. For ", list("is_done_box()"), 
#&gt;                 ", a\n", "value to test.")), "\n", "\n", list(
#&gt;                 list("empty"), list("Whether the box is empty. If ", 
#&gt;                   list("NULL"), ", ", list("is_done_box()"), 
#&gt;                   "\n", "returns ", list("TRUE"), " for all done boxes. If ", 
#&gt;                   list("TRUE"), ", it returns ", list("TRUE"), 
#&gt;                   "\n", "only for empty boxes. Otherwise it returns ", 
#&gt;                   list("TRUE"), " only for\n", "non-empty boxes.")), 
#&gt;                 "\n"), "\n", list("\n", "A ", list("boxed"), 
#&gt;                 " value.\n"), "\n", list("\n", "A value boxed with ", 
#&gt;                 list("done()"), " signals to its caller that it\n", 
#&gt;                 "should stop iterating. Use it to shortcircuit a loop.\n"), 
#&gt;             "\n", list("\n", "done(3)\n", "\n", "x &lt;- done(3)\n", 
#&gt;                 "is_done_box(x)\n"), "\n"), dots_definitions.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_definitions"), "\n", list("dots_definitions"), 
#&gt;             "\n", list("Capture definition objects"), "\n", list(
#&gt;                 "\n", "dots_definitions(..., .named = FALSE, .ignore_empty = c(\"trailing\",\n", 
#&gt;                 "  \"none\", \"all\"))\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("For ", list("enexprs()"), 
#&gt;                   ", ", list("ensyms()"), " and ", list("enquos()"), 
#&gt;                   ", names of\n", "arguments to capture without evaluation (including ", 
#&gt;                   list("..."), "). For\n", list("exprs()"), " and ", 
#&gt;                   list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                   "(including expressions contained in ", list(
#&gt;                     "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n"), "\n", list("\n", "Capture definition objects\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("dots_definitions()"), " is experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), dots_n.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_n"), "\n", list("dots_n"), "\n", list(
#&gt;                 "How many arguments are currently forwarded in dots?"), 
#&gt;             "\n", list("\n", "dots_n(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Forwarded arguments.")), 
#&gt;                 "\n"), "\n", list("\n", "This returns the number of arguments currently forwarded in ", 
#&gt;                 list("..."), "\n", "as an integer.\n"), "\n", 
#&gt;             list("\n", "fn &lt;- function(...) dots_n(..., baz)\n", 
#&gt;                 "fn(foo, bar)\n"), "\n", list("internal"), "\n"), 
#&gt;         dots_values.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("dots_values"), "\n", list("dots_values"), 
#&gt;             "\n", list("Evaluate dots with preliminary splicing"), 
#&gt;             "\n", list("\n", "dots_values(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("..."), list("Arguments to evaluate and process splicing operators.")), 
#&gt;                 "\n", "\n", list(list(".ignore_empty"), list(
#&gt;                   "Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a tool for advanced users. It captures dots, processes\n", 
#&gt;                 "unquoting and splicing operators, and evaluates them. Unlike\n", 
#&gt;                 list(list("dots_list()")), ", it does not flatten spliced objects, instead they\n", 
#&gt;                 "are attributed a ", list("spliced"), " class (see ", 
#&gt;                 list(list("splice()")), "). You can process\n", 
#&gt;                 "spliced objects manually, perhaps with a custom predicate (see\n", 
#&gt;                 list(list("flatten_if()")), ").\n"), "\n", list(
#&gt;                 "\n", "dots &lt;- dots_values(!!! list(1, 2), 3)\n", 
#&gt;                 "dots\n", "\n", "# Flatten the objects marked as spliced:\n", 
#&gt;                 "flatten_if(dots, is_spliced)\n"), "\n", list(
#&gt;                 "internal"), "\n"), duplicate.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sexp.R", 
#&gt;             "\n", list("duplicate"), "\n", list("duplicate"), 
#&gt;             "\n", list("Duplicate an R object"), "\n", list("\n", 
#&gt;                 "duplicate(x, shallow = FALSE)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("Any R object. However, uncopyable types like symbols and\n", 
#&gt;                   "environments are returned as is (just like with ", 
#&gt;                   list("&lt;-"), ").")), "\n", "\n", list(list("shallow"), 
#&gt;                   list("This is relevant for recursive data structures like\n", 
#&gt;                     "lists, calls and pairlists. A shallow copy only duplicates the\n", 
#&gt;                     "top-level data structure. The objects contained in the list are\n", 
#&gt;                     "still the same.")), "\n"), "\n", list("\n", 
#&gt;                 "In R semantics, objects are copied by value. This means that\n", 
#&gt;                 "modifying the copy leaves the original object intact. Since\n", 
#&gt;                 "copying data in memory is an expensive operation, copies in R are\n", 
#&gt;                 "as lazy as possible. They only happen when the new object is\n", 
#&gt;                 "actually modified. However, some operations (like ", 
#&gt;                 list(list("node_poke_car()")), "\n", "or ", list(
#&gt;                   list("node_poke_cdr()")), ") do not support copy-on-write. In those cases,\n", 
#&gt;                 "it is necessary to duplicate the object manually in order to\n", 
#&gt;                 "preserve copy-by-value semantics.\n"), "\n", 
#&gt;             list("\n", "Some objects are not duplicable, like symbols and environments.\n", 
#&gt;                 list("duplicate()"), " returns its input for these unique objects.\n"), 
#&gt;             "\n", list("\n", "pairlist\n"), "\n", list("internal"), 
#&gt;             "\n"), empty_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("empty_env"), "\n", list("empty_env"), 
#&gt;             "\n", list("Get the empty environment"), "\n", list(
#&gt;                 "\n", "empty_env()\n"), "\n", list("\n", "The empty environment is the only one that does not have a parent.\n", 
#&gt;                 "It is always used as the tail of an environment chain such as the\n", 
#&gt;                 "search path (see ", list(list("search_envs()")), 
#&gt;                 ").\n"), "\n", list("\n", "# Create environments with nothing in scope:\n", 
#&gt;                 "child_env(empty_env())\n"), "\n"), entrace.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("entrace"), "\n", list("entrace"), "\n", 
#&gt;             list("cnd_entrace"), "\n", list("Add backtrace from error handler"), 
#&gt;             "\n", list("\n", "entrace(cnd, ..., top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "cnd_entrace(cnd, ..., top = NULL, bottom = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("When ", 
#&gt;                 list("entrace()"), " is used as a calling handler, ", 
#&gt;                 list("cnd"), " is\n", "the condition to handle.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Unused. These dots are for future extensions.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n"), "\n", 
#&gt;             list("\n", list("entrace()"), " interrupts an error throw to add an ", 
#&gt;                 list("rlang backtrace"), " to the error. The error throw is\n", 
#&gt;                 "immediately resumed. ", list("cnd_entrace()"), 
#&gt;                 " adds a backtrace to a\n", "condition object, without any other effect. Both functions should\n", 
#&gt;                 "be called directly from an error handler.\n", 
#&gt;                 "\n", "Set the ", list("error"), " global option to ", 
#&gt;                 list("quote(rlang::entrace())"), " to\n", "transform base errors to rlang errors. These enriched errors\n", 
#&gt;                 "include a backtrace. The RProfile is a good place to set the\n", 
#&gt;                 "handler. See ", list("rlang_backtrace_on_error"), 
#&gt;                 " for details.\n", "\n", list("entrace()"), " also works as a ", 
#&gt;                 list("calling"), " handler, though it\n", "is often more practical to use the higher-level function\n", 
#&gt;                 list(list("with_abort()")), ".\n"), "\n", list(
#&gt;                 "\n", "if (FALSE) {  # Not run\n", "\n", "# Set the error handler in your RProfile like this:\n", 
#&gt;                 "if (requireNamespace(\"rlang\", quietly = TRUE)) {\n", 
#&gt;                 "  options(error = rlang::entrace)\n", "}\n", 
#&gt;                 "\n", "}\n"), "\n", list("\n", list(list("with_abort()")), 
#&gt;                 " to promote conditions to rlang errors.\n", 
#&gt;                 list(list("cnd_entrace()")), " to manually add a backtrace to a condition.\n"), 
#&gt;             "\n"), env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env"), "\n", list("env"), "\n", list("child_env"), 
#&gt;             "\n", list("new_environment"), "\n", list("Create a new environment"), 
#&gt;             "\n", list("\n", "env(...)\n", "\n", "child_env(.parent, ...)\n", 
#&gt;                 "\n", "new_environment(data = list(), parent = empty_env())\n"), 
#&gt;             "\n", list("\n", list(list("..., data"), list("Named values. You can supply one unnamed to specify\n", 
#&gt;                 "a custom parent, otherwise it defaults to the current\n", 
#&gt;                 "environment. These dots support ", list("tidy dots"), 
#&gt;                 "\n", "features.")), "\n", "\n", list(list(".parent, parent"), 
#&gt;                 list("A parent environment. Can be an object\n", 
#&gt;                   "supported by ", list(list("as_environment()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "These functions create new environments.\n", 
#&gt;                 list("\n", list(), " ", list("env()"), " creates a child of the current environment by default\n", 
#&gt;                   "and takes a variable number of named objects to populate it.\n", 
#&gt;                   list(), " ", list("new_environment()"), " creates a child of the empty environment by\n", 
#&gt;                   "default and takes a named list of objects to populate it.\n"), 
#&gt;                 "\n"), "\n", list(list("Environments as objects"), 
#&gt;                 list("\n", "\n", "\n", "Environments are containers of uniquely named objects. Their most\n", 
#&gt;                   "common use is to provide a scope for the evaluation of R\n", 
#&gt;                   "expressions. Not all languages have first class environments,\n", 
#&gt;                   "i.e. can manipulate scope as regular objects. Reification of scope\n", 
#&gt;                   "is one of the most powerful features of R as it allows you to change\n", 
#&gt;                   "what objects a function or expression sees when it is evaluated.\n", 
#&gt;                   "\n", "Environments also constitute a data structure in their own\n", 
#&gt;                   "right. They are a collection of uniquely named objects, subsettable\n", 
#&gt;                   "by name and modifiable by reference. This latter property (see\n", 
#&gt;                   "section on reference semantics) is especially useful for creating\n", 
#&gt;                   "mutable OO systems (cf the ", list(list("https://github.com/wch/R6"), 
#&gt;                     list("R6 package")), "\n", "and the ", list(
#&gt;                     list("http://ggplot2.tidyverse.org/articles/extending-ggplot2.html"), 
#&gt;                     list("ggproto system")), "\n", "for extending ggplot2).\n")), 
#&gt;             "\n", "\n", list(list("Inheritance"), list("\n", 
#&gt;                 "\n", "\n", "All R environments (except the ", 
#&gt;                 list("empty environment"), ") are\n", "defined with a parent environment. An environment and its\n", 
#&gt;                 "grandparents thus form a linear hierarchy that is the basis for\n", 
#&gt;                 list(list("https://en.wikipedia.org/wiki/Scope_(computer_science)"), 
#&gt;                   list("lexical scoping")), " in\n", "R. When R evaluates an expression, it looks up symbols in a given\n", 
#&gt;                 "environment. If it cannot find these symbols there, it keeps\n", 
#&gt;                 "looking them up in parent environments. This way, objects defined\n", 
#&gt;                 "in child environments have precedence over objects defined in\n", 
#&gt;                 "parent environments.\n", "\n", "The ability of overriding specific definitions is used in the\n", 
#&gt;                 "tidyeval framework to create powerful domain-specific grammars. A\n", 
#&gt;                 "common use of masking is to put data frame columns in scope. See\n", 
#&gt;                 "for example ", list(list("as_data_mask()")), 
#&gt;                 ".\n")), "\n", "\n", list(list("Reference semantics"), 
#&gt;                 list("\n", "\n", "\n", "Unlike regular objects such as vectors, environments are an\n", 
#&gt;                   list("uncopyable"), " object type. This means that if you\n", 
#&gt;                   "have multiple references to a given environment (by assigning the\n", 
#&gt;                   "environment to another symbol with ", list(
#&gt;                     "&lt;-"), " or passing the environment\n", "as argument to a function), modifying the bindings of one of those\n", 
#&gt;                   "references changes all other references as well.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("child_env()"), 
#&gt;                   " is in the questioning stage. It is redundant now\n", 
#&gt;                   "that ", list("env()"), " accepts parent environments.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# env() creates a new environment which has the current environment\n", 
#&gt;                 "# as parent\n", "env &lt;- env(a = 1, b = \"foo\")\n", 
#&gt;                 "env$b\n", "identical(env_parent(env), current_env())\n", 
#&gt;                 "\n", "# Supply one unnamed argument to override the default:\n", 
#&gt;                 "env &lt;- env(base_env(), a = 1, b = \"foo\")\n", 
#&gt;                 "identical(env_parent(env), base_env())\n", "\n", 
#&gt;                 "\n", "# child_env() lets you specify a parent:\n", 
#&gt;                 "child &lt;- child_env(env, c = \"bar\")\n", "identical(env_parent(child), env)\n", 
#&gt;                 "\n", "# This child environment owns `c` but inherits `a` and `b` from `env`:\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# `parent` is passed to as_environment() to provide handy\n", 
#&gt;                 "# shortcuts. Pass a string to create a child of a package\n", 
#&gt;                 "# environment:\n", "child_env(\"rlang\")\n", 
#&gt;                 "env_parent(child_env(\"rlang\"))\n", "\n", "# Or `NULL` to create a child of the empty environment:\n", 
#&gt;                 "child_env(NULL)\n", "env_parent(child_env(NULL))\n", 
#&gt;                 "\n", "# The base package environment is often a good default choice for a\n", 
#&gt;                 "# parent environment because it contains all standard base\n", 
#&gt;                 "# functions. Also note that it will never inherit from other loaded\n", 
#&gt;                 "# package environments since R keeps the base package at the tail\n", 
#&gt;                 "# of the search path:\n", "base_child &lt;- child_env(\"base\")\n", 
#&gt;                 "env_has(base_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# On the other hand, a child of the empty environment doesn't even\n", 
#&gt;                 "# see a definition for `(`\n", "empty_child &lt;- child_env(NULL)\n", 
#&gt;                 "env_has(empty_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# Note that all other package environments inherit from base_env()\n", 
#&gt;                 "# as well:\n", "rlang_child &lt;- child_env(\"rlang\")\n", 
#&gt;                 "env_has(rlang_child, \"env\", inherit = TRUE)     # rlang function\n", 
#&gt;                 "env_has(rlang_child, \"lapply\", inherit = TRUE)  # base function\n", 
#&gt;                 "\n", "\n", "# Both env() and child_env() support tidy dots features:\n", 
#&gt;                 "objs &lt;- list(b = \"foo\", c = \"bar\")\n", "env &lt;- env(a = 1, !!! objs)\n", 
#&gt;                 "env$c\n", "\n", "# You can also unquote names with the definition operator `:=`\n", 
#&gt;                 "var &lt;- \"a\"\n", "env &lt;- env(!!var := \"A\")\n", 
#&gt;                 "env$a\n", "\n", "\n", "# Use new_environment() to create containers with the empty\n", 
#&gt;                 "# environment as parent:\n", "env &lt;- new_environment()\n", 
#&gt;                 "env_parent(env)\n", "\n", "# Like other new_ constructors, it takes an object rather than dots:\n", 
#&gt;                 "new_environment(list(a = \"foo\", b = \"bar\"))\n"), 
#&gt;             "\n", list("\n", list(list("env_has()")), ", ", list(
#&gt;                 list("env_bind()")), ".\n"), "\n"), env_bind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bind"), "\n", list("env_bind"), "\n", 
#&gt;             list("env_bind_lazy"), "\n", list("env_bind_active"), 
#&gt;             "\n", list("Bind symbols to objects in an environment"), 
#&gt;             "\n", list("\n", "env_bind(.env, ...)\n", "\n", "env_bind_lazy(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_active(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", "The input object ", 
#&gt;                 list(".env"), ", with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", "These functions create bindings in an environment. The bindings are\n", 
#&gt;                 "supplied through ", list("..."), " as pairs of names and values or expressions.\n", 
#&gt;                 list("env_bind()"), " is equivalent to evaluating a ", 
#&gt;                 list("&lt;-"), " expression within\n", "the given environment. This function should take care of the\n", 
#&gt;                 "majority of use cases but the other variants can be useful for\n", 
#&gt;                 "specific problems.\n", list("\n", list(), " ", 
#&gt;                   list("env_bind()"), " takes named ", list("values"), 
#&gt;                   " which are bound in ", list(".env"), ".\n", 
#&gt;                   list("env_bind()"), " is equivalent to ", list(
#&gt;                     list("base::assign()")), ".\n", list(), " ", 
#&gt;                   list("env_bind_active()"), " takes named ", 
#&gt;                   list("functions"), " and creates active\n", 
#&gt;                   "bindings in ", list(".env"), ". This is equivalent to\n", 
#&gt;                   list(list("base::makeActiveBinding()")), ". An active binding executes a\n", 
#&gt;                   "function each time it is evaluated. The arguments are passed to\n", 
#&gt;                   list(list("as_function()")), " so you can supply formulas instead of functions.\n", 
#&gt;                   "\n", "Remember that functions are scoped in their own environment.\n", 
#&gt;                   "These functions can thus refer to symbols from this enclosure\n", 
#&gt;                   "that are not actually in scope in the dynamic environment where\n", 
#&gt;                   "the active bindings are invoked. This allows creative solutions\n", 
#&gt;                   "to difficult problems (see the implementations of ", 
#&gt;                   list("dplyr::do()"), "\n", "methods for an example).\n", 
#&gt;                   list(), " ", list("env_bind_lazy()"), " takes named ", 
#&gt;                   list("expressions"), ". This is equivalent\n", 
#&gt;                   "to ", list(list("base::delayedAssign()")), 
#&gt;                   ". The arguments are captured with\n", list(
#&gt;                     list("exprs()")), " (and thus support call-splicing and unquoting) and\n", 
#&gt;                   "assigned to symbols in ", list(".env"), ". These expressions are not\n", 
#&gt;                   "evaluated immediately but lazily. Once a symbol is evaluated, the\n", 
#&gt;                   "corresponding expression is evaluated in turn and its value is\n", 
#&gt;                   "bound to the symbol (the expressions are thus evaluated only\n", 
#&gt;                   "once, if at all).\n"), "\n"), "\n", list(list(
#&gt;                 "Side effects"), list("\n", "\n", "\n", "Since environments have reference semantics (see relevant section\n", 
#&gt;                 "in ", list(list("env()")), " documentation), modifying the bindings of an environment\n", 
#&gt;                 "produces effects in all other references to that environment. In\n", 
#&gt;                 "other words, ", list("env_bind()"), " and its variants have side effects.\n", 
#&gt;                 "\n", "Like other side-effecty functions like ", 
#&gt;                 list("par()"), " and ", list("options()"), ",\n", 
#&gt;                 list("env_bind()"), " and variants return the old values invisibly.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "Passing an environment wrapper like a formula or a function instead\n", 
#&gt;                 "of an environment is soft-deprecated as of rlang 0.3.0. This\n", 
#&gt;                 "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                 "should now extract the environment separately before calling these\n", 
#&gt;                 "functions.\n")), "\n", "\n", list("\n", "# env_bind() is a programmatic way of assigning values to symbols\n", 
#&gt;                 "# with `&lt;-`. We can add bindings in the current environment:\n", 
#&gt;                 "env_bind(current_env(), foo = \"bar\")\n", "foo\n", 
#&gt;                 "\n", "# Or modify those bindings:\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "env_bind(current_env(), bar = \"BAR\")\n", "bar\n", 
#&gt;                 "\n", "# You can remove bindings by supplying zap sentinels:\n", 
#&gt;                 "env_bind(current_env(), foo = zap())\n", "try(foo)\n", 
#&gt;                 "\n", "# Unquote-splice a named list of zaps\n", 
#&gt;                 "zaps &lt;- rep_named(c(\"foo\", \"bar\"), list(zap()))\n", 
#&gt;                 "env_bind(current_env(), !!!zaps)\n", "try(bar)\n", 
#&gt;                 "\n", "# It is most useful to change other environments:\n", 
#&gt;                 "my_env &lt;- env()\n", "env_bind(my_env, foo = \"foo\")\n", 
#&gt;                 "my_env$foo\n", "\n", "# A useful feature is to splice lists of named values:\n", 
#&gt;                 "vals &lt;- list(a = 10, b = 20)\n", "env_bind(my_env, !!!vals, c = 30)\n", 
#&gt;                 "my_env$b\n", "my_env$c\n", "\n", "# You can also unquote a variable referring to a symbol or a string\n", 
#&gt;                 "# as binding name:\n", "var &lt;- \"baz\"\n", "env_bind(my_env, !!var := \"BAZ\")\n", 
#&gt;                 "my_env$baz\n", "\n", "\n", "# The old values of the bindings are returned invisibly:\n", 
#&gt;                 "old &lt;- env_bind(my_env, a = 1, b = 2, baz = \"baz\")\n", 
#&gt;                 "old\n", "\n", "# You can restore the original environment state by supplying the\n", 
#&gt;                 "# old values back:\n", "env_bind(my_env, !!!old)\n", 
#&gt;                 "\n", "# env_bind_lazy() assigns expressions lazily:\n", 
#&gt;                 "env &lt;- env()\n", "env_bind_lazy(env, name = { cat(\"forced!\\n\"); \"value\" })\n", 
#&gt;                 "\n", "# Referring to the binding will cause evaluation:\n", 
#&gt;                 "env$name\n", "\n", "# But only once, subsequent references yield the final value:\n", 
#&gt;                 "env$name\n", "\n", "# You can unquote expressions:\n", 
#&gt;                 "expr &lt;- quote(message(\"forced!\"))\n", "env_bind_lazy(env, name = !!expr)\n", 
#&gt;                 "env$name\n", "\n", "\n", "# By default the expressions are evaluated in the current\n", 
#&gt;                 "# environment. For instance we can create a local binding and refer\n", 
#&gt;                 "# to it, even though the variable is bound in a different\n", 
#&gt;                 "# environment:\n", "who &lt;- \"mickey\"\n", "env_bind_lazy(env, name = paste(who, \"mouse\"))\n", 
#&gt;                 "env$name\n", "\n", "# You can specify another evaluation environment with `.eval_env`:\n", 
#&gt;                 "eval_env &lt;- env(who = \"minnie\")\n", "env_bind_lazy(env, name = paste(who, \"mouse\"), .eval_env = eval_env)\n", 
#&gt;                 "env$name\n", "\n", "# Or by unquoting a quosure:\n", 
#&gt;                 "quo &lt;- local({\n", "  who &lt;- \"fievel\"\n", 
#&gt;                 "  quo(paste(who, \"mouse\"))\n", "})\n", "env_bind_lazy(env, name = !!quo)\n", 
#&gt;                 "env$name\n", "\n", "# You can create active bindings with env_bind_active(). Active\n", 
#&gt;                 "# bindings execute a function each time they are evaluated:\n", 
#&gt;                 "fn &lt;- function() {\n", "  cat(\"I have been called\\n\")\n", 
#&gt;                 "  rnorm(1)\n", "}\n", "\n", "env &lt;- env()\n", 
#&gt;                 "env_bind_active(env, symbol = fn)\n", "\n", 
#&gt;                 "# `fn` is executed each time `symbol` is evaluated or retrieved:\n", 
#&gt;                 "env$symbol\n", "env$symbol\n", "eval_bare(quote(symbol), env)\n", 
#&gt;                 "eval_bare(quote(symbol), env)\n", "\n", "# All arguments are passed to as_function() so you can use the\n", 
#&gt;                 "# formula shortcut:\n", "env_bind_active(env, foo = ~ runif(1))\n", 
#&gt;                 "env$foo\n", "env$foo\n"), "\n"), env_bind_exprs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("env_bind_exprs"), "\n", list("env_bind_exprs"), 
#&gt;             "\n", list("env_bind_fns"), "\n", list("Bind a promise or active binding"), 
#&gt;             "\n", list("\n", "env_bind_exprs(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_fns(.env, ...)\n"), "\n", list(
#&gt;                 "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.3.0, ", list("env_bind_exprs()"), 
#&gt;                 " and ", list("env_bind_fns()"), " have\n", "been renamed to ", 
#&gt;                 list(list("env_bind_lazy()")), " and ", list(
#&gt;                   list("env_bind_active()")), " for\n", "consistency.\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_are_active.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_are_active"), "\n", list(
#&gt;                 "env_binding_are_active"), "\n", list("env_binding_are_lazy"), 
#&gt;             "\n", list("What kind of environment binding?"), 
#&gt;             "\n", list("\n", "env_binding_are_active(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_lazy(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "A logical vector as long as ", list("nms"), 
#&gt;                 " and named after it.\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_lock.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_lock"), "\n", list("env_binding_lock"), 
#&gt;             "\n", list("env_binding_unlock"), "\n", list("env_binding_are_locked"), 
#&gt;             "\n", list("Lock or unlock environment bindings"), 
#&gt;             "\n", list("\n", "env_binding_lock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_unlock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_locked(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("env_binding_are_unlocked()"), " returns a logical vector as\n", 
#&gt;                 "long as ", list("nms"), " and named after it. ", 
#&gt;                 list("env_binding_lock()"), " and\n", list("env_binding_unlock()"), 
#&gt;                 " return the old value of\n", list("env_binding_are_unlocked()"), 
#&gt;                 " invisibly.\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environment bindings trigger an error when an attempt is\n", 
#&gt;                 "made to redefine the binding.\n"), "\n", list(
#&gt;                 "\n", "# Bindings are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = \"A\", b = \"B\")\n", "env_binding_are_locked(env)\n", 
#&gt;                 "\n", "# But can optionally be locked:\n", "env_binding_lock(env, \"a\")\n", 
#&gt;                 "env_binding_are_locked(env)\n", "\n", "# If run, the following would now return an error because `a` is locked:\n", 
#&gt;                 "# env_bind(env, a = \"foo\")\n", "# with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "\n", "# Let's unlock it. Note that the return value indicate which\n", 
#&gt;                 "# bindings were locked:\n", "were_locked &lt;- env_binding_unlock(env)\n", 
#&gt;                 "were_locked\n", "\n", "# Now that it is unlocked we can modify it again:\n", 
#&gt;                 "env_bind(env, a = \"foo\")\n", "with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "env$a\n"), "\n", list("\n", list(list("env_lock()")), 
#&gt;                 " for locking an environment.\n"), "\n", list(
#&gt;                 "internal"), "\n"), env_bury.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bury"), "\n", list("env_bury"), "\n", 
#&gt;             list("Mask bindings by defining symbols deeper in a scope"), 
#&gt;             "\n", list("\n", "env_bury(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n"), "\n", list("\n", "A copy of ", 
#&gt;                 list(".env"), " enclosing the new environment containing\n", 
#&gt;                 "bindings to ", list("..."), " arguments.\n"), 
#&gt;             "\n", list("\n", list("env_bury()"), " is like ", 
#&gt;                 list(list("env_bind()")), " but it creates the bindings in a\n", 
#&gt;                 "new child environment. This makes sure the new bindings have\n", 
#&gt;                 "precedence over old ones, without altering existing environments.\n", 
#&gt;                 "Unlike ", list("env_bind()"), ", this function does not have side effects and\n", 
#&gt;                 "returns a new environment (or object wrapping that environment).\n"), 
#&gt;             "\n", list("\n", "orig_env &lt;- env(a = 10)\n", "fn &lt;- set_env(function() a, orig_env)\n", 
#&gt;                 "\n", "# fn() currently sees `a` as the value `10`:\n", 
#&gt;                 "fn()\n", "\n", "# env_bury() will bury the current scope of fn() behind a new\n", 
#&gt;                 "# environment:\n", "fn &lt;- env_bury(fn, a = 1000)\n", 
#&gt;                 "fn()\n", "\n", "# Even though the symbol `a` is still defined deeper in the scope:\n", 
#&gt;                 "orig_env$a\n"), "\n", list("\n", list(list("env_bind()")), 
#&gt;                 ", ", list(list("env_unbind()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), env_clone.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_clone"), "\n", list("env_clone"), "\n", 
#&gt;             list("Clone an environment"), "\n", list("\n", "env_clone(env, parent = env_parent(env))\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("The parent of the cloned environment.")), 
#&gt;                 "\n"), "\n", list("\n", "This creates a new environment containing exactly the same objects,\n", 
#&gt;                 "optionally with a new parent.\n"), "\n", list(
#&gt;                 "\n", "env &lt;- env(!!! mtcars)\n", "clone &lt;- env_clone(env)\n", 
#&gt;                 "identical(env, clone)\n", "identical(env$cyl, clone$cyl)\n"), 
#&gt;             "\n"), env_depth.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_depth"), "\n", list("env_depth"), "\n", 
#&gt;             list("Depth of an environment chain"), "\n", list(
#&gt;                 "\n", "env_depth(env)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n"), 
#&gt;             "\n", list("\n", "An integer.\n"), "\n", list("\n", 
#&gt;                 "This function returns the number of environments between ", 
#&gt;                 list("env"), " and\n", "the ", list("empty environment"), 
#&gt;                 ", including ", list("env"), ". The depth of\n", 
#&gt;                 list("env"), " is also the number of parents of ", 
#&gt;                 list("env"), " (since the empty\n", "environment counts as a parent).\n"), 
#&gt;             "\n", list("\n", "env_depth(empty_env())\n", "env_depth(pkg_env(\"rlang\"))\n"), 
#&gt;             "\n", list("\n", "The section on inheritance in ", 
#&gt;                 list(list("env()")), " documentation.\n"), "\n"), 
#&gt;         env_get.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_get"), "\n", list("env_get"), "\n", 
#&gt;             list("env_get_list"), "\n", list("Get an object in an environment"), 
#&gt;             "\n", list("\n", "env_get(env = caller_env(), nm, default, inherit = FALSE)\n", 
#&gt;                 "\n", "env_get_list(env = caller_env(), nms, default, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nm, nms"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default value in case there is no binding for ", 
#&gt;                   list("nm"), "\n", "in ", list("env"), ".")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "An object if it exists. Otherwise, throws an error.\n"), 
#&gt;             "\n", list("\n", list("env_get()"), " extracts an object from an enviroment ", 
#&gt;                 list("env"), ". By\n", "default, it does not look in the parent environments.\n", 
#&gt;                 list("env_get_list()"), " extracts multiple objects from an environment into\n", 
#&gt;                 "a named list.\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# This throws an error because `foo` is not directly defined in env:\n", 
#&gt;                 "# env_get(env, \"foo\")\n", "\n", "# However `foo` can be fetched in the parent environment:\n", 
#&gt;                 "env_get(env, \"foo\", inherit = TRUE)\n", "\n", 
#&gt;                 "# You can also avoid an error by supplying a default value:\n", 
#&gt;                 "env_get(env, \"foo\", default = \"FOO\")\n"), 
#&gt;             "\n"), env_has.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_has"), "\n", list("env_has"), "\n", 
#&gt;             list("Does an environment have or see bindings?"), 
#&gt;             "\n", list("\n", "env_has(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "A named logical vector as long as ", list("nms"), 
#&gt;                 ".\n"), "\n", list("\n", list("env_has()"), " is a vectorised predicate that queries whether an\n", 
#&gt;                 "environment owns bindings personally (with ", 
#&gt;                 list("inherit"), " set to\n", list("FALSE"), 
#&gt;                 ", the default), or sees them in its own environment or in\n", 
#&gt;                 "any of its parents (with ", list("inherit = TRUE"), 
#&gt;                 ").\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# env does not own `foo` but sees it in its parent environment:\n", 
#&gt;                 "env_has(env, \"foo\")\n", "env_has(env, \"foo\", inherit = TRUE)\n"), 
#&gt;             "\n"), env_inherits.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_inherits"), "\n", list("env_inherits"), 
#&gt;             "\n", list("Does environment inherit from another environment?"), 
#&gt;             "\n", list("\n", "env_inherits(env, ancestor)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("ancestor"), list("Another environment from which ", 
#&gt;                   list("x"), " might inherit.")), "\n"), "\n", 
#&gt;             list("\n", "This returns ", list("TRUE"), " if ", 
#&gt;                 list("x"), " has ", list("ancestor"), " among its parents.\n"), 
#&gt;             "\n"), env_lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_lock"), "\n", list("env_lock"), "\n", list(
#&gt;                 "env_is_locked"), "\n", list("Lock an environment"), 
#&gt;             "\n", list("\n", "env_lock(env)\n", "\n", "env_is_locked(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "The old value of ", 
#&gt;                 list("env_is_locked()"), " invisibly.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environments cannot be modified. An important example is\n", 
#&gt;                 "namespace environments which are locked by R when loaded in a\n", 
#&gt;                 "session. Once an environment is locked it normally cannot be\n", 
#&gt;                 "unlocked.\n", "\n", "Note that only the environment as a container is locked, not the\n", 
#&gt;                 "individual bindings. You can't remove or add a binding but you can\n", 
#&gt;                 "still modify the values of existing bindings. See\n", 
#&gt;                 list(list("env_binding_lock()")), " for locking individual bindings.\n"), 
#&gt;             "\n", list("\n", "# New environments are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = 1)\n", "env_is_locked(env)\n", 
#&gt;                 "\n", "# Use env_lock() to lock them:\n", "env_lock(env)\n", 
#&gt;                 "env_is_locked(env)\n", "\n", "# Now that `env` is locked, it is no longer possible to remove or\n", 
#&gt;                 "# add bindings. If run, the following would fail:\n", 
#&gt;                 "# env_unbind(env, \"a\")\n", "# env_bind(env, b = 2)\n", 
#&gt;                 "\n", "# Note that even though the environment as a container is locked,\n", 
#&gt;                 "# the individual bindings are still unlocked and can be modified:\n", 
#&gt;                 "env$a &lt;- 10\n"), "\n", list("\n", list(list(
#&gt;                 "env_binding_lock()")), "\n"), "\n", list("internal"), 
#&gt;             "\n"), env_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("env_name"), "\n", list("env_name"), "\n", 
#&gt;             list("env_label"), "\n", list("Label of an environment"), 
#&gt;             "\n", list("\n", "env_name(env)\n", "\n", "env_label(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Special environments like the global environment have their own\n", 
#&gt;                 "names. ", list("env_name()"), " returns:\n", 
#&gt;                 list("\n", list(), " \"global\" for the global environment.\n", 
#&gt;                   list(), " \"empty\" for the empty environment.\n", 
#&gt;                   list(), " \"base\" for the base package environment (the last environment on\n", 
#&gt;                   "the search path).\n", list(), " \"namespace:pkg\" if ", 
#&gt;                   list("env"), " is the namespace of the package \"pkg\".\n", 
#&gt;                   list(), " The ", list("name"), " attribute of ", 
#&gt;                   list("env"), " if it exists. This is how the\n", 
#&gt;                   list("package environments"), " and the ", 
#&gt;                   list("imports environments"), " store their names. The name of package\n", 
#&gt;                   "environments is typically \"package:pkg\".\n", 
#&gt;                   list(), " The empty string ", list("\"\""), 
#&gt;                   " otherwise.\n"), "\n", "\n", list("env_label()"), 
#&gt;                 " is exactly like ", list("env_name()"), " but returns the memory\n", 
#&gt;                 "address of anonymous environments as fallback.\n"), 
#&gt;             "\n", list("\n", "# Some environments have specific names:\n", 
#&gt;                 "env_name(global_env())\n", "env_name(ns_env(\"rlang\"))\n", 
#&gt;                 "\n", "# Anonymous environments don't have names but are labelled by their\n", 
#&gt;                 "# address in memory:\n", "env_name(env())\n", 
#&gt;                 "env_label(env())\n"), "\n"), env_names.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_names"), "\n", list("env_names"), 
#&gt;             "\n", list("env_length"), "\n", list("Names and numbers of symbols bound in an environment"), 
#&gt;             "\n", list("\n", "env_names(env)\n", "\n", "env_length(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of object names.\n"), 
#&gt;             "\n", list("\n", list("env_names()"), " returns object names from an enviroment ", 
#&gt;                 list("env"), " as a\n", "character vector. All names are returned, even those starting with\n", 
#&gt;                 "a dot. ", list("env_length()"), " returns the number of bindings.\n"), 
#&gt;             "\n", list(list("Names of symbols and objects"), 
#&gt;                 list("\n", "\n", "\n", "Technically, objects are bound to symbols rather than strings,\n", 
#&gt;                   "since the R interpreter evaluates symbols (see ", 
#&gt;                   list(list("is_expression()")), " for a\n", 
#&gt;                   "discussion of symbolic objects versus literal objects). However it\n", 
#&gt;                   "is often more convenient to work with strings. In rlang\n", 
#&gt;                   "terminology, the string corresponding to a symbol is called the\n", 
#&gt;                   list("name"), " of the symbol (or by extension the name of an object bound\n", 
#&gt;                   "to a symbol).\n")), "\n", "\n", list(list(
#&gt;                 "Encoding"), list("\n", "\n", "\n", "There are deep encoding issues when you convert a string to symbol\n", 
#&gt;                 "and vice versa. Symbols are ", list("always"), 
#&gt;                 " in the native encoding. If\n", "that encoding (let's say latin1) cannot support some characters,\n", 
#&gt;                 "these characters are serialised to ASCII. That's why you sometimes\n", 
#&gt;                 "see strings looking like ", list("&lt;U+1234&gt;"), 
#&gt;                 ", especially if you're running\n", "Windows (as R doesn't support UTF-8 as native encoding on that\n", 
#&gt;                 "platform).\n", "\n", "To alleviate some of the encoding pain, ", 
#&gt;                 list("env_names()"), " always\n", "returns a UTF-8 character vector (which is fine even on Windows)\n", 
#&gt;                 "with ASCII unicode points translated back to UTF-8.\n")), 
#&gt;             "\n", "\n", list("\n", "env &lt;- env(a = 1, b = 2)\n", 
#&gt;                 "env_names(env)\n"), "\n"), env_parent.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "env_parent"), "\n", list("env_parent"), "\n", 
#&gt;             list("env_tail"), "\n", list("env_parents"), "\n", 
#&gt;             list("Get parent environments"), "\n", list("\n", 
#&gt;                 "env_parent(env = caller_env(), n = 1)\n", "\n", 
#&gt;                 "env_tail(env = caller_env(), last = global_env(), sentinel = NULL)\n", 
#&gt;                 "\n", "env_parents(env = caller_env(), last = global_env())\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of generations to go up.")), 
#&gt;                 "\n", "\n", list(list("last"), list("The environment at which to stop. Defaults to the\n", 
#&gt;                   "global environment. The empty environment is always a stopping\n", 
#&gt;                   "condition so it is safe to leave the default even when taking the\n", 
#&gt;                   "tail or the parents of an environment on the search path.\n", 
#&gt;                   "\n", list("env_tail()"), " returns the environment which has ", 
#&gt;                   list("last"), " as parent\n", "and ", list(
#&gt;                     "env_parents()"), " returns the list of environments up to ", 
#&gt;                   list("last"), ".")), "\n", "\n", list(list(
#&gt;                   "sentinel"), list("This argument is defunct, please use ", 
#&gt;                   list("last"), " instead.")), "\n"), "\n", list(
#&gt;                 "\n", "An environment for ", list("env_parent()"), 
#&gt;                 " and ", list("env_tail()"), ", a list\n", "of environments for ", 
#&gt;                 list("env_parents()"), ".\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("env_parent()"), 
#&gt;                   " returns the parent environment of ", list(
#&gt;                     "env"), " if called\n", "with ", list("n = 1"), 
#&gt;                   ", the grandparent with ", list("n = 2"), ", etc.\n", 
#&gt;                   list(), " ", list("env_tail()"), " searches through the parents and returns the one\n", 
#&gt;                   "which has ", list(list("empty_env()")), " as parent.\n", 
#&gt;                   list(), " ", list("env_parents()"), " returns the list of all parents, including the\n", 
#&gt;                   "empty environment. This list is named using ", 
#&gt;                   list(list("env_name()")), ".\n"), "\n", "\n", 
#&gt;                 "See the section on ", list("inheritance"), " in ", 
#&gt;                 list(list("env()")), "'s documentation.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "The ", list("sentinel"), " argument of ", list(
#&gt;                   "env_tail()"), " has been deprecated in\n", 
#&gt;                 "rlang 0.2.0 and renamed to ", list("last"), 
#&gt;                 ". It is defunct as of rlang 0.4.0.\n")), "\n", 
#&gt;             "\n", list("\n", "# Get the parent environment with env_parent():\n", 
#&gt;                 "env_parent(global_env())\n", "\n", "# Or the tail environment with env_tail():\n", 
#&gt;                 "env_tail(global_env())\n", "\n", "# By default, env_parent() returns the parent environment of the\n", 
#&gt;                 "# current evaluation frame. If called at top-level (the global\n", 
#&gt;                 "# frame), the following two expressions are equivalent:\n", 
#&gt;                 "env_parent()\n", "env_parent(base_env())\n", 
#&gt;                 "\n", "# This default is more handy when called within a function. In this\n", 
#&gt;                 "# case, the enclosure environment of the function is returned\n", 
#&gt;                 "# (since it is the parent of the evaluation frame):\n", 
#&gt;                 "enclos_env &lt;- env()\n", "fn &lt;- set_env(function() env_parent(), enclos_env)\n", 
#&gt;                 "identical(enclos_env, fn())\n"), "\n"), env_poke.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_poke"), "\n", list("env_poke"), "\n", 
#&gt;             list("Poke an object in an environment"), "\n", list(
#&gt;                 "\n", "env_poke(env = caller_env(), nm, value, inherit = FALSE,\n", 
#&gt;                 "  create = !inherit)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n", 
#&gt;                 "\n", list(list("nm"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for a new binding.")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n", "\n", list(list("create"), 
#&gt;                   list("Whether to create a binding if it does not already\n", 
#&gt;                     "exist in the environment.")), "\n"), "\n", 
#&gt;             list("\n", "The old value of ", list("nm"), " or a ", 
#&gt;                 list("zap sentinel"), " if the\n", "binding did not exist yet.\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("env_poke()"), " will assign or reassign a binding in ", 
#&gt;                 list("env"), " if ", list("create"), "\n", "is ", 
#&gt;                 list("TRUE"), ". If ", list("create"), " is ", 
#&gt;                 list("FALSE"), " and a binding does not already\n", 
#&gt;                 "exists, an error is issued.\n"), "\n", list(
#&gt;                 "\n", "If ", list("inherit"), " is ", list("TRUE"), 
#&gt;                 ", the parents environments are checked for\n", 
#&gt;                 "an existing binding to reassign. If not found and ", 
#&gt;                 list("create"), " is\n", list("TRUE"), ", a new binding is created in ", 
#&gt;                 list("env"), ". The default value for\n", list(
#&gt;                   "create"), " is a function of ", list("inherit"), 
#&gt;                 ": ", list("FALSE"), " when inheriting,\n", list(
#&gt;                   "TRUE"), " otherwise.\n", "\n", "This default makes sense because the inheriting case is mostly\n", 
#&gt;                 "for overriding an existing binding. If not found, something\n", 
#&gt;                 "probably went wrong and it is safer to issue an error. Note that\n", 
#&gt;                 "this is different to the base R operator ", 
#&gt;                 list("&lt;&lt;-"), " which will create\n", "a binding in the global environment instead of the current\n", 
#&gt;                 "environment when no existing binding is found in the parents.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("env_poke()"), " is experimental. We are still experimenting with\n", 
#&gt;                 "reducing the number of redundant functions by using quasiquotation.\n", 
#&gt;                 "It is possible ", list("env_poke()"), " will be deprecated in favour of\n", 
#&gt;                 list("env_bind()"), " and name-unquoting with ", 
#&gt;                 list(":="), ".\n")), "\n", "\n", list("internal"), 
#&gt;             "\n"), env_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_print"), "\n", list("env_print"), "\n", 
#&gt;             list("Pretty-print an environment"), "\n", list("\n", 
#&gt;                 "env_print(env = caller_env())\n"), "\n", list(
#&gt;                 "\n", list(list("env"), list("An environment, or object that can be converted to an\n", 
#&gt;                   "environment by ", list(list("get_env()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This prints:\n", 
#&gt;                 list("\n", list(), " The ", list("label"), " and the parent label.\n", 
#&gt;                   list(), " Whether the environment is ", list(
#&gt;                     "locked"), ".\n", list(), " The bindings in the environment (up to 20 bindings). They are\n", 
#&gt;                   "printed succintly using ", list("pillar::type_sum()"), 
#&gt;                   " (if available,\n", "otherwise uses an internal version of that generic). In addition\n", 
#&gt;                   list("fancy bindings"), " (actives and promises) are\n", 
#&gt;                   "indicated as such.\n", list(), " Locked bindings get a ", 
#&gt;                   list("[L]"), " tag\n"), "\n"), "\n"), env_unbind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_unbind"), "\n", list("env_unbind"), 
#&gt;             "\n", list("Remove bindings from an environment"), 
#&gt;             "\n", list("\n", "env_unbind(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "The input object ", list("env"), " with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", list("env_unbind()"), " is the complement of ", 
#&gt;                 list(list("env_bind()")), ". Like ", list("env_has()"), 
#&gt;                 ",\n", "it ignores the parent environments of ", 
#&gt;                 list("env"), " by default. Set\n", list("inherit"), 
#&gt;                 " to ", list("TRUE"), " to track down bindings in parent environments.\n"), 
#&gt;             "\n", list("\n", "data &lt;- set_names(as.list(letters), letters)\n", 
#&gt;                 "env_bind(environment(), !!! data)\n", "env_has(environment(), letters)\n", 
#&gt;                 "\n", "# env_unbind() removes bindings:\n", "env_unbind(environment(), letters)\n", 
#&gt;                 "env_has(environment(), letters)\n", "\n", "# With inherit = TRUE, it removes bindings in parent environments\n", 
#&gt;                 "# as well:\n", "parent &lt;- child_env(NULL, foo = \"a\")\n", 
#&gt;                 "env &lt;- child_env(parent, foo = \"b\")\n", "env_unbind(env, \"foo\", inherit = TRUE)\n", 
#&gt;                 "env_has(env, \"foo\", inherit = TRUE)\n"), "\n"), 
#&gt;         env_unlock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_unlock"), "\n", list("env_unlock"), "\n", 
#&gt;             list("Unlock an environment"), "\n", list("\n", "env_unlock(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Whether the environment has been unlocked.\n"), 
#&gt;             "\n", list("\n", "This function should only be used in development tools or\n", 
#&gt;                 "interactively.\n"), "\n", list("internal"), 
#&gt;             "\n"), eval_bare.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("eval_bare"), "\n", list("eval_bare"), 
#&gt;             "\n", list("Evaluate an expression in an environment"), 
#&gt;             "\n", list("\n", "eval_bare(expr, env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate the expression.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_bare()"), " is a lower-level version of function ", 
#&gt;                 list(list("base::eval()")), ".\n", "Technically, it is a simple wrapper around the C function\n", 
#&gt;                 list("Rf_eval()"), ". You generally don't need to use ", 
#&gt;                 list("eval_bare()"), " instead\n", "of ", list(
#&gt;                   "eval()"), ". Its main advantage is that it handles stack-sensitive\n", 
#&gt;                 "(calls such as ", list("return()"), ", ", list(
#&gt;                   "on.exit()"), " or ", list("parent.frame()"), 
#&gt;                 ") more\n", "consistently when you pass an enviroment of a frame on the call\n", 
#&gt;                 "stack.\n"), "\n", list("\n", "These semantics are possible because ", 
#&gt;                 list("eval_bare()"), " creates only one\n", "frame on the call stack whereas ", 
#&gt;                 list("eval()"), " creates two frames, the\n", 
#&gt;                 "second of which has the user-supplied environment as frame\n", 
#&gt;                 "environment. When you supply an existing frame environment to\n", 
#&gt;                 list("base::eval()"), " there will be two frames on the stack with the same\n", 
#&gt;                 "frame environment. Stack-sensitive functions only detect the\n", 
#&gt;                 "topmost of these frames. We call these evaluation semantics\n", 
#&gt;                 "\"stack inconsistent\".\n", "\n", "Evaluating expressions in the actual frame environment has useful\n", 
#&gt;                 "practical implications for ", list("eval_bare()"), 
#&gt;                 ":\n", list("\n", list(), " ", list("return()"), 
#&gt;                   " calls are evaluated in frame environments that might\n", 
#&gt;                   "be burried deep in the call stack. This causes a long return that\n", 
#&gt;                   "unwinds multiple frames (triggering the ", 
#&gt;                   list("on.exit()"), " event for\n", "each frame). By contrast ", 
#&gt;                   list("eval()"), " only returns from the ", 
#&gt;                   list("eval()"), "\n", "call, one level up.\n", 
#&gt;                   list(), " ", list("on.exit()"), ", ", list(
#&gt;                     "parent.frame()"), ", ", list("sys.call()"), 
#&gt;                   ", and generally all\n", "the stack inspection functions ", 
#&gt;                   list("sys.xxx()"), " are evaluated in the\n", 
#&gt;                   "correct frame environment. This is similar to how this type of\n", 
#&gt;                   "calls can be evaluated deep in the call stack because of lazy\n", 
#&gt;                   "evaluation, when you force an argument that has been passed\n", 
#&gt;                   "around several times.\n"), "\n", "\n", "The flip side of the semantics of ", 
#&gt;                 list("eval_bare()"), " is that it can't\n", "evaluate ", 
#&gt;                 list("break"), " or ", list("next"), " expressions even if called within a\n", 
#&gt;                 "loop.\n"), "\n", list("\n", "# eval_bare() works just like base::eval() but you have to create\n", 
#&gt;                 "# the evaluation environment yourself:\n", "eval_bare(quote(foo), env(foo = \"bar\"))\n", 
#&gt;                 "\n", "# eval() has different evaluation semantics than eval_bare(). It\n", 
#&gt;                 "# can return from the supplied environment even if its an\n", 
#&gt;                 "# environment that is not on the call stack (i.e. because you've\n", 
#&gt;                 "# created it yourself). The following would trigger an error with\n", 
#&gt;                 "# eval_bare():\n", "ret &lt;- quote(return(\"foo\"))\n", 
#&gt;                 "eval(ret, env())\n", "# eval_bare(ret, env())  # \"no function to return from\" error\n", 
#&gt;                 "\n", "# Another feature of eval() is that you can control surround loops:\n", 
#&gt;                 "bail &lt;- quote(break)\n", "while (TRUE) {\n", 
#&gt;                 "  eval(bail)\n", "  # eval_bare(bail)  # \"no loop for break/next\" error\n", 
#&gt;                 "}\n", "\n", "# To explore the consequences of stack inconsistent semantics, let's\n", 
#&gt;                 "# create a function that evaluates `parent.frame()` deep in the call\n", 
#&gt;                 "# stack, in an environment corresponding to a frame in the middle of\n", 
#&gt;                 "# the stack. For consistency with R's lazy evaluation semantics, we'd\n", 
#&gt;                 "# expect to get the caller of that frame as result:\n", 
#&gt;                 "fn &lt;- function(eval_fn) {\n", "  list(\n", "    returned_env = middle(eval_fn),\n", 
#&gt;                 "    actual_env = current_env()\n", "  )\n", 
#&gt;                 "}\n", "middle &lt;- function(eval_fn) {\n", "  deep(eval_fn, current_env())\n", 
#&gt;                 "}\n", "deep &lt;- function(eval_fn, eval_env) {\n", 
#&gt;                 "  expr &lt;- quote(parent.frame())\n", "  eval_fn(expr, eval_env)\n", 
#&gt;                 "}\n", "\n", "# With eval_bare(), we do get the expected environment:\n", 
#&gt;                 "fn(rlang::eval_bare)\n", "\n", "# But that's not the case with base::eval():\n", 
#&gt;                 "fn(base::eval)\n"), "\n", list("\n", list(list(
#&gt;                 "eval_tidy()")), " for evaluation with data mask and quosure\n", 
#&gt;                 "support.\n"), "\n"), eval_tidy.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("eval_tidy"), "\n", list("eval_tidy"), 
#&gt;             "\n", list("Evaluate an expression with quosures and pronoun support"), 
#&gt;             "\n", list("\n", "eval_tidy(expr, data = NULL, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression or quosure to evaluate.")), 
#&gt;                 "\n", "\n", list(list("data"), list("A data frame, or named list or vector. Alternatively, a\n", 
#&gt;                   "data mask created with ", list(list("as_data_mask()")), 
#&gt;                   " or\n", list(list("new_data_mask()")), ". Objects in ", 
#&gt;                   list("data"), " have priority over those in\n", 
#&gt;                   list("env"), ". See the section about data masking.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate ", 
#&gt;                   list("expr"), ". This\n", "environment is not applicable for quosures because they have\n", 
#&gt;                   "their own environments.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_tidy()"), " is a variant of ", 
#&gt;                 list(list("base::eval()")), " that powers the tidy\n", 
#&gt;                 "evaluation framework. Like ", list("eval()"), 
#&gt;                 " it accepts user data as\n", "argument. Whereas ", 
#&gt;                 list("eval()"), " simply transforms the data to an\n", 
#&gt;                 "environment, ", list("eval_tidy()"), " transforms it to a ", 
#&gt;                 list("data mask"), " with\n", list(list("as_data_mask()")), 
#&gt;                 ". Evaluating in a data mask enables the following\n", 
#&gt;                 "features:\n", list("\n", list(), " ", list("Quosures"), 
#&gt;                   ". Quosures are expressions bundled with an\n", 
#&gt;                   "environment. If ", list("data"), " is supplied, objects in the data mask\n", 
#&gt;                   "always have precedence over the quosure environment, i.e. the\n", 
#&gt;                   "data masks the environment.\n", list(), " ", 
#&gt;                   list("Pronouns"), ". If ", list("data"), " is supplied, the ", 
#&gt;                   list(".env"), " and ", list(".data"), "\n", 
#&gt;                   "pronouns are installed in the data mask. ", 
#&gt;                   list(".env"), " is a reference to\n", "the calling environment and ", 
#&gt;                   list(".data"), " refers to the ", list("data"), 
#&gt;                   " argument.\n", "These pronouns lets you be explicit about where to find\n", 
#&gt;                   "values and throw errors if you try to access non-existent values.\n"), 
#&gt;                 "\n"), "\n", list(list("Data masking"), list(
#&gt;                 "\n", "\n", "\n", "Data masking refers to how columns or objects inside ", 
#&gt;                 list("data"), " have\n", "priority over objects defined in ", 
#&gt;                 list("env"), " (or in the quosure\n", "environment, if applicable). If there is a column ", 
#&gt;                 list("var"), " in ", list("data"), "\n", "and an object ", 
#&gt;                 list("var"), " in ", list("env"), ", and ", list(
#&gt;                   "expr"), " refers to ", list("var"), ", the\n", 
#&gt;                 "column has priority:", list("var &lt;- \"this one?\"\n", 
#&gt;                   "data &lt;- data.frame(var = rep(\"Or that one?\", 3))\n", 
#&gt;                   "\n", "within &lt;- function(data, expr) {\n", 
#&gt;                   "  eval_tidy(enquo(expr), data)\n", "}\n", 
#&gt;                   "\n", "within(data, toupper(var))\n", "#&gt; [1] \"OR THAT ONE?\" \"OR THAT ONE?\" \"OR THAT ONE?\"\n"), 
#&gt;                 "\n", "\n", "Because the columns or objects in ", 
#&gt;                 list("data"), " are always found first,\n", "before objects from ", 
#&gt;                 list("env"), ", we say that the data \"masks\" the\n", 
#&gt;                 "environment.\n")), "\n", "\n", list(list("When should eval_tidy() be used instead of eval()?"), 
#&gt;                 list("\n", "\n", "\n", list("base::eval()"), 
#&gt;                   " is sufficient for simple evaluation. Use\n", 
#&gt;                   list("eval_tidy()"), " when you'd like to support expressions referring to\n", 
#&gt;                   "the ", list(".data"), " pronoun, or when you need to support quosures.\n", 
#&gt;                   "\n", "If you're evaluating an expression captured with quasiquotation\n", 
#&gt;                   "support, it is recommended to use ", list(
#&gt;                     "eval_tidy()"), " because users will\n", 
#&gt;                   "likely unquote quosures.\n", "\n", "Note that unwrapping a quosure with ", 
#&gt;                   list(list("quo_get_expr()")), " does not\n", 
#&gt;                   "guarantee that there is no quosures inside the expression. Quosures\n", 
#&gt;                   "might be unquoted anywhere. For instance, the following does not\n", 
#&gt;                   "work reliably in the presence of nested quosures:", 
#&gt;                   list("my_quoting_fn &lt;- function(x) {\n", "  x &lt;- enquo(x)\n", 
#&gt;                     "  expr &lt;- quo_get_expr(x)\n", "  env &lt;- quo_get_env(x)\n", 
#&gt;                     "  eval(expr, env)\n", "}\n", "\n", "# Works:\n", 
#&gt;                     "my_quoting_fn(toupper(letters))\n", "\n", 
#&gt;                     "# Fails because of a nested quosure:\n", 
#&gt;                     "my_quoting_fn(toupper(!!quo(letters)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("rlang 0.3.0"), "\n", 
#&gt;                   "\n", "Passing an environment to ", list("data"), 
#&gt;                   " is deprecated. Please construct an\n", "rlang data mask with ", 
#&gt;                   list(list("new_data_mask()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "\n", "# With simple quoted expressions eval_tidy() works the same way as\n", 
#&gt;                 "# eval():\n", "apple &lt;- \"apple\"\n", "kiwi &lt;- \"kiwi\"\n", 
#&gt;                 "expr &lt;- quote(paste(apple, kiwi))\n", "expr\n", 
#&gt;                 "\n", "eval(expr)\n", "eval_tidy(expr)\n", "\n", 
#&gt;                 "# Both accept a data mask as argument:\n", "data &lt;- list(apple = \"CARROT\", kiwi = \"TOMATO\")\n", 
#&gt;                 "eval(expr, data)\n", "eval_tidy(expr, data)\n", 
#&gt;                 "\n", "\n", "# In addition eval_tidy() has support for quosures:\n", 
#&gt;                 "with_data &lt;- function(data, expr) {\n", "  quo &lt;- enquo(expr)\n", 
#&gt;                 "  eval_tidy(quo, data)\n", "}\n", "with_data(NULL, apple)\n", 
#&gt;                 "with_data(data, apple)\n", "with_data(data, list(apple, kiwi))\n", 
#&gt;                 "\n", "# Secondly eval_tidy() installs handy pronouns that allow users to\n", 
#&gt;                 "# be explicit about where to find symbols:\n", 
#&gt;                 "with_data(data, .data$apple)\n", "with_data(data, .env$apple)\n", 
#&gt;                 "\n", "\n", "# Note that instead of using `.env` it is often equivalent and may\n", 
#&gt;                 "# be preferred to unquote a value. There are two differences. First\n", 
#&gt;                 "# unquoting happens earlier, when the quosure is created. Secondly,\n", 
#&gt;                 "# subsetting `.env` with the `$` operator may be brittle because\n", 
#&gt;                 "# `$` does not look through the parents of the environment.\n", 
#&gt;                 "#\n", "# For instance using `.env$name` in a magrittr pipeline is an\n", 
#&gt;                 "# instance where this poses problem, because the magrittr pipe\n", 
#&gt;                 "# currently (as of v1.5.0) evaluates its operands in a *child* of\n", 
#&gt;                 "# the current environment (this child environment is where it\n", 
#&gt;                 "# defines the pronoun `.`).\n", list("\n", "  data %&gt;% with_data(!!kiwi)     # \"kiwi\"\n", 
#&gt;                   "  data %&gt;% with_data(.env$kiwi)  # NULL\n"), 
#&gt;                 "\n"), "\n", list("\n", list("quasiquotation"), 
#&gt;                 " for the second leg of the tidy evaluation\n", 
#&gt;                 "framework.\n"), "\n"), exec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("exec"), "\n", list("exec"), "\n", list(
#&gt;                 "Execute a function"), "\n", list("\n", "exec(.fn, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("A function, or function name as a string.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to function.\n", 
#&gt;                   "\n", "These dots support ", list("tidy-dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".env"), 
#&gt;                   list("Environment in which to evaluate the call. This will be\n", 
#&gt;                     "most useful if ", list("f"), " is a string, or the function has side-effects.")), 
#&gt;                 "\n"), "\n", list("\n", "This function constructs and evaluates a call to ", 
#&gt;                 list(".fn"), ".\n", "It has two primary uses:\n", 
#&gt;                 list("\n", list(), " To call a function with arguments stored in a list (if the function\n", 
#&gt;                   "doesn't support ", list("tidy-dots"), ")\n", 
#&gt;                   list(), " To call every function stored in a list (in conjunction with ", 
#&gt;                   list("map()"), "/\n", list(list("lapply()")), 
#&gt;                   ")\n"), "\n"), "\n", list("\n", "args &lt;- list(x = c(1:10, 100, NA), na.rm = TRUE)\n", 
#&gt;                 "exec(\"mean\", !!!args)\n", "exec(\"mean\", !!!args, trim = 0.2)\n", 
#&gt;                 "\n", "fs &lt;- list(a = function() \"a\", b = function() \"b\")\n", 
#&gt;                 "lapply(fs, exec)\n", "\n", "# Compare to do.call it will not automatically inline expressions\n", 
#&gt;                 "# into the evaluated call.\n", "x &lt;- 10\n", 
#&gt;                 "args &lt;- exprs(x1 = x + 1, x2 = x * 2)\n", "exec(list, !!!args)\n", 
#&gt;                 "do.call(list, args)\n", "\n", "# exec() is not designed to generate pretty function calls. This is\n", 
#&gt;                 "# most easily seen if you call a function that captures the call:\n", 
#&gt;                 "f &lt;- disp ~ cyl\n", "exec(\"lm\", f, data = mtcars)\n", 
#&gt;                 "\n", "# If you need finer control over the generated call, you'll need to\n", 
#&gt;                 "# construct it yourself. This may require creating a new environment\n", 
#&gt;                 "# with carefully constructed bindings\n", "data_env &lt;- env(data = mtcars)\n", 
#&gt;                 "eval(expr(lm(!!f, data)), data_env)\n"), "\n"), 
#&gt;         exiting.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("exiting"), "\n", list("exiting"), "\n", 
#&gt;             list("Exiting handler"), "\n", list("\n", "exiting(handler)\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", list("exiting()"), " is no longer necessary as handlers are exiting by default.\n"), 
#&gt;             "\n", list("internal"), "\n"), expr_interp.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("expr_interp"), "\n", list("expr_interp"), 
#&gt;             "\n", list("Process unquote operators in a captured expression"), 
#&gt;             "\n", list("\n", "expr_interp(x, env = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function, raw expression, or formula to interpolate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which unquoted expressions should be\n", 
#&gt;                   "evaluated. By default, the formula or closure environment if a\n", 
#&gt;                   "formula or a function, or the current environment otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "While all capturing functions in the tidy evaluation framework\n", 
#&gt;                 "perform unquote on capture (most notably ", 
#&gt;                 list(list("quo()")), "),\n", list("expr_interp()"), 
#&gt;                 " manually processes unquoting operators in\n", 
#&gt;                 "expressions that are already captured. ", list(
#&gt;                   "expr_interp()"), " should be\n", "called in all user-facing functions expecting a formula as argument\n", 
#&gt;                 "to provide the same quasiquotation functionality as NSE functions.\n"), 
#&gt;             "\n", list("\n", "# All tidy NSE functions like quo() unquote on capture:\n", 
#&gt;                 "quo(list(!!(1 + 2)))\n", "\n", "# expr_interp() is meant to provide the same functionality when you\n", 
#&gt;                 "# have a formula or expression that might contain unquoting\n", 
#&gt;                 "# operators:\n", "f &lt;- ~list(!!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "# Note that only the outer formula is unquoted (which is a reason\n", 
#&gt;                 "# to use expr_interp() as early as possible in all user-facing\n", 
#&gt;                 "# functions):\n", "f &lt;- ~list(~!!(1 + 2), !!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "\n", "# Another purpose for expr_interp() is to interpolate a closure's\n", 
#&gt;                 "# body. This is useful to inline a function within another. The\n", 
#&gt;                 "# important limitation is that all formal arguments of the inlined\n", 
#&gt;                 "# function should be defined in the receiving function:\n", 
#&gt;                 "other_fn &lt;- function(x) toupper(x)\n", "\n", 
#&gt;                 "fn &lt;- expr_interp(function(x) {\n", "  x &lt;- paste0(x, \"_suffix\")\n", 
#&gt;                 "  !!! body(other_fn)\n", "})\n", "fn\n", "fn(\"foo\")\n"), 
#&gt;             "\n"), expr_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_label"), "\n", list("expr_label"), 
#&gt;             "\n", list("expr_name"), "\n", list("expr_text"), 
#&gt;             "\n", list("Turn an expression to a label"), "\n", 
#&gt;             list("\n", "expr_label(expr)\n", "\n", "expr_name(expr)\n", 
#&gt;                 "\n", "expr_text(expr, width = 60L, nlines = Inf)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to labellise.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("expr_text()"), " turns the expression into a single string, which\n", 
#&gt;                 "might be multi-line. ", list("expr_name()"), 
#&gt;                 " is suitable for formatting\n", "names. It works best with symbols and scalar types, but also\n", 
#&gt;                 "accepts calls. ", list("expr_label()"), " formats the expression nicely for use\n", 
#&gt;                 "in messages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are in the questioning stage because they are\n", 
#&gt;                   "redundant with the ", list("quo_"), " variants and do not handle quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# To labellise a function argument, first capture it with\n", 
#&gt;                 "# substitute():\n", "fn &lt;- function(x) expr_label(substitute(x))\n", 
#&gt;                 "fn(x:y)\n", "\n", "# Strings are encoded\n", 
#&gt;                 "expr_label(\"a\\nb\")\n", "\n", "# Names and expressions are quoted with ``\n", 
#&gt;                 "expr_label(quote(x))\n", "expr_label(quote(a + b + c))\n", 
#&gt;                 "\n", "# Long expressions are collapsed\n", "expr_label(quote(foo({\n", 
#&gt;                 "  1 + 2\n", "  print(x)\n", "})))\n"), "\n"), 
#&gt;         expr_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_print"), "\n", list("expr_print"), 
#&gt;             "\n", list("expr_deparse"), "\n", list("Print an expression"), 
#&gt;             "\n", list("\n", "expr_print(x, width = peek_option(\"width\"))\n", 
#&gt;                 "\n", "expr_deparse(x, width = peek_option(\"width\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object or expression to print.")), 
#&gt;                 "\n", "\n", list(list("width"), list("The width of the deparsed or printed expression.\n", 
#&gt;                   "Defaults to the global option ", list("width"), 
#&gt;                   ".")), "\n"), "\n", list("\n", list("expr_print()"), 
#&gt;                 ", powered by ", list("expr_deparse()"), ", is an alternative\n", 
#&gt;                 "printer for R expressions with a few improvements over the base R\n", 
#&gt;                 "printer.\n", list("\n", list(), " It colourises ", 
#&gt;                   list("quosures"), " according to their environment.\n", 
#&gt;                   "Quosures from the global environment are printed normally while\n", 
#&gt;                   "quosures from local environments are printed in unique colour (or\n", 
#&gt;                   "in italic when all colours are taken).\n", 
#&gt;                   list(), " It wraps inlined objects in angular brackets. For instance, an\n", 
#&gt;                   "integer vector unquoted in a function call (e.g.\n", 
#&gt;                   list("expr(foo(!!(1:3)))"), ") is printed like this: ", 
#&gt;                   list("foo(&lt;int: 1L, 2L, 3L&gt;)"), " while by default R prints the code to create that vector:\n", 
#&gt;                   list("foo(1:3)"), " which is ambiguous.\n", 
#&gt;                   list(), " It respects the width boundary (from the global option ", 
#&gt;                   list("width"), ")\n", "in more cases.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# It supports any object. Non-symbolic objects are always printed\n", 
#&gt;                 "# within angular brackets:\n", "expr_print(1:3)\n", 
#&gt;                 "expr_print(function() NULL)\n", "\n", "# Contrast this to how the code to create these objects is printed:\n", 
#&gt;                 "expr_print(quote(1:3))\n", "expr_print(quote(function() NULL))\n", 
#&gt;                 "\n", "# The main cause of non-symbolic objects in expressions is\n", 
#&gt;                 "# quasiquotation:\n", "expr_print(expr(foo(!!(1:3))))\n", 
#&gt;                 "\n", "\n", "# Quosures from the global environment are printed normally:\n", 
#&gt;                 "expr_print(quo(foo))\n", "expr_print(quo(foo(!!quo(bar))))\n", 
#&gt;                 "\n", "# Quosures from local environments are colourised according to\n", 
#&gt;                 "# their environments (if you have crayon installed):\n", 
#&gt;                 "local_quo &lt;- local(quo(foo))\n", "expr_print(local_quo)\n", 
#&gt;                 "\n", "wrapper_quo &lt;- local(quo(bar(!!local_quo, baz)))\n", 
#&gt;                 "expr_print(wrapper_quo)\n"), "\n"), exprs_auto_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quotation.R", "\n", 
#&gt;             list("exprs_auto_name"), "\n", list("exprs_auto_name"), 
#&gt;             "\n", list("quos_auto_name"), "\n", list("Ensure that all elements of a list of expressions are named"), 
#&gt;             "\n", list("\n", "exprs_auto_name(exprs, width = NULL, printer = NULL)\n", 
#&gt;                 "\n", "quos_auto_name(quos, width = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("exprs"), list("A list of expressions.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Deprecated. Maximum width of names.")), 
#&gt;                 "\n", "\n", list(list("printer"), list("Deprecated. A function that takes an expression\n", 
#&gt;                   "and converts it to a string. This function must take an\n", 
#&gt;                   "expression as the first argument and ", list(
#&gt;                     "width"), " as the second\n", "argument.")), 
#&gt;                 "\n", "\n", list(list("quos"), list("A list of quosures.")), 
#&gt;                 "\n"), "\n", list("\n", "This gives default names to unnamed elements of a list of\n", 
#&gt;                 "expressions (or expression wrappers such as formulas or\n", 
#&gt;                 "quosures). ", list("exprs_auto_name()"), " deparses the expressions with\n", 
#&gt;                 list(list("expr_name()")), " by default. ", list(
#&gt;                   "quos_auto_name()"), " deparses with\n", list(
#&gt;                   list("quo_name()")), ".\n"), "\n"), f_rhs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("f_rhs"), "\n", list("f_rhs"), "\n", list("f_rhs&lt;-"), 
#&gt;             "\n", list("f_lhs"), "\n", list("f_lhs&lt;-"), "\n", 
#&gt;             list("f_env"), "\n", list("f_env&lt;-"), "\n", list(
#&gt;                 "Get or set formula components"), "\n", list(
#&gt;                 "\n", "f_rhs(f)\n", "\n", "f_rhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_lhs(f)\n", "\n", "f_lhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_env(f)\n", "\n", "f_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("f, x"), list("A formula")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value to replace with.")), 
#&gt;                 "\n"), "\n", list("\n", list("f_rhs"), " and ", 
#&gt;                 list("f_lhs"), " return language objects (i.e.  atomic\n", 
#&gt;                 "vectors of length 1, a name, or a call). ", 
#&gt;                 list("f_env"), " returns an\n", "environment.\n"), 
#&gt;             "\n", list("\n", list("f_rhs"), " extracts the righthand side, ", 
#&gt;                 list("f_lhs"), " extracts the lefthand\n", "side, and ", 
#&gt;                 list("f_env"), " extracts the environment. All functions throw an\n", 
#&gt;                 "error if ", list("f"), " is not a formula.\n"), 
#&gt;             "\n", list("\n", "f_rhs(~ 1 + 2 + 3)\n", "f_rhs(~ x)\n", 
#&gt;                 "f_rhs(~ \"A\")\n", "f_rhs(1 ~ 2)\n", "\n", "f_lhs(~ y)\n", 
#&gt;                 "f_lhs(x ~ y)\n", "\n", "f_env(~ x)\n"), "\n"), 
#&gt;         f_text.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("f_text"), "\n", list("f_text"), "\n", 
#&gt;             list("f_name"), "\n", list("f_label"), "\n", list(
#&gt;                 "Turn RHS of formula into a string or label"), 
#&gt;             "\n", list("\n", "f_text(x, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "f_name(x)\n", "\n", "f_label(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A formula.")), "\n", 
#&gt;                 "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", "Equivalent of ", list(
#&gt;                 list("expr_text()")), " and ", list(list("expr_label()")), 
#&gt;                 " for formulas.\n"), "\n", list("\n", "f &lt;- ~ a + b + bc\n", 
#&gt;                 "f_text(f)\n", "f_label(f)\n", "\n", "# Names a quoted with ``\n", 
#&gt;                 "f_label(~ x)\n", "# Strings are encoded\n", 
#&gt;                 "f_label(~ \"a\\nb\")\n", "# Long expressions are collapsed\n", 
#&gt;                 "f_label(~ foo({\n", "  1 + 2\n", "  print(x)\n", 
#&gt;                 "}))\n"), "\n"), flatten.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-squash.R", 
#&gt;             "\n", list("flatten"), "\n", list("flatten"), "\n", 
#&gt;             list("flatten_lgl"), "\n", list("flatten_int"), "\n", 
#&gt;             list("flatten_dbl"), "\n", list("flatten_cpl"), "\n", 
#&gt;             list("flatten_chr"), "\n", list("flatten_raw"), "\n", 
#&gt;             list("squash"), "\n", list("squash_lgl"), "\n", list(
#&gt;                 "squash_int"), "\n", list("squash_dbl"), "\n", 
#&gt;             list("squash_cpl"), "\n", list("squash_chr"), "\n", 
#&gt;             list("squash_raw"), "\n", list("flatten_if"), "\n", 
#&gt;             list("squash_if"), "\n", list("Flatten or squash a list of lists into a simpler vector"), 
#&gt;             "\n", list("\n", "flatten(x)\n", "\n", "flatten_lgl(x)\n", 
#&gt;                 "\n", "flatten_int(x)\n", "\n", "flatten_dbl(x)\n", 
#&gt;                 "\n", "flatten_cpl(x)\n", "\n", "flatten_chr(x)\n", 
#&gt;                 "\n", "flatten_raw(x)\n", "\n", "squash(x)\n", 
#&gt;                 "\n", "squash_lgl(x)\n", "\n", "squash_int(x)\n", 
#&gt;                 "\n", "squash_dbl(x)\n", "\n", "squash_cpl(x)\n", 
#&gt;                 "\n", "squash_chr(x)\n", "\n", "squash_raw(x)\n", 
#&gt;                 "\n", "flatten_if(x, predicate = is_spliced)\n", 
#&gt;                 "\n", "squash_if(x, predicate = is_spliced)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A list to flatten or squash. The contents of the list can\n", 
#&gt;                 "be anything for unsuffixed functions ", list(
#&gt;                   "flatten()"), " and ", list("squash()"), "\n", 
#&gt;                 "(as a list is returned), but the contents must match the type for\n", 
#&gt;                 "the other functions.")), "\n", "\n", list(list(
#&gt;                 "predicate"), list("A function of one argument returning whether it\n", 
#&gt;                 "should be spliced.")), "\n"), "\n", list("\n", 
#&gt;                 list("flatten()"), " returns a list, ", list(
#&gt;                   "flatten_lgl()"), " a logical\n", "vector, ", 
#&gt;                 list("flatten_int()"), " an integer vector, ", 
#&gt;                 list("flatten_dbl()"), " a\n", "double vector, and ", 
#&gt;                 list("flatten_chr()"), " a character vector. Similarly\n", 
#&gt;                 "for ", list("squash()"), " and the typed variants (", 
#&gt;                 list("squash_lgl()"), " etc).\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("flatten()"), " removes one level hierarchy from a list, while\n", 
#&gt;                 list("squash()"), " removes all levels. These functions are similar to\n", 
#&gt;                 list(list("unlist()")), " but they are type-stable so you always know what the\n", 
#&gt;                 "type of the output is.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "These functions are in the questioning stage. They have slightly\n", 
#&gt;                 "different semantics than the flattening functions in purrr and we\n", 
#&gt;                 "are currently rethinking our approach to flattening with the new\n", 
#&gt;                 "typing facilities of the vctrs package.\n")), 
#&gt;             "\n", "\n", list("\n", "x &lt;- replicate(2, sample(4), simplify = FALSE)\n", 
#&gt;                 "x\n", "\n", "flatten(x)\n", "flatten_int(x)\n", 
#&gt;                 "\n", "# With flatten(), only one level gets removed at a time:\n", 
#&gt;                 "deep &lt;- list(1, list(2, list(3)))\n", "flatten(deep)\n", 
#&gt;                 "flatten(flatten(deep))\n", "\n", "# But squash() removes all levels:\n", 
#&gt;                 "squash(deep)\n", "squash_dbl(deep)\n", "\n", 
#&gt;                 "# The typed flatten functions remove one level and coerce to an atomic\n", 
#&gt;                 "# vector at the same time:\n", "flatten_dbl(list(1, list(2)))\n", 
#&gt;                 "\n", "# Only bare lists are flattened, but you can splice S3 lists\n", 
#&gt;                 "# explicitly:\n", "foo &lt;- set_attrs(list(\"bar\"), class = \"foo\")\n", 
#&gt;                 "str(flatten(list(1, foo, list(100))))\n", "str(flatten(list(1, splice(foo), list(100))))\n", 
#&gt;                 "\n", "# Instead of splicing manually, flatten_if() and squash_if() let\n", 
#&gt;                 "# you specify a predicate function:\n", "is_foo &lt;- function(x) inherits(x, \"foo\") || is_bare_list(x)\n", 
#&gt;                 "str(flatten_if(list(1, foo, list(100)), is_foo))\n", 
#&gt;                 "\n", "# squash_if() does the same with deep lists:\n", 
#&gt;                 "deep_foo &lt;- list(1, list(foo, list(foo, 100)))\n", 
#&gt;                 "str(deep_foo)\n", "\n", "str(squash(deep_foo))\n", 
#&gt;                 "str(squash_if(deep_foo, is_foo))\n"), "\n", 
#&gt;             list("internal"), "\n"), fn_body.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_body"), "\n", list("fn_body"), "\n", list(
#&gt;                 "fn_body&lt;-"), "\n", list("Get or set function body"), 
#&gt;             "\n", list("\n", "fn_body(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_body(fn) &lt;- value\n"), "\n", list("\n", list(
#&gt;                 list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                   "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_body()"), " is a simple wrapper around ", 
#&gt;                 list(list("base::body()")), ". It always\n", 
#&gt;                 "returns a ", list("{"), " expression and throws an error when the input is a\n", 
#&gt;                 "primitive function (whereas ", list("body()"), 
#&gt;                 " returns ", list("NULL"), "). The setter\n", 
#&gt;                 "version preserves attributes, unlike ", list(
#&gt;                   "body&lt;-"), ".\n"), "\n", list("\n", "# fn_body() is like body() but always returns a block:\n", 
#&gt;                 "fn &lt;- function() do()\n", "body(fn)\n", "fn_body(fn)\n", 
#&gt;                 "\n", "# It also throws an error when used on a primitive function:\n", 
#&gt;                 "try(fn_body(base::list))\n"), "\n"), fn_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "fn_env"), "\n", list("fn_env"), "\n", list("fn_env&lt;-"), 
#&gt;             "\n", list("Return the closure environment of a function"), 
#&gt;             "\n", list("\n", "fn_env(fn)\n", "\n", "fn_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn, x"), list("A function.")), 
#&gt;                 "\n", "\n", list(list("value"), list("A new closure environment for the function.")), 
#&gt;                 "\n"), "\n", list("\n", "Closure environments define the scope of functions (see ", 
#&gt;                 list(list("env()")), ").\n", "When a function call is evaluated, R creates an evaluation frame\n", 
#&gt;                 "(see ", list(list("ctxt_stack()")), ") that inherits from the closure environment.\n", 
#&gt;                 "This makes all objects defined in the closure environment and all\n", 
#&gt;                 "its parents available to code executed within the function.\n"), 
#&gt;             "\n", list("\n", list("fn_env()"), " returns the closure environment of ", 
#&gt;                 list("fn"), ". There is also\n", "an assignment method to set a new closure environment.\n"), 
#&gt;             "\n", list("\n", "env &lt;- child_env(\"base\")\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(fn_env(fn), env)\n", 
#&gt;                 "\n", "other_env &lt;- child_env(\"base\")\n", "fn_env(fn) &lt;- other_env\n", 
#&gt;                 "identical(fn_env(fn), other_env)\n"), "\n"), 
#&gt;         fn_fmls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_fmls"), "\n", list("fn_fmls"), "\n", list(
#&gt;                 "fn_fmls_names"), "\n", list("fn_fmls_syms"), 
#&gt;             "\n", list("fn_fmls&lt;-"), "\n", list("fn_fmls_names&lt;-"), 
#&gt;             "\n", list("Extract arguments from a function"), 
#&gt;             "\n", list("\n", "fn_fmls(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_fmls_names(fn = caller_fn())\n", "\n", "fn_fmls_syms(fn = caller_fn())\n", 
#&gt;                 "\n", "fn_fmls(fn) &lt;- value\n", "\n", "fn_fmls_names(fn) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                 "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_fmls()"), " returns a named list of formal arguments.\n", 
#&gt;                 list("fn_fmls_names()"), " returns the names of the arguments.\n", 
#&gt;                 list("fn_fmls_syms()"), " returns formals as a named list of symbols. This\n", 
#&gt;                 "is especially useful for forwarding arguments in ", 
#&gt;                 list("constructed calls"), ".\n"), "\n", list(
#&gt;                 "\n", "Unlike ", list("formals()"), ", these helpers throw an error with primitive\n", 
#&gt;                 "functions instead of returning ", list("NULL"), 
#&gt;                 ".\n"), "\n", list("\n", "# Extract from current call:\n", 
#&gt;                 "fn &lt;- function(a = 1, b = 2) fn_fmls()\n", "fn()\n", 
#&gt;                 "\n", "# fn_fmls_syms() makes it easy to forward arguments:\n", 
#&gt;                 "call2(\"apply\", !!! fn_fmls_syms(lapply))\n", 
#&gt;                 "\n", "# You can also change the formals:\n", 
#&gt;                 "fn_fmls(fn) &lt;- list(A = 10, B = 20)\n", "fn()\n", 
#&gt;                 "\n", "fn_fmls_names(fn) &lt;- c(\"foo\", \"bar\")\n", 
#&gt;                 "fn()\n"), "\n", list("\n", list(list("call_args()")), 
#&gt;                 " and ", list(list("call_args_names()")), "\n"), 
#&gt;             "\n"), frame_position.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("frame_position"), "\n", list("frame_position"), 
#&gt;             "\n", list("Find the position or distance of a frame on the evaluation stack"), 
#&gt;             "\n", list("\n", "frame_position(frame, from = c(\"global\", \"current\"))\n"), 
#&gt;             "\n", list("\n", list(list("frame"), list("The environment of a frame. Can be any object with a\n", 
#&gt;                 list(list("get_env()")), " method. Note that for frame objects, the position from\n", 
#&gt;                 "the global frame is simply ", list("frame$pos"), 
#&gt;                 ". Alternatively, ", list("frame"), "\n", "can be an integer that represents the position on the stack (and\n", 
#&gt;                 "is thus returned as is if ", list("from"), " is \"global\".")), 
#&gt;                 "\n", "\n", list(list("from"), list("Whether to compute distance from the global frame (the\n", 
#&gt;                   "bottom of the evaluation stack), or from the current frame (the\n", 
#&gt;                   "top of the evaluation stack).")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "The frame position on the stack can be computed by counting frames\n", 
#&gt;                 "from the global frame (the bottom of the stack, the default) or\n", 
#&gt;                 "from the current frame (the top of the stack).\n"), 
#&gt;             "\n", list("\n", "While this function returns the position of the frame on the\n", 
#&gt;                 "evaluation stack, it can safely be called with intervening frames\n", 
#&gt;                 "as those will be discarded.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are deprecated and replaced by ", 
#&gt;                   list(list("trace_back()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) frame_position(env)\n", "\n", 
#&gt;                 "# frame_position() returns the position of the frame on the evaluation stack:\n", 
#&gt;                 "fn()\n", "identity(identity(fn()))\n", "\n", 
#&gt;                 "# Note that it trims off intervening calls before counting so you\n", 
#&gt;                 "# can safely nest it within other calls:\n", 
#&gt;                 "g &lt;- function(env) identity(identity(frame_position(env)))\n", 
#&gt;                 "fn()\n", "\n", "# You can also ask for the position from the current frame rather\n", 
#&gt;                 "# than the global frame:\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) frame_position(env, from = \"current\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), friendly_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("friendly_type"), "\n", list("friendly_type"), 
#&gt;             "\n", list("Format a type for error messages"), "\n", 
#&gt;             list("\n", "friendly_type(type)\n"), "\n", list("\n", 
#&gt;                 list(list("type"), list("A type as returned by ", 
#&gt;                   list(list("typeof()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "A string of the prettified type, qualified with an\n", 
#&gt;                 "indefinite article.\n"), "\n", list("\n", "Format a type for error messages\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("friendly_type()"), " is experimental.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "friendly_type(\"logical\")\n", 
#&gt;                 "friendly_type(\"integer\")\n", "friendly_type(\"string\")\n"), 
#&gt;             "\n", list("internal"), "\n"), get_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "get_env"), "\n", list("get_env"), "\n", list(
#&gt;                 "set_env"), "\n", list("env_poke_parent"), "\n", 
#&gt;             list("Get or set the environment of an object"), 
#&gt;             "\n", list("\n", "get_env(env, default = NULL)\n", 
#&gt;                 "\n", "set_env(env, new_env = caller_env())\n", 
#&gt;                 "\n", "env_poke_parent(env, new_env)\n"), "\n", 
#&gt;             list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The default environment in case ", 
#&gt;                   list("env"), " does not wrap\n", "an environment. If ", 
#&gt;                   list("NULL"), " and no environment could be extracted,\n", 
#&gt;                   "an error is issued.")), "\n", "\n", list(list(
#&gt;                   "new_env"), list("An environment to replace ", 
#&gt;                   list("env"), " with.")), "\n"), "\n", list(
#&gt;                 "\n", "These functions dispatch internally with methods for functions,\n", 
#&gt;                 "formulas and frames. If called with a missing argument, the\n", 
#&gt;                 "environment of the current evaluation frame (see ", 
#&gt;                 list(list("ctxt_stack()")), ") is\n", "returned. If you call ", 
#&gt;                 list("get_env()"), " with an environment, it acts as\n", 
#&gt;                 "the identity function and the environment is simply returned (this\n", 
#&gt;                 "helps simplifying code when writing generic functions for\n", 
#&gt;                 "environments).\n"), "\n", list("\n", "While ", 
#&gt;                 list("set_env()"), " returns a modified copy and does not have side\n", 
#&gt;                 "effects, ", list("env_poke_parent()"), " operates changes the environment by\n", 
#&gt;                 "side effect. This is because environments are\n", 
#&gt;                 list("uncopyable"), ". Be careful not to change environments\n", 
#&gt;                 "that you don't own, e.g. a parent environment of a function from a\n", 
#&gt;                 "package.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Using ", 
#&gt;                   list("get_env()"), " without supplying ", list(
#&gt;                     "env"), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                   list(list("current_env()")), " to retrieve the\n", 
#&gt;                   "current environment.\n", list(), " Passing environment wrappers like formulas or functions instead\n", 
#&gt;                   "of bare environments is deprecated as of rlang 0.3.0. This\n", 
#&gt;                   "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                   "should now extract the environment separately before calling\n", 
#&gt;                   "these functions.\n"), "\n")), "\n", "\n", 
#&gt;             list("\n", "# Environment of closure functions:\n", 
#&gt;                 "fn &lt;- function() \"foo\"\n", "get_env(fn)\n", 
#&gt;                 "\n", "# Or of quosures or formulas:\n", "get_env(~foo)\n", 
#&gt;                 "get_env(quo(foo))\n", "\n", "\n", "# Provide a default in case the object doesn't bundle an environment.\n", 
#&gt;                 "# Let's create an unevaluated formula:\n", "f &lt;- quote(~foo)\n", 
#&gt;                 "\n", "# The following line would fail if run because unevaluated formulas\n", 
#&gt;                 "# don't bundle an environment (they didn't have the chance to\n", 
#&gt;                 "# record one yet):\n", "# get_env(f)\n", "\n", 
#&gt;                 "# It is often useful to provide a default when you're writing\n", 
#&gt;                 "# functions accepting formulas as input:\n", 
#&gt;                 "default &lt;- env()\n", "identical(get_env(f, default), default)\n", 
#&gt;                 "\n", "# set_env() can be used to set the enclosure of functions and\n", 
#&gt;                 "# formulas. Let's create a function with a particular environment:\n", 
#&gt;                 "env &lt;- child_env(\"base\")\n", "fn &lt;- set_env(function() NULL, env)\n", 
#&gt;                 "\n", "# That function now has `env` as enclosure:\n", 
#&gt;                 "identical(get_env(fn), env)\n", "identical(get_env(fn), current_env())\n", 
#&gt;                 "\n", "# set_env() does not work by side effect. Setting a new environment\n", 
#&gt;                 "# for fn has no effect on the original function:\n", 
#&gt;                 "other_env &lt;- child_env(NULL)\n", "set_env(fn, other_env)\n", 
#&gt;                 "identical(get_env(fn), other_env)\n", "\n", 
#&gt;                 "# Since set_env() returns a new function with a different\n", 
#&gt;                 "# environment, you'll need to reassign the result:\n", 
#&gt;                 "fn &lt;- set_env(fn, other_env)\n", "identical(get_env(fn), other_env)\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_env()")), " and ", 
#&gt;                 list(list("quo_set_env()")), " for versions of\n", 
#&gt;                 list(list("get_env()")), " and ", list(list("set_env()")), 
#&gt;                 " that only work on quosures.\n"), "\n"), has_length.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/attr.R", "\n", 
#&gt;             list("has_length"), "\n", list("has_length"), "\n", 
#&gt;             list("How long is an object?"), "\n", list("\n", 
#&gt;                 "has_length(x, n = NULL)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("A R object.")), "\n", "\n", 
#&gt;                 list(list("n"), list("A specific length to test ", 
#&gt;                   list("x"), " with. If ", list("NULL"), ",\n", 
#&gt;                   list("has_length()"), " returns ", list("TRUE"), 
#&gt;                   " if ", list("x"), " has length greater than\n", 
#&gt;                   "zero, and ", list("FALSE"), " otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a function for the common task of testing the length of an\n", 
#&gt;                 "object. It checks the length of an object in a non-generic way:\n", 
#&gt;                 list(list("base::length()")), " methods are ignored.\n"), 
#&gt;             "\n", list("\n", "has_length(list())\n", "has_length(list(), 0)\n", 
#&gt;                 "\n", "has_length(letters)\n", "has_length(letters, 20)\n", 
#&gt;                 "has_length(letters, 26)\n"), "\n", list("internal"), 
#&gt;             "\n"), has_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("has_name"), "\n", list("has_name"), "\n", 
#&gt;             list("Does an object have an element with this name?"), 
#&gt;             "\n", list("\n", "has_name(x, name)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A data frame or another named object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Element name(s) to check")), 
#&gt;                 "\n"), "\n", list("\n", "A logical vector of the same length as ", 
#&gt;                 list("name"), "\n"), "\n", list("\n", "This function returns a logical value that indicates if a data\n", 
#&gt;                 "frame or another named object contains an element with a specific\n", 
#&gt;                 "name. Note that ", list("has_name()"), " only works with vectors. For instance,\n", 
#&gt;                 "environments need the specialised function ", 
#&gt;                 list(list("env_has()")), ".\n"), "\n", list("\n", 
#&gt;                 "Unnamed objects are treated as if all names are empty strings. ", 
#&gt;                 list("NA"), "\n", "input gives ", list("FALSE"), 
#&gt;                 " as output.\n"), "\n", list("\n", "has_name(iris, \"Species\")\n", 
#&gt;                 "has_name(mtcars, \"gears\")\n"), "\n"), inherits_any.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "inherits_any"), "\n", list("inherits_any"), 
#&gt;             "\n", list("inherits_all"), "\n", list("inherits_only"), 
#&gt;             "\n", list("Does an object inherit from a set of classes?"), 
#&gt;             "\n", list("\n", "inherits_any(x, class)\n", "\n", 
#&gt;                 "inherits_all(x, class)\n", "\n", "inherits_only(x, class)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test for inheritance.")), 
#&gt;                 "\n", "\n", list(list("class"), list("A character vector of classes.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " ", 
#&gt;                 list("inherits_any()"), " is like ", list(list(
#&gt;                   "base::inherits()")), " but is more explicit\n", 
#&gt;                 "about its behaviour with multiple classes. If ", 
#&gt;                 list("classes"), " contains\n", "several elements and the object inherits from at least one of\n", 
#&gt;                 "them, ", list("inherits_any()"), " returns ", 
#&gt;                 list("TRUE"), ".\n", list(), " ", list("inherits_all()"), 
#&gt;                 " tests that an object inherits from all of the\n", 
#&gt;                 "classes in the supplied order. This is usually the best way to\n", 
#&gt;                 "test for inheritance of multiple classes.\n", 
#&gt;                 list(), " ", list("inherits_only()"), " tests that the class vectors are identical. It\n", 
#&gt;                 "is a shortcut for ", list("identical(class(x), class)"), 
#&gt;                 ".\n"), "\n"), "\n", list("\n", "obj &lt;- structure(list(), class = c(\"foo\", \"bar\", \"baz\"))\n", 
#&gt;                 "\n", "# With the _any variant only one class must match:\n", 
#&gt;                 "inherits_any(obj, c(\"foobar\", \"bazbaz\"))\n", 
#&gt;                 "inherits_any(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "\n", "# With the _all variant all classes must match:\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"baz\"))\n", "\n", 
#&gt;                 "# The order of classes must match as well:\n", 
#&gt;                 "inherits_all(obj, c(\"baz\", \"foo\"))\n", "\n", 
#&gt;                 "# inherits_only() checks that the class vectors are identical:\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"baz\"))\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"bar\", \"baz\"))\n"), 
#&gt;             "\n"), invoke.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("invoke"), "\n", list("invoke"), "\n", 
#&gt;             list("Invoke a function with a list of arguments"), 
#&gt;             "\n", list("\n", "invoke(.fn, .args = list(), ..., .env = caller_env(),\n", 
#&gt;                 "  .bury = c(\".fn\", \"\"))\n"), "\n", list(
#&gt;                 "\n", list(list(".fn"), list("A function to invoke. Can be a function object or the\n", 
#&gt;                   "name of a function in scope of ", list(".env"), 
#&gt;                   ".")), "\n", "\n", list(list(".args, ..."), 
#&gt;                   list("List of arguments (possibly named) to be passed to\n", 
#&gt;                     list(".fn"), ".")), "\n", "\n", list(list(
#&gt;                   ".env"), list("The environment in which to call ", 
#&gt;                   list(".fn"), ".")), "\n", "\n", list(list(".bury"), 
#&gt;                   list("A character vector of length 2. The first string\n", 
#&gt;                     "specifies which name should the function have in the call\n", 
#&gt;                     "recorded in the evaluation stack. The second string specifies a\n", 
#&gt;                     "prefix for the argument names. Set ", list(
#&gt;                       ".bury"), " to ", list("NULL"), " if you\n", 
#&gt;                     "prefer to inline the function and its arguments in the call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "Normally, you invoke a R function by typing arguments manually. A\n", 
#&gt;                 "powerful alternative is to call a function with a list of arguments\n", 
#&gt;                 "assembled programmatically. This is the purpose of ", 
#&gt;                 list("invoke()"), ".\n"), "\n", list("\n", "Technically, ", 
#&gt;                 list("invoke()"), " is basically a version of ", 
#&gt;                 list(list("base::do.call()")), "\n", "that creates cleaner call traces because it does not inline the\n", 
#&gt;                 "function and the arguments in the call (see examples). To achieve\n", 
#&gt;                 "this, ", list("invoke()"), " creates a child environment of ", 
#&gt;                 list(".env"), " with ", list(".fn"), "\n", "and all arguments bound to new symbols (see ", 
#&gt;                 list(list("env_bury()")), "). It then\n", "uses the same strategy as ", 
#&gt;                 list(list("eval_bare()")), " to evaluate with minimal\n", 
#&gt;                 "noise.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", list("invoke()"), " is soft-deprecated in favour of ", 
#&gt;                 list(list("exec()")), ". Now that we\n", "understand better the interaction between unquoting and dots\n", 
#&gt;                 "capture, we can take a simpler approach in ", 
#&gt;                 list("exec()"), ".\n", "\n", "If you need finer control over the generated call, you should construct\n", 
#&gt;                 "an environment and call yourself, manually burying large objects\n", 
#&gt;                 "or complex expressions.\n")), "\n", "\n", list(
#&gt;                 "\n", "# invoke() has the same purpose as do.call():\n", 
#&gt;                 "invoke(paste, letters)\n", "\n", "# But it creates much cleaner calls:\n", 
#&gt;                 "invoke(call_inspect, mtcars)\n", "\n", "# and stacktraces:\n", 
#&gt;                 "fn &lt;- function(...) sys.calls()\n", "invoke(fn, list(mtcars))\n", 
#&gt;                 "\n", "# Compare to do.call():\n", "do.call(call_inspect, mtcars)\n", 
#&gt;                 "do.call(fn, list(mtcars))\n", "\n", "\n", "# Specify the function name either by supplying a string\n", 
#&gt;                 "# identifying the function (it should be visible in .env):\n", 
#&gt;                 "invoke(\"call_inspect\", letters)\n", "\n", 
#&gt;                 "# Or by changing the .bury argument, with which you can also change\n", 
#&gt;                 "# the argument prefix:\n", "invoke(call_inspect, mtcars, .bury = c(\"inspect!\", \"col\"))\n"), 
#&gt;             "\n", list("internal"), "\n"), is_call.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("is_call"), "\n", list("is_call"), "\n", list(
#&gt;                 "Is object a call?"), "\n", list("\n", "is_call(x, name = NULL, n = NULL, ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                 "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                 list("An optional name that the call should match. It is\n", 
#&gt;                   "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                   "and you can supply a vector of names to match. In this case,\n", 
#&gt;                   list("is_call()"), " returns ", list("TRUE"), 
#&gt;                   " if at least one name matches.")), "\n", "\n", 
#&gt;                 list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This function tests if ", 
#&gt;                 list("x"), " is a ", list("call"), ". This is a\n", 
#&gt;                 "pattern-matching predicate that returns ", list(
#&gt;                   "FALSE"), " if ", list("name"), " and ", list(
#&gt;                   "n"), "\n", "are supplied and the call does not match these properties.\n", 
#&gt;                 list("is_unary_call()"), " and ", list("is_binary_call()"), 
#&gt;                 " hardcode ", list("n"), " to 1 and 2.\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                 "is_lang()"), " has been soft-deprecated and renamed to ", 
#&gt;                 list("is_call()"), " in\n", "rlang 0.2.0 and similarly for ", 
#&gt;                 list("is_unary_lang()"), " and\n", list("is_binary_lang()"), 
#&gt;                 ". This renaming follows the general switch from\n", 
#&gt;                 "\"language\" to \"call\" in the rlang type nomenclature. See lifecycle\n", 
#&gt;                 "section in ", list(list("call2()")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "is_call(quote(foo(bar)))\n", 
#&gt;                 "\n", "# You can pattern-match the call with additional arguments:\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\")\n", "is_call(quote(foo(bar)), \"bar\")\n", 
#&gt;                 "is_call(quote(foo(bar)), quote(foo))\n", "\n", 
#&gt;                 "# Match the number of arguments with is_call():\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\", 1)\n", "is_call(quote(foo(bar)), \"foo\", 2)\n", 
#&gt;                 "\n", "\n", "# By default, namespaced calls are tested unqualified:\n", 
#&gt;                 "ns_expr &lt;- quote(base::list())\n", "is_call(ns_expr, \"list\")\n", 
#&gt;                 "\n", "# You can also specify whether the call shouldn't be namespaced by\n", 
#&gt;                 "# supplying an empty string:\n", "is_call(ns_expr, \"list\", ns = \"\")\n", 
#&gt;                 "\n", "# Or if it should have a namespace:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"utils\")\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"base\")\n", 
#&gt;                 "\n", "# You can supply multiple namespaces:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"base\"))\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"stats\"))\n", 
#&gt;                 "\n", "# If one of them is \"\", unnamespaced calls will match as well:\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = \"base\")\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "is_call(quote(base::list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "\n", "\n", "# The name argument is vectorised so you can supply a list of names\n", 
#&gt;                 "# to match with:\n", "is_call(quote(foo(bar)), c(\"bar\", \"baz\"))\n", 
#&gt;                 "is_call(quote(foo(bar)), c(\"bar\", \"foo\"))\n", 
#&gt;                 "is_call(quote(base::list), c(\"::\", \":::\", \"$\", \"@\"))\n"), 
#&gt;             "\n", list("\n", list(list("is_expression()")), "\n"), 
#&gt;             "\n"), is_callable.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("is_callable"), "\n", list("is_callable"), 
#&gt;             "\n", list("Is an object callable?"), "\n", list(
#&gt;                 "\n", "is_callable(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", "A callable object is an object that can appear in the function\n", 
#&gt;                 "position of a call (as opposed to argument position). This includes\n", 
#&gt;                 list("symbolic objects"), " that evaluate to a function or\n", 
#&gt;                 "literal functions embedded in the call.\n"), 
#&gt;             "\n", list("\n", "Note that strings may look like callable objects because\n", 
#&gt;                 "expressions of the form ", list("\"list\"()"), 
#&gt;                 " are valid R code. However,\n", "that's only because the R parser transforms strings to symbols. It\n", 
#&gt;                 "is not legal to manually set language heads to strings.\n"), 
#&gt;             "\n", list("\n", "# Symbolic objects and functions are callable:\n", 
#&gt;                 "is_callable(quote(foo))\n", "is_callable(base::identity)\n", 
#&gt;                 "\n", "# node_poke_car() lets you modify calls without any checking:\n", 
#&gt;                 "lang &lt;- quote(foo(10))\n", "node_poke_car(lang, current_env())\n", 
#&gt;                 "\n", "# Use is_callable() to check an input object is safe to put as CAR:\n", 
#&gt;                 "obj &lt;- base::identity\n", "\n", "if (is_callable(obj)) {\n", 
#&gt;                 "  lang &lt;- node_poke_car(lang, obj)\n", "} else {\n", 
#&gt;                 "  abort(\"`obj` must be callable\")\n", "}\n", 
#&gt;                 "\n", "eval_bare(lang)\n"), "\n", list("internal"), 
#&gt;             "\n"), is_condition.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("is_condition"), "\n", list("is_condition"), 
#&gt;             "\n", list("Is object a condition?"), "\n", list(
#&gt;                 "\n", "is_condition(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is object a condition?\n"), 
#&gt;             "\n", list("internal"), "\n"), is_copyable.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_copyable"), "\n", list("is_copyable"), "\n", 
#&gt;             list("Is an object copyable?"), "\n", list("\n", 
#&gt;                 "is_copyable(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "When an object is modified, R generally copies it (sometimes\n", 
#&gt;                 "lazily) to enforce ", list(list("https://en.wikipedia.org/wiki/Value_semantics"), 
#&gt;                   list("value semantics")), ".\n", "However, some internal types are uncopyable. If you try to copy\n", 
#&gt;                 "them, either with ", list("&lt;-"), " or by argument passing, you actually create\n", 
#&gt;                 "references to the original object rather than actual\n", 
#&gt;                 "copies. Modifying these references can thus have far reaching side\n", 
#&gt;                 "effects.\n"), "\n", list("\n", "# Let's add attributes with structure() to uncopyable types. Since\n", 
#&gt;                 "# they are not copied, the attributes are changed in place:\n", 
#&gt;                 "env &lt;- env()\n", "structure(env, foo = \"bar\")\n", 
#&gt;                 "env\n", "\n", "# These objects that can only be changed with side effect are not\n", 
#&gt;                 "# copyable:\n", "is_copyable(env)\n", "\n", 
#&gt;                 "structure(base::list, foo = \"bar\")\n", "str(base::list)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_empty.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_empty"), "\n", list("is_empty"), "\n", list(
#&gt;                 "Is object an empty vector or NULL?"), "\n", 
#&gt;             list("\n", "is_empty(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("object to test")), "\n"), "\n", 
#&gt;             list("\n", "Is object an empty vector or NULL?\n"), 
#&gt;             "\n", list("\n", "is_empty(NULL)\n", "is_empty(list())\n", 
#&gt;                 "is_empty(list(NULL))\n"), "\n"), is_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_env"), "\n", list("is_env"), "\n", 
#&gt;             list("is_bare_env"), "\n", list("Is an object an environment?"), 
#&gt;             "\n", list("\n", "is_env(x)\n", "\n", "is_bare_env(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("is_environment()")), "\n", "and ", 
#&gt;                 list(list("is_bare_environment()")), " in rlang 0.2.0. This is for consistency\n", 
#&gt;                 "with other type predicates which are not abbreviated.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_environment"), "\n", list("is_environment"), 
#&gt;             "\n", list("is_bare_environment"), "\n", list("Is object an environment?"), 
#&gt;             "\n", list("\n", "is_environment(x)\n", "\n", "is_bare_environment(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("is_bare_environment()"), 
#&gt;                 " tests whether ", list("x"), " is an environment without a s3 or\n", 
#&gt;                 "s4 class.\n"), "\n"), is_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_expr"), "\n", list("is_expr"), "\n", 
#&gt;             list("Is an object an expression?"), "\n", list("\n", 
#&gt;                 "is_expr(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to test.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "This function was deprecated and renamed to ", 
#&gt;                 list(list("is_expression()")), " in\n", "rlang 0.2.0. This is for consistency with other type predicates\n", 
#&gt;                 "which are not abbreviated.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_expression.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("is_expression"), "\n", list("is_expression"), 
#&gt;             "\n", list("is_syntactic_literal"), "\n", list("is_symbolic"), 
#&gt;             "\n", list("Is an object an expression?"), "\n", 
#&gt;             list("\n", "is_expression(x)\n", "\n", "is_syntactic_literal(x)\n", 
#&gt;                 "\n", "is_symbolic(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_expression()"), " tests for expressions, the set of objects that can be\n", 
#&gt;                 "obtained from parsing R code. An expression can be one of two\n", 
#&gt;                 "things: either a symbolic object (for which ", 
#&gt;                 list("is_symbolic()"), " returns\n", list("TRUE"), 
#&gt;                 "), or a syntactic literal (testable with\n", 
#&gt;                 list("is_syntactic_literal()"), "). Technically, calls can contain any R\n", 
#&gt;                 "object, not necessarily symbolic objects or syntactic\n", 
#&gt;                 "literals. However, this only happens in artificial\n", 
#&gt;                 "situations. Expressions as we define them only contain numbers,\n", 
#&gt;                 "strings, ", list("NULL"), ", symbols, and calls: this is the complete set of R\n", 
#&gt;                 "objects that can be created when R parses source code (e.g. from\n", 
#&gt;                 "using ", list(list("parse_expr()")), ").\n", 
#&gt;                 "\n", "Note that we are using the term expression in its colloquial sense\n", 
#&gt;                 "and not to refer to ", list(list("expression()")), 
#&gt;                 " vectors, a data type that wraps\n", "expressions in a vector and which isn't used much in modern R code.\n"), 
#&gt;             "\n", list("\n", list("is_symbolic()"), " returns ", 
#&gt;                 list("TRUE"), " for symbols and calls (objects with\n", 
#&gt;                 "type ", list("language"), "). Symbolic objects are replaced by their value\n", 
#&gt;                 "during evaluation. Literals are the complement of symbolic\n", 
#&gt;                 "objects. They are their own value and return themselves during\n", 
#&gt;                 "evaluation.\n", "\n", list("is_syntactic_literal()"), 
#&gt;                 " is a predicate that returns ", list("TRUE"), 
#&gt;                 " for the\n", "subset of literals that are created by R when parsing text (see\n", 
#&gt;                 list(list("parse_expr()")), "): numbers, strings and ", 
#&gt;                 list("NULL"), ". Along with symbols,\n", "these literals are the terminating nodes in an AST.\n", 
#&gt;                 "\n", "Note that in the most general sense, a literal is any R object that\n", 
#&gt;                 "evaluates to itself and that can be evaluated in the empty\n", 
#&gt;                 "environment. For instance, ", list("quote(c(1, 2))"), 
#&gt;                 " is not a literal, it is\n", "a call. However, the result of evaluating it in ", 
#&gt;                 list(list("base_env()")), " is a\n", "literal(in this case an atomic vector).\n", 
#&gt;                 "\n", "Pairlists are also a kind of language objects. However, since they\n", 
#&gt;                 "are mostly an internal data structure, ", list(
#&gt;                   "is_expression()"), " returns ", list("FALSE"), 
#&gt;                 "\n", "for pairlists. You can use ", list("is_pairlist()"), 
#&gt;                 " to explicitly check for\n", "them. Pairlists are the data structure for function arguments. They\n", 
#&gt;                 "usually do not arise from R code because subsetting a call is a\n", 
#&gt;                 "type-preserving operation. However, you can obtain the pairlist of\n", 
#&gt;                 "arguments by taking the CDR of the call object from C code. The\n", 
#&gt;                 "rlang function ", list(list("node_cdr()")), 
#&gt;                 " will do it from R. Another way in\n", "which pairlist of arguments arise is by extracting the argument\n", 
#&gt;                 "list of a closure with ", list(list("base::formals()")), 
#&gt;                 " or ", list(list("fn_fmls()")), ".\n"), "\n", 
#&gt;             list("\n", "q1 &lt;- quote(1)\n", "is_expression(q1)\n", 
#&gt;                 "is_syntactic_literal(q1)\n", "\n", "q2 &lt;- quote(x)\n", 
#&gt;                 "is_expression(q2)\n", "is_symbol(q2)\n", "\n", 
#&gt;                 "q3 &lt;- quote(x + 1)\n", "is_expression(q3)\n", 
#&gt;                 "is_call(q3)\n", "\n", "\n", "# Atomic expressions are the terminating nodes of a call tree:\n", 
#&gt;                 "# NULL or a scalar atomic vector:\n", "is_syntactic_literal(\"string\")\n", 
#&gt;                 "is_syntactic_literal(NULL)\n", "\n", "is_syntactic_literal(letters)\n", 
#&gt;                 "is_syntactic_literal(quote(call()))\n", "\n", 
#&gt;                 "# Parsable literals have the property of being self-quoting:\n", 
#&gt;                 "identical(\"foo\", quote(\"foo\"))\n", "identical(1L, quote(1L))\n", 
#&gt;                 "identical(NULL, quote(NULL))\n", "\n", "# Like any literals, they can be evaluated within the empty\n", 
#&gt;                 "# environment:\n", "eval_bare(quote(1L), empty_env())\n", 
#&gt;                 "\n", "# Whereas it would fail for symbolic expressions:\n", 
#&gt;                 "# eval_bare(quote(c(1L, 2L)), empty_env())\n", 
#&gt;                 "\n", "\n", "# Pairlists are also language objects representing argument lists.\n", 
#&gt;                 "# You will usually encounter them with extracted formals:\n", 
#&gt;                 "fmls &lt;- formals(is_expression)\n", "typeof(fmls)\n", 
#&gt;                 "\n", "# Since they are mostly an internal data structure, is_expression()\n", 
#&gt;                 "# returns FALSE for pairlists, so you will have to check explicitly\n", 
#&gt;                 "# for them:\n", "is_expression(fmls)\n", "is_pairlist(fmls)\n"), 
#&gt;             "\n", list("\n", list(list("is_call()")), " for a call predicate.\n"), 
#&gt;             "\n"), is_formula.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("is_formula"), "\n", list("is_formula"), 
#&gt;             "\n", list("is_bare_formula"), "\n", list("Is object a formula?"), 
#&gt;             "\n", list("\n", "is_formula(x, scoped = NULL, lhs = NULL)\n", 
#&gt;                 "\n", "is_bare_formula(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("scoped"), list("A boolean indicating whether the quosure is scoped,\n", 
#&gt;                   "that is, has a valid environment attribute. If ", 
#&gt;                   list("NULL"), ", the scope\n", "is not inspected.")), 
#&gt;                 "\n", "\n", list(list("lhs"), list("A boolean indicating whether the ", 
#&gt;                   list("formula"), "\n", "or ", list("definition"), 
#&gt;                   " has a left-hand side. If ", list("NULL"), 
#&gt;                   ",\n", "the LHS is not inspected.")), "\n"), 
#&gt;             "\n", list("\n", list("is_formula()"), " tests if ", 
#&gt;                 list("x"), " is a call to ", list("~"), ". ", 
#&gt;                 list("is_bare_formula()"), "\n", "tests in addition that ", 
#&gt;                 list("x"), " does not inherit from anything else than\n", 
#&gt;                 list("\"formula\""), ".\n"), "\n", list("\n", 
#&gt;                 "The ", list("scoped"), " argument patterns-match on whether the scoped bundled\n", 
#&gt;                 "with the quosure is valid or not. Invalid scopes may happen in\n", 
#&gt;                 "nested quotations like ", list("~~expr"), ", where the outer quosure is validly\n", 
#&gt;                 "scoped but not the inner one. This is because ", 
#&gt;                 list("~"), " saves the\n", "environment when it is evaluated, and quoted formulas are by\n", 
#&gt;                 "definition not evaluated.\n"), "\n", list("\n", 
#&gt;                 "x &lt;- disp ~ am\n", "is_formula(x)\n", "\n", 
#&gt;                 "is_formula(~10)\n", "is_formula(10)\n", "\n", 
#&gt;                 "is_formula(quo(foo))\n", "is_bare_formula(quo(foo))\n", 
#&gt;                 "\n", "# Note that unevaluated formulas are treated as bare formulas even\n", 
#&gt;                 "# though they don't inherit from \"formula\":\n", 
#&gt;                 "f &lt;- quote(~foo)\n", "is_bare_formula(f)\n", 
#&gt;                 "\n", "# However you can specify `scoped` if you need the predicate to\n", 
#&gt;                 "# return FALSE for these unevaluated formulas:\n", 
#&gt;                 "is_bare_formula(f, scoped = TRUE)\n", "is_bare_formula(eval(f), scoped = TRUE)\n"), 
#&gt;             "\n"), is_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_frame"), "\n", list("is_frame"), "\n", 
#&gt;             list("Is object a frame?"), "\n", list("\n", "is_frame(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "is_function"), "\n", list("is_function"), "\n", 
#&gt;             list("is_closure"), "\n", list("is_primitive"), "\n", 
#&gt;             list("is_primitive_eager"), "\n", list("is_primitive_lazy"), 
#&gt;             "\n", list("Is object a function?"), "\n", list("\n", 
#&gt;                 "is_function(x)\n", "\n", "is_closure(x)\n", 
#&gt;                 "\n", "is_primitive(x)\n", "\n", "is_primitive_eager(x)\n", 
#&gt;                 "\n", "is_primitive_lazy(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n"), "\n", list("\n", "The R language defines two different types of functions: primitive\n", 
#&gt;                 "functions, which are low-level, and closures, which are the regular\n", 
#&gt;                 "kind of functions.\n"), "\n", list("\n", "Closures are functions written in R, named after the way their\n", 
#&gt;                 "arguments are scoped within nested environments (see\n", 
#&gt;                 "https://en.wikipedia.org/wiki/Closure_(computer_programming)). The\n", 
#&gt;                 "root environment of the closure is called the closure\n", 
#&gt;                 "environment. When closures are evaluated, a new environment called\n", 
#&gt;                 "the evaluation frame is created with the closure environment as\n", 
#&gt;                 "parent. This is where the body of the closure is evaluated. These\n", 
#&gt;                 "closure frames appear on the evaluation stack (see ", 
#&gt;                 list(list("ctxt_stack()")), "),\n", "as opposed to primitive functions which do not necessarily have\n", 
#&gt;                 "their own evaluation frame and never appear on the stack.\n", 
#&gt;                 "\n", "Primitive functions are more efficient than closures for two\n", 
#&gt;                 "reasons. First, they are written entirely in fast low-level\n", 
#&gt;                 "code. Second, the mechanism by which they are passed arguments is\n", 
#&gt;                 "more efficient because they often do not need the full procedure of\n", 
#&gt;                 "argument matching (dealing with positional versus named arguments,\n", 
#&gt;                 "partial matching, etc). One practical consequence of the special\n", 
#&gt;                 "way in which primitives are passed arguments is that they\n", 
#&gt;                 "technically do not have formal arguments, and ", 
#&gt;                 list(list("formals()")), " will\n", "return ", 
#&gt;                 list("NULL"), " if called on a primitive function. Finally, primitive\n", 
#&gt;                 "functions can either take arguments lazily, like R closures do,\n", 
#&gt;                 "or evaluate them eagerly before being passed on to the C code.\n", 
#&gt;                 "The former kind of primitives are called \"special\" in R terminology,\n", 
#&gt;                 "while the latter is referred to as \"builtin\". ", 
#&gt;                 list("is_primitive_eager()"), "\n", "and ", list(
#&gt;                   "is_primitive_lazy()"), " allow you to check whether a primitive\n", 
#&gt;                 "function evaluates arguments eagerly or lazily.\n", 
#&gt;                 "\n", "You will also encounter the distinction between primitive and\n", 
#&gt;                 "internal functions in technical documentation. Like primitive\n", 
#&gt;                 "functions, internal functions are defined at a low level and\n", 
#&gt;                 "written in C. However, internal functions have no representation in\n", 
#&gt;                 "the R language. Instead, they are called via a call to\n", 
#&gt;                 list(list("base::.Internal()")), " within a regular closure. This ensures that\n", 
#&gt;                 "they appear as normal R function objects: they obey all the usual\n", 
#&gt;                 "rules of argument passing, and they appear on the evaluation stack\n", 
#&gt;                 "as any other closures. As a result, ", list(
#&gt;                   list("fn_fmls()")), " does not need to\n", 
#&gt;                 "look in the ", list(".ArgsEnv"), " environment to obtain a representation of\n", 
#&gt;                 "their arguments, and there is no way of querying from R whether\n", 
#&gt;                 "they are lazy ('special' in R terminology) or eager ('builtin').\n", 
#&gt;                 "\n", "You can call primitive functions with ", 
#&gt;                 list(list(".Primitive()")), " and internal\n", 
#&gt;                 "functions with ", list(list(".Internal()")), 
#&gt;                 ". However, calling internal functions\n", "in a package is forbidden by CRAN's policy because they are\n", 
#&gt;                 "considered part of the private API. They often assume that they\n", 
#&gt;                 "have been called with correctly formed arguments, and may cause R\n", 
#&gt;                 "to crash if you call them with unexpected objects.\n"), 
#&gt;             "\n", list("\n", "# Primitive functions are not closures:\n", 
#&gt;                 "is_closure(base::c)\n", "is_primitive(base::c)\n", 
#&gt;                 "\n", "# On the other hand, internal functions are wrapped in a closure\n", 
#&gt;                 "# and appear as such from the R side:\n", "is_closure(base::eval)\n", 
#&gt;                 "\n", "# Both closures and primitives are functions:\n", 
#&gt;                 "is_function(base::c)\n", "is_function(base::eval)\n", 
#&gt;                 "\n", "# Primitive functions never appear in evaluation stacks:\n", 
#&gt;                 "is_primitive(base::`[[`)\n", "is_primitive(base::list)\n", 
#&gt;                 "list(ctxt_stack())[[1]]\n", "\n", "# While closures do:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# Many primitive functions evaluate arguments eagerly:\n", 
#&gt;                 "is_primitive_eager(base::c)\n", "is_primitive_eager(base::list)\n", 
#&gt;                 "is_primitive_eager(base::`+`)\n", "\n", "# However, primitives that operate on expressions, like quote() or\n", 
#&gt;                 "# substitute(), are lazy:\n", "is_primitive_lazy(base::quote)\n", 
#&gt;                 "is_primitive_lazy(base::substitute)\n"), "\n"), 
#&gt;         is_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_installed"), "\n", list("is_installed"), 
#&gt;             "\n", list("Is a package installed in the library?"), 
#&gt;             "\n", list("\n", "is_installed(pkg)\n"), "\n", list(
#&gt;                 "\n", list(list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", list("TRUE"), " if the package is installed, ", 
#&gt;                 list("FALSE"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This checks that a package is installed with minimal side effects.\n", 
#&gt;                 "If installed, the package will be loaded but not attached.\n"), 
#&gt;             "\n", list("\n", "is_installed(\"utils\")\n", "is_installed(\"ggplot5\")\n"), 
#&gt;             "\n"), is_integerish.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/types.R", 
#&gt;             "\n", list("is_integerish"), "\n", list("is_integerish"), 
#&gt;             "\n", list("is_bare_integerish"), "\n", list("is_scalar_integerish"), 
#&gt;             "\n", list("Is a vector integer-like?"), "\n", list(
#&gt;                 "\n", "is_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_bare_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_scalar_integerish(x, finite = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check whether R considers a number vector to be\n", 
#&gt;                 "integer-like, according to its own tolerance check (which is in\n", 
#&gt;                 "fact delegated to the C library). This function is not adapted to\n", 
#&gt;                 "data analysis, see the help for ", list(list(
#&gt;                   "base::is.integer()")), " for examples\n", 
#&gt;                 "of how to check for whole numbers.\n", "\n", 
#&gt;                 "Things to consider when checking for integer-like doubles:\n", 
#&gt;                 list("\n", list(), " This check can be expensive because the whole double vector has\n", 
#&gt;                   "to be traversed and checked.\n", list(), " Large double values may be integerish but may still not be\n", 
#&gt;                   "coercible to integer. This is because integers in R only support\n", 
#&gt;                   "values up to ", list("2^31 - 1"), " while numbers stored as double can be\n", 
#&gt;                   "much larger.\n"), "\n"), "\n", list("\n", 
#&gt;                 "is_integerish(10L)\n", "is_integerish(10.0)\n", 
#&gt;                 "is_integerish(10.0, n = 2)\n", "is_integerish(10.000001)\n", 
#&gt;                 "is_integerish(TRUE)\n"), "\n", list("\n", list(
#&gt;                 list("is_bare_numeric()")), " for testing whether an object is a\n", 
#&gt;                 "base numeric type (a bare double or integer vector).\n"), 
#&gt;             "\n"), is_interactive.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/state.R", 
#&gt;             "\n", list("is_interactive"), "\n", list("is_interactive"), 
#&gt;             "\n", list("scoped_interactive"), "\n", list("with_interactive"), 
#&gt;             "\n", list("Is R running interactively?"), "\n", 
#&gt;             list("\n", "is_interactive()\n", "\n", "scoped_interactive(value = TRUE, frame = caller_env())\n", 
#&gt;                 "\n", "with_interactive(expr, value = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("value"), list("A single ", 
#&gt;                 list("TRUE"), " or ", list("FALSE"), ". This overrides the return\n", 
#&gt;                 "value of ", list("is_interactive()"), ".")), 
#&gt;                 "\n", "\n", list(list("frame"), list("The environment of a running function which defines\n", 
#&gt;                   "the scope of the temporary options. When the function returns,\n", 
#&gt;                   "the options are reset to their original values.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("An expression to evaluate with interactivity set to\n", 
#&gt;                   list("value"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "Like ", list(list("base::interactive()")), ", ", 
#&gt;                 list("is_interactive()"), " returns ", list("TRUE"), 
#&gt;                 " when\n", "the function runs interactively and ", 
#&gt;                 list("FALSE"), " when it runs in batch\n", "mode. It also checks, in this order:\n", 
#&gt;                 list("\n", list(), " The ", list("rlang_interactive"), 
#&gt;                   " global option. If set to a single ", list(
#&gt;                     "TRUE"), "\n", "or ", list("FALSE"), ", ", 
#&gt;                   list("is_interactive()"), " returns that value immediately. This\n", 
#&gt;                   "escape hatch is useful in unit tests or to manually turn on\n", 
#&gt;                   "interactive features in RMarkdown outputs.\n", 
#&gt;                   list(), " Whether knitr, an RStudio notebook, or testthat is in progress.\n"), 
#&gt;                 "\n", "\n", list("with_interactive()"), " and ", 
#&gt;                 list("scoped_interactive()"), " set the global\n", 
#&gt;                 "option conveniently.\n"), "\n"), is_lang.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_lang"), "\n", list("is_lang"), "\n", 
#&gt;             list("is_unary_lang"), "\n", list("is_binary_lang"), 
#&gt;             "\n", list("quo_is_lang"), "\n", list("Is object a call?"), 
#&gt;             "\n", list("\n", "is_lang(x, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_unary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_binary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_lang(quo)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                   "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                   list("An optional name that the call should match. It is\n", 
#&gt;                     "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                     "and you can supply a vector of names to match. In this case,\n", 
#&gt;                     list("is_call()"), " returns ", list("TRUE"), 
#&gt;                     " if at least one name matches.")), "\n", 
#&gt;                 "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("is_call()")), " and its ", list("n"), 
#&gt;                 "\n", "argument instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_named.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("is_named"), "\n", list("is_named"), "\n", 
#&gt;             list("is_dictionaryish"), "\n", list("have_name"), 
#&gt;             "\n", list("Is object named?"), "\n", list("\n", 
#&gt;                 "is_named(x)\n", "\n", "is_dictionaryish(x)\n", 
#&gt;                 "\n", "have_name(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " and ", list(
#&gt;                 "is_dictionaryish()"), " are scalar predicates\n", 
#&gt;                 "and return ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ". ", list("have_name()"), " is vectorised and\n", 
#&gt;                 "returns a logical vector as long as the input.\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " checks that ", 
#&gt;                 list("x"), " has names attributes, and that none of\n", 
#&gt;                 "the names are missing or empty (", list("NA"), 
#&gt;                 " or ", list("\"\""), "). ", list("is_dictionaryish()"), 
#&gt;                 "\n", "checks that an object is a dictionary: that it has actual names and\n", 
#&gt;                 "in addition that there are no duplicated names. ", 
#&gt;                 list("have_name()"), "\n", "is a vectorised version of ", 
#&gt;                 list("is_named()"), ".\n"), "\n", list("\n", 
#&gt;                 "# A data frame usually has valid, unique names\n", 
#&gt;                 "is_named(mtcars)\n", "have_name(mtcars)\n", 
#&gt;                 "is_dictionaryish(mtcars)\n", "\n", "# But data frames can also have duplicated columns:\n", 
#&gt;                 "dups &lt;- cbind(mtcars, cyl = seq_len(nrow(mtcars)))\n", 
#&gt;                 "is_dictionaryish(dups)\n", "\n", "# The names are still valid:\n", 
#&gt;                 "is_named(dups)\n", "have_name(dups)\n", "\n", 
#&gt;                 "\n", "# For empty objects the semantics are slightly different.\n", 
#&gt;                 "# is_dictionaryish() returns TRUE for empty objects:\n", 
#&gt;                 "is_dictionaryish(list())\n", "\n", "# But is_named() will only return TRUE if there is a names\n", 
#&gt;                 "# attribute (a zero-length character vector in this case):\n", 
#&gt;                 "x &lt;- set_names(list(), character(0))\n", "is_named(x)\n", 
#&gt;                 "\n", "\n", "# Empty and missing names are invalid:\n", 
#&gt;                 "invalid &lt;- dups\n", "names(invalid)[2] &lt;- \"\"\n", 
#&gt;                 "names(invalid)[5] &lt;- NA\n", "\n", "# is_named() performs a global check while have_name() can show you\n", 
#&gt;                 "# where the problem is:\n", "is_named(invalid)\n", 
#&gt;                 "have_name(invalid)\n", "\n", "# have_name() will work even with vectors that don't have a names\n", 
#&gt;                 "# attribute:\n", "have_name(letters)\n"), "\n"), 
#&gt;         is_namespace.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_namespace"), "\n", list("is_namespace"), 
#&gt;             "\n", list("Is an object a namespace environment?"), 
#&gt;             "\n", list("\n", "is_namespace(x)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is an object a namespace environment?\n"), 
#&gt;             "\n"), is_pairlist.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("is_pairlist"), "\n", list("is_pairlist"), 
#&gt;             "\n", list("is_node"), "\n", list("is_node_list"), 
#&gt;             "\n", list("Is object a node or pairlist?"), "\n", 
#&gt;             list("\n", "is_pairlist(x)\n", "\n", "is_node(x)\n", 
#&gt;                 "\n", "is_node_list(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("is_pairlist()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), ".\n", list(), " ", list("is_node()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), " or ", list("language"), ".\n", 
#&gt;                 "It tests whether ", list("x"), " is a node that has a CAR and a CDR,\n", 
#&gt;                 "including callable nodes (language objects).\n", 
#&gt;                 list(), " ", list("is_node_list()"), " checks that ", 
#&gt;                 list("x"), " has type ", list("pairlist"), " or ", 
#&gt;                 list("NULL"), ".\n", list("NULL"), " is the empty node list.\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are experimental. We are still figuring out a good\n", 
#&gt;                 "naming convention to refer to the different lisp-like lists in R.\n")), 
#&gt;             "\n", "\n", list("\n", list(list("is_call()")), " tests for language nodes.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_reference.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_reference"), "\n", list("is_reference"), 
#&gt;             "\n", list("Is an object referencing another?"), 
#&gt;             "\n", list("\n", "is_reference(x, y)\n"), "\n", list(
#&gt;                 "\n", list(list("x, y"), list("R objects.")), 
#&gt;                 "\n"), "\n", list("\n", "There are typically two situations where two symbols may refer to\n", 
#&gt;                 "the same object.\n", list("\n", list(), " R objects usually have copy-on-write semantics. This is an\n", 
#&gt;                   "optimisation that ensures that objects are only copied if\n", 
#&gt;                   "needed. When you copy a vector, no memory is actually copied\n", 
#&gt;                   "until you modify either the original object or the copy is\n", 
#&gt;                   "modified.\n", "\n", "Note that the copy-on-write optimisation is an implementation\n", 
#&gt;                   "detail that is not guaranteed by the specification of the R\n", 
#&gt;                   "language.\n", list(), " Assigning an ", list(
#&gt;                     "uncopyable"), " object (like an\n", "environment) creates a reference. These objects are never copied\n", 
#&gt;                   "even if you modify one of the references.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Reassigning an uncopyable object such as an environment creates a\n", 
#&gt;                 "# reference:\n", "env &lt;- env()\n", "ref &lt;- env\n", 
#&gt;                 "is_reference(ref, env)\n", "\n", "# Due to copy-on-write optimisation, a copied vector can\n", 
#&gt;                 "# temporarily reference the original vector:\n", 
#&gt;                 "vec &lt;- 1:10\n", "copy &lt;- vec\n", "is_reference(copy, vec)\n", 
#&gt;                 "\n", "# Once you modify on of them, the copy is triggered in the\n", 
#&gt;                 "# background and the objects cease to reference each other:\n", 
#&gt;                 "vec[[1]] &lt;- 100\n", "is_reference(copy, vec)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_stack.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_stack"), "\n", list("is_stack"), "\n", 
#&gt;             list("is_eval_stack"), "\n", list("is_call_stack"), 
#&gt;             "\n", list("Is object a stack?"), "\n", list("\n", 
#&gt;                 "is_stack(x)\n", "\n", "is_eval_stack(x)\n", 
#&gt;                 "\n", "is_call_stack(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_symbol.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/sym.R", "\n", list(
#&gt;                 "is_symbol"), "\n", list("is_symbol"), "\n", 
#&gt;             list("Is object a symbol?"), "\n", list("\n", "is_symbol(x, name = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An optional name or vector of names that the symbol\n", 
#&gt;                   "should match.")), "\n"), "\n", list("\n", 
#&gt;                 "Is object a symbol?\n"), "\n"), is_true.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_true"), "\n", list("is_true"), "\n", list(
#&gt;                 "is_false"), "\n", list("Is object identical to TRUE or FALSE?"), 
#&gt;             "\n", list("\n", "is_true(x)\n", "\n", "is_false(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", "These functions bypass R's automatic conversion rules and check\n", 
#&gt;                 "that ", list("x"), " is literally ", list("TRUE"), 
#&gt;                 " or ", list("FALSE"), ".\n"), "\n", list("\n", 
#&gt;                 "is_true(TRUE)\n", "is_true(1)\n", "\n", "is_false(FALSE)\n", 
#&gt;                 "is_false(0)\n"), "\n"), is_weakref.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("is_weakref"), "\n", list("is_weakref"), "\n", 
#&gt;             list("Is object a weak reference?"), "\n", list("\n", 
#&gt;                 "is_weakref(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "Is object a weak reference?\n"), "\n"), 
#&gt;         lang.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang"), "\n", list("lang"), "\n", list(
#&gt;                 "new_language"), "\n", list("Create a call"), 
#&gt;             "\n", list("\n", "lang(.fn, ..., .ns = NULL)\n", 
#&gt;                 "\n", "new_language(head, tail = NULL)\n"), "\n", 
#&gt;             list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call2()")), " and\n", list(list("new_call()")), 
#&gt;                 " instead.\n"), "\n", list("internal"), "\n"), 
#&gt;         lang_head.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_head"), "\n", list("lang_head"), 
#&gt;             "\n", list("lang_tail"), "\n", list("Return the head or tail of a call"), 
#&gt;             "\n", list("\n", "lang_head(lang)\n", "\n", "lang_tail(lang)\n"), 
#&gt;             "\n", list("\n", list(list("lang"), list("A call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.2.0 these functions are retired (deprecated for now)\n", 
#&gt;                 "because they are low level accessors that are rarely needed for end\n", 
#&gt;                 "users.\n"), "\n", list("internal"), "\n"), lang_modify.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_modify"), "\n", list("lang_modify"), 
#&gt;             "\n", list("lang_standardise"), "\n", list("lang_fn"), 
#&gt;             "\n", list("lang_name"), "\n", list("lang_args"), 
#&gt;             "\n", list("lang_args_names"), "\n", list("Manipulate or access a call"), 
#&gt;             "\n", list("\n", "lang_modify(.lang, ..., .standardise = FALSE)\n", 
#&gt;                 "\n", "lang_standardise(lang)\n", "\n", "lang_fn(lang)\n", 
#&gt;                 "\n", "lang_name(lang)\n", "\n", "lang_args(lang)\n", 
#&gt;                 "\n", "lang_args_names(lang)\n"), "\n", list(
#&gt;                 "\n", list(list("..."), list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                   list(".standardise"), list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n", "\n", list(list("lang, .lang"), 
#&gt;                   list("The ", list("call"), " or ", list(".call"), 
#&gt;                     " argument of the renamed\n", "functions.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call_modify()")), ",\n", list(list(
#&gt;                   "call_standardise()")), ", or ", list(list(
#&gt;                   "call_fn()")), " instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), last_error.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-abort.R", 
#&gt;             "\n", list("last_error"), "\n", list("last_error"), 
#&gt;             "\n", list("last_trace"), "\n", list("Last ", list(
#&gt;                 "abort()"), " error"), "\n", list("\n", "last_error()\n", 
#&gt;                 "\n", "last_trace()\n"), "\n", list("\n", list(
#&gt;                 "\n", list(), " ", list("last_error()"), " returns the last error thrown with ", 
#&gt;                 list(list("abort()")), ". The\n", "error is printed with a backtrace in simplified form.\n", 
#&gt;                 list(), " ", list("last_trace()"), " is a shortcut to return the backtrace stored in\n", 
#&gt;                 "the last error. This backtrace is printed in full form.\n"), 
#&gt;                 "\n"), "\n"), lifecycle.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle.R", 
#&gt;             "\n", list("lifecycle"), "\n", list("lifecycle"), 
#&gt;             "\n", list("Life cycle of the rlang package"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"maturing\")"), 
#&gt;                 "\n", "\n", "The rlang package is currently maturing. Unless otherwise stated,\n", 
#&gt;                 "this applies to all its exported functions. Maturing functions are\n", 
#&gt;                 "susceptible to API changes. Only use these in packages if you're\n", 
#&gt;                 "prepared to make changes as the package evolves. See sections below\n", 
#&gt;                 "for a list of functions marked as stable.\n", 
#&gt;                 "\n", "The documentation pages of retired functions contain life cycle\n", 
#&gt;                 "sections that explain the reasons for their retirements.\n"), 
#&gt;             "\n", list(list("Stable functions"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("eval_tidy()")), 
#&gt;                   "\n", list(), " ", list("!!"), ", ", list("!!!"), 
#&gt;                   "\n", list(), " ", list(list("enquo()")), ", ", 
#&gt;                   list(list("quo()")), ", ", list(list("quos()")), 
#&gt;                   "\n", list(), " ", list(list("enexpr()")), 
#&gt;                   ", ", list(list("expr()")), ", ", list(list(
#&gt;                     "exprs()")), "\n", list(), " ", list(list(
#&gt;                     "sym()")), ", ", list(list("syms()")), "\n", 
#&gt;                   list(), " ", list(list("new_quosure()")), ", ", 
#&gt;                   list(list("is_quosure()")), "\n", list(), " ", 
#&gt;                   list(list("missing_arg()")), ", ", list(list(
#&gt;                     "is_missing()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_expr()")), ", ", list(list(
#&gt;                     "quo_set_expr()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_env()")), ", ", list(list("quo_set_env()")), 
#&gt;                   "\n", list(), " ", list(list("eval_bare()")), 
#&gt;                   "\n", list(), " ", list(list("set_names()")), 
#&gt;                   ", ", list(list("names2()")), "\n", list(), 
#&gt;                   " ", list(list("as_function()")), ", ", list(
#&gt;                     list("new_function()")), "\n"), "\n")), "\n", 
#&gt;             "\n", list(list("Experimental functions"), list("\n", 
#&gt;                 "\n", "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These functions are not yet part of the rlang API. Expect breaking\n", 
#&gt;                 "changes.\n", list("\n", list(), " ", list(list(
#&gt;                   "with_env()")), ", ", list(list("locally()")), 
#&gt;                   ", ", list(list("env_poke()")), "\n", list(), 
#&gt;                   " ", list(list("pkg_env()")), ", ", list(list(
#&gt;                     "pkg_env_name()")), ", ", list(list("ns_env()")), 
#&gt;                   ", ", list(list("ns_imports_env()")), ", ", 
#&gt;                   list(list("ns_env_name()")), "\n", list(), 
#&gt;                   " ", list(list("is_pairlist()")), ", ", list(
#&gt;                     list("as_pairlist()")), ", ", list(list("is_node()")), 
#&gt;                   ", ", list(list("is_node_list()")), "\n", list(), 
#&gt;                   " ", list(list("is_definition()")), ", ", list(
#&gt;                     list("new_definition()")), ", ", list(list(
#&gt;                     "is_formulaish()")), ",\n", list(list("dots_definitions()")), 
#&gt;                   "\n", list(), " ", list(list("scoped_options()")), 
#&gt;                   ", ", list(list("with_options()")), ", ", list(
#&gt;                     list("push_options()")), ",\n", list(list(
#&gt;                     "peek_options()")), ", ", list(list("peek_option()")), 
#&gt;                   "\n", list(), " ", list(list("as_bytes()")), 
#&gt;                   ", ", list(list("chr_unserialise_unicode()")), 
#&gt;                   "\n", list(), " ", list(list("caller_fn()")), 
#&gt;                   ", ", list(list("current_fn()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Questioning stage"), list(
#&gt;                 "\n", "\n", "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("In the questioning stage as of rlang 0.4.0"), 
#&gt;                 "\n", "\n", "These functions are likely to be moved to the vctrs package:\n", 
#&gt;                 list("\n", list(), " ", list(list("lgl()")), 
#&gt;                   ", ", list(list("int()")), ", etc.\n", list(), 
#&gt;                   " ", list(list("new_logical()")), ", ", list(
#&gt;                     list("new_integer()")), ", etc.\n", list(), 
#&gt;                   " ", list("na_lgl"), ", ", list("na_int"), 
#&gt;                   ", ", list(list("is_lgl_na()")), ", ", list(
#&gt;                     list("is_int_na()")), ", etc.\n"), "\n", 
#&gt;                 "\n", list("In the questioning stage as of rlang 0.3.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("child_env()")), 
#&gt;                   "\n", list(), " ", list(list("flatten()")), 
#&gt;                   ", ", list(list("squash()")), ", and their atomic vector variants\n", 
#&gt;                   list(), " ", list(list("modify()")), " and ", 
#&gt;                   list(list("prepend()")), "\n", list(), " ", 
#&gt;                   list(list("with_restarts()")), ", ", list(list(
#&gt;                     "rst_list()")), ", ", list(list("rst_exists()")), 
#&gt;                   ", ", list(list("rst_jump()")), ",\n", list(
#&gt;                     list("rst_maybe_jump()")), ", ", list(list(
#&gt;                     "rst_abort()")), ". It is not clear yet whether we\n", 
#&gt;                   "want to recommend restarts as a style of programming in R.\n", 
#&gt;                   list(), " ", list(list("return_from()")), " and ", 
#&gt;                   list(list("return_to()")), ".\n", list(), " ", 
#&gt;                   list(list("expr_label()")), ", ", list(list(
#&gt;                     "expr_name()")), ", and ", list(list("expr_text()")), 
#&gt;                   ".\n"), "\n", "\n", list("In the questioning stage as of rlang 0.2.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("UQ()")), 
#&gt;                   ", ", list(list("UQS()")), "\n", list(), " ", 
#&gt;                   list(list("dots_splice()")), ", ", list(list(
#&gt;                     "splice()")), "\n"), "\n")), "\n", "\n", 
#&gt;             list(list("Soft-deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                   "\n", "\n", list("Soft-deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("exiting()")), 
#&gt;                     ": Handlers are now treated as exiting by default.\n", 
#&gt;                     list(), " ", list(list("invoke()")), ": Use the simpler ", 
#&gt;                     list(list("exec()")), " instead.\n", list(), 
#&gt;                     " ", list(list("as_logical()")), ", ", list(
#&gt;                       list("as_integer()")), ", etc. =&gt; ", list(
#&gt;                       "vctrs::vec_cast()"), ".\n", list(), " ", 
#&gt;                     list(list("type_of()")), ", ", list(list(
#&gt;                       "switch_type()")), ", ", list(list("coerce_type()")), 
#&gt;                     ", ", list(list("switch_class()")), ",\n", 
#&gt;                     list(list("coerce_class()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                   "\n", "\n", list("Bumped to deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("modify()")), 
#&gt;                     " and ", list(list("prepend()")), ".\n", 
#&gt;                     list(), " ", list("new_logical_along()"), 
#&gt;                     ", ", list("new_integer_along()"), ",\n", 
#&gt;                     list("new_double_along()"), ", ", list("new_complex_along()"), 
#&gt;                     ",\n", list("new_character_along()"), ", ", 
#&gt;                     list("new_raw_along()"), ", ", list("new_list_along()"), 
#&gt;                     ".\n", list(), " ", list(list("lang_modify()")), 
#&gt;                     " =&gt; ", list(list("call_modify()")), "\n", 
#&gt;                     list(), " ", list(list("lang_standardise()")), 
#&gt;                     " =&gt; ", list(list("call_standardise()")), 
#&gt;                     "\n", list(), " ", list(list("lang_fn()")), 
#&gt;                     " =&gt; ", list(list("call_fn()")), "\n", list(), 
#&gt;                     " ", list(list("lang_name()")), " =&gt; ", list(
#&gt;                       list("call_name()")), "\n", list(), " ", 
#&gt;                     list(list("lang_args()")), " =&gt; ", list(list(
#&gt;                       "call_args()")), "\n", list(), " ", list(
#&gt;                       list("lang_args_names()")), " =&gt; ", list(
#&gt;                       list("call_args_names()")), "\n", list(), 
#&gt;                     " ", list(list("lang_head()")), ", ", list(
#&gt;                       list("lang_tail()")), "\n", list(), " ", 
#&gt;                     list(list("lang()")), " =&gt; ", list(list("call2()")), 
#&gt;                     "\n", list(), " ", list(list("new_language()")), 
#&gt;                     " =&gt; ", list(list("new_call()")), "\n", list(), 
#&gt;                     " ", list(list("is_lang()")), " =&gt; ", list(
#&gt;                       list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("is_unary_lang()")), " =&gt; Use the ", 
#&gt;                     list("n"), " argument of ", list(list("is_call()")), 
#&gt;                     "\n", list(), " ", list(list("is_binary_lang()")), 
#&gt;                     " =&gt; Use the ", list("n"), " argument of ", 
#&gt;                     list(list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("quo_is_lang()")), " =&gt; ", list(
#&gt;                       list("quo_is_call()")), "\n", list(), " ", 
#&gt;                     list(list("call_modify()")), ": ", list(".standardise"), 
#&gt;                     " and ", list(".env"), " arguments.\n", list(), 
#&gt;                     " ", list(list("is_expr()")), " =&gt; ", list(
#&gt;                       list("is_expression()")), "\n", list(), 
#&gt;                     " ", list("quo_expr()"), " =&gt; ", list(list(
#&gt;                       "quo_squash()")), "\n", list(), " ", list(
#&gt;                       list("parse_quosure()")), " =&gt; ", list(
#&gt;                       list("parse_quo()")), "\n", list(), " ", 
#&gt;                     list(list("parse_quosures()")), " =&gt; ", list(
#&gt;                       list("parse_quos()")), "\n", list(), " Assigning non-quosure objects to quosure lists.\n", 
#&gt;                     list(), " ", list("as.character()"), " on quosures.\n", 
#&gt;                     list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": ", list(".cnd"), " =&gt; ", list("cnd"), 
#&gt;                     "\n", list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": The ", list(".mufflable"), " argument no longer has any effect\n", 
#&gt;                     list(), " ", list("scoped_names()"), " =&gt; ", 
#&gt;                     list(list("base::search()")), "\n", list(), 
#&gt;                     " ", list("is_scoped()"), " =&gt; ", list(list(
#&gt;                       "is_attached()")), "\n", list(), " ", list(
#&gt;                       "scoped_env()"), " =&gt; ", list(list("search_env()")), 
#&gt;                     "\n", list(), " ", list("scoped_envs()"), 
#&gt;                     " =&gt; ", list(list("search_envs()")), "\n", 
#&gt;                     list(), " ", list("env_bind_exprs()"), " =&gt; ", 
#&gt;                     list(list("env_bind_lazy()")), "\n", list(), 
#&gt;                     " ", list("env_bind_fns()"), " =&gt; ", list(
#&gt;                       list("env_bind_active()")), "\n", list(), 
#&gt;                     " Passing a function or formula to ", list(
#&gt;                       "env_depth()"), ",\n", list("env_poke_parent()"), 
#&gt;                     ", ", list("env_parent&lt;-"), ", ", list("env_tail()"), 
#&gt;                     ", ", list("set_env()"), ",\n", list("env_clone()"), 
#&gt;                     ", ", list("env_inherits()"), ", ", list(
#&gt;                       "env_bind()"), ",\n", list("scoped_bindings()"), 
#&gt;                     ", ", list("with_bindings()"), ", ", list(
#&gt;                       "env_poke()"), ",\n", list("env_has()"), 
#&gt;                     ", ", list("env_get()"), ", ", list("env_names()"), 
#&gt;                     ", ", list("env_bind_exprs()"), " and\n", 
#&gt;                     list("env_bind_fns()"), ". This internal genericity was causing confusion\n", 
#&gt;                     "(see issue #427). You should now extract the environment\n", 
#&gt;                     "separately before calling these functions.\n", 
#&gt;                     list(), " ", list(list("get_env()")), ": The ", 
#&gt;                     list("env"), " argument no longer has a default and must be supplied\n", 
#&gt;                     list(), " ", list(list("is_frame()")), ", ", 
#&gt;                     list(list("global_frame()")), ", ", list(
#&gt;                       list("current_frame()")), ",\n", list(list(
#&gt;                       "ctxt_frame()")), ", ", list(list("call_frame()")), 
#&gt;                     ", ", list(list("frame_position()")), ",\n", 
#&gt;                     list(list("caller_frame()")), "\n", list(), 
#&gt;                     " ", list(list("ctxt_depth()")), ", ", list(
#&gt;                       list("call_depth()")), ", ", list(list(
#&gt;                       "ctxt_stack()")), ", ", list(list("call_stack()")), 
#&gt;                     ",\n", list(list("stack_trim()")), "\n", 
#&gt;                     list(), " ", list(list("set_attrs()")), ", ", 
#&gt;                     list(list("mut_attrs()")), "\n", list(), 
#&gt;                     " The ", list("width"), " and ", list("printer"), 
#&gt;                     " arguments of ", list(list("exprs_auto_name()")), 
#&gt;                     " and\n", list(list("quos_auto_name()")), 
#&gt;                     " no longer have any effect. For the same\n", 
#&gt;                     "reason, passing a width as ", list(".named"), 
#&gt;                     " argument of dots collectors\n", "like ", 
#&gt;                     list("quos()"), " is deprecated.\n", list(), 
#&gt;                     " ", list("as_overscope()"), " =&gt; ", list(
#&gt;                       list("as_data_mask()")), "\n", list(), 
#&gt;                     " ", list("new_overscope()"), " =&gt; ", list(
#&gt;                       list("new_data_mask()")), "\n", list(), 
#&gt;                     " ", list("overscope_eval_next()"), " =&gt; ", 
#&gt;                     list(list("eval_tidy()")), "\n", list(), 
#&gt;                     " ", list("overscope_clean()"), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Defunct functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"defunct\")"), 
#&gt;                   "\n", "\n", list("Defunct as of rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list("length()"), 
#&gt;                     " and ", list("names()"), " on tidy eval ", 
#&gt;                     list(".data"), " pronouns.\n", list(), " Supplying a named ", 
#&gt;                     list("!!!"), " call.\n", list(), " ", list(
#&gt;                       list("as_data_mask()")), ": ", list("parent"), 
#&gt;                     " argument\n", list(), " ", list(list("new_data_mask()")), 
#&gt;                     ": ", list("parent"), " argument\n", list(), 
#&gt;                     " ", list(list("env_tail()")), ": ", list(
#&gt;                       "sentinel"), " =&gt; ", list("last"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ": ", list("msg"), ", ", list("type"), " =&gt; ", 
#&gt;                     list(".msg"), ", ", list(".type"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ", ", list(list("cnd()")), ", ", list(list(
#&gt;                       "error_cnd()")), ",\n", list(list("warning_cnd()")), 
#&gt;                     ", ", list(list("message_cnd()")), ": ", 
#&gt;                     list("call"), " argument.\n", list(), " ", 
#&gt;                     list(list("is_character()")), ", ", list(
#&gt;                       list("is_string()")), ", and variants: The ", 
#&gt;                     list("encoding"), "\n", "argument.\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Archived"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"archived\")"), 
#&gt;                 "\n", "\n", "These functions were entirely removed from the package. You will\n", 
#&gt;                 "find them in the commit history and previous releases.\n", 
#&gt;                 "\n", list("Archived as of rlang 0.4.0"), "\n", 
#&gt;                 list("\n", list(), " ", list("UQE()"), "\n", 
#&gt;                   list(), " ", list("as_dictionary()"), ", ", 
#&gt;                   list("is_dictionary()"), "\n", list(), " ", 
#&gt;                   list("as_quosureish()"), ", ", list("is_quosureish()"), 
#&gt;                   "\n", list(), " ", list("eval_tidy_()"), "\n", 
#&gt;                   list(), " ", list("mut_utf8_locale()"), ", ", 
#&gt;                   list("mut_latin1_locale()"), ", ", list("mut_mbcs_locale()"), 
#&gt;                   "\n", list(), " ", list("set_chr_encoding()"), 
#&gt;                   ", ", list("chr_encoding()"), ", ", list("set_str_encoding()"), 
#&gt;                   ", ", list("str_encoding()"), "\n", list(), 
#&gt;                   " ", list("as_native_character()"), ", ", list(
#&gt;                     "as_utf8_string()"), ", ", list("as_native_string()"), 
#&gt;                   "\n", list(), " ", list("lang_type_of()"), 
#&gt;                   ", ", list("switch_lang()"), ", ", list("coerce_lang()"), 
#&gt;                   "\n"), "\n", "\n", list("Archived as of rlang 0.3.0:"), 
#&gt;                 "\n", list("\n", list(), " ", list("cnd_inform()"), 
#&gt;                   ", ", list("cnd_warn()"), " and ", list("cnd_abort()"), 
#&gt;                   "\n", list(), " ", list("new_cnd()"), " =&gt; ", 
#&gt;                   list(list("cnd()")), "\n", list(), " ", list(
#&gt;                     "cnd_message()"), " =&gt; ", list(list("message_cnd()")), 
#&gt;                   "\n", list(), " ", list("cnd_warning()"), " =&gt; ", 
#&gt;                   list(list("warning_cnd()")), "\n", list(), 
#&gt;                   " ", list("cnd_error()"), " =&gt; ", list(list(
#&gt;                     "error_cnd()")), "\n", list(), " ", list(
#&gt;                     "rst_muffle()"), " =&gt; ", list(list("cnd_muffle()")), 
#&gt;                   "\n", list(), " ", list("inplace()"), " =&gt; ", 
#&gt;                   list(list("calling()")), ". The ", list("muffle"), 
#&gt;                   " argument of ", list("inplace()"), "\n", "has not been implemented in ", 
#&gt;                   list("calling()"), " and is now defunct.\n", 
#&gt;                   list(), " ", list(list("cnd_signal()")), ": ", 
#&gt;                   list(".msg"), " and ", list(".call"), ".\n", 
#&gt;                   list(), " ", list(list("cnd()")), ", ", list(
#&gt;                     list("error_cnd()")), ", ", list(list("warning_cnd()")), 
#&gt;                   " and ", list(list("message_cnd()")), ":\n", 
#&gt;                   list(".msg"), " =&gt; ", list("message"), ".\n"), 
#&gt;                 "\n")), "\n", "\n", list("internal"), "\n"), 
#&gt;         missing.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-na.R", 
#&gt;             "\n", list("data"), "\n", list("missing"), "\n", 
#&gt;             list("missing"), "\n", list("na_lgl"), "\n", list(
#&gt;                 "na_int"), "\n", list("na_dbl"), "\n", list("na_chr"), 
#&gt;             "\n", list("na_cpl"), "\n", list("Missing values"), 
#&gt;             "\n", list("An object of class ", list("logical"), 
#&gt;                 " of length 1."), "\n", list("\n", "na_lgl\n", 
#&gt;                 "\n", "na_int\n", "\n", "na_dbl\n", "\n", "na_chr\n", 
#&gt;                 "\n", "na_cpl\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Missing values are represented in R with the general symbol\n", 
#&gt;                 list("NA"), ". They can be inserted in almost all data containers: all\n", 
#&gt;                 "atomic vectors except raw vectors can contain missing values. To\n", 
#&gt;                 "achieve this, R automatically converts the general ", 
#&gt;                 list("NA"), " symbol to a\n", "typed missing value appropriate for the target vector. The objects\n", 
#&gt;                 "provided here are aliases for those typed ", 
#&gt;                 list("NA"), " objects.\n"), "\n", list("\n", 
#&gt;                 "Typed missing values are necessary because R needs sentinel values\n", 
#&gt;                 "of the same type (i.e. the same machine representation of the data)\n", 
#&gt;                 "as the containers into which they are inserted. The official typed\n", 
#&gt;                 "missing values are ", list("NA_integer_"), ", ", 
#&gt;                 list("NA_real_"), ", ", list("NA_character_"), 
#&gt;                 " and\n", list("NA_complex_"), ". The missing value for logical vectors is simply the\n", 
#&gt;                 "default ", list("NA"), ". The aliases provided in rlang are consistently named\n", 
#&gt;                 "and thus simpler to remember. Also, ", list(
#&gt;                   "na_lgl"), " is provided as an\n", "alias to ", 
#&gt;                 list("NA"), " that makes intent clearer.\n", 
#&gt;                 "\n", "Since ", list("na_lgl"), " is the default ", 
#&gt;                 list("NA"), ", expressions such as ", list("c(NA, NA)"), 
#&gt;                 "\n", "yield logical vectors as no data is available to give a clue of the\n", 
#&gt;                 "target type. In the same way, since lists and environments can\n", 
#&gt;                 "contain any types, expressions like ", list(
#&gt;                   "list(NA)"), " store a logical\n", list("NA"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These shortcuts might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;             "\n", "\n", list("\n", "typeof(NA)\n", "typeof(na_lgl)\n", 
#&gt;                 "typeof(na_int)\n", "\n", "# Note that while the base R missing symbols cannot be overwritten,\n", 
#&gt;                 "# that's not the case for rlang's aliases:\n", 
#&gt;                 "na_dbl &lt;- NA\n", "typeof(na_dbl)\n"), "\n", 
#&gt;             list("datasets"), "\n", list("internal"), "\n"), 
#&gt;         missing_arg.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("missing_arg"), "\n", list("missing_arg"), "\n", 
#&gt;             list("is_missing"), "\n", list("maybe_missing"), 
#&gt;             "\n", list("Generate or handle a missing argument"), 
#&gt;             "\n", list("\n", "missing_arg()\n", "\n", "is_missing(x)\n", 
#&gt;                 "\n", "maybe_missing(x, default = missing_arg())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object that might be the missing argument.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The object to return if the input is missing,\n", 
#&gt;                   "defaults to ", list("missing_arg()"), ".")), 
#&gt;                 "\n"), "\n", list("\n", "These functions help using the missing argument as a regular R\n", 
#&gt;                 "object.\n", list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " generates a missing argument.\n", list(), 
#&gt;                   " ", list("is_missing()"), " is like ", list(
#&gt;                     list("base::missing()")), " but also supports\n", 
#&gt;                   "testing for missing arguments contained in other objects like\n", 
#&gt;                   "lists.\n", list(), " ", list("maybe_missing()"), 
#&gt;                   " is useful to pass down an input that might be\n", 
#&gt;                   "missing to another function, potentially substituting by a\n", 
#&gt;                   "default value. It avoids triggering an \"argument is missing\" error.\n"), 
#&gt;                 "\n"), "\n", list(list("Other ways to reify the missing argument"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "base::quote(expr = )"), " is the canonical way to create a missing\n", 
#&gt;                   "argument object.\n", list(), " ", list("expr()"), 
#&gt;                   " called without argument creates a missing argument.\n", 
#&gt;                   list(), " ", list("quo()"), " called without argument creates an empty quosure, i.e. a\n", 
#&gt;                   "quosure containing the missing argument object.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Fragility of the missing argument object"), 
#&gt;                 list("\n", "\n", "\n", "The missing argument is an object that triggers an error if and\n", 
#&gt;                   "only if it is the result of evaluating a symbol. No error is\n", 
#&gt;                   "produced when a function call evaluates to the missing argument\n", 
#&gt;                   "object. This means that expressions like ", 
#&gt;                   list("x[[1]] &lt;- missing_arg()"), "\n", "are perfectly safe. Likewise, ", 
#&gt;                   list("x[[1]]"), " is safe even if the result\n", 
#&gt;                   "is the missing object.\n", "\n", "However, as soon as the missing argument is passed down between\n", 
#&gt;                   "functions through an argument, you're at risk of triggering a\n", 
#&gt;                   "missing error. This is because arguments are passed through\n", 
#&gt;                   "symbols. To work around this, ", list("is_missing()"), 
#&gt;                   " and ", list("maybe_missing(x)"), "\n", "use a bit of magic to determine if the input is the missing\n", 
#&gt;                   "argument without triggering a missing error.\n", 
#&gt;                   "\n", list("maybe_missing()"), " is particularly useful for prototyping\n", 
#&gt;                   "meta-programming algorithms in R. The missing argument is a likely\n", 
#&gt;                   "input when computing on the language because it is a standard\n", 
#&gt;                   "object in formals lists. While C functions are always allowed to\n", 
#&gt;                   "return the missing argument and pass it to other C functions, this\n", 
#&gt;                   "is not the case on the R side. If you're implementing your\n", 
#&gt;                   "meta-programming algorithm in R, use ", list(
#&gt;                     "maybe_missing()"), " when an\n", "input might be the missing argument object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " and ", list("is_missing()"), " are stable.\n", 
#&gt;                   list(), " Like the rest of rlang, ", list("maybe_missing()"), 
#&gt;                   " is maturing.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# The missing argument usually arises inside a function when the\n", 
#&gt;                 "# user omits an argument that does not have a default:\n", 
#&gt;                 "fn &lt;- function(x) is_missing(x)\n", "fn()\n", 
#&gt;                 "\n", "# Creating a missing argument can also be useful to generate calls\n", 
#&gt;                 "args &lt;- list(1, missing_arg(), 3, missing_arg())\n", 
#&gt;                 "quo(fn(!!! args))\n", "\n", "# Other ways to create that object include:\n", 
#&gt;                 "quote(expr = )\n", "expr()\n", "\n", "# It is perfectly valid to generate and assign the missing\n", 
#&gt;                 "# argument in a list.\n", "x &lt;- missing_arg()\n", 
#&gt;                 "l &lt;- list(missing_arg())\n", "\n", "# Just don't evaluate a symbol that contains the empty argument.\n", 
#&gt;                 "# Evaluating the object `x` that we created above would trigger an\n", 
#&gt;                 "# error.\n", "# x  # Not run\n", "\n", "# On the other hand accessing a missing argument contained in a\n", 
#&gt;                 "# list does not trigger an error because subsetting is a function\n", 
#&gt;                 "# call:\n", "l[[1]]\n", "is.null(l[[1]])\n", 
#&gt;                 "\n", "# In case you really need to access a symbol that might contain the\n", 
#&gt;                 "# empty argument object, use maybe_missing():\n", 
#&gt;                 "maybe_missing(x)\n", "is.null(maybe_missing(x))\n", 
#&gt;                 "is_missing(maybe_missing(x))\n", "\n", "\n", 
#&gt;                 "# Note that base::missing() only works on symbols and does not\n", 
#&gt;                 "# support complex expressions. For this reason the following lines\n", 
#&gt;                 "# would throw an error:\n", "\n", "#&gt; missing(missing_arg())\n", 
#&gt;                 "#&gt; missing(l[[1]])\n", "\n", "# while is_missing() will work as expected:\n", 
#&gt;                 "is_missing(missing_arg())\n", "is_missing(l[[1]])\n"), 
#&gt;             "\n"), mut_node_car.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("mut_node_car"), "\n", list("mut_node_car"), 
#&gt;             "\n", list("mut_node_cdr"), "\n", list("mut_node_caar"), 
#&gt;             "\n", list("mut_node_cadr"), "\n", list("mut_node_cdar"), 
#&gt;             "\n", list("mut_node_cddr"), "\n", list("mut_node_tag"), 
#&gt;             "\n", list("Mutate node components"), "\n", list(
#&gt;                 "\n", "mut_node_car(x, newcar)\n", "\n", "mut_node_cdr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_caar(x, newcar)\n", "\n", "mut_node_cadr(x, newcar)\n", 
#&gt;                 "\n", "mut_node_cdar(x, newcdr)\n", "\n", "mut_node_cddr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_tag(x, newtag)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newcar"), list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newcdr"), list("The new CAR or CDR for the node. These\n", 
#&gt;                     "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("node_poke_"), "\n", "prefix in rlang 0.2.0. This change follows a new naming convention\n", 
#&gt;                 "where mutation is referred to as \"poking\".\n"), 
#&gt;             "\n", list("internal"), "\n"), names2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("names2"), "\n", list("names2"), "\n", 
#&gt;             list("Get names of a vector"), "\n", list("\n", "names2(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This names getter always returns a character vector, even when an\n", 
#&gt;                 "object does not have a ", list("names"), " attribute. In this case, it returns\n", 
#&gt;                 "a vector of empty names ", list("\"\""), ". It also standardises missing names to\n", 
#&gt;                 list("\"\""), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("names2()"), " is stable.\n")), 
#&gt;             "\n", "\n", list("\n", "names2(letters)\n", "\n", 
#&gt;                 "# It also takes care of standardising missing names:\n", 
#&gt;                 "x &lt;- set_names(1:3, c(\"a\", NA, \"b\"))\n", 
#&gt;                 "names2(x)\n"), "\n"), `new-vector-along-retired.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("new-vector-along-retired"), "\n", list(
#&gt;                 "new-vector-along-retired"), "\n", list("new_logical_along"), 
#&gt;             "\n", list("new_integer_along"), "\n", list("new_double_along"), 
#&gt;             "\n", list("new_character_along"), "\n", list("new_complex_along"), 
#&gt;             "\n", list("new_raw_along"), "\n", list("new_list_along"), 
#&gt;             "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "new_logical_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_integer_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_double_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_character_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_complex_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_raw_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_list_along(x, names = base::names(x))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions are deprecated as of rlang 0.3.0 because they\n", 
#&gt;                 "are longer to type than the equivalent ", list(
#&gt;                   list("rep_along()")), " or\n", list(list("rep_named()")), 
#&gt;                 " calls without added clarity.\n"), "\n", list(
#&gt;                 "internal"), "\n"), `new-vector.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("new-vector"), "\n", list("new-vector"), 
#&gt;             "\n", list("new_logical"), "\n", list("new_integer"), 
#&gt;             "\n", list("new_double"), "\n", list("new_character"), 
#&gt;             "\n", list("new_complex"), "\n", list("new_raw"), 
#&gt;             "\n", list("new_list"), "\n", list("Create vectors matching a given length"), 
#&gt;             "\n", list("\n", "new_logical(n, names = NULL)\n", 
#&gt;                 "\n", "new_integer(n, names = NULL)\n", "\n", 
#&gt;                 "new_double(n, names = NULL)\n", "\n", "new_character(n, names = NULL)\n", 
#&gt;                 "\n", "new_complex(n, names = NULL)\n", "\n", 
#&gt;                 "new_raw(n, names = NULL)\n", "\n", "new_list(n, names = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The vector length.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "These functions construct vectors of a given length, with attributes\n", 
#&gt;                 "specified via dots. Except for ", list("new_list()"), 
#&gt;                 " and ", list("new_raw()"), ", the\n", "empty vectors are filled with typed ", 
#&gt;                 list("missing"), " values. This is in\n", "contrast to the base function ", 
#&gt;                 list(list("base::vector()")), " which creates\n", 
#&gt;                 "zero-filled vectors.\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are likely to be replaced by a vctrs equivalent in\n", 
#&gt;                   "the future. They are in the questioning lifecycle stage.\n")), 
#&gt;             "\n", "\n", list("\n", "new_list(10)\n", "new_logical(10)\n"), 
#&gt;             "\n", list("\n", "rep_along\n"), "\n", list("internal"), 
#&gt;             "\n"), new_call.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_call"), "\n", list("new_call"), "\n", 
#&gt;             list("Create a new call from components"), "\n", 
#&gt;             list("\n", "new_call(car, cdr = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("car"), list("The head of the call. It should be a\n", 
#&gt;                 list("callable"), " object: a symbol, call, or literal\n", 
#&gt;                 "function.")), "\n", "\n", list(list("cdr"), 
#&gt;                 list("The tail of the call, i.e. a ", list("node list"), 
#&gt;                   " of\n", "arguments.")), "\n"), "\n", list(
#&gt;                 "\n", "Create a new call from components\n"), 
#&gt;             "\n", list("internal"), "\n"), new_formula.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("new_formula"), "\n", list("new_formula"), "\n", 
#&gt;             list("Create a formula"), "\n", list("\n", "new_formula(lhs, rhs, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("lhs, rhs"), list("A call, name, or atomic vector.")), 
#&gt;                 "\n", "\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A formula object.\n"), 
#&gt;             "\n", list("\n", "Create a formula\n"), "\n", list(
#&gt;                 "\n", "new_formula(quote(a), quote(b))\n", "new_formula(NULL, quote(b))\n"), 
#&gt;             "\n", list("\n", list(list("new_quosure()")), "\n"), 
#&gt;             "\n"), new_function.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("new_function"), "\n", list("new_function"), 
#&gt;             "\n", list("Create a function"), "\n", list("\n", 
#&gt;                 "new_function(args, body, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("args"), list("A named list or pairlist of default arguments. Note\n", 
#&gt;                 "that if you want arguments that don't have defaults, you'll need\n", 
#&gt;                 "to use the special function ", list(list("pairlist2()")), 
#&gt;                 ". If you need quoted\n", "defaults, use ", list(
#&gt;                   list("exprs()")), ".")), "\n", "\n", list(list(
#&gt;                 "body"), list("A language object representing the code inside the\n", 
#&gt;                 "function. Usually this will be most easily generated with\n", 
#&gt;                 list(list("base::quote()")))), "\n", "\n", list(
#&gt;                 list("env"), list("The parent environment of the function, defaults to the\n", 
#&gt;                   "calling environment of ", list("new_function()"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This constructs a new function given its three components:\n", 
#&gt;                 "list of arguments, body code and parent environment.\n"), 
#&gt;             "\n", list("\n", "f &lt;- function() letters\n", "g &lt;- new_function(NULL, quote(letters))\n", 
#&gt;                 "identical(f, g)\n", "\n", "# Pass a list or pairlist of named arguments to create a function\n", 
#&gt;                 "# with parameters. The name becomes the parameter name and the\n", 
#&gt;                 "# argument the default value for this parameter:\n", 
#&gt;                 "new_function(list(x = 10), quote(x))\n", "new_function(pairlist2(x = 10), quote(x))\n", 
#&gt;                 "\n", "# Use `exprs()` to create quoted defaults. Compare:\n", 
#&gt;                 "new_function(pairlist2(x = 5 + 5), quote(x))\n", 
#&gt;                 "new_function(exprs(x = 5 + 5), quote(x))\n", 
#&gt;                 "\n", "# Pass empty arguments to omit defaults. `list()` doesn't allow\n", 
#&gt;                 "# empty arguments but `pairlist2()` does:\n", 
#&gt;                 "new_function(pairlist2(x = , y = 5 + 5), quote(x + y))\n", 
#&gt;                 "new_function(exprs(x = , y = 5 + 5), quote(x + y))\n"), 
#&gt;             "\n"), new_node.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_node"), "\n", list("new_node"), "\n", 
#&gt;             list("node_car"), "\n", list("node_cdr"), "\n", list(
#&gt;                 "node_caar"), "\n", list("node_cadr"), "\n", 
#&gt;             list("node_cdar"), "\n", list("node_cddr"), "\n", 
#&gt;             list("node_poke_car"), "\n", list("node_poke_cdr"), 
#&gt;             "\n", list("node_poke_caar"), "\n", list("node_poke_cadr"), 
#&gt;             "\n", list("node_poke_cdar"), "\n", list("node_poke_cddr"), 
#&gt;             "\n", list("node_tag"), "\n", list("node_poke_tag"), 
#&gt;             "\n", list("Helpers for pairlist and language nodes"), 
#&gt;             "\n", list("\n", "new_node(car, cdr = NULL)\n", "\n", 
#&gt;                 "node_car(x)\n", "\n", "node_cdr(x)\n", "\n", 
#&gt;                 "node_caar(x)\n", "\n", "node_cadr(x)\n", "\n", 
#&gt;                 "node_cdar(x)\n", "\n", "node_cddr(x)\n", "\n", 
#&gt;                 "node_poke_car(x, newcar)\n", "\n", "node_poke_cdr(x, newcdr)\n", 
#&gt;                 "\n", "node_poke_caar(x, newcar)\n", "\n", "node_poke_cadr(x, newcar)\n", 
#&gt;                 "\n", "node_poke_cdar(x, newcdr)\n", "\n", "node_poke_cddr(x, newcdr)\n", 
#&gt;                 "\n", "node_tag(x)\n", "\n", "node_poke_tag(x, newtag)\n"), 
#&gt;             "\n", list("\n", list(list("car, newcar, cdr, newcdr"), 
#&gt;                 list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                 list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Setters like ", list(
#&gt;                 "node_poke_car()"), " invisibly return ", list(
#&gt;                 "x"), " modified\n", "in place. Getters return the requested node component.\n"), 
#&gt;             "\n", list("\n", list("Important"), ": These functions are for expert R programmers only.\n", 
#&gt;                 "You should only use them if you feel comfortable manipulating low\n", 
#&gt;                 "level R data structures at the C level. We export them at the R level\n", 
#&gt;                 "in order to make it easy to prototype C code. They don't perform\n", 
#&gt;                 "any type checking and can crash R very easily (try to take the CAR\n", 
#&gt;                 "of an integer vector --- save any important objects beforehand!).\n"), 
#&gt;             "\n", list("\n", list(list("duplicate()")), " for creating copy-safe objects and\n", 
#&gt;                 list(list("base::pairlist()")), " for an easier way of creating a linked list of\n", 
#&gt;                 "nodes.\n"), "\n", list("internal"), "\n"), new_quosures.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "new_quosures"), "\n", list("new_quosures"), 
#&gt;             "\n", list("as_quosures"), "\n", list("is_quosures"), 
#&gt;             "\n", list("Create a list of quosures"), "\n", list(
#&gt;                 "\n", "new_quosures(x)\n", "\n", "as_quosures(x, env, named = FALSE)\n", 
#&gt;                 "\n", "is_quosures(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("A list of quosures or objects to coerce to quosures.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The default environment for the new quosures.")), 
#&gt;                 "\n", "\n", list(list("named"), list("Whether to name the list with ", 
#&gt;                   list(list("quos_auto_name()")), ".")), "\n"), 
#&gt;             "\n", list("\n", "This small S3 class provides methods for ", 
#&gt;                 list("["), " and ", list("c()"), " and ensures\n", 
#&gt;                 "the following invariants:\n", list("\n", list(), 
#&gt;                   " The list only contains quosures.\n", list(), 
#&gt;                   " It is always named, possibly with a vector of empty strings.\n"), 
#&gt;                 "\n", "\n", list("new_quosures()"), " takes a list of quosures and adds the ", 
#&gt;                 list("quosures"), "\n", "class and a vector of empty names if needed. ", 
#&gt;                 list("as_quosures()"), " calls\n", list(list(
#&gt;                   "as_quosure()")), " on all elements before creating the ", 
#&gt;                 list("quosures"), "\n", "object.\n"), "\n"), 
#&gt;         new_weakref.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/weakref.R", 
#&gt;             "\n", list("new_weakref"), "\n", list("new_weakref"), 
#&gt;             "\n", list("Create a weak reference"), "\n", list(
#&gt;                 "\n", "new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("key"), list("The key for the weak reference. Must be a reference object -- that\n", 
#&gt;                 "is, an environment or external pointer.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for the weak reference. This can be ", 
#&gt;                   list("NULL"), ", if you\n", "want to use the weak reference like a weak pointer.")), 
#&gt;                 "\n", "\n", list(list("finalizer"), list("A function that is run after the key becomes unreachable.")), 
#&gt;                 "\n", "\n", list(list("on_quit"), list("Should the finalizer be run when R exits?")), 
#&gt;                 "\n"), "\n", list("\n", "A weak reference is a special R object which makes it possible to keep a\n", 
#&gt;                 "reference to an object without preventing garbage collection of that object.\n", 
#&gt;                 "It can also be used to keep data about an object without preventing GC of the\n", 
#&gt;                 "object, similar to WeakMaps in JavaScript.\n", 
#&gt;                 "\n", "Objects in R are considered ", list("reachable"), 
#&gt;                 " if they can be accessed by following\n", "a chain of references, starting from a ", 
#&gt;                 list("root node"), "; root nodes are\n", "specially-designated R objects, and include the global environment and base\n", 
#&gt;                 "environment. As long as the key is reachable, the value will not be garbage\n", 
#&gt;                 "collected. This is true even if the weak reference object becomes\n", 
#&gt;                 "unreachable. The key effectively prevents the weak reference and its value\n", 
#&gt;                 "from being collected, according to the following chain of ownership:\n", 
#&gt;                 list("weakref &lt;- key -&gt; value"), ".\n", "\n", 
#&gt;                 "When the key becomes unreachable, the key and value in the weak reference\n", 
#&gt;                 "object are replaced by ", list("NULL"), ", and the finalizer is scheduled to execute.\n"), 
#&gt;             "\n", list("\n", "e &lt;- env()\n", "\n", "# Create a weak reference to e\n", 
#&gt;                 "w &lt;- new_weakref(e, finalizer = function(e) message(\"finalized\"))\n", 
#&gt;                 "\n", "# Get the key object from the weak reference\n", 
#&gt;                 "identical(wref_key(w), e)\n", "\n", "# When the regular reference (the `e` binding) is removed and a GC occurs,\n", 
#&gt;                 "# the weak reference will not keep the object alive.\n", 
#&gt;                 "rm(e)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "\n", "\n", "# A weak reference with a key and value. The value contains data about the\n", 
#&gt;                 "# key.\n", "k &lt;- env()\n", "v &lt;- list(1, 2, 3)\n", 
#&gt;                 "w &lt;- new_weakref(k, v)\n", "\n", "identical(wref_key(w), k)\n", 
#&gt;                 "identical(wref_value(w), v)\n", "\n", "# When v is removed, the weak ref keeps it alive because k is still reachable.\n", 
#&gt;                 "rm(v)\n", "gc()\n", "identical(wref_value(w), list(1, 2, 3))\n", 
#&gt;                 "\n", "# When k is removed, the weak ref does not keep k or v alive.\n", 
#&gt;                 "rm(k)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "identical(wref_value(w), NULL)\n"), "\n", list(
#&gt;                 "\n", list(list("is_weakref()")), ", ", list(
#&gt;                   list("wref_key()")), " and ", list(list("wref_value()")), 
#&gt;                 ".\n"), "\n", list("experimental"), "\n"), ns_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("ns_env"), "\n", list("ns_env"), "\n", 
#&gt;             list("ns_imports_env"), "\n", list("ns_env_name"), 
#&gt;             "\n", list("Get the namespace of a package"), "\n", 
#&gt;             list("\n", "ns_env(x = caller_env())\n", "\n", "ns_imports_env(x = caller_env())\n", 
#&gt;                 "\n", "ns_env_name(x = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list(list("\n", list(), 
#&gt;                 " For ", list("ns_env()"), ", the name of a package or an environment as a\n", 
#&gt;                 "string.\n", list("\n", list(), " An environment (the current environment by default).\n", 
#&gt;                   list(), " A function.\n"), "\n", "\n", "In the latter two cases, the environment ancestry is searched for\n", 
#&gt;                 "a namespace with ", list(list("base::topenv()")), 
#&gt;                 ". If the environment doesn't\n", "inherit from a namespace, this is an error.\n"))), 
#&gt;                 "\n", "\n", list(list("env"), list("A namespace environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Namespaces are the environment where all the functions of a package\n", 
#&gt;                 "live. The parent environments of namespaces are the ", 
#&gt;                 list("imports"), "\n", "environments, which contain all the functions imported from other\n", 
#&gt;                 "packages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental and may not belong to the rlang\n", 
#&gt;                   "package. Expect API changes.\n")), "\n", "\n", 
#&gt;             list("\n", list(list("pkg_env()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), `op-definition.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-definition"), "\n", list("op-definition"), 
#&gt;             "\n", list("is_definition"), "\n", list("new_definition"), 
#&gt;             "\n", list("is_formulaish"), "\n", list("Definition operator"), 
#&gt;             "\n", list("\n", "is_definition(x)\n", "\n", "new_definition(lhs, rhs, env = caller_env())\n", 
#&gt;                 "\n", "is_formulaish(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("lhs, rhs"), list("Expressions for the LHS and RHS of the definition.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The evaluation environment bundled with the definition.")), 
#&gt;                 "\n"), "\n", list("\n", "The definition operator is typically used in DSL packages like\n", 
#&gt;                 list("ggvis"), " and ", list("data.table"), ". It is also used in the tidyverse as a way\n", 
#&gt;                 "of unquoting names (see ", list("quasiquotation"), 
#&gt;                 ").\n", list("\n", list(), " ", list("is_definition()"), 
#&gt;                   " returns ", list("TRUE"), " for calls to ", 
#&gt;                   list(":="), ".\n", list(), " ", list("is_formulaish()"), 
#&gt;                   " returns ", list("TRUE"), " for both formulas and\n", 
#&gt;                   "colon-equals operators.\n"), "\n"), "\n", 
#&gt;             list("\n", "The recommended way to use it is to capture arguments as\n", 
#&gt;                 "expressions or quosures. You can then give a special function\n", 
#&gt;                 "definition for the ", list(":="), " symbol in an overscope. Note that if you\n", 
#&gt;                 "capture dots with ", list(list("exprs()")), 
#&gt;                 " or ", list(list("quos()")), ", you need to disable\n", 
#&gt;                 "interpretation of ", list(":="), " by setting ", 
#&gt;                 list(".unquote_names"), " to ", list("FALSE"), 
#&gt;                 ".\n", "\n", "From rlang and data.table perspectives, this operator is not meant\n", 
#&gt;                 "to be evaluated directly at top-level which is why the exported\n", 
#&gt;                 "definitions issue an error.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "\n", "# A predicate is provided to distinguish formulas from the\n", 
#&gt;                 "# colon-equals operator:\n", "is_definition(quote(a := b))\n", 
#&gt;                 "is_definition(a ~ b)\n", "\n", "\n", "# is_formulaish() tests for both definitions and formulas:\n", 
#&gt;                 "is_formulaish(a ~ b)\n", "is_formulaish(quote(a := b))\n"), 
#&gt;             "\n", list("internal"), "\n"), `op-get-attr.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-get-attr"), "\n", list("op-get-attr"), "\n", 
#&gt;             list("%@%"), "\n", list("%@%&lt;-"), "\n", list("Infix attribute accessor and setter"), 
#&gt;             "\n", list("\n", "x %@% name\n", "\n", "x %@% name &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Attribute name")), 
#&gt;                 "\n", "\n", list(list("value"), list("New value for attribute ", 
#&gt;                   list("name"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "This operator extracts or sets attributes for regular objects and\n", 
#&gt;                 "S4 fields for S4 objects.\n"), "\n", list("\n", 
#&gt;                 "# Unlike `@`, this operator extracts attributes for any kind of\n", 
#&gt;                 "# objects:\n", "factor(1:3) %@% \"levels\"\n", 
#&gt;                 "mtcars %@% class\n", "\n", "mtcars %@% class &lt;- NULL\n", 
#&gt;                 "mtcars\n", "\n", "# It also works on S4 objects:\n", 
#&gt;                 ".Person &lt;- setClass(\"Person\", slots = c(name = \"character\", species = \"character\"))\n", 
#&gt;                 "fievel &lt;- .Person(name = \"Fievel\", species = \"mouse\")\n", 
#&gt;                 "fievel %@% name\n"), "\n"), `op-na-default.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-na-default"), "\n", list("op-na-default"), 
#&gt;             "\n", list("%|%"), "\n", list("Replace missing values"), 
#&gt;             "\n", list("\n", "x %|% y\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("The original values.")), "\n", 
#&gt;                 "\n", list(list("y"), list("The replacement values. Must be of length 1 or the same length as ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "This infix function is similar to ", 
#&gt;                 list("%||%"), " but is vectorised\n", "and provides a default value for missing elements. It is faster\n", 
#&gt;                 "than using ", list(list("base::ifelse()")), 
#&gt;                 " and does not perform type conversions.\n"), 
#&gt;             "\n", list("\n", "c(\"a\", \"b\", NA, \"c\") %|% \"default\"\n", 
#&gt;                 "c(1L, NA, 3L, NA, NA) %|% (6L:10L)\n"), "\n", 
#&gt;             list("\n", list("op-null-default"), "\n"), "\n"), 
#&gt;         `op-null-default.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/operators.R", 
#&gt;             "\n", list("op-null-default"), "\n", list("op-null-default"), 
#&gt;             "\n", list("%||%"), "\n", list("Default value for ", 
#&gt;                 list("NULL")), "\n", list("\n", "x %||% y\n"), 
#&gt;             "\n", list("\n", list(list("x, y"), list("If ", list(
#&gt;                 "x"), " is NULL, will return ", list("y"), "; otherwise returns ", 
#&gt;                 list("x"), ".")), "\n"), "\n", list("\n", "This infix function makes it easy to replace ", 
#&gt;                 list("NULL"), "s with a default\n", "value. It's inspired by the way that Ruby's or operation (", 
#&gt;                 list("||"), ")\n", "works.\n"), "\n", list("\n", 
#&gt;                 "1 %||% 2\n", "NULL %||% 2\n"), "\n"), overscope_eval_next.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("overscope_eval_next"), "\n", list("overscope_eval_next"), 
#&gt;             "\n", list("Evaluate next quosure in a data mask"), 
#&gt;             "\n", list("\n", "overscope_eval_next(overscope, quo, env = base_env())\n"), 
#&gt;             "\n", list("\n", list(list("overscope"), list("A valid overscope containing bindings for ", 
#&gt;                 list("~"), ",\n", list(".top_env"), " and ", 
#&gt;                 list("_F"), " and whose parents contain overscoped bindings\n", 
#&gt;                 "for tidy evaluation.")), "\n", "\n", list(list(
#&gt;                 "quo"), list("A quosure.")), "\n", "\n", list(
#&gt;                 list("env"), list("The lexical enclosure in case ", 
#&gt;                   list("quo"), " is not a validly\n", "scoped quosure. This is the ", 
#&gt;                   list("base environment"), " by\n", "default.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("overscope_eval_next()"), " is deprecated as of rlang 0.2.0. Please use\n", 
#&gt;                 list("eval_tidy()"), " to which you can now supply an overscope.\n"), 
#&gt;             "\n", list("internal"), "\n"), pairlist2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("pairlist2"), "\n", list("pairlist2"), "\n", 
#&gt;             list("Create pairlists with splicing support"), "\n", 
#&gt;             list("\n", "pairlist2(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Arguments stored in the pairlist. Empty arguments are\n", 
#&gt;                   "preserved.")), "\n"), "\n", list("\n", "This pairlist constructor supports ", 
#&gt;                 list("tidy dots"), " features\n", "like ", list(
#&gt;                   "!!!"), ". Use it to manually create argument lists for calls or\n", 
#&gt;                 "parameter lists for functions.\n"), "\n", list(
#&gt;                 "\n", "# Unlike `exprs()`, `pairlist2()` evaluates its arguments.\n", 
#&gt;                 "new_function(pairlist2(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "new_function(exprs(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "\n", "# It preserves missing arguments, which is useful for creating\n", 
#&gt;                 "# parameters without defaults:\n", "new_function(pairlist2(x = , y = 3 * 6), quote(x * y))\n"), 
#&gt;             "\n"), parse_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parse.R", 
#&gt;             "\n", list("parse_expr"), "\n", list("parse_expr"), 
#&gt;             "\n", list("parse_exprs"), "\n", list("parse_quo"), 
#&gt;             "\n", list("parse_quos"), "\n", list("Parse R code"), 
#&gt;             "\n", list("\n", "parse_expr(x)\n", "\n", "parse_exprs(x)\n", 
#&gt;                 "\n", "parse_quo(x, env)\n", "\n", "parse_quos(x, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("parse_expr()"), 
#&gt;                 " returns an ", list("expression"), ",\n", list(
#&gt;                   "parse_exprs()"), " returns a list of expressions. Note that for the\n", 
#&gt;                 "plural variants the length of the output may be greater than the\n", 
#&gt;                 "length of the input. This would happen is one of the strings\n", 
#&gt;                 "contain several expressions (such as ", list(
#&gt;                   "\"foo; bar\""), ").\n"), "\n", list("\n", 
#&gt;                 "These functions parse and transform text into R expressions. This\n", 
#&gt;                 "is the first step to interpret or evaluate a piece of R code\n", 
#&gt;                 "written by a programmer.\n"), "\n", list("\n", 
#&gt;                 list("parse_expr()"), " returns one expression. If the text contains more\n", 
#&gt;                 "than one expression (separated by semicolons or new lines), an error is\n", 
#&gt;                 "issued. On the other hand ", list("parse_exprs()"), 
#&gt;                 " can handle multiple\n", "expressions. It always returns a list of expressions (compare to\n", 
#&gt;                 list(list("base::parse()")), " which returns a base::expression vector). All\n", 
#&gt;                 "functions also support R connections.\n", "\n", 
#&gt;                 "The versions suffixed with ", list("_quo"), 
#&gt;                 " and ", list("_quos"), " return\n", list("quosures"), 
#&gt;                 " rather than raw expressions.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " ", list("parse_quosure()"), " and ", 
#&gt;                   list("parse_quosures()"), " were soft-deprecated in\n", 
#&gt;                   "rlang 0.2.0 and renamed to ", list("parse_quo()"), 
#&gt;                   " and ", list("parse_quos()"), ". This\n", 
#&gt;                   "is consistent with the rule that abbreviated suffixes indicate\n", 
#&gt;                   "the return type of a function.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# parse_expr() can parse any R expression:\n", 
#&gt;                 "parse_expr(\"mtcars %&gt;% dplyr::mutate(cyl_prime = cyl / sd(cyl))\")\n", 
#&gt;                 "\n", "# A string can contain several expressions separated by ; or \\n\n", 
#&gt;                 "parse_exprs(\"NULL; list()\\n foo(bar)\")\n", 
#&gt;                 "\n", "# You can also parse source files by passing a R connection. Let's\n", 
#&gt;                 "# create a file containing R code:\n", "path &lt;- tempfile(\"my-file.R\")\n", 
#&gt;                 "cat(\"1; 2; mtcars\", file = path)\n", "\n", 
#&gt;                 "# We can now parse it by supplying a connection:\n", 
#&gt;                 "parse_exprs(file(path))\n"), "\n", list("\n", 
#&gt;                 list(list("base::parse()")), "\n"), "\n"), parse_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("parse_quosure"), "\n", list("parse_quosure"), 
#&gt;             "\n", list("parse_quosures"), "\n", list("Parse text into a quosure"), 
#&gt;             "\n", list("\n", "parse_quosure(x, env = caller_env())\n", 
#&gt;                 "\n", "parse_quosures(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("parse_quo()")), "\n", "and ", list(
#&gt;                   list("parse_quos()")), " in rlang 0.2.0. This is for consistency with the\n", 
#&gt;                 "convention that suffixes indicating return types are not\n", 
#&gt;                 "abbreviated.\n"), "\n", list("internal"), "\n"), 
#&gt;         prepend.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("prepend"), "\n", list("prepend"), "\n", 
#&gt;             list("modify"), "\n", list("Prepend a vector"), "\n", 
#&gt;             list("\n", "prepend(x, values, before = 1)\n", "\n", 
#&gt;                 "modify(.x, ...)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("the vector to be modified.")), "\n", 
#&gt;                 "\n", list(list("values"), list("to be included in the modified vector.")), 
#&gt;                 "\n", "\n", list(list("before"), list("a subscript, before which the values are to be appended.")), 
#&gt;                 "\n", "\n", list(list(".x"), list("A vector to modify.")), 
#&gt;                 "\n", "\n", list(list("..."), list("List of elements to merge into ", 
#&gt;                   list(".x"), ". Named elements\n", "already existing in ", 
#&gt;                   list(".x"), " are used as replacements. Elements that\n", 
#&gt;                   "have new or no names are inserted at the end. These dots support\n", 
#&gt;                   list("tidy dots"), " features.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "Vector functions are now out of scope for rlang. They might be\n", 
#&gt;                 "revived in the vctrs or funs packages.\n"), 
#&gt;             "\n", list("internal"), "\n"), prim_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "prim_name"), "\n", list("prim_name"), "\n", 
#&gt;             list("Name of a primitive function"), "\n", list(
#&gt;                 "\n", "prim_name(prim)\n"), "\n", list("\n", 
#&gt;                 list(list("prim"), list("A primitive function such as ", 
#&gt;                   list(list("base::c()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "Name of a primitive function\n"), "\n", 
#&gt;             list("internal"), "\n"), quasiquotation.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("quasiquotation"), "\n", list("quasiquotation"), 
#&gt;             "\n", list("UQ"), "\n", list("UQS"), "\n", list("{{}}"), 
#&gt;             "\n", list("{{"), "\n", list("!!"), "\n", list("!!!"), 
#&gt;             "\n", list(":="), "\n", list("qq_show"), "\n", list(
#&gt;                 "Quasiquotation of an expression"), "\n", list(
#&gt;                 "\n", "qq_show(expr)\n"), "\n", list("\n", list(
#&gt;                 list("expr"), list("An expression to be quasiquoted.")), 
#&gt;                 "\n"), "\n", list("\n", "Quasiquotation is the mechanism that makes it possible to program\n", 
#&gt;                 "flexibly with tidy evaluation grammars like dplyr. It is enabled in\n", 
#&gt;                 "all functions quoting their arguments with ", 
#&gt;                 list("enquo()"), ", ", list("enexpr()"), ",\n", 
#&gt;                 "or the plural variants.\n", "\n", "Quasiquotation is the combination of quoting an expression while\n", 
#&gt;                 "allowing immediate evaluation (unquoting) of part of that\n", 
#&gt;                 "expression. We provide both syntactic operators and functional\n", 
#&gt;                 "forms for unquoting.\n", list("\n", list(), 
#&gt;                   " The ", list("!!"), " operator unquotes its argument. It gets evaluated\n", 
#&gt;                   "immediately in the surrounding context.\n", 
#&gt;                   list(), " The ", list("!!!"), " operator unquotes and splices its argument. The\n", 
#&gt;                   "argument should represent a list or a vector. Each element will\n", 
#&gt;                   "be embedded in the surrounding call, i.e. each element is\n", 
#&gt;                   "inserted as an argument. If the vector is named, the names are\n", 
#&gt;                   "used as argument names.\n", "\n", "If the vector is a classed object (like a factor), it is\n", 
#&gt;                   "converted to a list with ", list(list("base::as.list()")), 
#&gt;                   " to ensure proper\n", "dispatch. If it is an S4 objects, it is converted to a list with\n", 
#&gt;                   list(list("methods::as()")), ".\n", list(), 
#&gt;                   " The ", list("{{ }}"), " operator quotes and unquotes its argument in one\n", 
#&gt;                   "go, a pattern that we call ", list("interpolation"), 
#&gt;                   ". It is an alias for\n", list("!!enquo(arg)"), 
#&gt;                   ".\n", "\n", "Like ", list("enquo()"), ", ", 
#&gt;                   list("{{ }}"), " is used in functions to capture an\n", 
#&gt;                   "argument as a quoted expression. This expression is immediately\n", 
#&gt;                   "unquoted in place.\n"), "\n", "\n", "Use ", 
#&gt;                 list("qq_show()"), " to experiment with quasiquotation or debug the\n", 
#&gt;                 "effect of unquoting operators. ", list("qq_show()"), 
#&gt;                 " quotes its input,\n", "processes unquoted parts, and prints the result with\n", 
#&gt;                 list(list("expr_print()")), ". This expression printer has a clearer output than\n", 
#&gt;                 "the base R printer (see the ", list("documentation topic"), 
#&gt;                 ").\n"), "\n", list(list("Unquoting names"), 
#&gt;                 list("\n", "\n", "\n", "When a function takes multiple named arguments\n", 
#&gt;                   "(e.g. ", list("dplyr::mutate()"), "), it is difficult to supply a variable as\n", 
#&gt;                   "name. Since the LHS of ", list("="), " is quoted, giving the name of a variable\n", 
#&gt;                   "results in the argument having the name of the variable rather than\n", 
#&gt;                   "the name stored in that variable. This problem is right up the\n", 
#&gt;                   "alley for the unquoting operator ", list("!!"), 
#&gt;                   ". If you were able to unquote\n", "the variable when supplying the name, the argument would be named\n", 
#&gt;                   "after the content of that variable.\n", "\n", 
#&gt;                   "Unfortunately R is very strict about the kind of expressions\n", 
#&gt;                   "supported on the LHS of ", list("="), ". This is why we have made the more\n", 
#&gt;                   "flexible ", list(":="), " operator an alias of ", 
#&gt;                   list("="), ". You can use it to supply\n", 
#&gt;                   "names, e.g. ", list("a := b"), " is equivalent to ", 
#&gt;                   list("a = b"), ". Since its syntax is\n", "more flexible you can unquote on the LHS:", 
#&gt;                   list("name &lt;- \"Jane\"\n", "\n", "list2(!!name := 1 + 2)\n", 
#&gt;                     "exprs(!!name := 1 + 2)\n", "quos(!!name := 1 + 2)\n"), 
#&gt;                   "\n", "\n", "Like ", list("="), ", the ", list(
#&gt;                     ":="), " operator expects strings or symbols on its LHS.\n", 
#&gt;                   "\n", "Note that unquoting on the LHS of ", 
#&gt;                   list(":="), " only works in top level\n", "expressions. These are all valid:", 
#&gt;                   list("exprs(!!nm := x)\n", "tibble(!!nm := x)\n", 
#&gt;                     "list2(!!nm := x)\n"), "\n", "\n", "But deep-unquoting names isn't supported:", 
#&gt;                   list("expr(foo(!!nm := x))\n", "exprs(foo(!!nm := x))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Theory"), list(
#&gt;                 "\n", "\n", "\n", "Formally, ", list("quo()"), 
#&gt;                 " and ", list("expr()"), " are quasiquote functions, ", 
#&gt;                 list("!!"), " is\n", "the unquote operator, and ", 
#&gt;                 list("!!!"), " is the unquote-splice operator.\n", 
#&gt;                 "These terms have a rich history in Lisp languages, and live on in\n", 
#&gt;                 "modern languages like\n", list(list("https://docs.julialang.org/en/v1/manual/metaprogramming/"), 
#&gt;                   list("Julia")), "\n", "and\n", list(list("https://docs.racket-lang.org/reference/quasiquote.html"), 
#&gt;                   list("Racket")), ".\n")), "\n", "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " Calling ", list("UQ()"), " and ", 
#&gt;                   list("UQS()"), " with the rlang namespace qualifier is\n", 
#&gt;                   "deprecated as of rlang 0.3.0. Just use the unqualified forms\n", 
#&gt;                   "instead:", list("# Bad\n", "rlang::expr(mean(rlang::UQ(var) * 100))\n", 
#&gt;                     "\n", "# Ok\n", "rlang::expr(mean(UQ(var) * 100))\n", 
#&gt;                     "\n", "# Good\n", "rlang::expr(mean(!!var * 100))\n"), 
#&gt;                   "\n", "\n", "Supporting namespace qualifiers complicates the implementation of\n", 
#&gt;                   "unquotation and is misleading as to the nature of unquoting\n", 
#&gt;                   "operators (which are syntactic operators that operates at\n", 
#&gt;                   "quotation-time rather than function calls at evaluation-time).\n", 
#&gt;                   list(), " ", list("UQ()"), " and ", list("UQS()"), 
#&gt;                   " were soft-deprecated in rlang 0.2.0 in order\n", 
#&gt;                   "to make the syntax of quasiquotation more consistent. The prefix\n", 
#&gt;                   "forms are now ", list("`!!`()"), " and ", 
#&gt;                   list("`!!!`()"), " which is\n", "consistent with other R operators (e.g. ", 
#&gt;                   list("`+`(a, b)"), " is the\n", "prefix form of ", 
#&gt;                   list("a + b"), ").\n", "\n", "Note that the prefix forms are not as relevant as before because\n", 
#&gt;                   list("!!"), " now has the right operator precedence, i.e. the same as\n", 
#&gt;                   "unary ", list("-"), " or ", list("+"), ". It is thus safe to mingle it with other\n", 
#&gt;                   "operators, e.g. ", list("!!a + !!b"), " does the right thing. In addition the\n", 
#&gt;                   "parser now strips one level of parentheses around unquoted\n", 
#&gt;                   "expressions. This way ", list("(!!\"foo\")(...)"), 
#&gt;                   " expands to ", list("foo(...)"), ".\n", "These changes make the prefix forms less useful.\n", 
#&gt;                   "\n", "Finally, the named functional forms ", 
#&gt;                   list("UQ()"), " and ", list("UQS()"), " were\n", 
#&gt;                   "misleading because they suggested that existing knowledge about\n", 
#&gt;                   "functions is applicable to quasiquotation. This was reinforced by\n", 
#&gt;                   "the visible definitions of these functions exported by rlang and\n", 
#&gt;                   "by the tidy eval parser interpreting ", list(
#&gt;                     "rlang::UQ()"), " as ", list("!!"), ". In\n", 
#&gt;                   "reality unquoting is ", list("not"), " a function call, it is a syntactic\n", 
#&gt;                   "operation. The operator form makes it clearer that unquoting is\n", 
#&gt;                   "special.\n"), "\n")), "\n", "\n", list("\n", 
#&gt;                 "# Interpolation with {{  }} is the easiest way to forward\n", 
#&gt;                 "# arguments to tidy eval functions:\n", "if (is_attached(\"package:dplyr\")) {\n", 
#&gt;                 "\n", "# Forward all arguments involving data frame columns by\n", 
#&gt;                 "# interpolating them within other data masked arguments.\n", 
#&gt;                 "# Here we interpolate `arg` in a `summarise()` call:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean({{ arg }}, na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "my_function(mtcars, cyl * 10)\n", 
#&gt;                 "\n", "# The  operator is just a shortcut for `!!enquo()`:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean(!!enquo(arg), na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "\n", 
#&gt;                 "}\n", "\n", "# Quasiquotation functions quote expressions like base::quote()\n", 
#&gt;                 "quote(how_many(this))\n", "expr(how_many(this))\n", 
#&gt;                 "quo(how_many(this))\n", "\n", "# In addition, they support unquoting. Let's store symbols\n", 
#&gt;                 "# (i.e. object names) in variables:\n", "this &lt;- sym(\"apples\")\n", 
#&gt;                 "that &lt;- sym(\"oranges\")\n", "\n", "# With unquotation you can insert the contents of these variables\n", 
#&gt;                 "# inside the quoted expression:\n", "expr(how_many(!!this))\n", 
#&gt;                 "expr(how_many(!!that))\n", "\n", "# You can also insert values:\n", 
#&gt;                 "expr(how_many(!!(1 + 2)))\n", "quo(how_many(!!(1 + 2)))\n", 
#&gt;                 "\n", "\n", "# Note that when you unquote complex objects into an expression,\n", 
#&gt;                 "# the base R printer may be a bit misleading. For instance compare\n", 
#&gt;                 "# the output of `expr()` and `quo()` (which uses a custom printer)\n", 
#&gt;                 "# when we unquote an integer vector:\n", "expr(how_many(!!(1:10)))\n", 
#&gt;                 "quo(how_many(!!(1:10)))\n", "\n", "# This is why it's often useful to use qq_show() to examine the\n", 
#&gt;                 "# result of unquotation operators. It uses the same printer as\n", 
#&gt;                 "# quosures but does not return anything:\n", 
#&gt;                 "qq_show(how_many(!!(1:10)))\n", "\n", "\n", 
#&gt;                 "# Use `!!!` to add multiple arguments to a function. Its argument\n", 
#&gt;                 "# should evaluate to a list or vector:\n", "args &lt;- list(1:3, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!!args))\n", "\n", "# You can combine the two\n", 
#&gt;                 "var &lt;- quote(xyz)\n", "extra_args &lt;- list(trim = 0.9, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!var , !!!extra_args))\n", "\n", "\n", 
#&gt;                 "# The plural versions have support for the `:=` operator.\n", 
#&gt;                 "# Like `=`, `:=` creates named arguments:\n", 
#&gt;                 "quos(mouse1 := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "# The `:=` is mainly useful to unquote names. Unlike `=` it\n", 
#&gt;                 "# supports `!!` on its LHS:\n", "var &lt;- \"unquote me!\"\n", 
#&gt;                 "quos(!!var := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "\n", "# All these features apply to dots captured by enquos():\n", 
#&gt;                 "fn &lt;- function(...) enquos(...)\n", "fn(!!!args, !!var := penny)\n", 
#&gt;                 "\n", "\n", "# Unquoting is especially useful for building an expression by\n", 
#&gt;                 "# expanding around a variable part (the unquoted part):\n", 
#&gt;                 "quo1 &lt;- quo(toupper(foo))\n", "quo1\n", "\n", 
#&gt;                 "quo2 &lt;- quo(paste(!!quo1, bar))\n", "quo2\n", 
#&gt;                 "\n", "quo3 &lt;- quo(list(!!quo2, !!!syms(letters[1:5])))\n", 
#&gt;                 "quo3\n"), "\n"), quo_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("quo_expr"), "\n", list("quo_expr"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_expr(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated, please use ", 
#&gt;                 list(list("quo_squash()")), " instead.\n"), "\n", 
#&gt;             list("internal"), "\n"), quo_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quo.R", "\n", 
#&gt;             list("quo_label"), "\n", list("quo_label"), "\n", 
#&gt;             list("quo_text"), "\n", list("quo_name"), "\n", list(
#&gt;                 "Format quosures for printing or labelling"), 
#&gt;             "\n", list("\n", "quo_label(quo)\n", "\n", "quo_text(quo, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "quo_name(quo)\n"), "\n", list("\n", list(
#&gt;                 list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("Note:"), " You should now use ", 
#&gt;                 list(list("as_label()")), " or ", list(list("as_name()")), 
#&gt;                 " instead\n", "of ", list("quo_name()"), ". See life cycle section below.\n", 
#&gt;                 "\n", "These functions take an arbitrary R object, typically an\n", 
#&gt;                 list("expression"), ", and represent it as a string.\n", 
#&gt;                 list("\n", list(), " ", list("quo_name()"), " returns an abbreviated representation of the object\n", 
#&gt;                   "as a single line string. It is suitable for default names.\n", 
#&gt;                   list(), " ", list("quo_text()"), " returns a multiline string. For instance block\n", 
#&gt;                   "expressions like ", list("{ foo; bar }"), 
#&gt;                   " are represented on 4 lines (one\n", "for each symbol, and the curly braces on their own lines).\n"), 
#&gt;                 "\n", "\n", "These deparsers are only suitable for creating default names or\n", 
#&gt;                 "printing output at the console. The behaviour of your functions\n", 
#&gt;                 "should not depend on deparsed objects. If you are looking for a way\n", 
#&gt;                 "of transforming symbols to strings, use ", list(
#&gt;                   list("as_string()")), " instead of\n", list(
#&gt;                   "quo_name()"), ". Unlike deparsing, the transformation between symbols\n", 
#&gt;                 "and strings is non-lossy and well defined.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are in the questioning life cycle stage.\n", 
#&gt;                 list("\n", list(), " ", list(list("as_label()")), 
#&gt;                   " and ", list(list("as_name()")), " should be used instead of\n", 
#&gt;                   list("quo_name()"), ". ", list("as_label()"), 
#&gt;                   " transforms any R object to a string\n", "but should only be used to create a default name. Labelisation is\n", 
#&gt;                   "not a well defined operation and no assumption should be made\n", 
#&gt;                   "about the label. On the other hand, ", list(
#&gt;                     "as_name()"), " only works with\n", "(possibly quosured) symbols, but is a well defined and\n", 
#&gt;                   "deterministic operation.\n", list(), " We don't have a good replacement for ", 
#&gt;                   list("quo_text()"), " yet. See\n", list("https://github.com/r-lib/rlang/issues/636"), 
#&gt;                   " to follow discussions\n", "about a new deparsing API.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(foo(!! quo(bar)))\n", "quo\n", "\n", 
#&gt;                 "# quo_squash() unwraps all quosures and returns a raw expression:\n", 
#&gt;                 "quo_squash(quo)\n", "\n", "# This is used by quo_text() and quo_label():\n", 
#&gt;                 "quo_text(quo)\n", "\n", "# Compare to the unwrapped expression:\n", 
#&gt;                 "expr_text(quo)\n", "\n", "# quo_name() is helpful when you need really short labels:\n", 
#&gt;                 "quo_name(quo(sym))\n", "quo_name(quo(!! sym))\n"), 
#&gt;             "\n", list("\n", list(list("expr_label()")), ", ", 
#&gt;                 list(list("f_label()")), "\n"), "\n"), quo_squash.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quo_squash"), "\n", list("quo_squash"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_squash(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("quo_squash()"), " flattens all nested quosures within an expression.\n", 
#&gt;                 "For example it transforms ", list("^foo(^bar(), ^baz)"), 
#&gt;                 " to the bare\n", "expression ", list("foo(bar(), baz)"), 
#&gt;                 ".\n", "\n", "This operation is safe if the squashed quosure is used for\n", 
#&gt;                 "labelling or printing (see ", list(list("quo_label()")), 
#&gt;                 " or ", list(list("quo_name()")), "). However\n", 
#&gt;                 "if the squashed quosure is evaluated, all expressions of the\n", 
#&gt;                 "flattened quosures are resolved in a single environment. This is a\n", 
#&gt;                 "source of bugs so it is good practice to set ", 
#&gt;                 list("warn"), " to ", list("TRUE"), " to\n", 
#&gt;                 "let the user know about the lossy squashing.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "This function replaces ", list("quo_expr()"), 
#&gt;                 " which was deprecated in\n", "rlang 0.2.0. ", 
#&gt;                 list("quo_expr()"), " was a misnomer because it implied that it\n", 
#&gt;                 "was a mere expression acccessor for quosures whereas it was really\n", 
#&gt;                 "a lossy operation that squashed all nested quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(wrapper(!!quo(wrappee)))\n", "quo\n", 
#&gt;                 "\n", "# quo_squash() flattens all the quosures and returns a simple expression:\n", 
#&gt;                 "quo_squash(quo)\n"), "\n"), quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quosure"), "\n", list("quosure"), "\n", list(
#&gt;                 "is_quosure"), "\n", list("quo_is_missing"), 
#&gt;             "\n", list("quo_is_symbol"), "\n", list("quo_is_call"), 
#&gt;             "\n", list("quo_is_symbolic"), "\n", list("quo_is_null"), 
#&gt;             "\n", list("quo_get_expr"), "\n", list("quo_get_env"), 
#&gt;             "\n", list("quo_set_expr"), "\n", list("quo_set_env"), 
#&gt;             "\n", list("Quosure getters, setters and testers"), 
#&gt;             "\n", list("\n", "is_quosure(x)\n", "\n", "quo_is_missing(quo)\n", 
#&gt;                 "\n", "quo_is_symbol(quo, name = NULL)\n", "\n", 
#&gt;                 "quo_is_call(quo, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_symbolic(quo)\n", "\n", "quo_is_null(quo)\n", 
#&gt;                 "\n", "quo_get_expr(quo)\n", "\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo_set_expr(quo, expr)\n", "\n", "quo_set_env(quo, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("The name of the symbol or function call. If ", 
#&gt;                   list("NULL"), " the\n", "name is not tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("expr"), list(
#&gt;                   "A new expression for the quosure.")), "\n", 
#&gt;                 "\n", list(list("env"), list("A new environment for the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure is a type of ", 
#&gt;                 list("quoted expression"), " that includes\n", 
#&gt;                 "a reference to the context where it was created. A quosure is thus\n", 
#&gt;                 "guaranteed to evaluate in its original environment and can refer to\n", 
#&gt;                 "local objects.\n", "\n", "You can access the quosure components (its expression and its\n", 
#&gt;                 "environment) with:\n", list("\n", list(), " ", 
#&gt;                   list(list("get_expr()")), " and ", list(list(
#&gt;                     "get_env()")), ". These getters also support other\n", 
#&gt;                   "kinds of objects such as formulas.\n", list(), 
#&gt;                   " ", list("quo_get_expr()"), " and ", list(
#&gt;                     "quo_get_env()"), ". These getters only work\n", 
#&gt;                   "with quosures and throw an error with other types of input.\n"), 
#&gt;                 "\n", "\n", "Test if an object is a quosure with ", 
#&gt;                 list("is_quosure()"), ". If you know an\n", "object is a quosure, use the ", 
#&gt;                 list("quo_"), " prefixed predicates to check\n", 
#&gt;                 "its contents, ", list("quo_is_missing()"), ", ", 
#&gt;                 list("quo_is_symbol()"), ", etc.\n"), "\n", list(
#&gt;                 list("Quosured constants"), list("\n", "\n", 
#&gt;                   "\n", "A quosure usually does not carry environments for ", 
#&gt;                   list("constant objects"), " like strings or numbers. ", 
#&gt;                   list(list("quo()")), " and\n", list(list("enquo()")), 
#&gt;                   " only capture an environment for ", list("symbolic expressions"), 
#&gt;                   ". For instance, all of these return the\n", 
#&gt;                   list("empty environment"), ":", list("quo_get_env(quo(\"constant\"))\n", 
#&gt;                     "quo_get_env(quo(100))\n", "quo_get_env(quo(NA))\n"), 
#&gt;                   "\n", "\n", "On the other hand, quosures capture the environment of symbolic\n", 
#&gt;                   "expressions, i.e. expressions whose meaning depends on the\n", 
#&gt;                   "environment in which they are evaluated and what objects are\n", 
#&gt;                   "defined there:", list("quo_get_env(quo(some_object))\n", 
#&gt;                     "quo_get_env(quo(some_function()))\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Empty quosures"), list("\n", 
#&gt;                 "\n", "\n", "When missing arguments are captured as quosures, either through\n", 
#&gt;                 list(list("enquo()")), " or ", list(list("quos()")), 
#&gt;                 ", they are returned as an empty quosure. These\n", 
#&gt;                 "quosures contain the ", list("missing argument"), 
#&gt;                 " and typically\n", "have the ", list("empty environment"), 
#&gt;                 " as enclosure.\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "is_quosure()"), " is stable.\n", list(), " ", 
#&gt;                   list("quo_get_expr()"), " and ", list("quo_get_env()"), 
#&gt;                   " are stable.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "quo &lt;- quo(my_quosure)\n", "quo\n", "\n", 
#&gt;                 "\n", "# Access and set the components of a quosure:\n", 
#&gt;                 "quo_get_expr(quo)\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo &lt;- quo_set_expr(quo, quote(baz))\n", 
#&gt;                 "quo &lt;- quo_set_env(quo, empty_env())\n", "quo\n", 
#&gt;                 "\n", "# Test wether an object is a quosure:\n", 
#&gt;                 "is_quosure(quo)\n", "\n", "# If it is a quosure, you can use the specialised type predicates\n", 
#&gt;                 "# to check what is inside it:\n", "quo_is_symbol(quo)\n", 
#&gt;                 "quo_is_call(quo)\n", "quo_is_null(quo)\n", "\n", 
#&gt;                 "# quo_is_missing() checks for a special kind of quosure, the one\n", 
#&gt;                 "# that contains the missing argument:\n", "quo()\n", 
#&gt;                 "quo_is_missing(quo())\n", "\n", "fn &lt;- function(arg) enquo(arg)\n", 
#&gt;                 "fn()\n", "quo_is_missing(fn())\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), " for creating quosures by quotation; ", 
#&gt;                 list(list("as_quosure()")), "\n", "and ", list(
#&gt;                   list("new_quosure()")), " for constructing quosures manually.\n"), 
#&gt;             "\n"), quotation.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quotation.R", 
#&gt;             "\n", list("quotation"), "\n", list("quotation"), 
#&gt;             "\n", list("expr"), "\n", list("enexpr"), "\n", list(
#&gt;                 "exprs"), "\n", list("enexprs"), "\n", list("ensym"), 
#&gt;             "\n", list("ensyms"), "\n", list("quo"), "\n", list(
#&gt;                 "enquo"), "\n", list("quos"), "\n", list("enquos"), 
#&gt;             "\n", list("Quotation"), "\n", list("\n", "expr(expr)\n", 
#&gt;                 "\n", "enexpr(arg)\n", "\n", "exprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE)\n", "\n", 
#&gt;                 "enexprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "ensym(arg)\n", "\n", "ensyms(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "quo(expr)\n", "\n", "enquo(arg)\n", "\n", "quos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .unquote_names = TRUE)\n", "\n", "enquos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An expression.")), 
#&gt;                 "\n", "\n", list(list("arg"), list("A symbol representing an argument. The expression\n", 
#&gt;                   "supplied to that argument will be captured instead of being\n", 
#&gt;                   "evaluated.")), "\n", "\n", list(list("..."), 
#&gt;                   list("For ", list("enexprs()"), ", ", list(
#&gt;                     "ensyms()"), " and ", list("enquos()"), ", names of\n", 
#&gt;                     "arguments to capture without evaluation (including ", 
#&gt;                     list("..."), "). For\n", list("exprs()"), 
#&gt;                     " and ", list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                     "(including expressions contained in ", list(
#&gt;                       "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n", "\n", list(list(".unquote_names"), 
#&gt;                   list("Whether to treat ", list(":="), " as ", 
#&gt;                     list("="), ". Unlike ", list("="), ", the\n", 
#&gt;                     list(":="), " syntax supports ", list("!!"), 
#&gt;                     " unquoting on the LHS.")), "\n", "\n", list(
#&gt;                   list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                     "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                     list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                     " to only keep the first occurrences, to ", 
#&gt;                     list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                     list("\"error\""), " to raise an informative\n", 
#&gt;                     "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "Quotation is a mechanism by which an expression supplied as\n", 
#&gt;                 "argument is captured by a function. Instead of seeing the value of\n", 
#&gt;                 "the argument, the function sees the recipe (the R code) to make\n", 
#&gt;                 "that value. This is possible because R ", list(
#&gt;                   "expressions"), " are\n", "representable as regular objects in R:\n", 
#&gt;                 list("\n", list(), " Calls represent the action of calling a function to\n", 
#&gt;                   "compute a new value. Evaluating a call causes that value to be\n", 
#&gt;                   "computed. Calls typically involve symbols to reference R objects.\n", 
#&gt;                   list(), " Symbols represent the name that is given to an object in a\n", 
#&gt;                   "particular context (an ", list("environment"), 
#&gt;                   ").\n"), "\n", "\n", "We call objects containing calls and symbols ", 
#&gt;                 list("expressions"), ".\n", "There are two ways to create R expressions. First you can ", 
#&gt;                 list("build"), "\n", "calls and symbols from parts and pieces (see ", 
#&gt;                 list(list("sym()")), ", ", list(list("syms()")), 
#&gt;                 " and\n", list(list("call2()")), "). The other way is by ", 
#&gt;                 list("quotation"), " or ", list("quasiquotation"), 
#&gt;                 ",\n", "i.e. by intercepting an expression instead of evaluating it.\n"), 
#&gt;             "\n", list(list("User expressions versus your expressions"), 
#&gt;                 list("\n", "\n", "\n", "There are two points of view when it comes to capturing an\n", 
#&gt;                   "expression:\n", list("\n", list(), " You can capture the expressions supplied by ", 
#&gt;                     list("the user"), " of your\n", "function. This is the purpose of ", 
#&gt;                     list("ensym()"), ", ", list("enexpr()"), 
#&gt;                     " and\n", list("enquo()"), " and their plural variants. These functions take an\n", 
#&gt;                     "argument name and capture the expression that was supplied to\n", 
#&gt;                     "that argument.\n", list(), " You can capture the expressions that ", 
#&gt;                     list("you"), " supply. To this end\n", "use ", 
#&gt;                     list("expr()"), " and ", list("quo()"), " and their plural variants ", 
#&gt;                     list("exprs()"), " and\n", list("quos()"), 
#&gt;                     ".\n"), "\n")), "\n", "\n", list(list("Capture raw expressions"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "enexpr()"), " and ", list("expr()"), " capture a single raw expression.\n", 
#&gt;                   list(), " ", list("enexprs()"), " and ", list(
#&gt;                     "exprs()"), " capture a list of raw expressions\n", 
#&gt;                   "including expressions contained in ", list(
#&gt;                     "..."), ".\n", list(), " ", list("ensym()"), 
#&gt;                   " and ", list("ensyms()"), " are variants of ", 
#&gt;                   list("enexpr()"), " and\n", list("enexprs()"), 
#&gt;                   " that check the captured expression is either a string\n", 
#&gt;                   "(which they convert to symbol) or a symbol. If anything else\n", 
#&gt;                   "is supplied they throw an error.\n"), "\n", 
#&gt;                   "\n", "In terms of base functions, ", list(
#&gt;                     "enexpr(arg)"), " corresponds to\n", list(
#&gt;                     "base::substitute(arg)"), " (though that function also features complex\n", 
#&gt;                   "substitution semantics) and ", list("expr()"), 
#&gt;                   " is like ", list(list("quote()")), " (and\n", 
#&gt;                   list(list("bquote()")), " if we consider unquotation syntax). The plural variant\n", 
#&gt;                   list("exprs()"), " is equivalent to ", list(
#&gt;                     list("base::alist()")), ". Finally there is no\n", 
#&gt;                   "function in base R that is equivalent to ", 
#&gt;                   list("enexprs()"), " but you can\n", "reproduce its behaviour with ", 
#&gt;                   list("eval(substitute(alist(...)))"), ".\n")), 
#&gt;             "\n", "\n", list(list("Capture expressions in quosures"), 
#&gt;                 list("\n", "\n", "\n", list("quo()"), " and ", 
#&gt;                   list("enquo()"), " are similar to their ", 
#&gt;                   list("expr"), " counterparts but\n", "capture both the expression and its environment in an object called\n", 
#&gt;                   "a quosure. This wrapper contains a reference to the original\n", 
#&gt;                   "environment in which that expression was captured. Keeping track of\n", 
#&gt;                   "the environments of expressions is important because this is where\n", 
#&gt;                   "functions and objects mentioned in the expression are defined.\n", 
#&gt;                   "\n", "Quosures are objects that can be evaluated with ", 
#&gt;                   list(list("eval_tidy()")), " just\n", "like symbols or function calls. Since they always evaluate in their\n", 
#&gt;                   "original environment, quosures can be seen as vehicles that allow\n", 
#&gt;                   "expressions to travel from function to function but that beam back\n", 
#&gt;                   "instantly to their original environment upon evaluation.\n", 
#&gt;                   "\n", "See the ", list("quosure"), " help topic about tools to work with quosures.\n")), 
#&gt;             "\n", "\n", list(list("Quasiquotation"), list("\n", 
#&gt;                 "\n", "\n", "All quotation functions in rlang have support for ", 
#&gt;                 list("unquoting operators"), ". The combination of quotation and\n", 
#&gt;                 "unquotation is called ", list("quasiquotation"), 
#&gt;                 ".\n", "\n", "Unquotation provides a way to refer to variables during quotation.\n", 
#&gt;                 "Variables are problematic when quoting because a captured\n", 
#&gt;                 "expression is essentially a constant, just like a string is a\n", 
#&gt;                 "constant. For instance in all the following cases ", 
#&gt;                 list("apple"), " is a\n", "constant: ", list(
#&gt;                   "~apple"), ", ", list("\"apple\""), " and ", 
#&gt;                 list("expr(apple)"), ". Unquoting allows\n", 
#&gt;                 "you to introduce a part of variability within a captured\n", 
#&gt;                 "expression.\n", list("\n", list(), " In the case of ", 
#&gt;                   list("enexpr()"), " and ", list("enquo()"), 
#&gt;                   ", unquoting provides an\n", "escape hatch to the users of your function that allows them to\n", 
#&gt;                   "manipulate the expression that you capture.\n", 
#&gt;                   list(), " In the case of ", list("expr()"), 
#&gt;                   " and ", list("quo()"), ", quasiquotation lets you\n", 
#&gt;                   "build a complex expressions where some parts are constant (the\n", 
#&gt;                   "parts that are captured) and some parts are variable (the parts\n", 
#&gt;                   "that are unquoted).\n"), "\n", "\n", "See the ", 
#&gt;                 list("quasiquotation"), " help topic for more about this as well as\n", 
#&gt;                 list(list("https://adv-r.hadley.nz/quasiquotation.html"), 
#&gt;                   list("the chapter in Advanced R")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# expr() and exprs() capture expressions that you supply:\n", 
#&gt;                 "expr(symbol)\n", "exprs(several, such, symbols)\n", 
#&gt;                 "\n", "# enexpr() and enexprs() capture expressions that your user supplied:\n", 
#&gt;                 "expr_inputs &lt;- function(arg, ...) {\n", "  user_exprs &lt;- enexprs(arg, ...)\n", 
#&gt;                 "  user_exprs\n", "}\n", "expr_inputs(hello)\n", 
#&gt;                 "expr_inputs(hello, bonjour, ciao)\n", "\n", 
#&gt;                 "# ensym() and ensyms() provide additional type checking to ensure\n", 
#&gt;                 "# the user calling your function has supplied bare object names:\n", 
#&gt;                 "sym_inputs &lt;- function(...) {\n", "  user_symbols &lt;- ensyms(...)\n", 
#&gt;                 "  user_symbols\n", "}\n", "sym_inputs(hello, \"bonjour\")\n", 
#&gt;                 "## sym_inputs(say(hello))  # Error: Must supply symbols or strings\n", 
#&gt;                 "expr_inputs(say(hello))\n", "\n", "\n", "# All these quoting functions have quasiquotation support. This\n", 
#&gt;                 "# means that you can unquote (evaluate and inline) part of the\n", 
#&gt;                 "# captured expression:\n", "what &lt;- sym(\"bonjour\")\n", 
#&gt;                 "expr(say(what))\n", "expr(say(!!what))\n", "\n", 
#&gt;                 "# This also applies to expressions supplied by the user. This is\n", 
#&gt;                 "# like an escape hatch that allows control over the captured\n", 
#&gt;                 "# expression:\n", "expr_inputs(say(!!what), !!what)\n", 
#&gt;                 "\n", "\n", "# Finally, you can capture expressions as quosures. A quosure is an\n", 
#&gt;                 "# object that contains both the expression and its environment:\n", 
#&gt;                 "quo &lt;- quo(letters)\n", "quo\n", "\n", "get_expr(quo)\n", 
#&gt;                 "get_env(quo)\n", "\n", "# Quosures can be evaluated with eval_tidy():\n", 
#&gt;                 "eval_tidy(quo)\n", "\n", "# They have the nice property that you can pass them around from\n", 
#&gt;                 "# context to context (that is, from function to function) and they\n", 
#&gt;                 "# still evaluate in their original environment:\n", 
#&gt;                 "multiply_expr_by_10 &lt;- function(expr) {\n", 
#&gt;                 "  # We capture the user expression and its environment:\n", 
#&gt;                 "  expr &lt;- enquo(expr)\n", "\n", "  # Then create an object that only exists in this function:\n", 
#&gt;                 "  local_ten &lt;- 10\n", "\n", "  # Now let's create a multiplication expression that (a) inlines\n", 
#&gt;                 "  # the user expression as LHS (still wrapped in its quosure) and\n", 
#&gt;                 "  # (b) refers to the local object in the RHS:\n", 
#&gt;                 "  quo(!!expr * local_ten)\n", "}\n", "quo &lt;- multiply_expr_by_10(2 + 3)\n", 
#&gt;                 "\n", "# The local parts of the quosure are printed in colour if your\n", 
#&gt;                 "# terminal is capable of displaying colours:\n", 
#&gt;                 "quo\n", "\n", "# All the quosures in the expression evaluate in their original\n", 
#&gt;                 "# context. The local objects are looked up properly and we get the\n", 
#&gt;                 "# expected result:\n", "eval_tidy(quo)\n"), 
#&gt;             "\n"), rep_along.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("rep_along"), "\n", list("rep_along"), 
#&gt;             "\n", list("rep_named"), "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "rep_along(along, x)\n", "\n", "rep_named(names, x)\n"), 
#&gt;             "\n", list("\n", list(list("along"), list("Vector whose length determine how many times ", 
#&gt;                 list("x"), "\n", "is repeated.")), "\n", "\n", 
#&gt;                 list(list("x"), list("Values to repeat.")), "\n", 
#&gt;                 "\n", list(list("names"), list("Names for the new vector. The length of ", 
#&gt;                   list("names"), "\n", "determines how many times ", 
#&gt;                   list("x"), " is repeated.")), "\n"), "\n", 
#&gt;             list("\n", "These functions take the idea of ", list(
#&gt;                 list("seq_along()")), " and apply it to\n", "repeating values.\n"), 
#&gt;             "\n", list("\n", "x &lt;- 0:5\n", "rep_along(x, 1:2)\n", 
#&gt;                 "rep_along(x, 1)\n", "\n", "# Create fresh vectors by repeating missing values:\n", 
#&gt;                 "rep_along(x, na_int)\n", "rep_along(x, na_chr)\n", 
#&gt;                 "\n", "# rep_named() repeats a value along a names vectors\n", 
#&gt;                 "rep_named(c(\"foo\", \"bar\"), list(letters))\n"), 
#&gt;             "\n", list("\n", "new-vector\n"), "\n"), restarting.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("restarting"), "\n", list("restarting"), 
#&gt;             "\n", list("Create a restarting handler"), "\n", 
#&gt;             list("\n", "restarting(.restart, ..., .fields = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Additional arguments passed on the restart\n", 
#&gt;                   "function. These arguments are evaluated only once and\n", 
#&gt;                   "immediately, when creating the restarting handler. Furthermore,\n", 
#&gt;                   "they support ", list("tidy dots"), " features.")), 
#&gt;                 "\n", "\n", list(list(".fields"), list("A character vector specifying the fields of the\n", 
#&gt;                   "condition that should be passed as arguments to the restart. If\n", 
#&gt;                   "named, the names (except empty names ", list(
#&gt;                     "\"\""), ") are used as\n", "argument names for calling the restart function. Otherwise the\n", 
#&gt;                   "the fields themselves are used as argument names.")), 
#&gt;                 "\n"), "\n", list("\n", "This constructor automates the common task of creating an\n", 
#&gt;                 list(list("calling()")), " handler that invokes a restart.\n"), 
#&gt;             "\n", list("\n", "Jumping to a restart point from a calling handler has two\n", 
#&gt;                 "effects. First, the control flow jumps to wherever the restart was\n", 
#&gt;                 "established, and the restart function is called (with ", 
#&gt;                 list("..."), ", or\n", list(".fields"), " as arguments). Execution resumes from the\n", 
#&gt;                 list(list("with_restarts()")), " call. Secondly, the transfer of the control flow\n", 
#&gt;                 "out of the function that signalled the condition means that the\n", 
#&gt;                 "handler has dealt with the condition. Thus the condition will not\n", 
#&gt;                 "be passed on to other potential handlers established on the stack.\n"), 
#&gt;             "\n", list("\n", "# This is a restart that takes a data frame and names as arguments\n", 
#&gt;                 "rst_bar &lt;- function(df, nms) {\n", "  stats::setNames(df, nms)\n", 
#&gt;                 "}\n", "\n", "# This restart is simpler and does not take arguments\n", 
#&gt;                 "rst_baz &lt;- function() \"baz\"\n", "\n", "# Signalling a condition parameterised with a data frame\n", 
#&gt;                 "fn &lt;- function() {\n", "  with_restarts(signal(\"A foobar condition occurred\", \"foo\", foo_field = mtcars),\n", 
#&gt;                 "    rst_bar = rst_bar,\n", "    rst_baz = rst_baz\n", 
#&gt;                 "  )\n", "}\n", "\n", "# Creating a restarting handler that passes arguments `nms` and\n", 
#&gt;                 "# `df`, the latter taken from a data field of the condition object\n", 
#&gt;                 "restart_bar &lt;- restarting(\"rst_bar\",\n", "  nms = LETTERS[1:11], .fields = c(df = \"foo_field\")\n", 
#&gt;                 ")\n", "\n", "# The restarting handlers jumps to `rst_bar` when `foo` is signalled:\n", 
#&gt;                 "with_handlers(fn(), foo = restart_bar)\n", "\n", 
#&gt;                 "# The restarting() constructor is especially nice to use with\n", 
#&gt;                 "# restarts that do not need arguments:\n", "with_handlers(fn(), foo = restarting(\"rst_baz\"))\n"), 
#&gt;             "\n", list("\n", list(list("calling()")), " and ", 
#&gt;                 list(list("exiting()")), ".\n"), "\n", list("internal"), 
#&gt;             "\n"), return_from.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("return_from"), "\n", list("return_from"), 
#&gt;             "\n", list("return_to"), "\n", list("Jump to or from a frame"), 
#&gt;             "\n", list("\n", "return_from(frame, value = NULL)\n", 
#&gt;                 "\n", "return_to(frame, value = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("frame"), list("An environment, a frame object, or any object with an\n", 
#&gt;                 list(list("get_env()")), " method. The environment should be an evaluation\n", 
#&gt;                 "environment currently on the stack.")), "\n", 
#&gt;                 "\n", list(list("value"), list("The return value.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "While ", list(list("base::return()")), 
#&gt;                 " can only return from the current local\n", 
#&gt;                 "frame, these two functions will return from any frame on the\n", 
#&gt;                 "current evaluation stack, between the global and the currently\n", 
#&gt;                 "active context. They provide a way of performing arbitrary\n", 
#&gt;                 "non-local jumps out of the function currently under evaluation.\n"), 
#&gt;             "\n", list("\n", list("return_from()"), " will jump out of ", 
#&gt;                 list("frame"), ". ", list("return_to()"), " is a bit\n", 
#&gt;                 "trickier. It will jump out of the frame located just before ", 
#&gt;                 list("frame"), "\n", "in the evaluation stack, so that control flow ends up in ", 
#&gt;                 list("frame"), ",\n", "at the location where the previous frame was called from.\n", 
#&gt;                 "\n", "These functions should only be used rarely. These sort of non-local\n", 
#&gt;                 "gotos can be hard to reason about in casual code, though they can\n", 
#&gt;                 "sometimes be useful. Also, consider to use the condition system to\n", 
#&gt;                 "perform non-local jumps.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "The support for ", 
#&gt;                 list("frame"), " object is soft-deprecated.  Please pass\n", 
#&gt;                 "simple environments to ", list("return_from()"), 
#&gt;                 " and ", list("return_to()"), ".\n", "\n", "These functions are in the questioning lifecycle because we are\n", 
#&gt;                 "considering simpler alternatives.\n")), "\n", 
#&gt;             "\n", list("\n", "# Passing fn() evaluation frame to g():\n", 
#&gt;                 "fn &lt;- function() {\n", "  val &lt;- g(current_env())\n", 
#&gt;                 "  cat(\"g returned:\", val, \"\\n\")\n", "  \"normal return\"\n", 
#&gt;                 "}\n", "g &lt;- function(env) h(env)\n", "\n", "# Here we return from fn() with a new return value:\n", 
#&gt;                 "h &lt;- function(env) return_from(env, \"early return\")\n", 
#&gt;                 "fn()\n", "\n", "# Here we return to fn(). The call stack unwinds until the last frame\n", 
#&gt;                 "# called by fn(), which is g() in that case.\n", 
#&gt;                 "h &lt;- function(env) return_to(env, \"early return\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), rlang_backtrace_on_error.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-abort.R", "\n", 
#&gt;             list("rlang_backtrace_on_error"), "\n", list("rlang_backtrace_on_error"), 
#&gt;             "\n", list("add_backtrace"), "\n", list("Display backtrace on error"), 
#&gt;             "\n", list("\n", "Errors thrown with ", list(list(
#&gt;                 "abort()")), " automatically save a backtrace that\n", 
#&gt;                 "can be inspected by calling ", list(list("last_error()")), 
#&gt;                 ". Optionally, you can\n", "also display the backtrace alongside the error message by setting\n", 
#&gt;                 "the option ", list("rlang_backtrace_on_error"), 
#&gt;                 " to one of the following\n", "values:\n", list(
#&gt;                   "\n", list(), " ", list("\"reminder\""), ": Display a reminder that the backtrace can be\n", 
#&gt;                   "inspected by calling ", list(list("rlang::last_error()")), 
#&gt;                   ".\n", list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                   list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                   list(), " ", list("\"full\""), ": Display the full backtrace tree.\n"), 
#&gt;                 "\n"), "\n", list(list("Promote base errors to rlang errors"), 
#&gt;                 list("\n", "\n", "\n", "Call ", list("options(error = rlang::enframe)"), 
#&gt;                   " to instrument base\n", "errors with rlang features. This handler does two things:\n", 
#&gt;                   list("\n", list(), " It saves the base error as an rlang object. This allows you to\n", 
#&gt;                     "call ", list(list("last_error()")), " to print the backtrace or inspect its data.\n", 
#&gt;                     list(), " It prints the backtrace for the current error according to the\n", 
#&gt;                     list(list("rlang_backtrace_on_error")), " option.\n"), 
#&gt;                   "\n")), "\n", "\n", list("\n", "# Display a simplified backtrace on error for both base and rlang\n", 
#&gt;                 "# errors:\n", "\n", "# options(\n", "#   rlang_backtrace_on_error = \"branch\",\n", 
#&gt;                 "#   error = rlang::enframe\n", "# )\n", "# stop(\"foo\")\n"), 
#&gt;             "\n"), rst_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_abort"), "\n", list("rst_abort"), 
#&gt;             "\n", list("Jump to the abort restart"), "\n", list(
#&gt;                 "\n", "rst_abort()\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"questioning\")"), "\n", 
#&gt;                 "\n", "The abort restart is the only restart that is established at top\n", 
#&gt;                 "level. It is used by R as a top-level target, most notably when an\n", 
#&gt;                 "error is issued (see ", list(list("abort()")), 
#&gt;                 ") that no handler is able\n", "to deal with (see ", 
#&gt;                 list(list("with_handlers()")), ").\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# The `abort` restart is a bit special in that it is always\n", 
#&gt;                 "# registered in a R session. You will always find it on the restart\n", 
#&gt;                 "# stack because it is established at top level:\n", 
#&gt;                 "rst_list()\n", "\n", "# You can use the `above` restart to jump to top level without\n", 
#&gt;                 "# signalling an error:\n", list("\n", "fn &lt;- function() {\n", 
#&gt;                   "  cat(\"aborting...\\n\")\n", "  rst_abort()\n", 
#&gt;                   "  cat(\"This is never called\\n\")\n", "}\n", 
#&gt;                   "{\n", "  fn()\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# The `above` restart is the target that R uses to jump to top\n", 
#&gt;                 "# level when critical errors are signalled:\n", 
#&gt;                 list("\n", "{\n", "  abort(\"error\")\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# If another `abort` restart is specified, errors are signalled as\n", 
#&gt;                 "# usual but then control flow resumes with from the new restart:\n", 
#&gt;                 list("\n", "out &lt;- NULL\n", "{\n", "  out &lt;- with_restarts(abort(\"error\"), abort = function() \"restart!\")\n", 
#&gt;                   "  cat(\"This is called\\n\")\n", "}\n", "cat(\"`out` has now become:\", out, \"\\n\")\n"), 
#&gt;                 "\n"), "\n", list("\n", list(list("rst_jump()")), 
#&gt;                 ", ", list(list("abort()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), rst_list.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_list"), "\n", list("rst_list"), "\n", 
#&gt;             list("rst_exists"), "\n", list("rst_jump"), "\n", 
#&gt;             list("rst_maybe_jump"), "\n", list("Restarts utilities"), 
#&gt;             "\n", list("\n", "rst_list()\n", "\n", "rst_exists(.restart)\n", 
#&gt;                 "\n", "rst_jump(.restart, ...)\n", "\n", "rst_maybe_jump(.restart, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed on to the restart function. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restarts are named jumping points established by ", 
#&gt;                 list(list("with_restarts()")), ".\n", list("rst_list()"), 
#&gt;                 " returns the names of all restarts currently\n", 
#&gt;                 "established. ", list("rst_exists()"), " checks if a given restart is\n", 
#&gt;                 "established. ", list("rst_jump()"), " stops execution of the current function\n", 
#&gt;                 "and jumps to a restart point. If the restart does not exist, an\n", 
#&gt;                 "error is thrown.  ", list("rst_maybe_jump()"), 
#&gt;                 " first checks that a restart\n", "exists before jumping.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 list(list("with_restarts()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), `scalar-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("scalar-type-predicates"), "\n", list("scalar-type-predicates"), 
#&gt;             "\n", list("is_scalar_list"), "\n", list("is_scalar_atomic"), 
#&gt;             "\n", list("is_scalar_vector"), "\n", list("is_scalar_integer"), 
#&gt;             "\n", list("is_scalar_double"), "\n", list("is_scalar_character"), 
#&gt;             "\n", list("is_scalar_logical"), "\n", list("is_scalar_raw"), 
#&gt;             "\n", list("is_string"), "\n", list("is_scalar_bytes"), 
#&gt;             "\n", list("is_bool"), "\n", list("Scalar type predicates"), 
#&gt;             "\n", list("\n", "is_scalar_list(x)\n", "\n", "is_scalar_atomic(x)\n", 
#&gt;                 "\n", "is_scalar_vector(x)\n", "\n", "is_scalar_integer(x)\n", 
#&gt;                 "\n", "is_scalar_double(x)\n", "\n", "is_scalar_character(x, encoding = NULL)\n", 
#&gt;                 "\n", "is_scalar_logical(x)\n", "\n", "is_scalar_raw(x)\n", 
#&gt;                 "\n", "is_string(x, string = NULL)\n", "\n", 
#&gt;                 "is_scalar_bytes(x)\n", "\n", "is_bool(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to be tested.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n", "\n", list(list("string"), list("A string to compare to ", 
#&gt;                   list("x"), ". If a character vector,\n", "returns ", 
#&gt;                   list("TRUE"), " if at least one element is equal to ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "These predicates check for a given type and whether the vector is\n", 
#&gt;                 "\"scalar\", that is, of length 1.\n", "\n", 
#&gt;                 "In addition to the length check, ", list("is_string()"), 
#&gt;                 " and ", list("is_bool()"), "\n", "return ", 
#&gt;                 list("FALSE"), " if their input is missing. This is useful for\n", 
#&gt;                 "type-checking arguments, when your function expects a single string\n", 
#&gt;                 "or a single ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ".\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("bare-type-predicates"), "\n"), "\n"), 
#&gt;         scoped_bindings.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("scoped_bindings"), "\n", list("scoped_bindings"), 
#&gt;             "\n", list("with_bindings"), "\n", list("Temporarily change bindings of an environment"), 
#&gt;             "\n", list("\n", "scoped_bindings(..., .env = .frame, .frame = caller_env())\n", 
#&gt;                 "\n", "with_bindings(.expr, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Pairs of names and values. These dots support splicing\n", 
#&gt;                 "(with value semantics) and name unquoting.")), 
#&gt;                 "\n", "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The frame environment that determines the scope of\n", 
#&gt;                   "the temporary bindings. When that frame is popped from the call\n", 
#&gt;                   "stack, bindings are switched back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary bindings.")), 
#&gt;                 "\n"), "\n", list("\n", list("scoped_bindings()"), 
#&gt;                 " returns the values of old bindings\n", "invisibly; ", 
#&gt;                 list("with_bindings()"), " returns the value of ", 
#&gt;                 list("expr"), ".\n"), "\n", list("\n", list("\n", 
#&gt;                 list(), " ", list("scoped_bindings()"), " temporarily changes bindings in ", 
#&gt;                 list(".env"), " (which\n", "is by default the caller environment). The bindings are reset to\n", 
#&gt;                 "their original values when the current frame (or an arbitrary one\n", 
#&gt;                 "if you specify ", list(".frame"), ") goes out of scope.\n", 
#&gt;                 list(), " ", list("with_bindings()"), " evaluates ", 
#&gt;                 list("expr"), " with temporary bindings. When\n", 
#&gt;                 list("with_bindings()"), " returns, bindings are reset to their original\n", 
#&gt;                 "values. It is a simple wrapper around ", list(
#&gt;                   "scoped_bindings()"), ".\n"), "\n"), "\n", 
#&gt;             list("\n", "foo &lt;- \"foo\"\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "\n", "# `foo` will be temporarily rebinded while executing `expr`\n", 
#&gt;                 "with_bindings(paste(foo, bar), foo = \"rebinded\")\n", 
#&gt;                 "paste(foo, bar)\n"), "\n"), scoped_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("scoped_env"), "\n", list("scoped_env"), 
#&gt;             "\n", list("is_scoped"), "\n", list("scoped_envs"), 
#&gt;             "\n", list("scoped_names"), "\n", list("Retired ", 
#&gt;                 list("scoped"), " functions"), "\n", list("\n", 
#&gt;                 "scoped_env(nm)\n", "\n", "is_scoped(nm)\n", 
#&gt;                 "\n", "scoped_envs()\n", "\n", "scoped_names()\n"), 
#&gt;             "\n", list("\n", list(list("nm"), list("The name of an environment attached to the search\n", 
#&gt;                 "path. Call ", list(list("base::search()")), 
#&gt;                 " to see what is currently on the path.")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated as of rlang 0.3.0. They are replaced\n", 
#&gt;                 "by ", list(list("is_attached()")), ", ...\n"), 
#&gt;             "\n", list("internal"), "\n"), scoped_options.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/state.R", "\n", 
#&gt;             list("scoped_options"), "\n", list("scoped_options"), 
#&gt;             "\n", list("with_options"), "\n", list("push_options"), 
#&gt;             "\n", list("peek_options"), "\n", list("peek_option"), 
#&gt;             "\n", list("Change global options"), "\n", list("\n", 
#&gt;                 "scoped_options(..., .frame = caller_env())\n", 
#&gt;                 "\n", "with_options(.expr, ...)\n", "\n", "push_options(...)\n", 
#&gt;                 "\n", "peek_options(...)\n", "\n", "peek_option(name)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("For ", list(
#&gt;                 "scoped_options()"), " and ", list("push_options()"), 
#&gt;                 ", named\n", "values defining new option values. For ", 
#&gt;                 list("peek_options()"), ", strings\n", "or character vectors of option names.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The environment of a stack frame which defines the\n", 
#&gt;                   "scope of the temporary options. When the frame returns, the\n", 
#&gt;                   "options are set back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary options.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An option name as string.")), 
#&gt;                 "\n"), "\n", list("\n", "For ", list("scoped_options()"), 
#&gt;                 " and ", list("push_options()"), ", the old option\n", 
#&gt;                 "values. ", list("peek_option()"), " returns the current value of an option\n", 
#&gt;                 "while the plural ", list("peek_options()"), 
#&gt;                 " returns a list of current\n", "option values.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("scoped_options()"), 
#&gt;                 " changes options for the duration of a stack\n", 
#&gt;                 "frame (by default the current one). Options are set back to their\n", 
#&gt;                 "old values when the frame returns.\n", list(), 
#&gt;                 " ", list("with_options()"), " changes options while an expression is\n", 
#&gt;                 "evaluated. Options are restored when the expression returns.\n", 
#&gt;                 list(), " ", list("push_options()"), " adds or changes options permanently.\n", 
#&gt;                 list(), " ", list("peek_option()"), " and ", 
#&gt;                 list("peek_options()"), " return option values. The\n", 
#&gt;                 "former returns the option directly while the latter returns a\n", 
#&gt;                 "list.\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "# Store and retrieve a global option:\n", 
#&gt;                 "push_options(my_option = 10)\n", "peek_option(\"my_option\")\n", 
#&gt;                 "\n", "# Change the option temporarily:\n", "with_options(my_option = 100, peek_option(\"my_option\"))\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The scoped variant is useful within functions:\n", 
#&gt;                 "fn &lt;- function() {\n", "  scoped_options(my_option = 100)\n", 
#&gt;                 "  peek_option(\"my_option\")\n", "}\n", "fn()\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The plural peek returns a named list:\n", 
#&gt;                 "peek_options(\"my_option\")\n", "peek_options(\"my_option\", \"digits\")\n"), 
#&gt;             "\n", list("experimental"), "\n"), search_envs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("search_envs"), "\n", list("search_envs"), 
#&gt;             "\n", list("search_env"), "\n", list("pkg_env"), 
#&gt;             "\n", list("pkg_env_name"), "\n", list("is_attached"), 
#&gt;             "\n", list("base_env"), "\n", list("global_env"), 
#&gt;             "\n", list("Search path environments"), "\n", list(
#&gt;                 "\n", "search_envs()\n", "\n", "search_env(name)\n", 
#&gt;                 "\n", "pkg_env(pkg)\n", "\n", "pkg_env_name(pkg)\n", 
#&gt;                 "\n", "is_attached(x)\n", "\n", "base_env()\n", 
#&gt;                 "\n", "global_env()\n"), "\n", list("\n", list(
#&gt;                 list("name"), list("The name of an environment attached to the search\n", 
#&gt;                   "path. Call ", list(list("base::search()")), 
#&gt;                   " to get the names of environments\n", "currently attached to the search path. Note that the search name\n", 
#&gt;                   "of a package environment is prefixed with ", 
#&gt;                   list("\"package:\""), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", "The search path is a chain of environments containing exported\n", 
#&gt;                 "functions of attached packages.\n", "\n", "The API includes:\n", 
#&gt;                 list("\n", list(), " ", list(list("base::search()")), 
#&gt;                   " to get the names of environments attached to the\n", 
#&gt;                   "search path.\n", list(), " ", list("search_envs()"), 
#&gt;                   " returns the environments on the search path as a\n", 
#&gt;                   "list.\n", list(), " ", list("pkg_env_name()"), 
#&gt;                   " takes a bare package name and prefixes it with\n", 
#&gt;                   list("\"package:\""), ". Attached package environments have search names of\n", 
#&gt;                   "the form ", list("package:name"), ".\n", list(), 
#&gt;                   " ", list("pkg_env()"), " takes a bare package name and returns the scoped\n", 
#&gt;                   "environment of packages if they are attached to the search path,\n", 
#&gt;                   "and throws an error otherwise. It is a shortcut for\n", 
#&gt;                   list("search_env(pkg_env_name(\"pkgname\"))"), 
#&gt;                   ".\n", list(), " ", list("is_attached()"), 
#&gt;                   " returns ", list("TRUE"), " when its argument (a search name\n", 
#&gt;                   "or a package environment) is attached to the search path.\n"), 
#&gt;                 "\n"), "\n", list(list("The search path"), list(
#&gt;                 "\n", "\n", "\n", "This chain of environments determines what objects are visible from\n", 
#&gt;                 "the global workspace. It contains the following elements:\n", 
#&gt;                 list("\n", list(), " The chain always starts with ", 
#&gt;                   list("global_env()"), " and finishes with\n", 
#&gt;                   list("base_env()"), " (technically, it finishes with the ", 
#&gt;                   list("empty_env()"), "\n", "which the base package environment inherits from).\n", 
#&gt;                   list(), " Each ", list(list("base::library()")), 
#&gt;                   " call attaches a new package environment to\n", 
#&gt;                   "the search path. Attached packages are associated with a ", 
#&gt;                   list("search name"), ".\n", list(), " In addition, any list, data frame, or environment can be attached\n", 
#&gt;                   "to the search path with ", list(list("base::attach()")), 
#&gt;                   ".\n"), "\n")), "\n", "\n", list("\n", "# List the search names of environments attached to the search path:\n", 
#&gt;                 "search()\n", "\n", "# Get the corresponding environments:\n", 
#&gt;                 "search_envs()\n", "\n", "# The global environment and the base package are always first and\n", 
#&gt;                 "# last in the chain, respectively:\n", "envs &lt;- search_envs()\n", 
#&gt;                 "envs[[1]]\n", "envs[[length(envs)]]\n", "\n", 
#&gt;                 "# These two environments have their own shortcuts:\n", 
#&gt;                 "global_env()\n", "base_env()\n", "\n", "# Packages appear in the search path with a special name. Use\n", 
#&gt;                 "# pkg_env_name() to create that name:\n", "pkg_env_name(\"rlang\")\n", 
#&gt;                 "search_env(pkg_env_name(\"rlang\"))\n", "\n", 
#&gt;                 "# Alternatively, get the scoped environment of a package with\n", 
#&gt;                 "# pkg_env():\n", "pkg_env(\"utils\")\n"), "\n", 
#&gt;             list("internal"), "\n"), seq2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("seq2"), "\n", list("seq2"), "\n", list("seq2_along"), 
#&gt;             "\n", list("Increasing sequence of integers in an interval"), 
#&gt;             "\n", list("\n", "seq2(from, to)\n", "\n", "seq2_along(from, x)\n"), 
#&gt;             "\n", list("\n", list(list("from"), list("The starting point of the sequence.")), 
#&gt;                 "\n", "\n", list(list("to"), list("The end point.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A vector whose length is the end point.")), 
#&gt;                 "\n"), "\n", list("\n", "An integer vector containing a strictly increasing\n", 
#&gt;                 "sequence.\n"), "\n", list("\n", "These helpers take two endpoints and return the sequence of all\n", 
#&gt;                 "integers within that interval. For ", list("seq2_along()"), 
#&gt;                 ", the upper\n", "endpoint is taken from the length of a vector. Unlike\n", 
#&gt;                 list("base::seq()"), ", they return an empty vector if the starting point is\n", 
#&gt;                 "a larger integer than the end point.\n"), "\n", 
#&gt;             list("\n", "seq2(2, 10)\n", "seq2(10, 2)\n", "seq(10, 2)\n", 
#&gt;                 "\n", "seq2_along(10, letters)\n"), "\n"), set_attrs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("set_attrs"), "\n", list("set_attrs"), 
#&gt;             "\n", list("mut_attrs"), "\n", list("Add attributes to an object"), 
#&gt;             "\n", list("\n", "set_attrs(.x, ...)\n", "\n", "mut_attrs(.x, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("An object to decorate with attributes.")), 
#&gt;                 "\n", "\n", list(list("..."), list("A list of named attributes. These have ", 
#&gt;                   list("explicit splicing semantics"), ". Pass a single unnamed ", 
#&gt;                   list("NULL"), " argument to\n", "zap all attributes from ", 
#&gt;                   list(".x"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("set_attrs()"), " returns a modified ", 
#&gt;                 list("shallow copy"), "\n", "of ", list(".x"), 
#&gt;                 ". ", list("mut_attrs()"), " invisibly returns the original ", 
#&gt;                 list(".x"), "\n", "modified in place.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("set_attrs()"), " adds, changes, or zaps attributes of objects. Pass a\n", 
#&gt;                 "single unnamed ", list("NULL"), " argument to zap all attributes. For\n", 
#&gt;                 list("uncopyable"), " types, use ", list("mut_attrs()"), 
#&gt;                 ".\n"), "\n", list("\n", "Unlike ", list(list(
#&gt;                 "structure()")), ", these setters have no special handling of\n", 
#&gt;                 "internal attributes names like ", list(".Dim"), 
#&gt;                 ", ", list(".Dimnames"), " or ", list(".Names"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are deprecated since rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "set_attrs(letters, names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "\n", "# Splice a list of attributes:\n", "attrs &lt;- list(attr = \"attr\", names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "obj &lt;- set_attrs(letters, splice(attrs))\n", 
#&gt;                 "obj\n", "\n", "# Zap attributes by passing a single unnamed NULL argument:\n", 
#&gt;                 "set_attrs(obj, NULL)\n", "set_attrs(obj, !!! list(NULL))\n", 
#&gt;                 "\n", "# Note that set_attrs() never modifies objects in place:\n", 
#&gt;                 "obj\n", "\n", "# For uncopyable types, mut_attrs() lets you modify in place:\n", 
#&gt;                 "env &lt;- env()\n", "mut_attrs(env, foo = \"bar\")\n", 
#&gt;                 "env\n"), "\n", list("internal"), "\n"), set_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/expr.R", "\n", 
#&gt;             list("set_expr"), "\n", list("set_expr"), "\n", list(
#&gt;                 "get_expr"), "\n", list("Set and get an expression"), 
#&gt;             "\n", list("\n", "set_expr(x, value)\n", "\n", "get_expr(x, default = x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An expression, closure, or one-sided formula. In addition,\n", 
#&gt;                 list("set_expr()"), " accept frames.")), "\n", 
#&gt;                 "\n", list(list("value"), list("An updated expression.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default expression to return when ", 
#&gt;                   list("x"), " is not an\n", "expression wrapper. Defaults to ", 
#&gt;                   list("x"), " itself.")), "\n"), "\n", list(
#&gt;                 "\n", "The updated original input for ", list(
#&gt;                   "set_expr()"), ". A raw\n", "expression for ", 
#&gt;                 list("get_expr()"), ".\n"), "\n", list("\n", 
#&gt;                 "These helpers are useful to make your function work generically\n", 
#&gt;                 "with quosures and raw expressions. First call ", 
#&gt;                 list("get_expr()"), " to\n", "extract an expression. Once you're done processing the expression,\n", 
#&gt;                 "call ", list("set_expr()"), " on the original object to update the expression.\n", 
#&gt;                 "You can return the result of ", list("set_expr()"), 
#&gt;                 ", either a formula or an\n", "expression depending on the input type. Note that ", 
#&gt;                 list("set_expr()"), " does\n", "not change its input, it creates a new object.\n"), 
#&gt;             "\n", list("\n", "f &lt;- ~foo(bar)\n", "e &lt;- quote(foo(bar))\n", 
#&gt;                 "frame &lt;- identity(identity(ctxt_frame()))\n", 
#&gt;                 "\n", "get_expr(f)\n", "get_expr(e)\n", "get_expr(frame)\n", 
#&gt;                 "\n", "set_expr(f, quote(baz))\n", "set_expr(e, quote(baz))\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_expr()")), " and ", 
#&gt;                 list(list("quo_set_expr()")), " for versions of\n", 
#&gt;                 list(list("get_expr()")), " and ", list(list(
#&gt;                   "set_expr()")), " that only work on quosures.\n"), 
#&gt;             "\n"), set_names.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("set_names"), "\n", list("set_names"), 
#&gt;             "\n", list("Set names of a vector"), "\n", list("\n", 
#&gt;                 "set_names(x, nm = x, ...)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Vector to name.")), "\n", 
#&gt;                 "\n", list(list("nm, ..."), list("Vector of names, the same length as ", 
#&gt;                   list("x"), ".\n", "\n", "You can specify names in the following ways:\n", 
#&gt;                   list("\n", list(), " If you do nothing, ", 
#&gt;                     list("x"), " will be named with itself.\n", 
#&gt;                     list(), " If ", list("x"), " already has names, you can provide a function or formula\n", 
#&gt;                     "to transform the existing names. In that case, ", 
#&gt;                     list("..."), " is passed\n", "to the function.\n", 
#&gt;                     list(), " If ", list("nm"), " is ", list(
#&gt;                       "NULL"), ", the names are removed (if present).\n", 
#&gt;                     list(), " In all other cases, ", list("nm"), 
#&gt;                     " and ", list("..."), " are coerced to character.\n"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "stats::setNames()")), ", with more features and\n", 
#&gt;                 "stricter argument checking.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                   "set_names()"), " is stable and exported in purrr.\n")), 
#&gt;             "\n", "\n", list("\n", "set_names(1:4, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "set_names(1:4, letters[1:4])\n", "set_names(1:4, \"a\", \"b\", \"c\", \"d\")\n", 
#&gt;                 "\n", "# If the second argument is ommitted a vector is named with itself\n", 
#&gt;                 "set_names(letters[1:5])\n", "\n", "# Alternatively you can supply a function\n", 
#&gt;                 "set_names(1:10, ~ letters[seq_along(.)])\n", 
#&gt;                 "set_names(head(mtcars), toupper)\n", "\n", "# If the input vector is unnamed, it is first named after itself\n", 
#&gt;                 "# before the function is applied:\n", "set_names(letters, toupper)\n", 
#&gt;                 "\n", "# `...` is passed to the function:\n", 
#&gt;                 "set_names(head(mtcars), paste0, \"_foo\")\n"), 
#&gt;             "\n"), splice.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("splice"), "\n", list("splice"), "\n", 
#&gt;             list("is_spliced"), "\n", list("is_spliced_bare"), 
#&gt;             "\n", list("dots_splice"), "\n", list("Splice lists"), 
#&gt;             "\n", list("\n", "splice(x)\n", "\n", "is_spliced(x)\n", 
#&gt;                 "\n", "is_spliced_bare(x)\n", "\n", "dots_splice(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A list to splice.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to collect with ", 
#&gt;                   list("!!!"), " support.")), "\n", "\n", list(
#&gt;                   list(".ignore_empty"), list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("splice"), 
#&gt;                   " marks an object to be spliced. It is equivalent to using\n", 
#&gt;                   list("!!!"), " in a function with ", list("tidy dots semantics"), 
#&gt;                   ".\n", list(), " ", list("dots_splice()"), 
#&gt;                   " is like ", list(list("dots_list()")), " but automatically splices\n", 
#&gt;                   "list inputs.\n"), "\n"), "\n", list(list("Standard splicing versus quoting splicing"), 
#&gt;                 list("\n", "\n", "\n", "The ", list("!!!"), " operator works differently in ", 
#&gt;                   list("standard"), " functions taking\n", "dots with ", 
#&gt;                   list("dots_list()"), " than in ", list("quoting"), 
#&gt;                   " functions taking dots\n", "with ", list(list(
#&gt;                     "enexprs()")), " or ", list(list("enquos()")), 
#&gt;                   ".\n", list("\n", list(), " In quoting functions ", 
#&gt;                     list("!!!"), " disaggregates its argument (let's call\n", 
#&gt;                     "it ", list("x"), ") into as many objects as there are elements in\n", 
#&gt;                     list("x"), ". E.g. ", list("quo(foo(!!! c(1, 2)))"), 
#&gt;                     " is completely equivalent to\n", list("quo(foo(1, 2))"), 
#&gt;                     ". The creation of those separate objects has an\n", 
#&gt;                     "overhead but is typically not important when manipulating calls\n", 
#&gt;                     "because function calls typically take a small number of\n", 
#&gt;                     "arguments.\n", list(), " In standard functions, disaggregating the spliced collection\n", 
#&gt;                     "would have a negative performance impact in cases where\n", 
#&gt;                     list("dots_list()"), " is used to build up data structures from user\n", 
#&gt;                     "inputs. To avoid this spliced inputs are marked with ", 
#&gt;                     list(list("splice()")), "\n", "and the final list is built with (the equivalent of)\n", 
#&gt;                     list("flatten_if(dots, is_spliced)"), ".\n"), 
#&gt;                   "\n", "\n", "Most of the time you should not care about the difference. However\n", 
#&gt;                   "if you use a standard function taking tidy dots within a quoting\n", 
#&gt;                   "function, the ", list("!!!"), " operator will disaggregate its argument because\n", 
#&gt;                   "the behaviour of the quasiquoting function has priority. You might\n", 
#&gt;                   "then observe some performance cost in edge cases. Here is one\n", 
#&gt;                   "example where this would happen:", list("purrr::rerun(10, dplyr::bind_rows(!!! x))\n"), 
#&gt;                   "\n", "\n", list("purrr::rerun()"), " is a quoting function and ", 
#&gt;                   list("dplyr::bind_rows()"), " is\n", "a standard function. Because ", 
#&gt;                   list("bind_rows()"), " is called ", list("inside"), 
#&gt;                   "\n", list("rerun()"), ", the list ", list(
#&gt;                     "x"), " will be disaggregated into a pairlist of\n", 
#&gt;                   "arguments. To avoid this you can use ", list(
#&gt;                     "splice()"), " instead:", list("purrr::rerun(10, dplyr::bind_rows(splice(x)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "dots_splice()"), " is in the questioning stage. It is part of our\n", 
#&gt;                   "experiments with dots semantics. Compared to ", 
#&gt;                   list("dots_list()"), ",\n", list("dots_splice()"), 
#&gt;                   " automatically splices lists. We now lean towards\n", 
#&gt;                   "adopting a single type of dots semantics (those of ", 
#&gt;                   list("dots_list()"), ")\n", "where splicing is explicit.\n", 
#&gt;                   list(), " ", list("splice()"), " is in the questioning stage. It is not clear whether it is\n", 
#&gt;                   "really needed as there are other ways to avoid the performance\n", 
#&gt;                   "issue discussed above.\n"), "\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), stack.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack"), "\n", list("stack"), "\n", list(
#&gt;                 "global_frame"), "\n", list("current_frame"), 
#&gt;             "\n", list("ctxt_frame"), "\n", list("call_frame"), 
#&gt;             "\n", list("ctxt_depth"), "\n", list("call_depth"), 
#&gt;             "\n", list("ctxt_stack"), "\n", list("call_stack"), 
#&gt;             "\n", list("Call stack information"), "\n", list(
#&gt;                 "\n", "global_frame()\n", "\n", "current_frame()\n", 
#&gt;                 "\n", "ctxt_frame(n = 1)\n", "\n", "call_frame(n = 1, clean = TRUE)\n", 
#&gt;                 "\n", "ctxt_depth()\n", "\n", "call_depth()\n", 
#&gt;                 "\n", "ctxt_stack(n = NULL, trim = 0)\n", "\n", 
#&gt;                 "call_stack(n = NULL, clean = TRUE)\n"), "\n", 
#&gt;             list("\n", list(list("n"), list("The number of frames to go back in the stack.")), 
#&gt;                 "\n", "\n", list(list("clean"), list("Whether to post-process the call stack to clean\n", 
#&gt;                   "non-standard frames. If ", list("TRUE"), ", suboptimal call-stack entries by\n", 
#&gt;                   list(list("base::eval()")), " will be cleaned up: the duplicate frame created by\n", 
#&gt;                   list("eval()"), " is eliminated.")), "\n", 
#&gt;                 "\n", list(list("trim"), list("The number of layers of intervening frames to trim off\n", 
#&gt;                   "the stack. See ", list(list("stack_trim()")), 
#&gt;                   " and examples.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "The ", list("eval_"), " and ", list("call_"), 
#&gt;                 " families of functions provide a replacement\n", 
#&gt;                 "for the base R functions prefixed with ", list(
#&gt;                   "sys."), " (which are all about\n", "the context stack), as well as for ", 
#&gt;                 list(list("parent.frame()")), " (which is the\n", 
#&gt;                 "only base R function for querying the call stack). The context\n", 
#&gt;                 "stack includes all R-level evaluation contexts. It is linear in\n", 
#&gt;                 "terms of execution history but due to lazy evaluation it is\n", 
#&gt;                 "potentially nonlinear in terms of call history. The call stack\n", 
#&gt;                 "history, on the other hand, is homogenous.\n"), 
#&gt;             "\n", list("\n", list("ctxt_frame()"), " and ", list(
#&gt;                 "call_frame()"), " return a ", list("frame"), 
#&gt;                 " object\n", "containing the following fields: ", 
#&gt;                 list("expr"), " and ", list("env"), " (call expression\n", 
#&gt;                 "and evaluation environment), ", list("pos"), 
#&gt;                 " and ", list("caller_pos"), " (position of\n", 
#&gt;                 "current frame in the context stack and position of the caller), and\n", 
#&gt;                 list("fun"), " (function of the current frame). ", 
#&gt;                 list("ctxt_stack()"), " and\n", list("call_stack()"), 
#&gt;                 " return a list of all context or call frames on the\n", 
#&gt;                 "stack. Finally, ", list("ctxt_depth()"), " and ", 
#&gt;                 list("call_depth()"), " report the\n", "current context position or the number of calling frames on the\n", 
#&gt;                 "stack.\n", "\n", "The base R functions take two sorts of arguments to indicate which\n", 
#&gt;                 "frame to query: ", list("which"), " and ", list(
#&gt;                   "n"), ". The ", list("n"), " argument is\n", 
#&gt;                 "straightforward: it's the number of frames to go down the stack,\n", 
#&gt;                 "with ", list("n = 1"), " referring to the current context. The ", 
#&gt;                 list("which"), " argument\n", "is more complicated and changes meaning for values lower than 1.\n", 
#&gt;                 "For the sake of consistency, the rlang functions all take the\n", 
#&gt;                 "same kind of argument ", list("n"), ". This argument has a single meaning (the\n", 
#&gt;                 "number of frames to go down the stack) and cannot be lower than 1.\n", 
#&gt;                 "\n", "Note finally that ", list("parent.frame(1)"), 
#&gt;                 " corresponds to\n", list("call_frame(2)$env"), 
#&gt;                 ", as ", list("n = 1"), " always refers to the current\n", 
#&gt;                 "frame. This makes the ", list("_frame()"), " and ", 
#&gt;                 list("_stack()"), " functions\n", "consistent: ", 
#&gt;                 list("ctxt_frame(2)"), " is the same as ", list(
#&gt;                   "ctxt_stack()[[2]]"), ".\n", "Also, ", list(
#&gt;                   "ctxt_depth()"), " returns one more frame than\n", 
#&gt;                 list(list("base::sys.nframe()")), " because it counts the global frame. That is\n", 
#&gt;                 "consistent with the ", list("_stack()"), " functions which return the global\n", 
#&gt;                 "frame as well. This way, ", list("call_stack(call_depth())"), 
#&gt;                 " is the same as\n", list("global_frame()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are soft-deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Expressions within arguments count as contexts\n", 
#&gt;                 "identity(identity(ctxt_depth())) # returns 2\n", 
#&gt;                 "\n", "# But they are not part of the call stack because arguments are\n", 
#&gt;                 "# evaluated within the calling function (or the global environment\n", 
#&gt;                 "# if called at top level)\n", "identity(identity(call_depth())) # returns 0\n", 
#&gt;                 "\n", "# The context stacks includes all intervening execution frames. The\n", 
#&gt;                 "# call stack doesn't:\n", "f &lt;- function(x) identity(x)\n", 
#&gt;                 "f(f(ctxt_stack()))\n", "f(f(call_stack()))\n", 
#&gt;                 "\n", "g &lt;- function(cmd) cmd()\n", "f(g(ctxt_stack))\n", 
#&gt;                 "f(g(call_stack))\n", "\n", "# The rlang _stack() functions return a list of frame\n", 
#&gt;                 "# objects. Use purrr::transpose() or index a field with\n", 
#&gt;                 "# purrr::map()'s to extract a particular field from a stack:\n", 
#&gt;                 "\n", "# stack &lt;- f(f(call_stack()))\n", "# purrr::map(stack, \"env\")\n", 
#&gt;                 "# purrr::transpose(stack)$expr\n", "\n", "# current_frame() is an alias for ctxt_frame(1)\n", 
#&gt;                 "fn &lt;- function() list(current = current_frame(), first = ctxt_frame(1))\n", 
#&gt;                 "fn()\n", "\n", "# While current_frame() is the top of the stack, global_frame() is\n", 
#&gt;                 "# the bottom:\n", "fn &lt;- function() {\n", "  n &lt;- ctxt_depth()\n", 
#&gt;                 "  ctxt_frame(n)\n", "}\n", "identical(fn(), global_frame())\n", 
#&gt;                 "\n", "\n", "# ctxt_stack() returns a stack with all intervening frames. You can\n", 
#&gt;                 "# trim layers of intervening frames with the trim argument:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "identity(identity(ctxt_stack(trim = 1)))\n", 
#&gt;                 "\n", "# ctxt_stack() is called within fn() with intervening frames:\n", 
#&gt;                 "fn &lt;- function(trim) identity(identity(ctxt_stack(trim = trim)))\n", 
#&gt;                 "fn(0)\n", "\n", "# We can trim the first layer of those:\n", 
#&gt;                 "fn(1)\n", "\n", "# The outside intervening frames (at the fn() call site) are still\n", 
#&gt;                 "# returned, but can be trimmed as well:\n", 
#&gt;                 "identity(identity(fn(1)))\n", "identity(identity(fn(2)))\n", 
#&gt;                 "\n", "g &lt;- function(trim) identity(identity(fn(trim)))\n", 
#&gt;                 "g(2)\n", "g(3)\n"), "\n", list("internal"), 
#&gt;             "\n"), stack_trim.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack_trim"), "\n", list("stack_trim"), 
#&gt;             "\n", list("Trim top call layers from the evaluation stack"), 
#&gt;             "\n", list("\n", "stack_trim(stack, n = 1)\n"), "\n", 
#&gt;             list("\n", list(list("stack"), list("An evaluation stack.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of call frames (not eval frames) to trim off\n", 
#&gt;                   "the top of the stack. In other words, the number of layers of\n", 
#&gt;                   "intervening frames to trim.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list(list("ctxt_stack()")), " can be tricky to use in real code because all\n", 
#&gt;                 "intervening frames are returned with the stack, including those at\n", 
#&gt;                 list("ctxt_stack()"), " own call site. ", list(
#&gt;                   "stack_trim()"), " makes it easy to\n", "remove layers of intervening calls.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Intervening frames appear on the evaluation stack:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# stack_trim() will trim the first n layers of calls:\n", 
#&gt;                 "stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "\n", "# Note that it also takes care of calls intervening at its own call\n", 
#&gt;                 "# site:\n", "identity(identity(\n", "  stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "))\n", "\n", "# It is especially useful when used within a function that needs to\n", 
#&gt;                 "# inspect the evaluation stack but should nonetheless be callable\n", 
#&gt;                 "# within nested calls without side effects:\n", 
#&gt;                 "stack_util &lt;- function() {\n", "  # n = 2 means that two layers of intervening calls should be\n", 
#&gt;                 "  # removed: The layer at ctxt_stack()'s call site (including the\n", 
#&gt;                 "  # stack_trim() call), and the layer at stack_util()'s call.\n", 
#&gt;                 "  stack &lt;- stack_trim(ctxt_stack(), n = 2)\n", 
#&gt;                 "  stack\n", "}\n", "user_fn &lt;- function() {\n", 
#&gt;                 "  # A user calls your stack utility with intervening frames:\n", 
#&gt;                 "  identity(identity(stack_util()))\n", "}\n", 
#&gt;                 "# These intervening frames won't appear in the evaluation stack\n", 
#&gt;                 "identity(user_fn())\n"), "\n", list("internal"), 
#&gt;             "\n"), string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("string"), "\n", list("string"), "\n", 
#&gt;             list("Create a string"), "\n", list("\n", "string(x, encoding = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A character vector or a vector or list of string-like\n", 
#&gt;                 "objects.")), "\n", "\n", list(list("encoding"), 
#&gt;                 list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These base-type constructors allow more control over the creation\n", 
#&gt;                 "of strings in R. They take character vectors or string-like objects\n", 
#&gt;                 "(integerish or raw vectors), and optionally set the encoding. The\n", 
#&gt;                 "string version checks that the input contains a scalar string.\n"), 
#&gt;             "\n", list("\n", "# As everywhere in R, you can specify a string with Unicode\n", 
#&gt;                 "# escapes. The characters corresponding to Unicode codepoints will\n", 
#&gt;                 "# be encoded in UTF-8, and the string will be marked as UTF-8\n", 
#&gt;                 "# automatically:\n", "cafe &lt;- string(\"caf\\uE9\")\n", 
#&gt;                 "Encoding(cafe)\n", "as_bytes(cafe)\n", "\n", 
#&gt;                 "# In addition, string() provides useful conversions to let\n", 
#&gt;                 "# programmers control how the string is represented in memory. For\n", 
#&gt;                 "# encodings other than UTF-8, you'll need to supply the bytes in\n", 
#&gt;                 "# hexadecimal form. If it is a latin1 encoding, you can mark the\n", 
#&gt;                 "# string explicitly:\n", "cafe_latin1 &lt;- string(c(0x63, 0x61, 0x66, 0xE9), \"latin1\")\n", 
#&gt;                 "Encoding(cafe_latin1)\n", "as_bytes(cafe_latin1)\n"), 
#&gt;             "\n", list("internal"), "\n"), switch_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("switch_type"), "\n", list("switch_type"), 
#&gt;             "\n", list("coerce_type"), "\n", list("switch_class"), 
#&gt;             "\n", list("coerce_class"), "\n", list("Dispatch on base types"), 
#&gt;             "\n", list("\n", "switch_type(.x, ...)\n", "\n", 
#&gt;                 "coerce_type(.x, .to, ...)\n", "\n", "switch_class(.x, ...)\n", 
#&gt;                 "\n", "coerce_class(.x, .to, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".x"), list("An object from which to dispatch.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named clauses. The names should be types as returned by\n", 
#&gt;                   list(list("type_of()")), ".")), "\n", "\n", 
#&gt;                 list(list(".to"), list("This is useful when you switchpatch within a coercing\n", 
#&gt;                   "function. If supplied, this should be a string indicating the\n", 
#&gt;                   "target type. A catch-all clause is then added to signal an error\n", 
#&gt;                   "stating the conversion failure. This type is prettified unless\n", 
#&gt;                   list(".to"), " inherits from the S3 class ", 
#&gt;                   list("\"AsIs\""), " (see ", list(list("base::I()")), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("switch_type()"), " is equivalent to\n", 
#&gt;                 list(list("switch"), "(", list("type_of"), "(x, ...))"), 
#&gt;                 ", while\n", list("switch_class()"), " switchpatches based on ", 
#&gt;                 list("class(x)"), ". The ", list("coerce_"), 
#&gt;                 "\n", "versions are intended for type conversion and provide a standard\n", 
#&gt;                 "error message when conversion fails.\n"), "\n", 
#&gt;             list("\n", "switch_type(3L,\n", "  double = \"foo\",\n", 
#&gt;                 "  integer = \"bar\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# Use the coerce_ version to get standardised error handling when no\n", 
#&gt;                 "# type matches:\n", "to_chr &lt;- function(x) {\n", 
#&gt;                 "  coerce_type(x, \"a chr\",\n", "    integer = as.character(x),\n", 
#&gt;                 "    double = as.character(x)\n", "  )\n", "}\n", 
#&gt;                 "to_chr(3L)\n", "\n", "# Strings have their own type:\n", 
#&gt;                 "switch_type(\"str\",\n", "  character = \"foo\",\n", 
#&gt;                 "  string = \"bar\",\n", "  \"default\"\n", ")\n", 
#&gt;                 "\n", "# Use a fallthrough clause if you need to dispatch on all character\n", 
#&gt;                 "# vectors, including strings:\n", "switch_type(\"str\",\n", 
#&gt;                 "  string = ,\n", "  character = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "\n", "# special and builtin functions are treated as primitive, since\n", 
#&gt;                 "# there is usually no reason to treat them differently:\n", 
#&gt;                 "switch_type(base::list,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "switch_type(base::`$`,\n", 
#&gt;                 "  primitive = \"foo\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# closures are not primitives:\n", 
#&gt;                 "switch_type(rlang::switch_type,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n"), "\n", list("internal"), 
#&gt;             "\n"), sym.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("sym"), "\n", list("sym"), "\n", list("syms"), 
#&gt;             "\n", list("Create a symbol or list of symbols"), 
#&gt;             "\n", list("\n", "sym(x)\n", "\n", "syms(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or list of strings.")), 
#&gt;                 "\n"), "\n", list("\n", "A symbol for ", list(
#&gt;                 "sym()"), " and a list of symbols for ", list(
#&gt;                 "syms()"), ".\n"), "\n", list("\n", "These functions take strings as input and turn them into symbols.\n"), 
#&gt;             "\n", list("\n", "# The empty string returns the missing argument:\n", 
#&gt;                 "sym(\"\")\n", "\n", "# This way sym() and as_string() are inverse of each other:\n", 
#&gt;                 "as_string(missing_arg())\n", "sym(as_string(missing_arg()))\n"), 
#&gt;             "\n"), `tidy-dots.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R, R/vec-new.R", 
#&gt;             "\n", list("tidy-dots"), "\n", list("tidy-dots"), 
#&gt;             "\n", list("dots_list"), "\n", list("list2"), "\n", 
#&gt;             list("Collect dots as lists"), "\n", list("\n", "dots_list(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "list2(...)\n"), "\n", list("\n", list(list("..."), 
#&gt;                 list("Arguments to collect with ", list("!!!"), 
#&gt;                   " support.")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                 list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "A list of arguments. This list is always named: unnamed\n", 
#&gt;                 "arguments are named with the empty string ", 
#&gt;                 list("\"\""), ".\n"), "\n", list("\n", list("list2()"), 
#&gt;                 " is equivalent to ", list("list(...)"), " with a few additional\n", 
#&gt;                 "features:\n", list("\n", list(), " You can splice other lists with the\n", 
#&gt;                   list("unquote-splice"), " ", list("!!!"), " operator.\n", 
#&gt;                   list(), " You can unquote names by using the ", 
#&gt;                   list("unquote"), "\n", "operator ", list("!!"), 
#&gt;                   " on the left-hand side of ", list(":="), ".\n", 
#&gt;                   list(), " Trailing commas are ignored, making it easier to copy and paste\n", 
#&gt;                   "arguments.\n"), "\n", "\n", "For lack of a better name, these features are collectively called\n", 
#&gt;                 "\"tidy dots\".\n", "\n", list("dots_list()"), 
#&gt;                 " is a lower-level version of ", list("list2()"), 
#&gt;                 " that offers\n", "additional parameters for dots capture.\n"), 
#&gt;             "\n", list("\n", "# Let's create a function that takes a variable number of arguments:\n", 
#&gt;                 "numeric &lt;- function(...) {\n", "  dots &lt;- list2(...)\n", 
#&gt;                 "  num &lt;- as.numeric(dots)\n", "  set_names(num, names(dots))\n", 
#&gt;                 "}\n", "numeric(1, 2, 3)\n", "\n", "# The main difference with list(...) is that list2(...) enables\n", 
#&gt;                 "# the `!!!` syntax to splice lists:\n", "x &lt;- list(2, 3)\n", 
#&gt;                 "numeric(1, !!! x, 4)\n", "\n", "# As well as unquoting of names:\n", 
#&gt;                 "nm &lt;- \"yup!\"\n", "numeric(!!nm := 1)\n", "\n", 
#&gt;                 "\n", "# One useful application of splicing is to work around exact and\n", 
#&gt;                 "# partial matching of arguments. Let's create a function taking\n", 
#&gt;                 "# named arguments and dots:\n", "fn &lt;- function(data, ...) {\n", 
#&gt;                 "  list2(...)\n", "}\n", "\n", "# You normally cannot pass an argument named `data` through the dots\n", 
#&gt;                 "# as it will match `fn`'s `data` argument. The splicing syntax\n", 
#&gt;                 "# provides a workaround:\n", "fn(\"wrong!\", data = letters)  # exact matching of `data`\n", 
#&gt;                 "fn(\"wrong!\", dat = letters)   # partial matching of `data`\n", 
#&gt;                 "fn(some_data, !!!list(data = letters))  # no matching\n", 
#&gt;                 "\n", "\n", "# Empty arguments trigger an error by default:\n", 
#&gt;                 "try(fn(, ))\n", "\n", "# You can choose to preserve empty arguments instead:\n", 
#&gt;                 "list3 &lt;- function(...) dots_list(..., .preserve_empty = TRUE)\n", 
#&gt;                 "\n", "# Note how the last empty argument is still ignored because\n", 
#&gt;                 "# `.ignore_empty` defaults to \"trailing\":\n", 
#&gt;                 "list3(, )\n", "\n", "# The list with preserved empty arguments is equivalent to:\n", 
#&gt;                 "list(missing_arg())\n", "\n", "\n", "# Arguments with duplicated names are kept by default:\n", 
#&gt;                 "list2(a = 1, a = 2, b = 3, b = 4, 5, 6)\n", 
#&gt;                 "\n", "# Use the `.homonyms` argument to keep only the first of these:\n", 
#&gt;                 "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"first\")\n", 
#&gt;                 "\n", "# Or the last:\n", "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"last\")\n", 
#&gt;                 "\n", "# Or raise an informative error:\n", "try(dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"error\"))\n", 
#&gt;                 "\n", "\n", "# dots_list() can be configured to warn when a `&lt;-` call is\n", 
#&gt;                 "# detected:\n", "my_list &lt;- function(...) dots_list(..., .check_assign = TRUE)\n", 
#&gt;                 "my_list(a &lt;- 1)\n", "\n", "# There is no warning if the assignment is wrapped in braces.\n", 
#&gt;                 "# This requires users to be explicit about their intent:\n", 
#&gt;                 "my_list({ a &lt;- 1 })\n"), "\n", list("\n", list(
#&gt;                 list("exprs()")), " for extracting dots without evaluation.\n"), 
#&gt;             "\n"), `tidyeval-data.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("data"), "\n", list("tidyeval-data"), 
#&gt;             "\n", list("tidyeval-data"), "\n", list(".data"), 
#&gt;             "\n", list("Data pronoun for tidy evaluation"), "\n", 
#&gt;             list("\n", ".data\n"), "\n", list("\n", "This pronoun allows you to be explicit when you refer to an object\n", 
#&gt;                 "inside the data. Referring to the ", list(".data"), 
#&gt;                 " pronoun rather than to\n", "the original data frame has several advantages:\n", 
#&gt;                 list("\n", list(), " It makes it easy to refer to column names stored as strings. If\n", 
#&gt;                   list("var"), " contains the column ", list(
#&gt;                     "\"height\""), ", the pronoun will subset that\n", 
#&gt;                   "column:", list("var &lt;- \"height\"\n", "dplyr::summarise(df, mean(.data[[var]]))\n"), 
#&gt;                   "\n", "\n", "The index variable ", list("var"), 
#&gt;                   " is ", list("unquoted"), ", which\n", "ensures a column named ", 
#&gt;                   list("var"), " in the data frame cannot mask it.\n", 
#&gt;                   "This makes the pronoun safe to use in functions and packages.\n", 
#&gt;                   list(), " Sometimes a computation is not about the whole data but about a\n", 
#&gt;                   "subset. For example if you supply a grouped data frame to a dplyr\n", 
#&gt;                   "verb, the ", list(".data"), " pronoun contains the group subset.\n", 
#&gt;                   list(), " It lets dplyr know that you're referring to a column from the\n", 
#&gt;                   "data which is helpful to generate correct queries when the source\n", 
#&gt;                   "is a database.\n"), "\n", "\n", "The ", list(
#&gt;                   ".data"), " object exported here is useful to import in your\n", 
#&gt;                 "package namespace to avoid a ", list("R CMD check"), 
#&gt;                 " note when referring to\n", "objects from the data mask.\n"), 
#&gt;             "\n", list("datasets"), "\n"), trace_back.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/trace.R", "\n", 
#&gt;             list("trace_back"), "\n", list("trace_back"), "\n", 
#&gt;             list("trace_length"), "\n", list("Capture a backtrace"), 
#&gt;             "\n", list("\n", "trace_back(top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "trace_length(trace)\n"), "\n", list("\n", 
#&gt;                 list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n", "\n", 
#&gt;                 list(list("trace"), list("A backtrace created by ", 
#&gt;                   list("trace_back()"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "A backtrace captures the sequence of calls that lead to the current\n", 
#&gt;                 "function, sometimes called the call stack. Because of lazy\n", 
#&gt;                 "evaluation, the call stack in R is actually a tree, which the\n", 
#&gt;                 list("summary()"), " method of this object will reveal.\n"), 
#&gt;             "\n", list("\n", list("trace_length()"), " returns the number of frames in a backtrace.\n"), 
#&gt;             "\n", list("\n", "# Trim backtraces automatically (this improves the generated\n", 
#&gt;                 "# documentation for the rlang website and the same trick can be\n", 
#&gt;                 "# useful within knitr documents):\n", "options(rlang_trace_top_env = current_env())\n", 
#&gt;                 "\n", "f &lt;- function() g()\n", "g &lt;- function() h()\n", 
#&gt;                 "h &lt;- function() trace_back()\n", "\n", "# When no lazy evaluation is involved the backtrace is linear\n", 
#&gt;                 "# (i.e. every call has only one child)\n", "f()\n", 
#&gt;                 "\n", "# Lazy evaluation introduces a tree like structure\n", 
#&gt;                 "identity(identity(f()))\n", "identity(try(f()))\n", 
#&gt;                 "try(identity(f()))\n", "\n", "# When printing, you can request to simplify this tree to only show\n", 
#&gt;                 "# the direct sequence of calls that lead to `trace_back()`\n", 
#&gt;                 "x &lt;- try(identity(f()))\n", "x\n", "print(x, simplify = \"branch\")\n", 
#&gt;                 "\n", "# With a little cunning you can also use it to capture the\n", 
#&gt;                 "# tree from within a base NSE function\n", "x &lt;- NULL\n", 
#&gt;                 "with(mtcars, {x &lt;&lt;- f(); 10})\n", "x\n", "\n", 
#&gt;                 "\n", "# Restore default top env for next example\n", 
#&gt;                 "options(rlang_trace_top_env = NULL)\n", "\n", 
#&gt;                 "# When code is executed indirectly, i.e. via source or within an\n", 
#&gt;                 "# RMarkdown document, you'll tend to get a lot of guff at the beginning\n", 
#&gt;                 "# related to the execution environment:\n", 
#&gt;                 "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n", "\n", "# To automatically strip this off, specify which frame should be\n", 
#&gt;                 "# the top of the backtrace. This will automatically trim off calls\n", 
#&gt;                 "# prior to that frame:\n", "top &lt;- current_env()\n", 
#&gt;                 "h &lt;- function() trace_back(top)\n", "\n", "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n"), "\n"), `type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("type-predicates"), "\n", list("type-predicates"), 
#&gt;             "\n", list("is_list"), "\n", list("is_atomic"), "\n", 
#&gt;             list("is_vector"), "\n", list("is_integer"), "\n", 
#&gt;             list("is_double"), "\n", list("is_character"), "\n", 
#&gt;             list("is_logical"), "\n", list("is_raw"), "\n", list(
#&gt;                 "is_bytes"), "\n", list("is_null"), "\n", list(
#&gt;                 "Type predicates"), "\n", list("\n", "is_list(x, n = NULL)\n", 
#&gt;                 "\n", "is_atomic(x, n = NULL)\n", "\n", "is_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_integer(x, n = NULL)\n", "\n", "is_double(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_logical(x, n = NULL)\n", "\n", "is_raw(x, n = NULL)\n", 
#&gt;                 "\n", "is_bytes(x, n = NULL)\n", "\n", "is_null(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These type predicates aim to make type testing in R more\n", 
#&gt;                 "consistent. They are wrappers around ", list(
#&gt;                   list("base::typeof()")), ", so operate\n", 
#&gt;                 "at a level beneath S3/S4 etc.\n"), "\n", list(
#&gt;                 "\n", "Compared to base R functions:\n", list(
#&gt;                   "\n", list(), " The predicates for vectors include the ", 
#&gt;                   list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                   list(), " Unlike ", list("is.atomic()"), ", ", 
#&gt;                   list("is_atomic()"), " does not return ", list(
#&gt;                     "TRUE"), " for\n", list("NULL"), ".\n", list(), 
#&gt;                   " Unlike ", list("is.vector()"), ", ", list(
#&gt;                     "is_vector()"), " tests if an object is an\n", 
#&gt;                   "atomic vector or a list. ", list("is.vector"), 
#&gt;                   " checks for the presence of\n", "attributes (other than name).\n"), 
#&gt;                 "\n"), "\n", list("\n", list("bare-type-predicates"), 
#&gt;                 " ", list("scalar-type-predicates"), "\n"), "\n"), 
#&gt;         type_of.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("type_of"), "\n", list("type_of"), "\n", 
#&gt;             list("Base type of an object"), "\n", list("\n", 
#&gt;                 "type_of(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An R object.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "base::typeof()")), " with a few differences that\n", 
#&gt;                 "make dispatching easier:\n", list("\n", list(), 
#&gt;                   " The type of one-sided formulas is \"quote\".\n", 
#&gt;                   list(), " The type of character vectors of length 1 is \"string\".\n", 
#&gt;                   list(), " The type of special and builtin functions is \"primitive\".\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", list("type_of()"), " is an experimental function. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "type_of(10L)\n", "\n", "# Quosures are treated as a new base type but not formulas:\n", 
#&gt;                 "type_of(quo(10L))\n", "type_of(~10L)\n", "\n", 
#&gt;                 "# Compare to base::typeof():\n", "typeof(quo(10L))\n", 
#&gt;                 "\n", "# Strings are treated as a new base type:\n", 
#&gt;                 "type_of(letters)\n", "type_of(letters[[1]])\n", 
#&gt;                 "\n", "# This is a bit inconsistent with the core language tenet that data\n", 
#&gt;                 "# types are vectors. However, treating strings as a different\n", 
#&gt;                 "# scalar type is quite helpful for switching on function inputs\n", 
#&gt;                 "# since so many arguments expect strings:\n", 
#&gt;                 "switch_type(\"foo\", character = abort(\"vector!\"), string = \"result\")\n", 
#&gt;                 "\n", "# Special and builtin primitives are both treated as primitives.\n", 
#&gt;                 "# That's because it is often irrelevant which type of primitive an\n", 
#&gt;                 "# input is:\n", "typeof(list)\n", "typeof(`$`)\n", 
#&gt;                 "type_of(list)\n", "type_of(`$`)\n"), "\n", list(
#&gt;                 "internal"), "\n"), vec_poke_n.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("vec_poke_n"), "\n", list("vec_poke_n"), "\n", 
#&gt;             list("vec_poke_range"), "\n", list("Poke values into a vector"), 
#&gt;             "\n", list("\n", "vec_poke_n(x, start, y, from = 1L, n = length(y))\n", 
#&gt;                 "\n", "vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("The destination vector.")), 
#&gt;                 "\n", "\n", list(list("start"), list("The index indicating where to start modifying ", 
#&gt;                   list("x"), ".")), "\n", "\n", list(list("y"), 
#&gt;                   list("The source vector.")), "\n", "\n", list(
#&gt;                   list("from"), list("The index indicating where to start copying from ", 
#&gt;                     list("y"), ".")), "\n", "\n", list(list("n"), 
#&gt;                   list("How many elements should be copied from ", 
#&gt;                     list("y"), " to ", list("x"), ".")), "\n", 
#&gt;                 "\n", list(list("to"), list("The index indicating the end of the range to copy from ", 
#&gt;                   list("y"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n", 
#&gt;                 "\n", "These tools are for R experts only. They copy elements from ", 
#&gt;                 list("y"), "\n", "into ", list("x"), " by mutation. You should only do this if you own ", 
#&gt;                 list("x"), ",\n", "i.e. if you have created it or if you are certain that it doesn't\n", 
#&gt;                 "exist in any other context. Otherwise you might create unintended\n", 
#&gt;                 "side effects that have undefined consequences.\n"), 
#&gt;             "\n", list("internal"), "\n"), `vector-coercion.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("vector-coercion"), "\n", list("vector-coercion"), 
#&gt;             "\n", list("as_logical"), "\n", list("as_integer"), 
#&gt;             "\n", list("as_double"), "\n", list("as_complex"), 
#&gt;             "\n", list("as_character"), "\n", list("as_list"), 
#&gt;             "\n", list("Coerce an object to a base type"), "\n", 
#&gt;             list("\n", "as_logical(x)\n", "\n", "as_integer(x)\n", 
#&gt;                 "\n", "as_double(x)\n", "\n", "as_complex(x)\n", 
#&gt;                 "\n", "as_character(x, encoding = NULL)\n", "\n", 
#&gt;                 "as_list(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to coerce to a base type.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "These are equivalent to the base functions (e.g. ", 
#&gt;                 list(list("as.logical()")), ",\n", list(list(
#&gt;                   "as.list()")), ", etc), but perform coercion rather than conversion.\n", 
#&gt;                 "This means they are not generic and will not call S3 conversion\n", 
#&gt;                 "methods. They only attempt to coerce the base type of their\n", 
#&gt;                 "input. In addition, they have stricter implicit coercion rules and\n", 
#&gt;                 "will never attempt any kind of parsing. E.g. they will not try to\n", 
#&gt;                 "figure out if a character vector represents integers or booleans.\n", 
#&gt;                 "Finally, they treat attributes consistently, unlike the base R\n", 
#&gt;                 "functions: all attributes except names are removed.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated in favour of ", 
#&gt;                 list("vctrs::vec_cast()"), ".\n")), "\n", "\n", 
#&gt;             list(list("Coercion to logical and numeric atomic vectors"), 
#&gt;                 list("\n", "\n", list("\n", list(), " To logical vectors: Integer and integerish double vectors. See\n", 
#&gt;                   list(list("is_integerish()")), ".\n", list(), 
#&gt;                   " To integer vectors: Logical and integerish double vectors.\n", 
#&gt;                   list(), " To double vectors: Logical and integer vectors.\n", 
#&gt;                   list(), " To complex vectors: Logical, integer and double vectors.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Coercion to character vectors"), 
#&gt;                 list("\n", "\n", "\n", list("as_character()"), 
#&gt;                   " and ", list("as_string()"), " have an optional ", 
#&gt;                   list("encoding"), "\n", "argument to specify the encoding. R uses this information for\n", 
#&gt;                   "internal handling of strings and character vectors. Note that this\n", 
#&gt;                   "is only declarative, no encoding conversion is attempted.\n", 
#&gt;                   "\n", "Note that only ", list("as_string()"), 
#&gt;                   " can coerce symbols to a scalar\n", "character vector. This makes the code more explicit and adds an\n", 
#&gt;                   "extra type check.\n")), "\n", "\n", list(list(
#&gt;                 "Coercion to lists"), list("\n", "\n", "\n", 
#&gt;                 list("as_list()"), " only coerces vector and dictionary types (environments\n", 
#&gt;                 "are an example of dictionary type). Unlike ", 
#&gt;                 list(list("base::as.list()")), ",\n", list("as_list()"), 
#&gt;                 " removes all attributes except names.\n")), 
#&gt;             "\n", "\n", list(list("Effects of removing attributes"), 
#&gt;                 list("\n", "\n", "\n", "A technical side-effect of removing the attributes of the input is\n", 
#&gt;                   "that the underlying objects has to be copied. This has no\n", 
#&gt;                   "performance implications in the case of lists because this is a\n", 
#&gt;                   "shallow copy: only the list structure is copied, not the contents\n", 
#&gt;                   "(see ", list(list("duplicate()")), "). However, be aware that atomic vectors\n", 
#&gt;                   "containing large amounts of data will have to be copied.\n", 
#&gt;                   "\n", "In general, any attribute modification creates a copy, which is why\n", 
#&gt;                   "it is better to avoid using attributes with heavy atomic vectors.\n", 
#&gt;                   "Uncopyable objects like environments and symbols are an exception\n", 
#&gt;                   "to this rule: in this case, attributes modification happens in\n", 
#&gt;                   "place and has side-effects.\n")), "\n", "\n", 
#&gt;             list("\n", "# Coercing atomic vectors removes attributes with both base R and rlang:\n", 
#&gt;                 "x &lt;- structure(TRUE, class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.logical(x)\n", "\n", "# But coercing lists preserves attributes in base R but not rlang:\n", 
#&gt;                 "l &lt;- structure(list(TRUE), class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# Implicit conversions are performed in base R but not rlang:\n", 
#&gt;                 "as.logical(l)\n", list("\n", "as_logical(l)\n"), 
#&gt;                 "\n", "\n", "# Conversion methods are bypassed, making the result of the\n", 
#&gt;                 "# coercion more predictable:\n", "as.list.foo &lt;- function(x) \"wrong\"\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# The input is never parsed. E.g. character vectors of numbers are\n", 
#&gt;                 "# not converted to numeric types:\n", "as.integer(\"33\")\n", 
#&gt;                 list("\n", "as_integer(\"33\")\n"), "\n", "\n", 
#&gt;                 "\n", "# With base R tools there is no way to convert an environment to a\n", 
#&gt;                 "# list without either triggering method dispatch, or changing the\n", 
#&gt;                 "# original environment. as_list() makes it easy:\n", 
#&gt;                 "x &lt;- structure(as_environment(mtcars[1:2]), class = \"foobar\")\n", 
#&gt;                 "as.list.foobar &lt;- function(x) abort(\"dont call me\")\n", 
#&gt;                 "as_list(x)\n"), "\n", list("internal"), "\n"), 
#&gt;         `vector-construction.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("vector-construction"), "\n", list("vector-construction"), 
#&gt;             "\n", list("lgl"), "\n", list("int"), "\n", list(
#&gt;                 "dbl"), "\n", list("cpl"), "\n", list("chr"), 
#&gt;             "\n", list("bytes"), "\n", list("ll"), "\n", list(
#&gt;                 "Create vectors"), "\n", list("\n", "lgl(...)\n", 
#&gt;                 "\n", "int(...)\n", "\n", "dbl(...)\n", "\n", 
#&gt;                 "cpl(...)\n", "\n", "chr(...)\n", "\n", "bytes(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Components of the new vector. Bare lists and explicitly\n", 
#&gt;                 "spliced lists are spliced.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "The atomic vector constructors are equivalent to ", 
#&gt;                 list(list("c()")), " but:\n", list("\n", list(), 
#&gt;                   " They allow you to be more explicit about the output\n", 
#&gt;                   "type. Implicit coercions (e.g. from integer to logical) follow\n", 
#&gt;                   "the rules described in ", list("vector-coercion"), 
#&gt;                   ".\n", list(), " They use ", list("tidy dots"), 
#&gt;                   " and thus support splicing with ", list("!!!"), 
#&gt;                   ".\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " All the abbreviated constructors such as ", 
#&gt;                   list("lgl()"), " will probably be\n", "moved to the vctrs package at some point. This is why they are\n", 
#&gt;                   "marked as questioning.\n", list(), " Automatic splicing is soft-deprecated and will trigger a warning\n", 
#&gt;                   "in a future version. Please splice explicitly with ", 
#&gt;                   list("!!!"), ".\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# These constructors are like a typed version of c():\n", 
#&gt;                 "c(TRUE, FALSE)\n", "lgl(TRUE, FALSE)\n", "\n", 
#&gt;                 "# They follow a restricted set of coercion rules:\n", 
#&gt;                 "int(TRUE, FALSE, 20)\n", "\n", "# Lists can be spliced:\n", 
#&gt;                 "dbl(10, !!! list(1, 2L), TRUE)\n", "\n", "\n", 
#&gt;                 "# They splice names a bit differently than c(). The latter\n", 
#&gt;                 "# automatically composes inner and outer names:\n", 
#&gt;                 "c(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "\n", "# On the other hand, rlang's ctors use the inner names and issue a\n", 
#&gt;                 "# warning to inform the user that the outer names are ignored:\n", 
#&gt;                 "dbl(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "dbl(a = c(1, 2))\n", "\n", "# As an exception, it is allowed to provide an outer name when the\n", 
#&gt;                 "# inner vector is an unnamed scalar atomic:\n", 
#&gt;                 "dbl(a = 1)\n", "\n", "# Spliced lists behave the same way:\n", 
#&gt;                 "dbl(!!! list(a = 1))\n", "dbl(!!! list(a = c(A = 1)))\n", 
#&gt;                 "\n", "# bytes() accepts integerish inputs\n", 
#&gt;                 "bytes(1:10)\n", "bytes(0x01, 0xff, c(0x03, 0x05), list(10, 20, 30L))\n"), 
#&gt;             "\n"), `vector-old-ctors.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("node"), "\n", list("node"), "\n", list(
#&gt;                 "vector-old-ctors"), "\n", list("lgl_len"), "\n", 
#&gt;             list("int_len"), "\n", list("dbl_len"), "\n", list(
#&gt;                 "chr_len"), "\n", list("cpl_len"), "\n", list(
#&gt;                 "raw_len"), "\n", list("bytes_len"), "\n", list(
#&gt;                 "list_len"), "\n", list("lgl_along"), "\n", list(
#&gt;                 "int_along"), "\n", list("dbl_along"), "\n", 
#&gt;             list("chr_along"), "\n", list("cpl_along"), "\n", 
#&gt;             list("raw_along"), "\n", list("bytes_along"), "\n", 
#&gt;             list("list_along"), "\n", list("Retired vector construction by length"), 
#&gt;             "\n", list("\n", "node(car, cdr = NULL)\n", "\n", 
#&gt;                 "lgl_len(.n)\n", "\n", "int_len(.n)\n", "\n", 
#&gt;                 "dbl_len(.n)\n", "\n", "chr_len(.n)\n", "\n", 
#&gt;                 "cpl_len(.n)\n", "\n", "raw_len(.n)\n", "\n", 
#&gt;                 "bytes_len(.n)\n", "\n", "list_len(.n)\n", "\n", 
#&gt;                 "lgl_along(.x)\n", "\n", "int_along(.x)\n", "\n", 
#&gt;                 "dbl_along(.x)\n", "\n", "chr_along(.x)\n", "\n", 
#&gt;                 "cpl_along(.x)\n", "\n", "raw_along(.x)\n", "\n", 
#&gt;                 "bytes_along(.x)\n", "\n", "list_along(.x)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("new_"), " prefix in\n", "rlang 0.2.0. This is for consistency with other non-variadic object\n", 
#&gt;                 "constructors.\n"), "\n", list("internal"), "\n"), 
#&gt;         with_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("with_abort"), "\n", list("with_abort"), 
#&gt;             "\n", list("Promote all errors to rlang errors"), 
#&gt;             "\n", list("\n", "with_abort(expr, classes = \"error\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression run in a context where errors are\n", 
#&gt;                 "promoted to rlang errors.")), "\n", "\n", list(
#&gt;                 list("classes"), list("Character vector of condition classes that should be\n", 
#&gt;                   "promoted to rlang errors.")), "\n"), "\n", 
#&gt;             list("\n", list("with_abort()"), " promotes conditions as if they were thrown with\n", 
#&gt;                 list(list("abort()")), ". These errors embed a ", 
#&gt;                 list("backtrace"), ". They are\n", "particularly suitable to be set as ", 
#&gt;                 list("parent errors"), " (see ", list("parent"), 
#&gt;                 "\n", "argument of ", list(list("abort()")), 
#&gt;                 ").\n"), "\n", list("\n", list("with_abort()"), 
#&gt;                 " installs a ", list("calling handler"), " for errors and\n", 
#&gt;                 "rethrows non-rlang errors with ", list(list(
#&gt;                   "abort()")), ". However, error handlers\n", 
#&gt;                 "installed ", list("within"), " ", list("with_abort()"), 
#&gt;                 " have priority. For this reason,\n", "you should use ", 
#&gt;                 list(list("tryCatch()")), " and ", list("exiting"), 
#&gt;                 " handlers outside\n", list("with_abort()"), 
#&gt;                 " rather than inside.\n"), "\n", list("\n", "# with_abort() automatically casts simple errors thrown by stop()\n", 
#&gt;                 "# to rlang errors. It is is handy for rethrowing low level\n", 
#&gt;                 "# errors. The backtraces are then segmented between the low level\n", 
#&gt;                 "# and high level contexts.\n", "f &lt;- function() g()\n", 
#&gt;                 "g &lt;- function() stop(\"Low level error\")\n", 
#&gt;                 "\n", "high_level &lt;- function() {\n", "  with_handlers(\n", 
#&gt;                 "    with_abort(f()),\n", "    error = ~ abort(\"High level error\", parent = .)\n", 
#&gt;                 "  )\n", "}\n"), "\n"), with_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("with_env"), "\n", list("with_env"), "\n", 
#&gt;             list("locally"), "\n", list("Evaluate an expression within a given environment"), 
#&gt;             "\n", list("\n", "with_env(env, expr)\n", "\n", "locally(expr)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment within which to evaluate ", 
#&gt;                 list("expr"), ". Can be\n", "an object with a ", 
#&gt;                 list(list("get_env()")), " method.")), "\n", 
#&gt;                 "\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions evaluate ", 
#&gt;                 list("expr"), " within a given environment (", 
#&gt;                 list("env"), "\n", "for ", list("with_env()"), 
#&gt;                 ", or the child of the current environment for\n", 
#&gt;                 list("locally"), "). They rely on ", list(list(
#&gt;                   "eval_bare()")), " which features a lighter\n", 
#&gt;                 "evaluation mechanism than base R ", list(list(
#&gt;                   "base::eval()")), ", and which also has\n", 
#&gt;                 "some subtle implications when evaluting stack sensitive functions\n", 
#&gt;                 "(see help for ", list(list("eval_bare()")), 
#&gt;                 ").\n"), "\n", list("\n", list("locally()"), 
#&gt;                 " is equivalent to the base function\n", list(
#&gt;                   list("base::local()")), " but it produces a much cleaner\n", 
#&gt;                 "evaluation stack, and has stack-consistent semantics. It is thus\n", 
#&gt;                 "more suited for experimenting with the R language.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "# with_env() is handy to create formulas with a given environment:\n", 
#&gt;                 "env &lt;- child_env(\"rlang\")\n", "f &lt;- with_env(env, ~new_formula())\n", 
#&gt;                 "identical(f_env(f), env)\n", "\n", "# Or functions with a given enclosure:\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(get_env(fn), env)\n", 
#&gt;                 "\n", "\n", "# Unlike eval() it doesn't create duplicates on the evaluation\n", 
#&gt;                 "# stack. You can thus use it e.g. to create non-local returns:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g(current_env())\n", 
#&gt;                 "  \"normal return\"\n", "}\n", "g &lt;- function(env) {\n", 
#&gt;                 "  with_env(env, return(\"early return\"))\n", 
#&gt;                 "}\n", "fn()\n", "\n", "\n", "# Since env is passed to as_environment(), it can be any object with an\n", 
#&gt;                 "# as_environment() method. For strings, the pkg_env() is returned:\n", 
#&gt;                 "with_env(\"base\", ~mtcars)\n", "\n", "# This can be handy to put dictionaries in scope:\n", 
#&gt;                 "with_env(mtcars, cyl)\n"), "\n", list("internal"), 
#&gt;             "\n"), with_handlers.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("with_handlers"), "\n", list("with_handlers"), 
#&gt;             "\n", list("calling"), "\n", list("Establish handlers on the stack"), 
#&gt;             "\n", list("\n", "with_handlers(.expr, ...)\n", "\n", 
#&gt;                 "calling(handler)\n"), "\n", list("\n", list(
#&gt;                 list(".expr"), list("An expression to execute in a context where new\n", 
#&gt;                   "handlers are established. The underscored version takes a quoted\n", 
#&gt;                   "expression or a quoted formula.")), "\n", 
#&gt;                 "\n", list(list("..."), list("Named handlers. These should be functions of one\n", 
#&gt;                   "argument. These handlers are treated as exiting by default. Use\n", 
#&gt;                   list(list("calling()")), " to specify a calling handler. These dots support\n", 
#&gt;                   list("tidy dots"), " features and are passed to ", 
#&gt;                   list(list("as_function()")), "\n", "to enable the formula shortcut for lambda functions.")), 
#&gt;                 "\n", "\n", list(list("handler"), list("A handler function that takes a condition as\n", 
#&gt;                   "argument. This is passed to ", list(list("as_function()")), 
#&gt;                   " and can thus be a\n", "formula describing a lambda function.")), 
#&gt;                 "\n"), "\n", list("\n", "Condition handlers are functions established on the evaluation\n", 
#&gt;                 "stack (see ", list(list("ctxt_stack()")), ") that are called by R when a condition is\n", 
#&gt;                 "signalled (see ", list(list("cnd_signal()")), 
#&gt;                 " and ", list(list("abort()")), " for two common signal\n", 
#&gt;                 "functions). They come in two types:\n", list(
#&gt;                   "\n", list(), " Exiting handlers aborts all code currently run between\n", 
#&gt;                   list("with_handlers()"), " and the point where the condition has been\n", 
#&gt;                   "raised. ", list("with_handlers()"), " passes the return value of the handler\n", 
#&gt;                   "to its caller.\n", list(), " Calling handlers, which are executed from inside the signalling\n", 
#&gt;                   "functions. Their return values are ignored, only their side\n", 
#&gt;                   "effects matters. Valid side effects are writing a log message, or\n", 
#&gt;                   "jumping out of the signalling context by ", 
#&gt;                   list("invoking a restart"), " or using ", list(
#&gt;                     list("return_from()")), ". If the raised\n", 
#&gt;                   "condition was an error, this interrupts the aborting process.\n", 
#&gt;                   "\n", "If a calling handler returns normally, it effectively declines to\n", 
#&gt;                   "handle the condition and other handlers on the stack (calling or\n", 
#&gt;                   "exiting) are given a chance to handle the condition.\n"), 
#&gt;                 "\n", "\n", "Handlers are exiting by default, use ", 
#&gt;                 list(list("calling()")), " to create a\n", "calling handler.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", " ", list(
#&gt;                 "exiting()"), " is soft-deprecated as of rlang\n", 
#&gt;                 "0.4.0 because ", list(list("with_handlers()")), 
#&gt;                 " now treats handlers as exiting by\n", "default.\n")), 
#&gt;             "\n", "\n", list("\n", "# Signal a condition with signal():\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"called?\\n\")\n", 
#&gt;                 "  \"fn() return value\"\n", "}\n", "g &lt;- function() {\n", 
#&gt;                 "  h()\n", "  cat(\"called?\\n\")\n", "}\n", 
#&gt;                 "h &lt;- function() {\n", "  signal(\"A foobar condition occurred\", \"foo\")\n", 
#&gt;                 "  cat(\"called?\\n\")\n", "}\n", "\n", "# Exiting handlers jump to with_handlers() before being\n", 
#&gt;                 "# executed. Their return value is handed over:\n", 
#&gt;                 "handler &lt;- function(c) \"handler return value\"\n", 
#&gt;                 "with_handlers(fn(), foo = handler)\n", "\n", 
#&gt;                 "# Calling handlers are called in turn and their return value is\n", 
#&gt;                 "# ignored. Returning just means they are declining to take charge of\n", 
#&gt;                 "# the condition. However, they can produce side-effects such as\n", 
#&gt;                 "# displaying a message:\n", "some_handler &lt;- function(c) cat(\"some handler!\\n\")\n", 
#&gt;                 "other_handler &lt;- function(c) cat(\"other handler!\\n\")\n", 
#&gt;                 "with_handlers(fn(), foo = calling(some_handler), foo = calling(other_handler))\n", 
#&gt;                 "\n", "# If a calling handler jumps to an earlier context, it takes\n", 
#&gt;                 "# charge of the condition and no other handler gets a chance to\n", 
#&gt;                 "# deal with it. The canonical way of transferring control is by\n", 
#&gt;                 "# jumping to a restart. See with_restarts() and restarting()\n", 
#&gt;                 "# documentation for more on this:\n", "exiting_handler &lt;- function(c) rst_jump(\"rst_foo\")\n", 
#&gt;                 "fn2 &lt;- function() {\n", "  with_restarts(g(), rst_foo = function() \"restart value\")\n", 
#&gt;                 "}\n", "with_handlers(fn2(), foo = calling(exiting_handler), foo = calling(other_handler))\n"), 
#&gt;             "\n"), with_restarts.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("with_restarts"), "\n", list("with_restarts"), 
#&gt;             "\n", list("Establish a restart point on the stack"), 
#&gt;             "\n", list("\n", "with_restarts(.expr, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".expr"), list("An expression to execute with new restarts established\n", 
#&gt;                 "on the stack. This argument is passed by expression and supports\n", 
#&gt;                 list("unquoting"), ". It is evaluated in a context where\n", 
#&gt;                 "restarts are established.")), "\n", "\n", list(
#&gt;                 list("..."), list("Named restart functions. The name is taken as the\n", 
#&gt;                   "restart name and the function is executed after the jump. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restart points are named functions that are established with\n", 
#&gt;                 list("with_restarts()"), ". Once established, you can interrupt the normal\n", 
#&gt;                 "execution of R code, jump to the restart, and resume execution from\n", 
#&gt;                 "there. Each restart is established along with a restart function\n", 
#&gt;                 "that is executed after the jump and that provides a return value\n", 
#&gt;                 "from the establishing point (i.e., a return value for\n", 
#&gt;                 list("with_restarts()"), ").\n"), "\n", list(
#&gt;                 "\n", "Restarts are not the only way of jumping to a previous call frame\n", 
#&gt;                 "(see ", list(list("return_from()")), " or ", 
#&gt;                 list(list("return_to()")), "). However, they have the\n", 
#&gt;                 "advantage of being callable by name once established.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Restarts are not the only way to jump to a previous frame, but\n", 
#&gt;                 "# they have the advantage of being callable by name:\n", 
#&gt;                 "fn &lt;- function() with_restarts(g(), my_restart = function() \"returned\")\n", 
#&gt;                 "g &lt;- function() h()\n", "h &lt;- function() { rst_jump(\"my_restart\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "# Whereas a non-local return requires to manually pass the calling\n", 
#&gt;                 "# frame to the return function:\n", "fn &lt;- function() g(current_env())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) { return_from(env, \"returned\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "\n", "# rst_maybe_jump() checks that a restart exists before trying to jump:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"will this be called?\\n\")\n", 
#&gt;                 "}\n", "g &lt;- function() {\n", "  rst_maybe_jump(\"my_restart\")\n", 
#&gt;                 "  cat(\"will this be called?\\n\")\n", "}\n", 
#&gt;                 "\n", "# Here no restart are on the stack:\n", 
#&gt;                 "fn()\n", "\n", "# If a restart point called `my_restart` was established on the\n", 
#&gt;                 "# stack before calling fn(), the control flow will jump there:\n", 
#&gt;                 "rst &lt;- function() {\n", "  cat(\"restarting...\\n\")\n", 
#&gt;                 "  \"return value\"\n", "}\n", "with_restarts(fn(), my_restart = rst)\n", 
#&gt;                 "\n", "\n", "# Restarts are particularly useful to provide alternative default\n", 
#&gt;                 "# values when the normal output cannot be computed:\n", 
#&gt;                 "\n", "fn &lt;- function(valid_input) {\n", "  if (valid_input) {\n", 
#&gt;                 "    return(\"normal value\")\n", "  }\n", "\n", 
#&gt;                 "  # We decide to return the empty string \"\" as default value. An\n", 
#&gt;                 "  # altenative strategy would be to signal an error. In any case,\n", 
#&gt;                 "  # we want to provide a way for the caller to get a different\n", 
#&gt;                 "  # output. For this purpose, we provide two restart functions that\n", 
#&gt;                 "  # returns alternative defaults:\n", "  restarts &lt;- list(\n", 
#&gt;                 "    rst_empty_chr = function() character(0),\n", 
#&gt;                 "    rst_null = function() NULL\n", "  )\n", 
#&gt;                 "\n", "  with_restarts(splice(restarts), .expr = {\n", 
#&gt;                 "\n", "    # Signal a typed condition to let the caller know that we are\n", 
#&gt;                 "    # about to return an empty string as default value:\n", 
#&gt;                 "    cnd_signal(\"default_empty_string\")\n", 
#&gt;                 "\n", "    # If no jump to with_restarts, return default value:\n", 
#&gt;                 "    \"\"\n", "  })\n", "}\n", "\n", "# Normal value for valid input:\n", 
#&gt;                 "fn(TRUE)\n", "\n", "# Default value for bad input:\n", 
#&gt;                 "fn(FALSE)\n", "\n", "# Change the default value if you need an empty character vector by\n", 
#&gt;                 "# defining a calling handler that jumps to the restart. It has to\n", 
#&gt;                 "# be calling because exiting handlers jump to the place where they\n", 
#&gt;                 "# are established before being executed, and the restart is not\n", 
#&gt;                 "# defined anymore at that point:\n", "rst_handler &lt;- calling(function(c) rst_jump(\"rst_empty_chr\"))\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = rst_handler)\n", 
#&gt;                 "\n", "# You can use restarting() to create restarting handlers easily:\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = restarting(\"rst_null\"))\n"), 
#&gt;             "\n", list("\n", list(list("return_from()")), " and ", 
#&gt;                 list(list("return_to()")), " for a more flexible way\n", 
#&gt;                 "of performing a non-local jump to an arbitrary call frame.\n"), 
#&gt;             "\n", list("internal"), "\n"), wref_key.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("wref_key"), "\n", list("wref_key"), "\n", list(
#&gt;                 "wref_value"), "\n", list("Get key/value from a weak reference object"), 
#&gt;             "\n", list("\n", "wref_key(x)\n", "\n", "wref_value(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A weak reference object.")), 
#&gt;                 "\n"), "\n", list("\n", "Get key/value from a weak reference object\n"), 
#&gt;             "\n", list("\n", list(list("is_weakref()")), " and ", 
#&gt;                 list(list("new_weakref()")), ".\n"), "\n"), zap.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "zap"), "\n", list("zap"), "\n", list("is_zap"), 
#&gt;             "\n", list("Create zap objects"), "\n", list("\n", 
#&gt;                 "zap()\n", "\n", "is_zap(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("zap()"), " creates a sentinel object that indicates that an object\n", 
#&gt;                 "should be removed. For instance, named zaps instruct ", 
#&gt;                 list(list("env_bind()")), "\n", "and ", list(
#&gt;                   list("call_modify()")), " to remove those objects from the environment or\n", 
#&gt;                 "the call.\n", "\n", "The advantage of zap objects is that they unambiguously signal the\n", 
#&gt;                 "intent of removing an object. Sentinels like ", 
#&gt;                 list("NULL"), " or\n", list(list("missing_arg()")), 
#&gt;                 " are ambiguous because they represent valid R\n", 
#&gt;                 "objects.\n"), "\n", list("\n", "# Create one zap object:\n", 
#&gt;                 "zap()\n", "\n", "# Create a list of zaps:\n", 
#&gt;                 "rep(list(zap()), 3)\n", "rep_named(c(\"foo\", \"bar\"), list(zap()))\n"), 
#&gt;             "\n")), source = list(abort.Rd = c("R/cnd-abort.R", 
#&gt;     "R/cnd-signal.R"), are_na.Rd = "R/vec-na.R", arg_match.Rd = "R/arg.R", 
#&gt;         as_box.Rd = "R/s3.R", as_bytes.Rd = "R/utils-encoding.R", 
#&gt;         as_data_mask.Rd = "R/eval-tidy.R", as_env.Rd = "R/lifecycle-retired.R", 
#&gt;         as_environment.Rd = "R/env.R", as_function.Rd = "R/fn.R", 
#&gt;         as_label.Rd = "R/deparse.R", as_name.Rd = "R/deparse.R", 
#&gt;         as_overscope.Rd = "R/lifecycle-retired.R", as_pairlist.Rd = "R/node.R", 
#&gt;         as_quosure.Rd = "R/quo.R", as_string.Rd = "R/sym.R", 
#&gt;         as_utf8_character.Rd = "R/utils-encoding.R", `bare-type-predicates.Rd` = "R/types.R", 
#&gt;         box.Rd = "R/s3.R", call2.Rd = "R/call.R", call_args.Rd = "R/call.R", 
#&gt;         call_fn.Rd = "R/call.R", call_inspect.Rd = "R/stack.R", 
#&gt;         call_modify.Rd = "R/call.R", call_name.Rd = "R/call.R", 
#&gt;         call_standardise.Rd = "R/call.R", caller_env.Rd = "R/env-special.R", 
#&gt;         caller_fn.Rd = "R/stack.R", caller_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         catch_cnd.Rd = "R/cnd-handlers.R", chr_unserialise_unicode.Rd = "R/utils-encoding.R", 
#&gt;         cnd.Rd = c("R/cnd-error.R", "R/cnd.R"), cnd_message.Rd = "R/cnd-message.R", 
#&gt;         cnd_muffle.Rd = "R/cnd-handlers.R", cnd_signal.Rd = "R/cnd-signal.R", 
#&gt;         cnd_type.Rd = "R/cnd.R", done.Rd = "R/s3.R", dots_definitions.Rd = "R/dots.R", 
#&gt;         dots_n.Rd = "R/dots.R", dots_values.Rd = "R/dots.R", 
#&gt;         duplicate.Rd = "R/sexp.R", empty_env.Rd = "R/env-special.R", 
#&gt;         entrace.Rd = "R/cnd-entrace.R", env.Rd = "R/env.R", env_bind.Rd = "R/env-binding.R", 
#&gt;         env_bind_exprs.Rd = "R/lifecycle-retired.R", env_binding_are_active.Rd = "R/env-binding.R", 
#&gt;         env_binding_lock.Rd = "R/env-binding.R", env_bury.Rd = "R/env-binding.R", 
#&gt;         env_clone.Rd = "R/env.R", env_depth.Rd = "R/env.R", env_get.Rd = "R/env-binding.R", 
#&gt;         env_has.Rd = "R/env-binding.R", env_inherits.Rd = "R/env.R", 
#&gt;         env_lock.Rd = "R/env.R", env_name.Rd = "R/env-special.R", 
#&gt;         env_names.Rd = "R/env-binding.R", env_parent.Rd = "R/env.R", 
#&gt;         env_poke.Rd = "R/env-binding.R", env_print.Rd = "R/env.R", 
#&gt;         env_unbind.Rd = "R/env-binding.R", env_unlock.Rd = "R/env.R", 
#&gt;         eval_bare.Rd = "R/eval.R", eval_tidy.Rd = "R/eval-tidy.R", 
#&gt;         exec.Rd = "R/eval.R", exiting.Rd = "R/lifecycle-retired.R", 
#&gt;         expr_interp.Rd = "R/quasiquotation.R", expr_label.Rd = "R/expr.R", 
#&gt;         expr_print.Rd = "R/expr.R", exprs_auto_name.Rd = "R/quotation.R", 
#&gt;         f_rhs.Rd = "R/formula.R", f_text.Rd = "R/formula.R", 
#&gt;         flatten.Rd = "R/vec-squash.R", fn_body.Rd = "R/fn.R", 
#&gt;         fn_env.Rd = "R/fn.R", fn_fmls.Rd = "R/fn.R", frame_position.Rd = "R/lifecycle-retired.R", 
#&gt;         friendly_type.Rd = "R/types.R", get_env.Rd = "R/env.R", 
#&gt;         has_length.Rd = "R/attr.R", has_name.Rd = "R/attr.R", 
#&gt;         inherits_any.Rd = "R/s3.R", invoke.Rd = "R/eval.R", is_call.Rd = "R/call.R", 
#&gt;         is_callable.Rd = "R/call.R", is_condition.Rd = "R/cnd.R", 
#&gt;         is_copyable.Rd = "R/types.R", is_empty.Rd = "R/types.R", 
#&gt;         is_env.Rd = "R/lifecycle-retired.R", is_environment.Rd = "R/types.R", 
#&gt;         is_expr.Rd = "R/lifecycle-retired.R", is_expression.Rd = "R/expr.R", 
#&gt;         is_formula.Rd = "R/formula.R", is_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         is_function.Rd = "R/fn.R", is_installed.Rd = "R/env-special.R", 
#&gt;         is_integerish.Rd = "R/types.R", is_interactive.Rd = "R/state.R", 
#&gt;         is_lang.Rd = "R/lifecycle-retired.R", is_named.Rd = "R/attr.R", 
#&gt;         is_namespace.Rd = "R/env-special.R", is_pairlist.Rd = "R/node.R", 
#&gt;         is_reference.Rd = "R/types.R", is_stack.Rd = "R/lifecycle-retired.R", 
#&gt;         is_symbol.Rd = "R/sym.R", is_true.Rd = "R/types.R", is_weakref.Rd = "R/weakref.R", 
#&gt;         lang.Rd = "R/lifecycle-retired.R", lang_head.Rd = "R/lifecycle-retired.R", 
#&gt;         lang_modify.Rd = "R/lifecycle-retired.R", last_error.Rd = "R/cnd-abort.R", 
#&gt;         lifecycle.Rd = "R/lifecycle.R", missing.Rd = "R/vec-na.R", 
#&gt;         missing_arg.Rd = "R/arg.R", mut_node_car.Rd = "R/lifecycle-retired.R", 
#&gt;         names2.Rd = "R/attr.R", `new-vector-along-retired.Rd` = "R/lifecycle-retired.R", 
#&gt;         `new-vector.Rd` = "R/vec-new.R", new_call.Rd = "R/node.R", 
#&gt;         new_formula.Rd = "R/formula.R", new_function.Rd = "R/fn.R", 
#&gt;         new_node.Rd = "R/node.R", new_quosures.Rd = "R/quo.R", 
#&gt;         new_weakref.Rd = "R/weakref.R", ns_env.Rd = "R/env-special.R", 
#&gt;         `op-definition.Rd` = "R/operators.R", `op-get-attr.Rd` = "R/operators.R", 
#&gt;         `op-na-default.Rd` = "R/operators.R", `op-null-default.Rd` = "R/operators.R", 
#&gt;         overscope_eval_next.Rd = "R/lifecycle-retired.R", pairlist2.Rd = "R/call.R", 
#&gt;         parse_expr.Rd = "R/parse.R", parse_quosure.Rd = "R/lifecycle-retired.R", 
#&gt;         prepend.Rd = "R/lifecycle-retired.R", prim_name.Rd = "R/fn.R", 
#&gt;         quasiquotation.Rd = "R/quasiquotation.R", quo_expr.Rd = "R/lifecycle-retired.R", 
#&gt;         quo_label.Rd = "R/quo.R", quo_squash.Rd = "R/quo.R", 
#&gt;         quosure.Rd = "R/quo.R", quotation.Rd = "R/quotation.R", 
#&gt;         rep_along.Rd = "R/vec-new.R", restarting.Rd = "R/cnd-handlers.R", 
#&gt;         return_from.Rd = "R/stack.R", rlang_backtrace_on_error.Rd = "R/cnd-abort.R", 
#&gt;         rst_abort.Rd = "R/cnd-restarts.R", rst_list.Rd = "R/cnd-restarts.R", 
#&gt;         `scalar-type-predicates.Rd` = "R/types.R", scoped_bindings.Rd = "R/env-binding.R", 
#&gt;         scoped_env.Rd = "R/lifecycle-retired.R", scoped_options.Rd = "R/state.R", 
#&gt;         search_envs.Rd = "R/env-special.R", seq2.Rd = "R/vec.R", 
#&gt;         set_attrs.Rd = "R/lifecycle-retired.R", set_expr.Rd = "R/expr.R", 
#&gt;         set_names.Rd = "R/attr.R", splice.Rd = "R/dots.R", stack.Rd = "R/lifecycle-retired.R", 
#&gt;         stack_trim.Rd = "R/lifecycle-retired.R", string.Rd = "R/utils-encoding.R", 
#&gt;         switch_type.Rd = "R/lifecycle-retired.R", sym.Rd = "R/sym.R", 
#&gt;         `tidy-dots.Rd` = c("R/dots.R", "R/vec-new.R"), `tidyeval-data.Rd` = "R/eval-tidy.R", 
#&gt;         trace_back.Rd = "R/trace.R", `type-predicates.Rd` = "R/types.R", 
#&gt;         type_of.Rd = "R/lifecycle-retired.R", vec_poke_n.Rd = "R/vec.R", 
#&gt;         `vector-coercion.Rd` = "R/lifecycle-retired.R", `vector-construction.Rd` = "R/vec-new.R", 
#&gt;         `vector-old-ctors.Rd` = "R/lifecycle-retired.R", with_abort.Rd = "R/cnd-entrace.R", 
#&gt;         with_env.Rd = "R/eval.R", with_handlers.Rd = "R/cnd-handlers.R", 
#&gt;         with_restarts.Rd = "R/cnd-restarts.R", wref_key.Rd = "R/weakref.R", 
#&gt;         zap.Rd = "R/s3.R"), concepts = list(abort.Rd = character(0), 
#&gt;         are_na.Rd = character(0), arg_match.Rd = character(0), 
#&gt;         as_box.Rd = character(0), as_bytes.Rd = character(0), 
#&gt;         as_data_mask.Rd = character(0), as_env.Rd = character(0), 
#&gt;         as_environment.Rd = character(0), as_function.Rd = character(0), 
#&gt;         as_label.Rd = character(0), as_name.Rd = character(0), 
#&gt;         as_overscope.Rd = character(0), as_pairlist.Rd = character(0), 
#&gt;         as_quosure.Rd = character(0), as_string.Rd = character(0), 
#&gt;         as_utf8_character.Rd = character(0), `bare-type-predicates.Rd` = character(0), 
#&gt;         box.Rd = character(0), call2.Rd = character(0), call_args.Rd = character(0), 
#&gt;         call_fn.Rd = character(0), call_inspect.Rd = character(0), 
#&gt;         call_modify.Rd = character(0), call_name.Rd = character(0), 
#&gt;         call_standardise.Rd = character(0), caller_env.Rd = character(0), 
#&gt;         caller_fn.Rd = character(0), caller_frame.Rd = character(0), 
#&gt;         catch_cnd.Rd = character(0), chr_unserialise_unicode.Rd = character(0), 
#&gt;         cnd.Rd = character(0), cnd_message.Rd = character(0), 
#&gt;         cnd_muffle.Rd = character(0), cnd_signal.Rd = character(0), 
#&gt;         cnd_type.Rd = character(0), done.Rd = character(0), dots_definitions.Rd = character(0), 
#&gt;         dots_n.Rd = character(0), dots_values.Rd = character(0), 
#&gt;         duplicate.Rd = character(0), empty_env.Rd = character(0), 
#&gt;         entrace.Rd = character(0), env.Rd = character(0), env_bind.Rd = character(0), 
#&gt;         env_bind_exprs.Rd = character(0), env_binding_are_active.Rd = character(0), 
#&gt;         env_binding_lock.Rd = character(0), env_bury.Rd = character(0), 
#&gt;         env_clone.Rd = character(0), env_depth.Rd = character(0), 
#&gt;         env_get.Rd = character(0), env_has.Rd = character(0), 
#&gt;         env_inherits.Rd = character(0), env_lock.Rd = character(0), 
#&gt;         env_name.Rd = character(0), env_names.Rd = character(0), 
#&gt;         env_parent.Rd = character(0), env_poke.Rd = character(0), 
#&gt;         env_print.Rd = character(0), env_unbind.Rd = character(0), 
#&gt;         env_unlock.Rd = character(0), eval_bare.Rd = character(0), 
#&gt;         eval_tidy.Rd = character(0), exec.Rd = character(0), 
#&gt;         exiting.Rd = character(0), expr_interp.Rd = character(0), 
#&gt;         expr_label.Rd = character(0), expr_print.Rd = character(0), 
#&gt;         exprs_auto_name.Rd = character(0), f_rhs.Rd = character(0), 
#&gt;         f_text.Rd = character(0), flatten.Rd = character(0), 
#&gt;         fn_body.Rd = character(0), fn_env.Rd = character(0), 
#&gt;         fn_fmls.Rd = character(0), frame_position.Rd = character(0), 
#&gt;         friendly_type.Rd = character(0), get_env.Rd = character(0), 
#&gt;         has_length.Rd = character(0), has_name.Rd = character(0), 
#&gt;         inherits_any.Rd = character(0), invoke.Rd = character(0), 
#&gt;         is_call.Rd = character(0), is_callable.Rd = character(0), 
#&gt;         is_condition.Rd = character(0), is_copyable.Rd = character(0), 
#&gt;         is_empty.Rd = character(0), is_env.Rd = character(0), 
#&gt;         is_environment.Rd = character(0), is_expr.Rd = character(0), 
#&gt;         is_expression.Rd = character(0), is_formula.Rd = character(0), 
#&gt;         is_frame.Rd = character(0), is_function.Rd = character(0), 
#&gt;         is_installed.Rd = character(0), is_integerish.Rd = character(0), 
#&gt;         is_interactive.Rd = character(0), is_lang.Rd = character(0), 
#&gt;         is_named.Rd = character(0), is_namespace.Rd = character(0), 
#&gt;         is_pairlist.Rd = character(0), is_reference.Rd = character(0), 
#&gt;         is_stack.Rd = character(0), is_symbol.Rd = character(0), 
#&gt;         is_true.Rd = character(0), is_weakref.Rd = character(0), 
#&gt;         lang.Rd = character(0), lang_head.Rd = character(0), 
#&gt;         lang_modify.Rd = character(0), last_error.Rd = character(0), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = character(0), 
#&gt;         missing_arg.Rd = character(0), mut_node_car.Rd = character(0), 
#&gt;         names2.Rd = character(0), `new-vector-along-retired.Rd` = character(0), 
#&gt;         `new-vector.Rd` = character(0), new_call.Rd = character(0), 
#&gt;         new_formula.Rd = character(0), new_function.Rd = character(0), 
#&gt;         new_node.Rd = character(0), new_quosures.Rd = character(0), 
#&gt;         new_weakref.Rd = character(0), ns_env.Rd = character(0), 
#&gt;         `op-definition.Rd` = character(0), `op-get-attr.Rd` = character(0), 
#&gt;         `op-na-default.Rd` = character(0), `op-null-default.Rd` = character(0), 
#&gt;         overscope_eval_next.Rd = character(0), pairlist2.Rd = character(0), 
#&gt;         parse_expr.Rd = character(0), parse_quosure.Rd = character(0), 
#&gt;         prepend.Rd = character(0), prim_name.Rd = character(0), 
#&gt;         quasiquotation.Rd = character(0), quo_expr.Rd = character(0), 
#&gt;         quo_label.Rd = character(0), quo_squash.Rd = character(0), 
#&gt;         quosure.Rd = character(0), quotation.Rd = character(0), 
#&gt;         rep_along.Rd = character(0), restarting.Rd = character(0), 
#&gt;         return_from.Rd = character(0), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = character(0), rst_list.Rd = character(0), 
#&gt;         `scalar-type-predicates.Rd` = character(0), scoped_bindings.Rd = character(0), 
#&gt;         scoped_env.Rd = character(0), scoped_options.Rd = character(0), 
#&gt;         search_envs.Rd = character(0), seq2.Rd = character(0), 
#&gt;         set_attrs.Rd = character(0), set_expr.Rd = character(0), 
#&gt;         set_names.Rd = character(0), splice.Rd = character(0), 
#&gt;         stack.Rd = character(0), stack_trim.Rd = character(0), 
#&gt;         string.Rd = character(0), switch_type.Rd = character(0), 
#&gt;         sym.Rd = character(0), `tidy-dots.Rd` = character(0), 
#&gt;         `tidyeval-data.Rd` = character(0), trace_back.Rd = character(0), 
#&gt;         `type-predicates.Rd` = character(0), type_of.Rd = character(0), 
#&gt;         vec_poke_n.Rd = character(0), `vector-coercion.Rd` = character(0), 
#&gt;         `vector-construction.Rd` = character(0), `vector-old-ctors.Rd` = character(0), 
#&gt;         with_abort.Rd = character(0), with_env.Rd = character(0), 
#&gt;         with_handlers.Rd = character(0), with_restarts.Rd = character(0), 
#&gt;         wref_key.Rd = character(0), zap.Rd = character(0)), internal = c(FALSE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, FALSE, FALSE)), tutorials = list(name = character(0), 
#&gt;         file_out = character(0), title = character(0), pagetitle = character(0), 
#&gt;         url = character(0)), vignettes = list(name = character(0), 
#&gt;         file_in = character(0), file_out = character(0), title = character(0)), 
#&gt;     topic_index = c(`:=` = "quasiquotation", `!!` = "quasiquotation", 
#&gt;     `!!!` = "quasiquotation", .data = "tidyeval-data", `{{` = "quasiquotation", 
#&gt;     `{{}}` = "quasiquotation", `%@%` = "op-get-attr", `%@%&lt;-` = "op-get-attr", 
#&gt;     `%|%` = "op-na-default", `%||%` = "op-null-default", abort = "abort", 
#&gt;     add_backtrace = "rlang_backtrace_on_error", are_na = "are_na", 
#&gt;     arg_match = "arg_match", as_box = "as_box", as_box_if = "as_box", 
#&gt;     as_bytes = "as_bytes", as_character = "vector-coercion", 
#&gt;     as_closure = "as_function", as_complex = "vector-coercion", 
#&gt;     as_data_mask = "as_data_mask", as_data_pronoun = "as_data_mask", 
#&gt;     as_double = "vector-coercion", as_env = "as_env", as_environment = "as_environment", 
#&gt;     as_function = "as_function", as_integer = "vector-coercion", 
#&gt;     as_label = "as_label", as_list = "vector-coercion", as_logical = "vector-coercion", 
#&gt;     as_name = "as_name", as_overscope = "as_overscope", as_pairlist = "as_pairlist", 
#&gt;     as_quosure = "as_quosure", as_quosures = "new_quosures", 
#&gt;     as_string = "as_string", as_utf8_character = "as_utf8_character", 
#&gt;     `bare-type-predicates` = "bare-type-predicates", base_env = "search_envs", 
#&gt;     box = "box", bytes = "vector-construction", bytes_along = "vector-old-ctors", 
#&gt;     bytes_len = "vector-old-ctors", call_args = "call_args", 
#&gt;     call_args_names = "call_args", call_depth = "stack", call_fn = "call_fn", 
#&gt;     call_frame = "stack", call_inspect = "call_inspect", call_modify = "call_modify", 
#&gt;     call_name = "call_name", call_ns = "call_name", call_stack = "stack", 
#&gt;     call_standardise = "call_standardise", call2 = "call2", caller_env = "caller_env", 
#&gt;     caller_fn = "caller_fn", caller_frame = "caller_frame", calling = "with_handlers", 
#&gt;     catch_cnd = "catch_cnd", child_env = "env", chr = "vector-construction", 
#&gt;     chr_along = "vector-old-ctors", chr_len = "vector-old-ctors", 
#&gt;     chr_unserialise_unicode = "chr_unserialise_unicode", cnd = "cnd", 
#&gt;     cnd_bullets = "cnd_message", cnd_entrace = "entrace", cnd_issue = "cnd_message", 
#&gt;     cnd_message = "cnd_message", cnd_muffle = "cnd_muffle", cnd_signal = "cnd_signal", 
#&gt;     cnd_type = "cnd_type", coerce_class = "switch_type", coerce_type = "switch_type", 
#&gt;     cpl = "vector-construction", cpl_along = "vector-old-ctors", 
#&gt;     cpl_len = "vector-old-ctors", ctxt_depth = "stack", ctxt_frame = "stack", 
#&gt;     ctxt_stack = "stack", current_env = "caller_env", current_fn = "caller_fn", 
#&gt;     current_frame = "stack", dbl = "vector-construction", dbl_along = "vector-old-ctors", 
#&gt;     dbl_len = "vector-old-ctors", done = "done", dots_definitions = "dots_definitions", 
#&gt;     dots_list = "tidy-dots", dots_n = "dots_n", dots_splice = "splice", 
#&gt;     dots_values = "dots_values", duplicate = "duplicate", empty_env = "empty_env", 
#&gt;     enexpr = "quotation", enexprs = "quotation", enquo = "quotation", 
#&gt;     enquos = "quotation", ensym = "quotation", ensyms = "quotation", 
#&gt;     entrace = "entrace", env = "env", env_bind = "env_bind", 
#&gt;     env_bind_active = "env_bind", env_bind_exprs = "env_bind_exprs", 
#&gt;     env_bind_fns = "env_bind_exprs", env_bind_lazy = "env_bind", 
#&gt;     env_binding_are_active = "env_binding_are_active", env_binding_are_lazy = "env_binding_are_active", 
#&gt;     env_binding_are_locked = "env_binding_lock", env_binding_lock = "env_binding_lock", 
#&gt;     env_binding_unlock = "env_binding_lock", env_bury = "env_bury", 
#&gt;     env_clone = "env_clone", env_depth = "env_depth", env_get = "env_get", 
#&gt;     env_get_list = "env_get", env_has = "env_has", env_inherits = "env_inherits", 
#&gt;     env_is_locked = "env_lock", env_label = "env_name", env_length = "env_names", 
#&gt;     env_lock = "env_lock", env_name = "env_name", env_names = "env_names", 
#&gt;     env_parent = "env_parent", env_parents = "env_parent", env_poke = "env_poke", 
#&gt;     env_poke_parent = "get_env", env_print = "env_print", env_tail = "env_parent", 
#&gt;     env_unbind = "env_unbind", env_unlock = "env_unlock", error_cnd = "cnd", 
#&gt;     eval_bare = "eval_bare", eval_tidy = "eval_tidy", exec = "exec", 
#&gt;     exiting = "exiting", expr = "quotation", expr_deparse = "expr_print", 
#&gt;     expr_interp = "expr_interp", expr_label = "expr_label", expr_name = "expr_label", 
#&gt;     expr_print = "expr_print", expr_text = "expr_label", exprs = "quotation", 
#&gt;     exprs_auto_name = "exprs_auto_name", f_env = "f_rhs", `f_env&lt;-` = "f_rhs", 
#&gt;     f_label = "f_text", f_lhs = "f_rhs", `f_lhs&lt;-` = "f_rhs", 
#&gt;     f_name = "f_text", f_rhs = "f_rhs", `f_rhs&lt;-` = "f_rhs", 
#&gt;     f_text = "f_text", flatten = "flatten", flatten_chr = "flatten", 
#&gt;     flatten_cpl = "flatten", flatten_dbl = "flatten", flatten_if = "flatten", 
#&gt;     flatten_int = "flatten", flatten_lgl = "flatten", flatten_raw = "flatten", 
#&gt;     fn_body = "fn_body", `fn_body&lt;-` = "fn_body", fn_env = "fn_env", 
#&gt;     `fn_env&lt;-` = "fn_env", fn_fmls = "fn_fmls", fn_fmls_names = "fn_fmls", 
#&gt;     `fn_fmls_names&lt;-` = "fn_fmls", fn_fmls_syms = "fn_fmls", 
#&gt;     `fn_fmls&lt;-` = "fn_fmls", format_bullets = "cnd_message", 
#&gt;     frame_position = "frame_position", friendly_type = "friendly_type", 
#&gt;     get_env = "get_env", get_expr = "set_expr", global_env = "search_envs", 
#&gt;     global_frame = "stack", has_length = "has_length", has_name = "has_name", 
#&gt;     have_name = "is_named", inform = "abort", inherits_all = "inherits_any", 
#&gt;     inherits_any = "inherits_any", inherits_only = "inherits_any", 
#&gt;     int = "vector-construction", int_along = "vector-old-ctors", 
#&gt;     int_len = "vector-old-ctors", interrupt = "abort", invoke = "invoke", 
#&gt;     is_atomic = "type-predicates", is_attached = "search_envs", 
#&gt;     is_bare_atomic = "bare-type-predicates", is_bare_bytes = "bare-type-predicates", 
#&gt;     is_bare_character = "bare-type-predicates", is_bare_double = "bare-type-predicates", 
#&gt;     is_bare_env = "is_env", is_bare_environment = "is_environment", 
#&gt;     is_bare_formula = "is_formula", is_bare_integer = "bare-type-predicates", 
#&gt;     is_bare_integerish = "is_integerish", is_bare_list = "bare-type-predicates", 
#&gt;     is_bare_logical = "bare-type-predicates", is_bare_numeric = "bare-type-predicates", 
#&gt;     is_bare_raw = "bare-type-predicates", is_bare_string = "bare-type-predicates", 
#&gt;     is_bare_vector = "bare-type-predicates", is_binary_lang = "is_lang", 
#&gt;     is_bool = "scalar-type-predicates", is_box = "box", is_bytes = "type-predicates", 
#&gt;     is_call = "is_call", is_call_stack = "is_stack", is_callable = "is_callable", 
#&gt;     is_character = "type-predicates", is_chr_na = "are_na", is_closure = "is_function", 
#&gt;     is_condition = "is_condition", is_copyable = "is_copyable", 
#&gt;     is_cpl_na = "are_na", is_dbl_na = "are_na", is_definition = "op-definition", 
#&gt;     is_dictionaryish = "is_named", is_done_box = "done", is_double = "type-predicates", 
#&gt;     is_empty = "is_empty", is_env = "is_env", is_environment = "is_environment", 
#&gt;     is_eval_stack = "is_stack", is_expr = "is_expr", is_expression = "is_expression", 
#&gt;     is_false = "is_true", is_formula = "is_formula", is_formulaish = "op-definition", 
#&gt;     is_frame = "is_frame", is_function = "is_function", is_installed = "is_installed", 
#&gt;     is_int_na = "are_na", is_integer = "type-predicates", is_integerish = "is_integerish", 
#&gt;     is_interactive = "is_interactive", is_lambda = "as_function", 
#&gt;     is_lang = "is_lang", is_lgl_na = "are_na", is_list = "type-predicates", 
#&gt;     is_logical = "type-predicates", is_missing = "missing_arg", 
#&gt;     is_na = "are_na", is_named = "is_named", is_namespace = "is_namespace", 
#&gt;     is_node = "is_pairlist", is_node_list = "is_pairlist", is_null = "type-predicates", 
#&gt;     is_pairlist = "is_pairlist", is_primitive = "is_function", 
#&gt;     is_primitive_eager = "is_function", is_primitive_lazy = "is_function", 
#&gt;     is_quosure = "quosure", is_quosures = "new_quosures", is_raw = "type-predicates", 
#&gt;     is_reference = "is_reference", is_scalar_atomic = "scalar-type-predicates", 
#&gt;     is_scalar_bytes = "scalar-type-predicates", is_scalar_character = "scalar-type-predicates", 
#&gt;     is_scalar_double = "scalar-type-predicates", is_scalar_integer = "scalar-type-predicates", 
#&gt;     is_scalar_integerish = "is_integerish", is_scalar_list = "scalar-type-predicates", 
#&gt;     is_scalar_logical = "scalar-type-predicates", is_scalar_raw = "scalar-type-predicates", 
#&gt;     is_scalar_vector = "scalar-type-predicates", is_scoped = "scoped_env", 
#&gt;     is_spliced = "splice", is_spliced_bare = "splice", is_stack = "is_stack", 
#&gt;     is_string = "scalar-type-predicates", is_symbol = "is_symbol", 
#&gt;     is_symbolic = "is_expression", is_syntactic_literal = "is_expression", 
#&gt;     is_true = "is_true", is_unary_lang = "is_lang", is_vector = "type-predicates", 
#&gt;     is_weakref = "is_weakref", is_zap = "zap", lang = "lang", 
#&gt;     lang_args = "lang_modify", lang_args_names = "lang_modify", 
#&gt;     lang_fn = "lang_modify", lang_head = "lang_head", lang_modify = "lang_modify", 
#&gt;     lang_name = "lang_modify", lang_standardise = "lang_modify", 
#&gt;     lang_tail = "lang_head", last_error = "last_error", last_trace = "last_error", 
#&gt;     lgl = "vector-construction", lgl_along = "vector-old-ctors", 
#&gt;     lgl_len = "vector-old-ctors", lifecycle = "lifecycle", list_along = "vector-old-ctors", 
#&gt;     list_len = "vector-old-ctors", list2 = "tidy-dots", ll = "vector-construction", 
#&gt;     locally = "with_env", maybe_missing = "missing_arg", message_cnd = "cnd", 
#&gt;     missing = "missing", missing_arg = "missing_arg", modify = "prepend", 
#&gt;     mut_attrs = "set_attrs", mut_node_caar = "mut_node_car", 
#&gt;     mut_node_cadr = "mut_node_car", mut_node_car = "mut_node_car", 
#&gt;     mut_node_cdar = "mut_node_car", mut_node_cddr = "mut_node_car", 
#&gt;     mut_node_cdr = "mut_node_car", mut_node_tag = "mut_node_car", 
#&gt;     na_chr = "missing", na_cpl = "missing", na_dbl = "missing", 
#&gt;     na_int = "missing", na_lgl = "missing", names2 = "names2", 
#&gt;     new_box = "box", new_call = "new_call", new_character = "new-vector", 
#&gt;     new_character_along = "new-vector-along-retired", new_complex = "new-vector", 
#&gt;     new_complex_along = "new-vector-along-retired", new_data_mask = "as_data_mask", 
#&gt;     new_definition = "op-definition", new_double = "new-vector", 
#&gt;     new_double_along = "new-vector-along-retired", new_environment = "env", 
#&gt;     new_formula = "new_formula", new_function = "new_function", 
#&gt;     new_integer = "new-vector", new_integer_along = "new-vector-along-retired", 
#&gt;     new_language = "lang", new_list = "new-vector", new_list_along = "new-vector-along-retired", 
#&gt;     new_logical = "new-vector", new_logical_along = "new-vector-along-retired", 
#&gt;     new_node = "new_node", new_overscope = "as_overscope", new_quosure = "as_quosure", 
#&gt;     new_quosures = "new_quosures", new_raw = "new-vector", new_raw_along = "new-vector-along-retired", 
#&gt;     new_weakref = "new_weakref", `new-vector` = "new-vector", 
#&gt;     `new-vector-along-retired` = "new-vector-along-retired", 
#&gt;     node = "vector-old-ctors", node_caar = "new_node", node_cadr = "new_node", 
#&gt;     node_car = "new_node", node_cdar = "new_node", node_cddr = "new_node", 
#&gt;     node_cdr = "new_node", node_poke_caar = "new_node", node_poke_cadr = "new_node", 
#&gt;     node_poke_car = "new_node", node_poke_cdar = "new_node", 
#&gt;     node_poke_cddr = "new_node", node_poke_cdr = "new_node", 
#&gt;     node_poke_tag = "new_node", node_tag = "new_node", ns_env = "ns_env", 
#&gt;     ns_env_name = "ns_env", ns_imports_env = "ns_env", `op-definition` = "op-definition", 
#&gt;     `op-get-attr` = "op-get-attr", `op-na-default` = "op-na-default", 
#&gt;     `op-null-default` = "op-null-default", overscope_clean = "as_overscope", 
#&gt;     overscope_eval_next = "overscope_eval_next", pairlist2 = "pairlist2", 
#&gt;     parse_expr = "parse_expr", parse_exprs = "parse_expr", parse_quo = "parse_expr", 
#&gt;     parse_quos = "parse_expr", parse_quosure = "parse_quosure", 
#&gt;     parse_quosures = "parse_quosure", peek_option = "scoped_options", 
#&gt;     peek_options = "scoped_options", pkg_env = "search_envs", 
#&gt;     pkg_env_name = "search_envs", prepend = "prepend", prim_name = "prim_name", 
#&gt;     push_options = "scoped_options", qq_show = "quasiquotation", 
#&gt;     quasiquotation = "quasiquotation", quo = "quotation", quo_expr = "quo_expr", 
#&gt;     quo_get_env = "quosure", quo_get_expr = "quosure", quo_is_call = "quosure", 
#&gt;     quo_is_lang = "is_lang", quo_is_missing = "quosure", quo_is_null = "quosure", 
#&gt;     quo_is_symbol = "quosure", quo_is_symbolic = "quosure", quo_label = "quo_label", 
#&gt;     quo_name = "quo_label", quo_set_env = "quosure", quo_set_expr = "quosure", 
#&gt;     quo_squash = "quo_squash", quo_text = "quo_label", quos = "quotation", 
#&gt;     quos_auto_name = "exprs_auto_name", quosure = "quosure", 
#&gt;     quotation = "quotation", raw_along = "vector-old-ctors", 
#&gt;     raw_len = "vector-old-ctors", rep_along = "rep_along", rep_named = "rep_along", 
#&gt;     restarting = "restarting", return_from = "return_from", return_to = "return_from", 
#&gt;     rlang_backtrace_on_error = "rlang_backtrace_on_error", rst_abort = "rst_abort", 
#&gt;     rst_exists = "rst_list", rst_jump = "rst_list", rst_list = "rst_list", 
#&gt;     rst_maybe_jump = "rst_list", `scalar-type-predicates` = "scalar-type-predicates", 
#&gt;     scoped_bindings = "scoped_bindings", scoped_env = "scoped_env", 
#&gt;     scoped_envs = "scoped_env", scoped_interactive = "is_interactive", 
#&gt;     scoped_names = "scoped_env", scoped_options = "scoped_options", 
#&gt;     search_env = "search_envs", search_envs = "search_envs", 
#&gt;     seq2 = "seq2", seq2_along = "seq2", set_attrs = "set_attrs", 
#&gt;     set_env = "get_env", set_expr = "set_expr", set_names = "set_names", 
#&gt;     signal = "abort", splice = "splice", squash = "flatten", 
#&gt;     squash_chr = "flatten", squash_cpl = "flatten", squash_dbl = "flatten", 
#&gt;     squash_if = "flatten", squash_int = "flatten", squash_lgl = "flatten", 
#&gt;     squash_raw = "flatten", stack = "stack", stack_trim = "stack_trim", 
#&gt;     string = "string", switch_class = "switch_type", switch_type = "switch_type", 
#&gt;     sym = "sym", syms = "sym", `tidy-dots` = "tidy-dots", `tidyeval-data` = "tidyeval-data", 
#&gt;     trace_back = "trace_back", trace_length = "trace_back", type_of = "type_of", 
#&gt;     `type-predicates` = "type-predicates", unbox = "box", UQ = "quasiquotation", 
#&gt;     UQS = "quasiquotation", vec_poke_n = "vec_poke_n", vec_poke_range = "vec_poke_n", 
#&gt;     `vector-coercion` = "vector-coercion", `vector-construction` = "vector-construction", 
#&gt;     `vector-old-ctors` = "vector-old-ctors", warn = "abort", 
#&gt;     warning_cnd = "cnd", with_abort = "with_abort", with_bindings = "scoped_bindings", 
#&gt;     with_env = "with_env", with_handlers = "with_handlers", with_interactive = "is_interactive", 
#&gt;     with_options = "scoped_options", with_restarts = "with_restarts", 
#&gt;     wref_key = "wref_key", wref_value = "wref_key", zap = "zap"
#&gt;     ), article_index = character(0)), examples = TRUE, run_dont_run = FALSE, 
#&gt;     seed = 1014, lazy = FALSE, override = list(destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE), 
#&gt;     envir = &lt;environment&gt;)
#&gt; 
#&gt; [[12]]
#&gt; (function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; })(pkg = list(package = "rlang", version = list(c(0L, 4L, 1L)), 
#&gt;     src_path = "/home/travis/build/r-lib/rlang", dst_path = "/tmp/RtmpGSP0ZP/file4f58692244b4", 
#&gt;     github_url = "https://github.com/r-lib/rlang", desc = &lt;environment&gt;, 
#&gt;     meta = list(url = "https://rlang.r-lib.org", template = list(
#&gt;         params = list(ganalytics = "UA-115082821-1")), home = list(
#&gt;         links = list(list(text = "The tidy eval bookdown", href = "https://tidyeval.tidyverse.org"))), 
#&gt;         navbar = list(structure = list(left = c("home", "reference", 
#&gt;         "lifecycle", "news"), right = "github"), components = list(
#&gt;             lifecycle = list(text = "Life cycle", href = "reference/lifecycle.html"), 
#&gt;             news = list(text = "News", menu = list(list(text = "Release notes"), 
#&gt;                 list(text = "Version 0.4.0", href = "https://www.tidyverse.org/articles/2019/06/rlang-0-4-0/"), 
#&gt;                 list(text = "Version 0.3.1", href = "https://www.tidyverse.org/articles/2019/01/rlang-0-3-1/"), 
#&gt;                 list(text = "Version 0.3.0", href = "https://www.tidyverse.org/articles/2018/10/rlang-0-3-0/"), 
#&gt;                 list(text = "Version 0.2.0", href = "https://www.tidyverse.org/articles/2018/03/rlang-0.2.0/"), 
#&gt;                 list(text = "------------------"), list(text = "Change log", 
#&gt;                   href = "news/index.html"))))), reference = list(
#&gt;             list(title = "Tidy evaluation", desc = "Quote arguments and expressions with unquoting support. The quosure variants wrap an environment with the expression.\n", 
#&gt;                 contents = c("quo", "quos", "enquo", "enquos", 
#&gt;                 "expr", "exprs", "enexpr", "enexprs", "quasiquotation", 
#&gt;                 "as_label", "as_name")), list(title = "Tidy dots", 
#&gt;                 desc = "Collect arguments contained in `...` with `!!!` and name-unquoting support.\n", 
#&gt;                 contents = c("list2", "dots_list", "pairlist2"
#&gt;                 )), list(title = "Errors, conditions, and backtraces", 
#&gt;                 contents = c("abort", "warn", "inform", "signal", 
#&gt;                 "trace_back", "with_abort", "entrace", "cnd_signal", 
#&gt;                 "last_error", "rlang_backtrace_on_error", "catch_cnd"
#&gt;                 )), list(title = "Evaluate expressions", contents = c("eval_tidy", 
#&gt;             "eval_bare", "exec")), list(title = "Symbols", contents = c("sym", 
#&gt;             "syms", "is_symbol", "as_string")), list(title = "Calls", 
#&gt;                 contents = c("starts_with(\"call_\")", "call2", 
#&gt;                 "is_call")), list(title = "Expressions", contents = c("starts_with(\"expr_\")", 
#&gt;             "starts_with(\"exprs_\")", "starts_with(\"parse_\")", 
#&gt;             "is_expression", "is_symbolic", "expr_text", "expr_label", 
#&gt;             "expr_name", "set_expr", "get_expr")), list(title = "Quosures", 
#&gt;                 contents = c("starts_with(\"quo_\")", "new_quosure", 
#&gt;                 "is_quosure", "as_quosure", "is_quosures", "quos_auto_name"
#&gt;                 )), list(title = "Formulas", contents = c("starts_with(\"f_\")", 
#&gt;             "new_formula", "is_formula", "is_bare_formula")), 
#&gt;             list(title = "Functions", contents = c("starts_with(\"fn_\")", 
#&gt;             "new_function", "is_function", "is_closure", "is_primitive", 
#&gt;             "as_function", "as_closure")), list(title = "Environments", 
#&gt;                 contents = c("env", "new_environment", "env_print", 
#&gt;                 "env_parent", "env_tail", "env_parents", "env_depth", 
#&gt;                 "get_env", "set_env", "env_clone", "env_inherits", 
#&gt;                 "is_environment", "is_bare_environment", "as_environment", 
#&gt;                 "caller_env")), list(title = "Environment bindings", 
#&gt;                 contents = c("env_bind", "env_bind_lazy", "env_bind_active", 
#&gt;                 "env_unbind", "with_bindings", "scoped_bindings", 
#&gt;                 "env_has", "env_get", "env_get_list", "env_names", 
#&gt;                 "env_length", "env_poke")), list(title = "Search path and namespaces", 
#&gt;                 contents = c("search_envs", "search_env", "base_env", 
#&gt;                 "global_env", "empty_env", "is_installed", "is_namespace", 
#&gt;                 "ns_env", "pkg_env", "env_name", "env_label")), 
#&gt;             list(title = "S3", contents = c("inherits_any", "inherits_all", 
#&gt;             "inherits_only", "new_box", "is_box", "as_box", "as_box_if", 
#&gt;             "unbox", "zap", "is_zap", "done")), list(title = "Create vectors", 
#&gt;                 desc = "Atomic vector constructors have implicit splicing (i.e. splice lists automatically), while the list constructor has explicit splicing.\n", 
#&gt;                 contents = c("lgl", "int", "dbl", "cpl", "chr", 
#&gt;                 "list2", "rep_along", "rep_named", "seq2", "seq2_along"
#&gt;                 )), list(title = "Attributes", contents = c("set_names", 
#&gt;             "names2", "has_name", "is_named")), list(title = "Type predicates", 
#&gt;                 contents = c("is_list", "is_atomic", "is_vector", 
#&gt;                 "is_integer", "is_double", "is_character", "is_logical", 
#&gt;                 "is_raw", "is_bytes", "is_scalar_list", "is_scalar_atomic", 
#&gt;                 "is_scalar_vector", "is_scalar_integer", "is_scalar_double", 
#&gt;                 "is_scalar_character", "is_scalar_logical", "is_scalar_raw", 
#&gt;                 "is_scalar_bytes", "is_bare_list", "is_bare_atomic", 
#&gt;                 "is_bare_vector", "is_bare_double", "is_bare_integer", 
#&gt;                 "is_bare_numeric", "is_bare_character", "is_bare_logical", 
#&gt;                 "is_bare_raw", "is_bare_bytes", "is_empty", "is_integerish", 
#&gt;                 "is_bare_integerish", "is_scalar_integerish", 
#&gt;                 "is_null", "is_true", "is_false", "is_string", 
#&gt;                 "is_bool", "is_bare_string")), list(title = "Operators", 
#&gt;                 contents = c("`%||%`", "`%|%`", "`%@%`")), list(
#&gt;                 title = "Function arguments", contents = c("arg_match", 
#&gt;                 "missing_arg", "is_missing", "maybe_missing")), 
#&gt;             list(title = "Create tidy evaluation APIs", desc = "Create data masking APIs à-la dplyr or tidyr. These functions are meant for developers rather than users.\n", 
#&gt;                 contents = c("`tidyeval-data`", "eval_tidy", 
#&gt;                 "as_data_mask", "new_data_mask", "as_data_pronoun"
#&gt;                 )), list(title = "Condition handlers", contents = c("with_handlers", 
#&gt;             "calling")), list(title = "Session state", contents = c("matches(\"interactive\")", 
#&gt;             "matches(\"option\")")), list(title = "Weak references", 
#&gt;                 contents = c("matches(\"weakref\")", "matches(\"wref\")"
#&gt;                 ))), destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     figures = list(dev = "grDevices::png", dpi = 96L, dev.args = list(), 
#&gt;         fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, 
#&gt;         fig.retina = 2L, fig.asp = 0.618046971569839), development = list(
#&gt;         destination = "dev", mode = "release", version_label = "default", 
#&gt;         version_tooltip = "Released version", in_dev = FALSE), 
#&gt;     topics = list(name = c("abort", "are_na", "arg_match", "as_box", 
#&gt;     "as_bytes", "as_data_mask", "as_env", "as_environment", "as_function", 
#&gt;     "as_label", "as_name", "as_overscope", "as_pairlist", "as_quosure", 
#&gt;     "as_string", "as_utf8_character", "bare-type-predicates", 
#&gt;     "box", "call2", "call_args", "call_fn", "call_inspect", "call_modify", 
#&gt;     "call_name", "call_standardise", "caller_env", "caller_fn", 
#&gt;     "caller_frame", "catch_cnd", "chr_unserialise_unicode", "error_cnd", 
#&gt;     "cnd_message", "cnd_muffle", "cnd_signal", "cnd_type", "done", 
#&gt;     "dots_definitions", "dots_n", "dots_values", "duplicate", 
#&gt;     "empty_env", "entrace", "env", "env_bind", "env_bind_exprs", 
#&gt;     "env_binding_are_active", "env_binding_lock", "env_bury", 
#&gt;     "env_clone", "env_depth", "env_get", "env_has", "env_inherits", 
#&gt;     "env_lock", "env_name", "env_names", "env_parent", "env_poke", 
#&gt;     "env_print", "env_unbind", "env_unlock", "eval_bare", "eval_tidy", 
#&gt;     "exec", "exiting", "expr_interp", "expr_label", "expr_print", 
#&gt;     "exprs_auto_name", "f_rhs", "f_text", "flatten", "fn_body", 
#&gt;     "fn_env", "fn_fmls", "frame_position", "friendly_type", "get_env", 
#&gt;     "has_length", "has_name", "inherits_any", "invoke", "is_call", 
#&gt;     "is_callable", "is_condition", "is_copyable", "is_empty", 
#&gt;     "is_env", "is_environment", "is_expr", "is_expression", "is_formula", 
#&gt;     "is_frame", "is_function", "is_installed", "is_integerish", 
#&gt;     "is_interactive", "is_lang", "is_named", "is_namespace", 
#&gt;     "is_pairlist", "is_reference", "is_stack", "is_symbol", "is_true", 
#&gt;     "is_weakref", "lang", "lang_head", "lang_modify", "last_error", 
#&gt;     "lifecycle", "missing", "missing_arg", "mut_node_car", "names2", 
#&gt;     "new-vector-along-retired", "new-vector", "new_call", "new_formula", 
#&gt;     "new_function", "new_node", "new_quosures", "new_weakref", 
#&gt;     "ns_env", "op-definition", "op-get-attr", "op-na-default", 
#&gt;     "op-null-default", "overscope_eval_next", "pairlist2", "parse_expr", 
#&gt;     "parse_quosure", "prepend", "prim_name", "quasiquotation", 
#&gt;     "quo_expr", "quo_label", "quo_squash", "quosure", "quotation", 
#&gt;     "rep_along", "restarting", "return_from", "rlang_backtrace_on_error", 
#&gt;     "rst_abort", "rst_list", "scalar-type-predicates", "scoped_bindings", 
#&gt;     "scoped_env", "scoped_options", "search_envs", "seq2", "set_attrs", 
#&gt;     "set_expr", "set_names", "splice", "stack", "stack_trim", 
#&gt;     "string", "switch_type", "sym", "tidy-dots", "tidyeval-data", 
#&gt;     "trace_back", "type-predicates", "type_of", "vec_poke_n", 
#&gt;     "vector-coercion", "vector-construction", "node", "with_abort", 
#&gt;     "with_env", "with_handlers", "with_restarts", "wref_key", 
#&gt;     "zap"), file_in = c("abort.Rd", "are_na.Rd", "arg_match.Rd", 
#&gt;     "as_box.Rd", "as_bytes.Rd", "as_data_mask.Rd", "as_env.Rd", 
#&gt;     "as_environment.Rd", "as_function.Rd", "as_label.Rd", "as_name.Rd", 
#&gt;     "as_overscope.Rd", "as_pairlist.Rd", "as_quosure.Rd", "as_string.Rd", 
#&gt;     "as_utf8_character.Rd", "bare-type-predicates.Rd", "box.Rd", 
#&gt;     "call2.Rd", "call_args.Rd", "call_fn.Rd", "call_inspect.Rd", 
#&gt;     "call_modify.Rd", "call_name.Rd", "call_standardise.Rd", 
#&gt;     "caller_env.Rd", "caller_fn.Rd", "caller_frame.Rd", "catch_cnd.Rd", 
#&gt;     "chr_unserialise_unicode.Rd", "cnd.Rd", "cnd_message.Rd", 
#&gt;     "cnd_muffle.Rd", "cnd_signal.Rd", "cnd_type.Rd", "done.Rd", 
#&gt;     "dots_definitions.Rd", "dots_n.Rd", "dots_values.Rd", "duplicate.Rd", 
#&gt;     "empty_env.Rd", "entrace.Rd", "env.Rd", "env_bind.Rd", "env_bind_exprs.Rd", 
#&gt;     "env_binding_are_active.Rd", "env_binding_lock.Rd", "env_bury.Rd", 
#&gt;     "env_clone.Rd", "env_depth.Rd", "env_get.Rd", "env_has.Rd", 
#&gt;     "env_inherits.Rd", "env_lock.Rd", "env_name.Rd", "env_names.Rd", 
#&gt;     "env_parent.Rd", "env_poke.Rd", "env_print.Rd", "env_unbind.Rd", 
#&gt;     "env_unlock.Rd", "eval_bare.Rd", "eval_tidy.Rd", "exec.Rd", 
#&gt;     "exiting.Rd", "expr_interp.Rd", "expr_label.Rd", "expr_print.Rd", 
#&gt;     "exprs_auto_name.Rd", "f_rhs.Rd", "f_text.Rd", "flatten.Rd", 
#&gt;     "fn_body.Rd", "fn_env.Rd", "fn_fmls.Rd", "frame_position.Rd", 
#&gt;     "friendly_type.Rd", "get_env.Rd", "has_length.Rd", "has_name.Rd", 
#&gt;     "inherits_any.Rd", "invoke.Rd", "is_call.Rd", "is_callable.Rd", 
#&gt;     "is_condition.Rd", "is_copyable.Rd", "is_empty.Rd", "is_env.Rd", 
#&gt;     "is_environment.Rd", "is_expr.Rd", "is_expression.Rd", "is_formula.Rd", 
#&gt;     "is_frame.Rd", "is_function.Rd", "is_installed.Rd", "is_integerish.Rd", 
#&gt;     "is_interactive.Rd", "is_lang.Rd", "is_named.Rd", "is_namespace.Rd", 
#&gt;     "is_pairlist.Rd", "is_reference.Rd", "is_stack.Rd", "is_symbol.Rd", 
#&gt;     "is_true.Rd", "is_weakref.Rd", "lang.Rd", "lang_head.Rd", 
#&gt;     "lang_modify.Rd", "last_error.Rd", "lifecycle.Rd", "missing.Rd", 
#&gt;     "missing_arg.Rd", "mut_node_car.Rd", "names2.Rd", "new-vector-along-retired.Rd", 
#&gt;     "new-vector.Rd", "new_call.Rd", "new_formula.Rd", "new_function.Rd", 
#&gt;     "new_node.Rd", "new_quosures.Rd", "new_weakref.Rd", "ns_env.Rd", 
#&gt;     "op-definition.Rd", "op-get-attr.Rd", "op-na-default.Rd", 
#&gt;     "op-null-default.Rd", "overscope_eval_next.Rd", "pairlist2.Rd", 
#&gt;     "parse_expr.Rd", "parse_quosure.Rd", "prepend.Rd", "prim_name.Rd", 
#&gt;     "quasiquotation.Rd", "quo_expr.Rd", "quo_label.Rd", "quo_squash.Rd", 
#&gt;     "quosure.Rd", "quotation.Rd", "rep_along.Rd", "restarting.Rd", 
#&gt;     "return_from.Rd", "rlang_backtrace_on_error.Rd", "rst_abort.Rd", 
#&gt;     "rst_list.Rd", "scalar-type-predicates.Rd", "scoped_bindings.Rd", 
#&gt;     "scoped_env.Rd", "scoped_options.Rd", "search_envs.Rd", "seq2.Rd", 
#&gt;     "set_attrs.Rd", "set_expr.Rd", "set_names.Rd", "splice.Rd", 
#&gt;     "stack.Rd", "stack_trim.Rd", "string.Rd", "switch_type.Rd", 
#&gt;     "sym.Rd", "tidy-dots.Rd", "tidyeval-data.Rd", "trace_back.Rd", 
#&gt;     "type-predicates.Rd", "type_of.Rd", "vec_poke_n.Rd", "vector-coercion.Rd", 
#&gt;     "vector-construction.Rd", "vector-old-ctors.Rd", "with_abort.Rd", 
#&gt;     "with_env.Rd", "with_handlers.Rd", "with_restarts.Rd", "wref_key.Rd", 
#&gt;     "zap.Rd"), file_out = c("abort.html", "are_na.html", "arg_match.html", 
#&gt;     "as_box.html", "as_bytes.html", "as_data_mask.html", "as_env.html", 
#&gt;     "as_environment.html", "as_function.html", "as_label.html", 
#&gt;     "as_name.html", "as_overscope.html", "as_pairlist.html", 
#&gt;     "as_quosure.html", "as_string.html", "as_utf8_character.html", 
#&gt;     "bare-type-predicates.html", "box.html", "call2.html", "call_args.html", 
#&gt;     "call_fn.html", "call_inspect.html", "call_modify.html", 
#&gt;     "call_name.html", "call_standardise.html", "caller_env.html", 
#&gt;     "caller_fn.html", "caller_frame.html", "catch_cnd.html", 
#&gt;     "chr_unserialise_unicode.html", "cnd.html", "cnd_message.html", 
#&gt;     "cnd_muffle.html", "cnd_signal.html", "cnd_type.html", "done.html", 
#&gt;     "dots_definitions.html", "dots_n.html", "dots_values.html", 
#&gt;     "duplicate.html", "empty_env.html", "entrace.html", "env.html", 
#&gt;     "env_bind.html", "env_bind_exprs.html", "env_binding_are_active.html", 
#&gt;     "env_binding_lock.html", "env_bury.html", "env_clone.html", 
#&gt;     "env_depth.html", "env_get.html", "env_has.html", "env_inherits.html", 
#&gt;     "env_lock.html", "env_name.html", "env_names.html", "env_parent.html", 
#&gt;     "env_poke.html", "env_print.html", "env_unbind.html", "env_unlock.html", 
#&gt;     "eval_bare.html", "eval_tidy.html", "exec.html", "exiting.html", 
#&gt;     "expr_interp.html", "expr_label.html", "expr_print.html", 
#&gt;     "exprs_auto_name.html", "f_rhs.html", "f_text.html", "flatten.html", 
#&gt;     "fn_body.html", "fn_env.html", "fn_fmls.html", "frame_position.html", 
#&gt;     "friendly_type.html", "get_env.html", "has_length.html", 
#&gt;     "has_name.html", "inherits_any.html", "invoke.html", "is_call.html", 
#&gt;     "is_callable.html", "is_condition.html", "is_copyable.html", 
#&gt;     "is_empty.html", "is_env.html", "is_environment.html", "is_expr.html", 
#&gt;     "is_expression.html", "is_formula.html", "is_frame.html", 
#&gt;     "is_function.html", "is_installed.html", "is_integerish.html", 
#&gt;     "is_interactive.html", "is_lang.html", "is_named.html", "is_namespace.html", 
#&gt;     "is_pairlist.html", "is_reference.html", "is_stack.html", 
#&gt;     "is_symbol.html", "is_true.html", "is_weakref.html", "lang.html", 
#&gt;     "lang_head.html", "lang_modify.html", "last_error.html", 
#&gt;     "lifecycle.html", "missing.html", "missing_arg.html", "mut_node_car.html", 
#&gt;     "names2.html", "new-vector-along-retired.html", "new-vector.html", 
#&gt;     "new_call.html", "new_formula.html", "new_function.html", 
#&gt;     "new_node.html", "new_quosures.html", "new_weakref.html", 
#&gt;     "ns_env.html", "op-definition.html", "op-get-attr.html", 
#&gt;     "op-na-default.html", "op-null-default.html", "overscope_eval_next.html", 
#&gt;     "pairlist2.html", "parse_expr.html", "parse_quosure.html", 
#&gt;     "prepend.html", "prim_name.html", "quasiquotation.html", 
#&gt;     "quo_expr.html", "quo_label.html", "quo_squash.html", "quosure.html", 
#&gt;     "quotation.html", "rep_along.html", "restarting.html", "return_from.html", 
#&gt;     "rlang_backtrace_on_error.html", "rst_abort.html", "rst_list.html", 
#&gt;     "scalar-type-predicates.html", "scoped_bindings.html", "scoped_env.html", 
#&gt;     "scoped_options.html", "search_envs.html", "seq2.html", "set_attrs.html", 
#&gt;     "set_expr.html", "set_names.html", "splice.html", "stack.html", 
#&gt;     "stack_trim.html", "string.html", "switch_type.html", "sym.html", 
#&gt;     "tidy-dots.html", "tidyeval-data.html", "trace_back.html", 
#&gt;     "type-predicates.html", "type_of.html", "vec_poke_n.html", 
#&gt;     "vector-coercion.html", "vector-construction.html", "vector-old-ctors.html", 
#&gt;     "with_abort.html", "with_env.html", "with_handlers.html", 
#&gt;     "with_restarts.html", "wref_key.html", "zap.html"), alias = list(
#&gt;         abort.Rd = c("abort", "warn", "inform", "signal", "interrupt"
#&gt;         ), are_na.Rd = c("are_na", "is_na", "is_lgl_na", "is_int_na", 
#&gt;         "is_dbl_na", "is_chr_na", "is_cpl_na"), arg_match.Rd = "arg_match", 
#&gt;         as_box.Rd = c("as_box", "as_box_if"), as_bytes.Rd = "as_bytes", 
#&gt;         as_data_mask.Rd = c("as_data_mask", "as_data_pronoun", 
#&gt;         "new_data_mask"), as_env.Rd = "as_env", as_environment.Rd = "as_environment", 
#&gt;         as_function.Rd = c("as_function", "is_lambda", "as_closure"
#&gt;         ), as_label.Rd = "as_label", as_name.Rd = "as_name", 
#&gt;         as_overscope.Rd = c("as_overscope", "new_overscope", 
#&gt;         "overscope_clean"), as_pairlist.Rd = "as_pairlist", as_quosure.Rd = c("as_quosure", 
#&gt;         "new_quosure"), as_string.Rd = "as_string", as_utf8_character.Rd = "as_utf8_character", 
#&gt;         `bare-type-predicates.Rd` = c("bare-type-predicates", 
#&gt;         "is_bare_list", "is_bare_atomic", "is_bare_vector", "is_bare_double", 
#&gt;         "is_bare_integer", "is_bare_numeric", "is_bare_character", 
#&gt;         "is_bare_logical", "is_bare_raw", "is_bare_string", "is_bare_bytes"
#&gt;         ), box.Rd = c("box", "new_box", "is_box", "unbox"), call2.Rd = "call2", 
#&gt;         call_args.Rd = c("call_args", "call_args_names"), call_fn.Rd = "call_fn", 
#&gt;         call_inspect.Rd = "call_inspect", call_modify.Rd = "call_modify", 
#&gt;         call_name.Rd = c("call_name", "call_ns"), call_standardise.Rd = "call_standardise", 
#&gt;         caller_env.Rd = c("caller_env", "current_env"), caller_fn.Rd = c("caller_fn", 
#&gt;         "current_fn"), caller_frame.Rd = "caller_frame", catch_cnd.Rd = "catch_cnd", 
#&gt;         chr_unserialise_unicode.Rd = "chr_unserialise_unicode", 
#&gt;         cnd.Rd = c("error_cnd", "cnd", "warning_cnd", "message_cnd"
#&gt;         ), cnd_message.Rd = c("cnd_message", "cnd_issue", "cnd_bullets", 
#&gt;         "format_bullets"), cnd_muffle.Rd = "cnd_muffle", cnd_signal.Rd = "cnd_signal", 
#&gt;         cnd_type.Rd = "cnd_type", done.Rd = c("done", "is_done_box"
#&gt;         ), dots_definitions.Rd = "dots_definitions", dots_n.Rd = "dots_n", 
#&gt;         dots_values.Rd = "dots_values", duplicate.Rd = "duplicate", 
#&gt;         empty_env.Rd = "empty_env", entrace.Rd = c("entrace", 
#&gt;         "cnd_entrace"), env.Rd = c("env", "child_env", "new_environment"
#&gt;         ), env_bind.Rd = c("env_bind", "env_bind_lazy", "env_bind_active"
#&gt;         ), env_bind_exprs.Rd = c("env_bind_exprs", "env_bind_fns"
#&gt;         ), env_binding_are_active.Rd = c("env_binding_are_active", 
#&gt;         "env_binding_are_lazy"), env_binding_lock.Rd = c("env_binding_lock", 
#&gt;         "env_binding_unlock", "env_binding_are_locked"), env_bury.Rd = "env_bury", 
#&gt;         env_clone.Rd = "env_clone", env_depth.Rd = "env_depth", 
#&gt;         env_get.Rd = c("env_get", "env_get_list"), env_has.Rd = "env_has", 
#&gt;         env_inherits.Rd = "env_inherits", env_lock.Rd = c("env_lock", 
#&gt;         "env_is_locked"), env_name.Rd = c("env_name", "env_label"
#&gt;         ), env_names.Rd = c("env_names", "env_length"), env_parent.Rd = c("env_parent", 
#&gt;         "env_tail", "env_parents"), env_poke.Rd = "env_poke", 
#&gt;         env_print.Rd = "env_print", env_unbind.Rd = "env_unbind", 
#&gt;         env_unlock.Rd = "env_unlock", eval_bare.Rd = "eval_bare", 
#&gt;         eval_tidy.Rd = "eval_tidy", exec.Rd = "exec", exiting.Rd = "exiting", 
#&gt;         expr_interp.Rd = "expr_interp", expr_label.Rd = c("expr_label", 
#&gt;         "expr_name", "expr_text"), expr_print.Rd = c("expr_print", 
#&gt;         "expr_deparse"), exprs_auto_name.Rd = c("exprs_auto_name", 
#&gt;         "quos_auto_name"), f_rhs.Rd = c("f_rhs", "f_rhs&lt;-", "f_lhs", 
#&gt;         "f_lhs&lt;-", "f_env", "f_env&lt;-"), f_text.Rd = c("f_text", 
#&gt;         "f_name", "f_label"), flatten.Rd = c("flatten", "flatten_lgl", 
#&gt;         "flatten_int", "flatten_dbl", "flatten_cpl", "flatten_chr", 
#&gt;         "flatten_raw", "squash", "squash_lgl", "squash_int", 
#&gt;         "squash_dbl", "squash_cpl", "squash_chr", "squash_raw", 
#&gt;         "flatten_if", "squash_if"), fn_body.Rd = c("fn_body", 
#&gt;         "fn_body&lt;-"), fn_env.Rd = c("fn_env", "fn_env&lt;-"), fn_fmls.Rd = c("fn_fmls", 
#&gt;         "fn_fmls_names", "fn_fmls_syms", "fn_fmls&lt;-", "fn_fmls_names&lt;-"
#&gt;         ), frame_position.Rd = "frame_position", friendly_type.Rd = "friendly_type", 
#&gt;         get_env.Rd = c("get_env", "set_env", "env_poke_parent"
#&gt;         ), has_length.Rd = "has_length", has_name.Rd = "has_name", 
#&gt;         inherits_any.Rd = c("inherits_any", "inherits_all", "inherits_only"
#&gt;         ), invoke.Rd = "invoke", is_call.Rd = "is_call", is_callable.Rd = "is_callable", 
#&gt;         is_condition.Rd = "is_condition", is_copyable.Rd = "is_copyable", 
#&gt;         is_empty.Rd = "is_empty", is_env.Rd = c("is_env", "is_bare_env"
#&gt;         ), is_environment.Rd = c("is_environment", "is_bare_environment"
#&gt;         ), is_expr.Rd = "is_expr", is_expression.Rd = c("is_expression", 
#&gt;         "is_syntactic_literal", "is_symbolic"), is_formula.Rd = c("is_formula", 
#&gt;         "is_bare_formula"), is_frame.Rd = "is_frame", is_function.Rd = c("is_function", 
#&gt;         "is_closure", "is_primitive", "is_primitive_eager", "is_primitive_lazy"
#&gt;         ), is_installed.Rd = "is_installed", is_integerish.Rd = c("is_integerish", 
#&gt;         "is_bare_integerish", "is_scalar_integerish"), is_interactive.Rd = c("is_interactive", 
#&gt;         "scoped_interactive", "with_interactive"), is_lang.Rd = c("is_lang", 
#&gt;         "is_unary_lang", "is_binary_lang", "quo_is_lang"), is_named.Rd = c("is_named", 
#&gt;         "is_dictionaryish", "have_name"), is_namespace.Rd = "is_namespace", 
#&gt;         is_pairlist.Rd = c("is_pairlist", "is_node", "is_node_list"
#&gt;         ), is_reference.Rd = "is_reference", is_stack.Rd = c("is_stack", 
#&gt;         "is_eval_stack", "is_call_stack"), is_symbol.Rd = "is_symbol", 
#&gt;         is_true.Rd = c("is_true", "is_false"), is_weakref.Rd = "is_weakref", 
#&gt;         lang.Rd = c("lang", "new_language"), lang_head.Rd = c("lang_head", 
#&gt;         "lang_tail"), lang_modify.Rd = c("lang_modify", "lang_standardise", 
#&gt;         "lang_fn", "lang_name", "lang_args", "lang_args_names"
#&gt;         ), last_error.Rd = c("last_error", "last_trace"), lifecycle.Rd = "lifecycle", 
#&gt;         missing.Rd = c("missing", "na_lgl", "na_int", "na_dbl", 
#&gt;         "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg", 
#&gt;         "is_missing", "maybe_missing"), mut_node_car.Rd = c("mut_node_car", 
#&gt;         "mut_node_cdr", "mut_node_caar", "mut_node_cadr", "mut_node_cdar", 
#&gt;         "mut_node_cddr", "mut_node_tag"), names2.Rd = "names2", 
#&gt;         `new-vector-along-retired.Rd` = c("new-vector-along-retired", 
#&gt;         "new_logical_along", "new_integer_along", "new_double_along", 
#&gt;         "new_character_along", "new_complex_along", "new_raw_along", 
#&gt;         "new_list_along"), `new-vector.Rd` = c("new-vector", 
#&gt;         "new_logical", "new_integer", "new_double", "new_character", 
#&gt;         "new_complex", "new_raw", "new_list"), new_call.Rd = "new_call", 
#&gt;         new_formula.Rd = "new_formula", new_function.Rd = "new_function", 
#&gt;         new_node.Rd = c("new_node", "node_car", "node_cdr", "node_caar", 
#&gt;         "node_cadr", "node_cdar", "node_cddr", "node_poke_car", 
#&gt;         "node_poke_cdr", "node_poke_caar", "node_poke_cadr", 
#&gt;         "node_poke_cdar", "node_poke_cddr", "node_tag", "node_poke_tag"
#&gt;         ), new_quosures.Rd = c("new_quosures", "as_quosures", 
#&gt;         "is_quosures"), new_weakref.Rd = "new_weakref", ns_env.Rd = c("ns_env", 
#&gt;         "ns_imports_env", "ns_env_name"), `op-definition.Rd` = c("op-definition", 
#&gt;         "is_definition", "new_definition", "is_formulaish"), 
#&gt;         `op-get-attr.Rd` = c("op-get-attr", "%@%", "%@%&lt;-"), 
#&gt;         `op-na-default.Rd` = c("op-na-default", "%|%"), `op-null-default.Rd` = c("op-null-default", 
#&gt;         "%||%"), overscope_eval_next.Rd = "overscope_eval_next", 
#&gt;         pairlist2.Rd = "pairlist2", parse_expr.Rd = c("parse_expr", 
#&gt;         "parse_exprs", "parse_quo", "parse_quos"), parse_quosure.Rd = c("parse_quosure", 
#&gt;         "parse_quosures"), prepend.Rd = c("prepend", "modify"
#&gt;         ), prim_name.Rd = "prim_name", quasiquotation.Rd = c("quasiquotation", 
#&gt;         "UQ", "UQS", "{{}}", "{{", "!!", "!!!", ":=", "qq_show"
#&gt;         ), quo_expr.Rd = "quo_expr", quo_label.Rd = c("quo_label", 
#&gt;         "quo_text", "quo_name"), quo_squash.Rd = "quo_squash", 
#&gt;         quosure.Rd = c("quosure", "is_quosure", "quo_is_missing", 
#&gt;         "quo_is_symbol", "quo_is_call", "quo_is_symbolic", "quo_is_null", 
#&gt;         "quo_get_expr", "quo_get_env", "quo_set_expr", "quo_set_env"
#&gt;         ), quotation.Rd = c("quotation", "expr", "enexpr", "exprs", 
#&gt;         "enexprs", "ensym", "ensyms", "quo", "enquo", "quos", 
#&gt;         "enquos"), rep_along.Rd = c("rep_along", "rep_named"), 
#&gt;         restarting.Rd = "restarting", return_from.Rd = c("return_from", 
#&gt;         "return_to"), rlang_backtrace_on_error.Rd = c("rlang_backtrace_on_error", 
#&gt;         "add_backtrace"), rst_abort.Rd = "rst_abort", rst_list.Rd = c("rst_list", 
#&gt;         "rst_exists", "rst_jump", "rst_maybe_jump"), `scalar-type-predicates.Rd` = c("scalar-type-predicates", 
#&gt;         "is_scalar_list", "is_scalar_atomic", "is_scalar_vector", 
#&gt;         "is_scalar_integer", "is_scalar_double", "is_scalar_character", 
#&gt;         "is_scalar_logical", "is_scalar_raw", "is_string", "is_scalar_bytes", 
#&gt;         "is_bool"), scoped_bindings.Rd = c("scoped_bindings", 
#&gt;         "with_bindings"), scoped_env.Rd = c("scoped_env", "is_scoped", 
#&gt;         "scoped_envs", "scoped_names"), scoped_options.Rd = c("scoped_options", 
#&gt;         "with_options", "push_options", "peek_options", "peek_option"
#&gt;         ), search_envs.Rd = c("search_envs", "search_env", "pkg_env", 
#&gt;         "pkg_env_name", "is_attached", "base_env", "global_env"
#&gt;         ), seq2.Rd = c("seq2", "seq2_along"), set_attrs.Rd = c("set_attrs", 
#&gt;         "mut_attrs"), set_expr.Rd = c("set_expr", "get_expr"), 
#&gt;         set_names.Rd = "set_names", splice.Rd = c("splice", "is_spliced", 
#&gt;         "is_spliced_bare", "dots_splice"), stack.Rd = c("stack", 
#&gt;         "global_frame", "current_frame", "ctxt_frame", "call_frame", 
#&gt;         "ctxt_depth", "call_depth", "ctxt_stack", "call_stack"
#&gt;         ), stack_trim.Rd = "stack_trim", string.Rd = "string", 
#&gt;         switch_type.Rd = c("switch_type", "coerce_type", "switch_class", 
#&gt;         "coerce_class"), sym.Rd = c("sym", "syms"), `tidy-dots.Rd` = c("tidy-dots", 
#&gt;         "dots_list", "list2"), `tidyeval-data.Rd` = c("tidyeval-data", 
#&gt;         ".data"), trace_back.Rd = c("trace_back", "trace_length"
#&gt;         ), `type-predicates.Rd` = c("type-predicates", "is_list", 
#&gt;         "is_atomic", "is_vector", "is_integer", "is_double", 
#&gt;         "is_character", "is_logical", "is_raw", "is_bytes", "is_null"
#&gt;         ), type_of.Rd = "type_of", vec_poke_n.Rd = c("vec_poke_n", 
#&gt;         "vec_poke_range"), `vector-coercion.Rd` = c("vector-coercion", 
#&gt;         "as_logical", "as_integer", "as_double", "as_complex", 
#&gt;         "as_character", "as_list"), `vector-construction.Rd` = c("vector-construction", 
#&gt;         "lgl", "int", "dbl", "cpl", "chr", "bytes", "ll"), `vector-old-ctors.Rd` = c("node", 
#&gt;         "vector-old-ctors", "lgl_len", "int_len", "dbl_len", 
#&gt;         "chr_len", "cpl_len", "raw_len", "bytes_len", "list_len", 
#&gt;         "lgl_along", "int_along", "dbl_along", "chr_along", "cpl_along", 
#&gt;         "raw_along", "bytes_along", "list_along"), with_abort.Rd = "with_abort", 
#&gt;         with_env.Rd = c("with_env", "locally"), with_handlers.Rd = c("with_handlers", 
#&gt;         "calling"), with_restarts.Rd = "with_restarts", wref_key.Rd = c("wref_key", 
#&gt;         "wref_value"), zap.Rd = c("zap", "is_zap")), funs = list(
#&gt;         abort.Rd = c("abort()", "warn()", "inform()", "signal()", 
#&gt;         "interrupt()"), are_na.Rd = c("are_na()", "is_na()", 
#&gt;         "is_lgl_na()", "is_int_na()", "is_dbl_na()", "is_chr_na()", 
#&gt;         "is_cpl_na()"), arg_match.Rd = "arg_match()", as_box.Rd = c("as_box()", 
#&gt;         "as_box_if()"), as_bytes.Rd = "as_bytes()", as_data_mask.Rd = c("as_data_mask()", 
#&gt;         "as_data_pronoun()", "new_data_mask()"), as_env.Rd = "as_env()", 
#&gt;         as_environment.Rd = "as_environment()", as_function.Rd = c("as_function()", 
#&gt;         "is_lambda()", "as_closure()"), as_label.Rd = "as_label()", 
#&gt;         as_name.Rd = "as_name()", as_overscope.Rd = c("as_overscope()", 
#&gt;         "new_overscope()", "overscope_clean()"), as_pairlist.Rd = "as_pairlist()", 
#&gt;         as_quosure.Rd = c("as_quosure()", "new_quosure()"), as_string.Rd = "as_string()", 
#&gt;         as_utf8_character.Rd = "as_utf8_character()", `bare-type-predicates.Rd` = c("is_bare_list()", 
#&gt;         "is_bare_atomic()", "is_bare_vector()", "is_bare_double()", 
#&gt;         "is_bare_integer()", "is_bare_numeric()", "is_bare_character()", 
#&gt;         "is_bare_logical()", "is_bare_raw()", "is_bare_string()", 
#&gt;         "is_bare_bytes()"), box.Rd = c("new_box()", "is_box()", 
#&gt;         "unbox()"), call2.Rd = "call2()", call_args.Rd = c("call_args()", 
#&gt;         "call_args_names()"), call_fn.Rd = "call_fn()", call_inspect.Rd = "call_inspect()", 
#&gt;         call_modify.Rd = "call_modify()", call_name.Rd = c("call_name()", 
#&gt;         "call_ns()"), call_standardise.Rd = "call_standardise()", 
#&gt;         caller_env.Rd = c("caller_env()", "current_env()"), caller_fn.Rd = c("caller_fn()", 
#&gt;         "current_fn()"), caller_frame.Rd = "caller_frame()", 
#&gt;         catch_cnd.Rd = "catch_cnd()", chr_unserialise_unicode.Rd = "chr_unserialise_unicode()", 
#&gt;         cnd.Rd = c("error_cnd()", "cnd()", "warning_cnd()", "message_cnd()"
#&gt;         ), cnd_message.Rd = c("cnd_message()", "cnd_issue()", 
#&gt;         "cnd_bullets()", "format_bullets()"), cnd_muffle.Rd = "cnd_muffle()", 
#&gt;         cnd_signal.Rd = "cnd_signal()", cnd_type.Rd = "cnd_type()", 
#&gt;         done.Rd = c("done()", "is_done_box()"), dots_definitions.Rd = "dots_definitions()", 
#&gt;         dots_n.Rd = "dots_n()", dots_values.Rd = "dots_values()", 
#&gt;         duplicate.Rd = "duplicate()", empty_env.Rd = "empty_env()", 
#&gt;         entrace.Rd = c("entrace()", "cnd_entrace()"), env.Rd = c("env()", 
#&gt;         "child_env()", "new_environment()"), env_bind.Rd = c("env_bind()", 
#&gt;         "env_bind_lazy()", "env_bind_active()"), env_bind_exprs.Rd = c("env_bind_exprs()", 
#&gt;         "env_bind_fns()"), env_binding_are_active.Rd = c("env_binding_are_active()", 
#&gt;         "env_binding_are_lazy()"), env_binding_lock.Rd = c("env_binding_lock()", 
#&gt;         "env_binding_unlock()", "env_binding_are_locked()"), 
#&gt;         env_bury.Rd = "env_bury()", env_clone.Rd = "env_clone()", 
#&gt;         env_depth.Rd = "env_depth()", env_get.Rd = c("env_get()", 
#&gt;         "env_get_list()"), env_has.Rd = "env_has()", env_inherits.Rd = "env_inherits()", 
#&gt;         env_lock.Rd = c("env_lock()", "env_is_locked()"), env_name.Rd = c("env_name()", 
#&gt;         "env_label()"), env_names.Rd = c("env_names()", "env_length()"
#&gt;         ), env_parent.Rd = c("env_parent()", "env_tail()", "env_parents()"
#&gt;         ), env_poke.Rd = "env_poke()", env_print.Rd = "env_print()", 
#&gt;         env_unbind.Rd = "env_unbind()", env_unlock.Rd = "env_unlock()", 
#&gt;         eval_bare.Rd = "eval_bare()", eval_tidy.Rd = "eval_tidy()", 
#&gt;         exec.Rd = "exec()", exiting.Rd = "exiting()", expr_interp.Rd = "expr_interp()", 
#&gt;         expr_label.Rd = c("expr_label()", "expr_name()", "expr_text()"
#&gt;         ), expr_print.Rd = c("expr_print()", "expr_deparse()"
#&gt;         ), exprs_auto_name.Rd = c("exprs_auto_name()", "quos_auto_name()"
#&gt;         ), f_rhs.Rd = c("f_rhs()", "`f_rhs&lt;-`()", "f_lhs()", 
#&gt;         "`f_lhs&lt;-`()", "f_env()", "`f_env&lt;-`()"), f_text.Rd = c("f_text()", 
#&gt;         "f_name()", "f_label()"), flatten.Rd = c("flatten()", 
#&gt;         "flatten_lgl()", "flatten_int()", "flatten_dbl()", "flatten_cpl()", 
#&gt;         "flatten_chr()", "flatten_raw()", "squash()", "squash_lgl()", 
#&gt;         "squash_int()", "squash_dbl()", "squash_cpl()", "squash_chr()", 
#&gt;         "squash_raw()", "flatten_if()", "squash_if()"), fn_body.Rd = c("fn_body()", 
#&gt;         "`fn_body&lt;-`()"), fn_env.Rd = c("fn_env()", "`fn_env&lt;-`()"
#&gt;         ), fn_fmls.Rd = c("fn_fmls()", "fn_fmls_names()", "fn_fmls_syms()", 
#&gt;         "`fn_fmls&lt;-`()", "`fn_fmls_names&lt;-`()"), frame_position.Rd = "frame_position()", 
#&gt;         friendly_type.Rd = "friendly_type()", get_env.Rd = c("get_env()", 
#&gt;         "set_env()", "env_poke_parent()"), has_length.Rd = "has_length()", 
#&gt;         has_name.Rd = "has_name()", inherits_any.Rd = c("inherits_any()", 
#&gt;         "inherits_all()", "inherits_only()"), invoke.Rd = "invoke()", 
#&gt;         is_call.Rd = "is_call()", is_callable.Rd = "is_callable()", 
#&gt;         is_condition.Rd = "is_condition()", is_copyable.Rd = "is_copyable()", 
#&gt;         is_empty.Rd = "is_empty()", is_env.Rd = c("is_env()", 
#&gt;         "is_bare_env()"), is_environment.Rd = c("is_environment()", 
#&gt;         "is_bare_environment()"), is_expr.Rd = "is_expr()", is_expression.Rd = c("is_expression()", 
#&gt;         "is_syntactic_literal()", "is_symbolic()"), is_formula.Rd = c("is_formula()", 
#&gt;         "is_bare_formula()"), is_frame.Rd = "is_frame()", is_function.Rd = c("is_function()", 
#&gt;         "is_closure()", "is_primitive()", "is_primitive_eager()", 
#&gt;         "is_primitive_lazy()"), is_installed.Rd = "is_installed()", 
#&gt;         is_integerish.Rd = c("is_integerish()", "is_bare_integerish()", 
#&gt;         "is_scalar_integerish()"), is_interactive.Rd = c("is_interactive()", 
#&gt;         "scoped_interactive()", "with_interactive()"), is_lang.Rd = c("is_lang()", 
#&gt;         "is_unary_lang()", "is_binary_lang()", "quo_is_lang()"
#&gt;         ), is_named.Rd = c("is_named()", "is_dictionaryish()", 
#&gt;         "have_name()"), is_namespace.Rd = "is_namespace()", is_pairlist.Rd = c("is_pairlist()", 
#&gt;         "is_node()", "is_node_list()"), is_reference.Rd = "is_reference()", 
#&gt;         is_stack.Rd = c("is_stack()", "is_eval_stack()", "is_call_stack()"
#&gt;         ), is_symbol.Rd = "is_symbol()", is_true.Rd = c("is_true()", 
#&gt;         "is_false()"), is_weakref.Rd = "is_weakref()", lang.Rd = c("lang()", 
#&gt;         "new_language()"), lang_head.Rd = c("lang_head()", "lang_tail()"
#&gt;         ), lang_modify.Rd = c("lang_modify()", "lang_standardise()", 
#&gt;         "lang_fn()", "lang_name()", "lang_args()", "lang_args_names()"
#&gt;         ), last_error.Rd = c("last_error()", "last_trace()"), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = c("na_lgl", 
#&gt;         "na_int", "na_dbl", "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg()", 
#&gt;         "is_missing()", "maybe_missing()"), mut_node_car.Rd = c("mut_node_car()", 
#&gt;         "mut_node_cdr()", "mut_node_caar()", "mut_node_cadr()", 
#&gt;         "mut_node_cdar()", "mut_node_cddr()", "mut_node_tag()"
#&gt;         ), names2.Rd = "names2()", `new-vector-along-retired.Rd` = c("new_logical_along()", 
#&gt;         "new_integer_along()", "new_double_along()", "new_character_along()", 
#&gt;         "new_complex_along()", "new_raw_along()", "new_list_along()"
#&gt;         ), `new-vector.Rd` = c("new_logical()", "new_integer()", 
#&gt;         "new_double()", "new_character()", "new_complex()", "new_raw()", 
#&gt;         "new_list()"), new_call.Rd = "new_call()", new_formula.Rd = "new_formula()", 
#&gt;         new_function.Rd = "new_function()", new_node.Rd = c("new_node()", 
#&gt;         "node_car()", "node_cdr()", "node_caar()", "node_cadr()", 
#&gt;         "node_cdar()", "node_cddr()", "node_poke_car()", "node_poke_cdr()", 
#&gt;         "node_poke_caar()", "node_poke_cadr()", "node_poke_cdar()", 
#&gt;         "node_poke_cddr()", "node_tag()", "node_poke_tag()"), 
#&gt;         new_quosures.Rd = c("new_quosures()", "as_quosures()", 
#&gt;         "is_quosures()"), new_weakref.Rd = "new_weakref()", ns_env.Rd = c("ns_env()", 
#&gt;         "ns_imports_env()", "ns_env_name()"), `op-definition.Rd` = c("is_definition()", 
#&gt;         "new_definition()", "is_formulaish()"), `op-get-attr.Rd` = c("`%@%`", 
#&gt;         "`%@%&lt;-`()"), `op-na-default.Rd` = "`%|%`", `op-null-default.Rd` = "`%||%`", 
#&gt;         overscope_eval_next.Rd = "overscope_eval_next()", pairlist2.Rd = "pairlist2()", 
#&gt;         parse_expr.Rd = c("parse_expr()", "parse_exprs()", "parse_quo()", 
#&gt;         "parse_quos()"), parse_quosure.Rd = c("parse_quosure()", 
#&gt;         "parse_quosures()"), prepend.Rd = c("prepend()", "modify()"
#&gt;         ), prim_name.Rd = "prim_name()", quasiquotation.Rd = "qq_show()", 
#&gt;         quo_expr.Rd = "quo_expr()", quo_label.Rd = c("quo_label()", 
#&gt;         "quo_text()", "quo_name()"), quo_squash.Rd = "quo_squash()", 
#&gt;         quosure.Rd = c("is_quosure()", "quo_is_missing()", "quo_is_symbol()", 
#&gt;         "quo_is_call()", "quo_is_symbolic()", "quo_is_null()", 
#&gt;         "quo_get_expr()", "quo_get_env()", "quo_set_expr()", 
#&gt;         "quo_set_env()"), quotation.Rd = c("expr()", "enexpr()", 
#&gt;         "exprs()", "enexprs()", "ensym()", "ensyms()", "quo()", 
#&gt;         "enquo()", "quos()", "enquos()"), rep_along.Rd = c("rep_along()", 
#&gt;         "rep_named()"), restarting.Rd = "restarting()", return_from.Rd = c("return_from()", 
#&gt;         "return_to()"), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = "rst_abort()", rst_list.Rd = c("rst_list()", 
#&gt;         "rst_exists()", "rst_jump()", "rst_maybe_jump()"), `scalar-type-predicates.Rd` = c("is_scalar_list()", 
#&gt;         "is_scalar_atomic()", "is_scalar_vector()", "is_scalar_integer()", 
#&gt;         "is_scalar_double()", "is_scalar_character()", "is_scalar_logical()", 
#&gt;         "is_scalar_raw()", "is_string()", "is_scalar_bytes()", 
#&gt;         "is_bool()"), scoped_bindings.Rd = c("scoped_bindings()", 
#&gt;         "with_bindings()"), scoped_env.Rd = c("scoped_env()", 
#&gt;         "is_scoped()", "scoped_envs()", "scoped_names()"), scoped_options.Rd = c("scoped_options()", 
#&gt;         "with_options()", "push_options()", "peek_options()", 
#&gt;         "peek_option()"), search_envs.Rd = c("search_envs()", 
#&gt;         "search_env()", "pkg_env()", "pkg_env_name()", "is_attached()", 
#&gt;         "base_env()", "global_env()"), seq2.Rd = c("seq2()", 
#&gt;         "seq2_along()"), set_attrs.Rd = c("set_attrs()", "mut_attrs()"
#&gt;         ), set_expr.Rd = c("set_expr()", "get_expr()"), set_names.Rd = "set_names()", 
#&gt;         splice.Rd = c("splice()", "is_spliced()", "is_spliced_bare()", 
#&gt;         "dots_splice()"), stack.Rd = c("global_frame()", "current_frame()", 
#&gt;         "ctxt_frame()", "call_frame()", "ctxt_depth()", "call_depth()", 
#&gt;         "ctxt_stack()", "call_stack()"), stack_trim.Rd = "stack_trim()", 
#&gt;         string.Rd = "string()", switch_type.Rd = c("switch_type()", 
#&gt;         "coerce_type()", "switch_class()", "coerce_class()"), 
#&gt;         sym.Rd = c("sym()", "syms()"), `tidy-dots.Rd` = c("dots_list()", 
#&gt;         "list2()"), `tidyeval-data.Rd` = ".data", trace_back.Rd = c("trace_back()", 
#&gt;         "trace_length()"), `type-predicates.Rd` = c("is_list()", 
#&gt;         "is_atomic()", "is_vector()", "is_integer()", "is_double()", 
#&gt;         "is_character()", "is_logical()", "is_raw()", "is_bytes()", 
#&gt;         "is_null()"), type_of.Rd = "type_of()", vec_poke_n.Rd = c("vec_poke_n()", 
#&gt;         "vec_poke_range()"), `vector-coercion.Rd` = c("as_logical()", 
#&gt;         "as_integer()", "as_double()", "as_complex()", "as_character()", 
#&gt;         "as_list()"), `vector-construction.Rd` = c("lgl()", "int()", 
#&gt;         "dbl()", "cpl()", "chr()", "bytes()"), `vector-old-ctors.Rd` = c("node()", 
#&gt;         "lgl_len()", "int_len()", "dbl_len()", "chr_len()", "cpl_len()", 
#&gt;         "raw_len()", "bytes_len()", "list_len()", "lgl_along()", 
#&gt;         "int_along()", "dbl_along()", "chr_along()", "cpl_along()", 
#&gt;         "raw_along()", "bytes_along()", "list_along()"), with_abort.Rd = "with_abort()", 
#&gt;         with_env.Rd = c("with_env()", "locally()"), with_handlers.Rd = c("with_handlers()", 
#&gt;         "calling()"), with_restarts.Rd = "with_restarts()", wref_key.Rd = c("wref_key()", 
#&gt;         "wref_value()"), zap.Rd = c("zap()", "is_zap()")), title = c("Signal an error, warning, or message", 
#&gt;     "Test for missing values", "Match an argument to a character vector", 
#&gt;     "Convert object to a box", "Coerce to a raw vector", "Create a data mask", 
#&gt;     "Coerce to an environment", "Coerce to an environment", "Convert to function or closure", 
#&gt;     "Create a default name for an R object", "Extract names from symbols", 
#&gt;     "Create an overscope", "Coerce to pairlist", "Coerce object to quosure", 
#&gt;     "Cast symbol to string", "Coerce to a character vector and attempt encoding conversion", 
#&gt;     "Bare type predicates", "Box a value", "Create a call", "Extract arguments from a call", 
#&gt;     "Extract function from a call", "Inspect a call", "Modify the arguments of a call", 
#&gt;     "Extract function name or namespaced of a call", "Standardise a call", 
#&gt;     "Get the current or caller environment", "Get properties of the current or caller frame", 
#&gt;     "Get caller frame", "Catch a condition", "Translate unicode points to UTF-8", 
#&gt;     "Create a condition object", "Build an error message from a main issue and bullet messages", 
#&gt;     "Muffle a condition", "Signal a condition object", "What type is a condition?", 
#&gt;     "Box a final value for early termination", "Capture definition objects", 
#&gt;     "How many arguments are currently forwarded in dots?", "Evaluate dots with preliminary splicing", 
#&gt;     "Duplicate an R object", "Get the empty environment", "Add backtrace from error handler", 
#&gt;     "Create a new environment", "Bind symbols to objects in an environment", 
#&gt;     "Bind a promise or active binding", "What kind of environment binding?", 
#&gt;     "Lock or unlock environment bindings", "Mask bindings by defining symbols deeper in a scope", 
#&gt;     "Clone an environment", "Depth of an environment chain", 
#&gt;     "Get an object in an environment", "Does an environment have or see bindings?", 
#&gt;     "Does environment inherit from another environment?", "Lock an environment", 
#&gt;     "Label of an environment", "Names and numbers of symbols bound in an environment", 
#&gt;     "Get parent environments", "Poke an object in an environment", 
#&gt;     "Pretty-print an environment", "Remove bindings from an environment", 
#&gt;     "Unlock an environment", "Evaluate an expression in an environment", 
#&gt;     "Evaluate an expression with quosures and pronoun support", 
#&gt;     "Execute a function", "Exiting handler", "Process unquote operators in a captured expression", 
#&gt;     "Turn an expression to a label", "Print an expression", "Ensure that all elements of a list of expressions are named", 
#&gt;     "Get or set formula components", "Turn RHS of formula into a string or label", 
#&gt;     "Flatten or squash a list of lists into a simpler vector", 
#&gt;     "Get or set function body", "Return the closure environment of a function", 
#&gt;     "Extract arguments from a function", "Find the position or distance of a frame on the evaluation stack", 
#&gt;     "Format a type for error messages", "Get or set the environment of an object", 
#&gt;     "How long is an object?", "Does an object have an element with this name?", 
#&gt;     "Does an object inherit from a set of classes?", "Invoke a function with a list of arguments", 
#&gt;     "Is object a call?", "Is an object callable?", "Is object a condition?", 
#&gt;     "Is an object copyable?", "Is object an empty vector or NULL?", 
#&gt;     "Is an object an environment?", "Is object an environment?", 
#&gt;     "Is an object an expression?", "Is an object an expression?", 
#&gt;     "Is object a formula?", "Is object a frame?", "Is object a function?", 
#&gt;     "Is a package installed in the library?", "Is a vector integer-like?", 
#&gt;     "Is R running interactively?", "Is object a call?", "Is object named?", 
#&gt;     "Is an object a namespace environment?", "Is object a node or pairlist?", 
#&gt;     "Is an object referencing another?", "Is object a stack?", 
#&gt;     "Is object a symbol?", "Is object identical to TRUE or FALSE?", 
#&gt;     "Is object a weak reference?", "Create a call", "Return the head or tail of a call", 
#&gt;     "Manipulate or access a call", "Last &lt;code&gt;abort()&lt;/code&gt; error", 
#&gt;     "Life cycle of the rlang package", "Missing values", "Generate or handle a missing argument", 
#&gt;     "Mutate node components", "Get names of a vector", "Create vectors matching the length of a given vector", 
#&gt;     "Create vectors matching a given length", "Create a new call from components", 
#&gt;     "Create a formula", "Create a function", "Helpers for pairlist and language nodes", 
#&gt;     "Create a list of quosures", "Create a weak reference", "Get the namespace of a package", 
#&gt;     "Definition operator", "Infix attribute accessor and setter", 
#&gt;     "Replace missing values", "Default value for &lt;code&gt;NULL&lt;/code&gt;", 
#&gt;     "Evaluate next quosure in a data mask", "Create pairlists with splicing support", 
#&gt;     "Parse R code", "Parse text into a quosure", "Prepend a vector", 
#&gt;     "Name of a primitive function", "Quasiquotation of an expression", 
#&gt;     "Squash a quosure", "Format quosures for printing or labelling", 
#&gt;     "Squash a quosure", "Quosure getters, setters and testers", 
#&gt;     "Quotation", "Create vectors matching the length of a given vector", 
#&gt;     "Create a restarting handler", "Jump to or from a frame", 
#&gt;     "Display backtrace on error", "Jump to the abort restart", 
#&gt;     "Restarts utilities", "Scalar type predicates", "Temporarily change bindings of an environment", 
#&gt;     "Retired &lt;code&gt;scoped&lt;/code&gt; functions", "Change global options", 
#&gt;     "Search path environments", "Increasing sequence of integers in an interval", 
#&gt;     "Add attributes to an object", "Set and get an expression", 
#&gt;     "Set names of a vector", "Splice lists", "Call stack information", 
#&gt;     "Trim top call layers from the evaluation stack", "Create a string", 
#&gt;     "Dispatch on base types", "Create a symbol or list of symbols", 
#&gt;     "Collect dots as lists", "Data pronoun for tidy evaluation", 
#&gt;     "Capture a backtrace", "Type predicates", "Base type of an object", 
#&gt;     "Poke values into a vector", "Coerce an object to a base type", 
#&gt;     "Create vectors", "Retired vector construction by length", 
#&gt;     "Promote all errors to rlang errors", "Evaluate an expression within a given environment", 
#&gt;     "Establish handlers on the stack", "Establish a restart point on the stack", 
#&gt;     "Get key/value from a weak reference object", "Create zap objects"
#&gt;     ), rd = list(abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/cnd-abort.R, R/cnd-signal.R", 
#&gt;         "\n", list("abort"), "\n", list("abort"), "\n", list(
#&gt;             "warn"), "\n", list("inform"), "\n", list("signal"), 
#&gt;         "\n", list("interrupt"), "\n", list("Signal an error, warning, or message"), 
#&gt;         "\n", list("\n", "abort(message = \"\", .subclass = NULL, ..., trace = NULL,\n", 
#&gt;             "  call = NULL, parent = NULL, msg, type)\n", "\n", 
#&gt;             "warn(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "inform(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "signal(message, .subclass, ...)\n", "\n", 
#&gt;             "interrupt()\n"), "\n", list("\n", list(list("message"), 
#&gt;             list("The message to display.\n", "\n", "Experimental: Can also be a named character vector, in which case\n", 
#&gt;                 "the message is assembled as a list of bullets. See\n", 
#&gt;                 list(list("cnd_message()")), " to learn how names control the bulleted output.")), 
#&gt;             "\n", "\n", list(list(".subclass"), list("Subclass of the condition. This allows your users\n", 
#&gt;                 "to selectively handle the conditions signalled by your functions.")), 
#&gt;             "\n", "\n", list(list("..."), list("Additional data to be stored in the condition object.")), 
#&gt;             "\n", "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                 " object created by ", list(list("trace_back()")), 
#&gt;                 ".")), "\n", "\n", list(list("call"), list("Defunct as of rlang 0.4.0. Storing the full\n", 
#&gt;                 "backtrace is now preferred to storing a simple call.")), 
#&gt;             "\n", "\n", list(list("parent"), list("A parent condition object created by ", 
#&gt;                 list(list("abort()")), ".")), "\n", "\n", list(
#&gt;                 list("msg, type"), list("These arguments were renamed to ", 
#&gt;                   list("message"), " and\n", list(".subclass"), 
#&gt;                   " and are defunct as of rlang 0.4.0.")), "\n"), 
#&gt;         "\n", list("\n", "These functions are equivalent to base functions ", 
#&gt;             list(list("base::stop()")), ",\n", list(list("base::warning()")), 
#&gt;             " and ", list(list("base::message()")), ", but make it easy to supply\n", 
#&gt;             "condition metadata:\n", list("\n", list(), " Supply ", 
#&gt;                 list(".subclass"), " to create a classed condition. Typed\n", 
#&gt;                 "conditions can be captured or handled selectively, allowing for\n", 
#&gt;                 "finer-grained error handling.\n", list(), " Supply metadata with named ", 
#&gt;                 list("..."), " arguments. This data will be\n", 
#&gt;                 "stored in the condition object and can be examined by handlers.\n"), 
#&gt;             "\n", "\n", list("interrupt()"), " allows R code to simulate a user interrupt of the\n", 
#&gt;             "kind that is signalled with ", list("Ctrl-C"), ". It is currently not possible\n", 
#&gt;             "to create custom interrupt condition objects.\n"), 
#&gt;         "\n", list(list("Backtrace"), list("\n", "\n", "\n", 
#&gt;             "Unlike ", list("stop()"), " and ", list("warning()"), 
#&gt;             ", these functions don't include call\n", "information by default. This saves you from typing ", 
#&gt;             list("call. = FALSE"), "\n", "and produces cleaner error messages.\n", 
#&gt;             "\n", "A backtrace is always saved into error objects. You can print a\n", 
#&gt;             "simplified backtrace of the last error by calling ", 
#&gt;             list(list("last_error()")), "\n", "and a full backtrace with ", 
#&gt;             list("summary(last_error())"), ".\n", "\n", "You can also display a backtrace with the error message by setting\n", 
#&gt;             "the option ", list("rlang_backtrace_on_error"), 
#&gt;             ". It supports the following\n", "values:\n", list(
#&gt;                 "\n", list(), " ", list("\"reminder\""), ": Invite users to call ", 
#&gt;                 list("rlang::last_error()"), " to see a\n", "backtrace.\n", 
#&gt;                 list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                 list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                 list(), " ", list("\"full\""), ": Display a full backtrace tree.\n", 
#&gt;                 list(), " ", list("\"none\""), ": Display nothing.\n"), 
#&gt;             "\n")), "\n", "\n", list(list("Mufflable conditions"), 
#&gt;             list("\n", "\n", "\n", "Signalling a condition with ", 
#&gt;                 list("inform()"), " or ", list("warn()"), " causes a message\n", 
#&gt;                 "to be displayed in the console. These messages can be muffled with\n", 
#&gt;                 list(list("base::suppressMessages()")), " or ", 
#&gt;                 list(list("base::suppressWarnings()")), ".\n", 
#&gt;                 "\n", "On recent R versions (&gt;= R 3.5.0), interrupts are typically\n", 
#&gt;                 "signalled with a ", list("\"resume\""), " restart. This is however not\n", 
#&gt;                 "guaranteed.\n")), "\n", "\n", list(list("Lifecycle"), 
#&gt;             list("\n", "\n", "\n", "These functions were changed in rlang 0.3.0 to take condition\n", 
#&gt;                 "metadata with ", list("..."), ". Consequently:\n", 
#&gt;                 list("\n", list(), " All arguments were renamed to be prefixed with a dot, except for\n", 
#&gt;                   list("type"), " which was renamed to ", list(
#&gt;                     ".subclass"), ".\n", list(), " ", list(".call"), 
#&gt;                   " (previously ", list("call"), ") can no longer be passed positionally.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# These examples are guarded to avoid throwing errors\n", 
#&gt;             "if (FALSE) {\n", "\n", "# Signal an error with a message just like stop():\n", 
#&gt;             "abort(\"Something bad happened\")\n", "\n", "# Give a class to the error:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\")\n", 
#&gt;             "\n", "# This will allow your users to handle the error selectively\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    warn(err$message) # Demote the error to a warning\n", 
#&gt;             "    NA                # Return an alternative value\n", 
#&gt;             "  }\n", ")\n", "\n", "# You can also specify metadata that will be stored in the condition:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\", data = 1:10)\n", 
#&gt;             "\n", "# This data can then be consulted by user handlers:\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    # Compute an alternative return value with the data:\n", 
#&gt;             "    recover_error(err$data)\n", "  }\n", ")\n", 
#&gt;             "\n", "# If you call low-level APIs it is good practice to catch technical\n", 
#&gt;             "# errors and rethrow them with a more meaningful message. Pass on\n", 
#&gt;             "# the caught error as `parent` to get a nice decomposition of\n", 
#&gt;             "# errors and backtraces:\n", "file &lt;- \"http://foo.bar/baz\"\n", 
#&gt;             "tryCatch(\n", "  download(file),\n", "  error = function(err) {\n", 
#&gt;             "    msg &lt;- sprintf(\"Can't download `%s`\", file)\n", 
#&gt;             "    abort(msg, parent = err)\n", "})\n", "\n", "# Unhandled errors are saved automatically by `abort()` and can be\n", 
#&gt;             "# retrieved with `last_error()`. The error prints with a simplified\n", 
#&gt;             "# backtrace:\n", "abort(\"Saved error?\")\n", "last_error()\n", 
#&gt;             "\n", "# Use `summary()` to print the full backtrace and the condition fields:\n", 
#&gt;             "summary(last_error())\n", "\n", "}\n"), "\n", list(
#&gt;             "\n", list(list("with_abort()")), " to convert all errors to rlang errors.\n"), 
#&gt;         "\n"), are_na.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/vec-na.R", "\n", 
#&gt;         list("are_na"), "\n", list("are_na"), "\n", list("is_na"), 
#&gt;         "\n", list("is_lgl_na"), "\n", list("is_int_na"), "\n", 
#&gt;         list("is_dbl_na"), "\n", list("is_chr_na"), "\n", list(
#&gt;             "is_cpl_na"), "\n", list("Test for missing values"), 
#&gt;         "\n", list("\n", "are_na(x)\n", "\n", "is_na(x)\n", "\n", 
#&gt;             "is_lgl_na(x)\n", "\n", "is_int_na(x)\n", "\n", "is_dbl_na(x)\n", 
#&gt;             "\n", "is_chr_na(x)\n", "\n", "is_cpl_na(x)\n"), 
#&gt;         "\n", list("\n", list(list("x"), list("An object to test")), 
#&gt;             "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;             "\n", "\n", list("are_na()"), " checks for missing values in a vector and is equivalent\n", 
#&gt;             "to ", list(list("base::is.na()")), ". It is a vectorised predicate, meaning that its\n", 
#&gt;             "output is always the same length as its input. On the other hand,\n", 
#&gt;             list("is_na()"), " is a scalar predicate and always returns a scalar\n", 
#&gt;             "boolean, ", list("TRUE"), " or ", list("FALSE"), 
#&gt;             ". If its input is not scalar, it returns\n", list(
#&gt;                 "FALSE"), ". Finally, there are typed versions that check for\n", 
#&gt;             "particular ", list("missing types"), ".\n"), "\n", 
#&gt;         list("\n", "The scalar predicates accept non-vector inputs. They are equivalent\n", 
#&gt;             "to ", list(list("is_null()")), " in that respect. In contrast the vectorised\n", 
#&gt;             "predicate ", list("are_na()"), " requires a vector input since it is defined\n", 
#&gt;             "over vector values.\n"), "\n", list(list("Life cycle"), 
#&gt;             list("\n", "\n", "\n", "These functions might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;         "\n", "\n", list("\n", "# are_na() is vectorised and works regardless of the type\n", 
#&gt;             "are_na(c(1, 2, NA))\n", "are_na(c(1L, NA, 3L))\n", 
#&gt;             "\n", "# is_na() checks for scalar input and works for all types\n", 
#&gt;             "is_na(NA)\n", "is_na(na_dbl)\n", "is_na(character(0))\n", 
#&gt;             "\n", "# There are typed versions as well:\n", "is_lgl_na(NA)\n", 
#&gt;             "is_lgl_na(na_dbl)\n"), "\n", list("internal"), "\n"), 
#&gt;         arg_match.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("arg_match"), "\n", list("arg_match"), "\n", 
#&gt;             list("Match an argument to a character vector"), 
#&gt;             "\n", list("\n", "arg_match(arg, values = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("arg"), list("A symbol referring to an argument accepting strings.")), 
#&gt;                 "\n", "\n", list(list("values"), list("The possible values that ", 
#&gt;                   list("arg"), " can take. If ", list("NULL"), 
#&gt;                   ",\n", "the values are taken from the function definition of the ", 
#&gt;                   list("caller frame"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "The string supplied to ", list("arg"), 
#&gt;                 ".\n"), "\n", list("\n", "This is equivalent to ", 
#&gt;                 list(list("base::match.arg()")), " with a few differences:\n", 
#&gt;                 list("\n", list(), " Partial matches trigger an error.\n", 
#&gt;                   list(), " Error messages are a bit more informative and obey the tidyverse\n", 
#&gt;                   "standards.\n"), "\n"), "\n", list("\n", "fn &lt;- function(x = c(\"foo\", \"bar\")) arg_match(x)\n", 
#&gt;                 "fn(\"bar\")\n", "\n", "# This would throw an informative error if run:\n", 
#&gt;                 "# fn(\"b\")\n", "# fn(\"baz\")\n"), "\n"), as_box.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "as_box"), "\n", list("as_box"), "\n", list("as_box_if"), 
#&gt;             "\n", list("Convert object to a box"), "\n", list(
#&gt;                 "\n", "as_box(x, class = NULL)\n", "\n", "as_box_if(.x, .p, .class = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("class, .class"), list(
#&gt;                   "A box class. If the input is already a box of\n", 
#&gt;                   "that class, it is returned as is. If the input needs to be boxed,\n", 
#&gt;                   list("class"), " is passed to ", list(list(
#&gt;                     "new_box()")), ".")), "\n", "\n", list(list(
#&gt;                   ".x"), list("An R object.")), "\n", "\n", list(
#&gt;                   list(".p"), list("A predicate function.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed to ", 
#&gt;                   list(".p"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("as_box()"), " boxes its input only if it is not already a box. The\n", 
#&gt;                   "class is also checked if supplied.\n", list(), 
#&gt;                   " ", list("as_box_if()"), " boxes its input only if it not already a box, or if\n", 
#&gt;                   "the predicate ", list(".p"), " returns ", 
#&gt;                   list("TRUE"), ".\n"), "\n"), "\n"), as_bytes.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_bytes"), "\n", list("as_bytes"), "\n", 
#&gt;             list("Coerce to a raw vector"), "\n", list("\n", 
#&gt;                 "as_bytes(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("A string.")), "\n"), "\n", list("\n", 
#&gt;                 "A raw vector of bytes.\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This currently only works with strings, and returns its hexadecimal\n", 
#&gt;                 "representation.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "Raw vector functions are experimental.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_data_mask.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/eval-tidy.R", "\n", 
#&gt;             list("as_data_mask"), "\n", list("as_data_mask"), 
#&gt;             "\n", list("as_data_pronoun"), "\n", list("new_data_mask"), 
#&gt;             "\n", list("Create a data mask"), "\n", list("\n", 
#&gt;                 "as_data_mask(data, parent = NULL)\n", "\n", 
#&gt;                 "as_data_pronoun(data)\n", "\n", "new_data_mask(bottom, top = bottom, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("Deprecated. This argument no longer has any effect.\n", 
#&gt;                   "The parent of the data mask is determined from either:\n", 
#&gt;                   list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                     list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"))), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "A data mask that you can supply to ", 
#&gt;                 list(list("eval_tidy()")), ".\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "A data mask is an environment (or possibly multiple environments\n", 
#&gt;                 "forming an ancestry) containing user-supplied objects. Objects in\n", 
#&gt;                 "the mask have precedence over objects in the environment (i.e. they\n", 
#&gt;                 "mask those objects). Many R functions evaluate quoted expressions\n", 
#&gt;                 "in a data mask so these expressions can refer to objects within the\n", 
#&gt;                 "user data.\n", "\n", "These functions let you construct a tidy eval data mask manually.\n", 
#&gt;                 "They are meant for developers of tidy eval interfaces rather than\n", 
#&gt;                 "for end users.\n"), "\n", list(list("Why build a data mask?"), 
#&gt;                 list("\n", "\n", "\n", "Most of the time you can just call ", 
#&gt;                   list(list("eval_tidy()")), " with a list or a\n", 
#&gt;                   "data frame and the data mask will be constructed automatically.\n", 
#&gt;                   "There are three main use cases for manual creation of data masks:\n", 
#&gt;                   list("\n", list(), " When ", list(list("eval_tidy()")), 
#&gt;                     " is called with the same data in a tight loop.\n", 
#&gt;                     "Because there is some overhead to creating tidy eval data masks,\n", 
#&gt;                     "constructing the mask once and reusing it for subsequent\n", 
#&gt;                     "evaluations may improve performance.\n", 
#&gt;                     list(), " When several expressions should be evaluated in the exact same\n", 
#&gt;                     "environment because a quoted expression might create new objects\n", 
#&gt;                     "that can be referred in other quoted expressions evaluated at a\n", 
#&gt;                     "later time. One example of this is ", list(
#&gt;                       "tibble::lst()"), " where new\n", "columns can refer to previous ones.\n", 
#&gt;                     list(), " When your data mask requires special features. For instance the\n", 
#&gt;                     "data frame columns in dplyr data masks are implemented with\n", 
#&gt;                     list("active bindings"), ".\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Building your own data mask"), 
#&gt;                 list("\n", "\n", "\n", "Unlike ", list(list("base::eval()")), 
#&gt;                   " which takes any kind of environments as data\n", 
#&gt;                   "mask, ", list(list("eval_tidy()")), " has specific requirements in order to support\n", 
#&gt;                   list("quosures"), ". For this reason you can't supply bare\n", 
#&gt;                   "environments.\n", "\n", "There are two ways of constructing an rlang data mask manually:\n", 
#&gt;                   list("\n", list(), " ", list("as_data_mask()"), 
#&gt;                     " transforms a list or data frame to a data mask.\n", 
#&gt;                     "It automatically installs the data pronoun ", 
#&gt;                     list(list(".data")), ".\n", list(), " ", 
#&gt;                     list("new_data_mask()"), " is a bare bones data mask constructor for\n", 
#&gt;                     "environments. You can supply a bottom and a top environment in\n", 
#&gt;                     "case your data mask comprises multiple environments (see section\n", 
#&gt;                     "below).\n", "\n", "Unlike ", list("as_data_mask()"), 
#&gt;                     " it does not install the ", list(".data"), 
#&gt;                     " pronoun\n", "so you need to provide one yourself. You can provide a pronoun\n", 
#&gt;                     "constructed with ", list("as_data_pronoun()"), 
#&gt;                     " or your own pronoun class.\n", "\n", list(
#&gt;                       "as_data_pronoun()"), " will create a pronoun from a list, an\n", 
#&gt;                     "environment, or an rlang data mask. In the latter case, the whole\n", 
#&gt;                     "ancestry is looked up from the bottom to the top of the mask.\n", 
#&gt;                     "Functions stored in the mask are bypassed by the pronoun.\n"), 
#&gt;                   "\n", "\n", "Once you have built a data mask, simply pass it to ", 
#&gt;                   list(list("eval_tidy()")), " as\n", "the ", 
#&gt;                   list("data"), " argument. You can repeat this as many times as\n", 
#&gt;                   "needed. Note that any objects created there (perhaps because of a\n", 
#&gt;                   "call to ", list("&lt;-"), ") will persist in subsequent evaluations.\n")), 
#&gt;             "\n", "\n", list(list("Top and bottom of data mask"), 
#&gt;                 list("\n", "\n", "\n", "In some cases you'll need several levels in your data mask. One\n", 
#&gt;                   "good reason is when you include functions in the mask. It's a good\n", 
#&gt;                   "idea to keep data objects one level lower than function objects, so\n", 
#&gt;                   "that the former cannot override the definitions of the latter (see\n", 
#&gt;                   "examples).\n", "\n", "In that case, set up all your environments and keep track of the\n", 
#&gt;                   "bottom child and the top parent. You'll need to pass both to\n", 
#&gt;                   list("new_data_mask()"), ".\n", "\n", "Note that the parent of the top environment is completely\n", 
#&gt;                   "undetermined, you shouldn't expect it to remain the same at all\n", 
#&gt;                   "times. This parent is replaced during evaluation by ", 
#&gt;                   list(list("eval_tidy()")), "\n", "to one of the following environments:\n", 
#&gt;                   list("\n", list(), " The default environment passed as the ", 
#&gt;                     list("env"), " argument of ", list("eval_tidy()"), 
#&gt;                     ".\n", list(), " The environment of the current quosure being evaluated, if applicable.\n"), 
#&gt;                   "\n", "\n", "Consequently, all masking data should be contained between the\n", 
#&gt;                   "bottom and top environment of the data mask.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "The ", list("parent"), " argument no longer has any effect and is defunct as of\n", 
#&gt;                 "rlang 0.4.0. The parent of the data mask is determined from either:\n", 
#&gt;                 list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                   list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"), 
#&gt;                 "\n", "\n", "Passing environments to ", list(
#&gt;                   "as_data_mask()"), " is deprecated as of rlang\n", 
#&gt;                 "0.3.0. Please use ", list("new_data_mask()"), 
#&gt;                 " instead.\n", "\n", list("rlang 0.2.0"), "\n", 
#&gt;                 "\n", "In early versions of rlang data masks were called overscopes. We\n", 
#&gt;                 "think data mask is a more natural name in R. It makes reference to\n", 
#&gt;                 "masking in the search path which occurs through the same mechanism\n", 
#&gt;                 "(in technical terms, lexical scoping with hierarchically nested\n", 
#&gt;                 "environments). We say that objects from user data mask objects\n", 
#&gt;                 "in the current environment.\n", "\n", "Following this change in terminology, ", 
#&gt;                 list("as_overscope()"), " and\n", list("new_overscope()"), 
#&gt;                 " were deprecated in rlang 0.2.0 in favour of\n", 
#&gt;                 list("as_data_mask()"), " and ", list("new_data_mask()"), 
#&gt;                 ".\n")), "\n", "\n", list("\n", "# Evaluating in a tidy evaluation environment enables all tidy\n", 
#&gt;                 "# features:\n", "mask &lt;- as_data_mask(mtcars)\n", 
#&gt;                 "eval_tidy(quo(letters), mask)\n", "\n", "# You can install new pronouns in the mask:\n", 
#&gt;                 "mask$.pronoun &lt;- as_data_pronoun(list(foo = \"bar\", baz = \"bam\"))\n", 
#&gt;                 "eval_tidy(quo(.pronoun$foo), mask)\n", "\n", 
#&gt;                 "# In some cases the data mask can leak to the user, for example if\n", 
#&gt;                 "# a function or formula is created in the data mask environment:\n", 
#&gt;                 "cyl &lt;- \"user variable from the context\"\n", 
#&gt;                 "fn &lt;- eval_tidy(quote(function() cyl), mask)\n", 
#&gt;                 "fn()\n", "\n", "# If new objects are created in the mask, they persist in the\n", 
#&gt;                 "# subsequent calls:\n", "eval_tidy(quote(new &lt;- cyl + am), mask)\n", 
#&gt;                 "eval_tidy(quote(new * 2), mask)\n", "\n", "\n", 
#&gt;                 "# In some cases your data mask is a whole chain of environments\n", 
#&gt;                 "# rather than a single environment. You'll have to use\n", 
#&gt;                 "# `new_data_mask()` and let it know about the bottom of the mask\n", 
#&gt;                 "# (the last child of the environment chain) and the topmost parent.\n", 
#&gt;                 "\n", "# A common situation where you'll want a multiple-environment mask\n", 
#&gt;                 "# is when you include functions in your mask. In that case you'll\n", 
#&gt;                 "# put functions in the top environment and data in the bottom. This\n", 
#&gt;                 "# will prevent the data from overwriting the functions.\n", 
#&gt;                 "top &lt;- new_environment(list(`+` = base::paste, c = base::paste))\n", 
#&gt;                 "\n", "# Let's add a middle environment just for sport:\n", 
#&gt;                 "middle &lt;- env(top)\n", "\n", "# And finally the bottom environment containing data:\n", 
#&gt;                 "bottom &lt;- env(middle, a = \"a\", b = \"b\", c = \"c\")\n", 
#&gt;                 "\n", "# We can now create a mask by supplying the top and bottom\n", 
#&gt;                 "# environments:\n", "mask &lt;- new_data_mask(bottom, top = top)\n", 
#&gt;                 "\n", "# This data mask can be passed to eval_tidy() instead of a list or\n", 
#&gt;                 "# data frame:\n", "eval_tidy(quote(a + b + c), data = mask)\n", 
#&gt;                 "\n", "# Note how the function `c()` and the object `c` are looked up\n", 
#&gt;                 "# properly because of the multi-level structure:\n", 
#&gt;                 "eval_tidy(quote(c(a, b, c)), data = mask)\n", 
#&gt;                 "\n", "# new_data_mask() does not create data pronouns, but\n", 
#&gt;                 "# data pronouns can be added manually:\n", "mask$.fns &lt;- as_data_pronoun(top)\n", 
#&gt;                 "\n", "# The `.data` pronoun should generally be created from the\n", 
#&gt;                 "# mask. This will ensure data is looked up throughout the whole\n", 
#&gt;                 "# ancestry. Only non-function objects are looked up from this\n", 
#&gt;                 "# pronoun:\n", "mask$.data &lt;- as_data_pronoun(mask)\n", 
#&gt;                 "mask$.data$c\n", "\n", "# Now we can reference the values with the pronouns:\n", 
#&gt;                 "eval_tidy(quote(c(.data$a, .data$b, .data$c)), data = mask)\n"), 
#&gt;             "\n"), as_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_env"), "\n", list("as_env"), "\n", 
#&gt;             list("Coerce to an environment"), "\n", list("\n", 
#&gt;                 "as_env(x, parent = NULL)\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated as it was renamed to ", 
#&gt;                 list(list("as_environment()")), "\n", "in rlang 0.2.0.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "as_environment"), "\n", list("as_environment"), 
#&gt;             "\n", list("Coerce to an environment"), "\n", list(
#&gt;                 "\n", "as_environment(x, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("A parent environment, ", 
#&gt;                   list(list("empty_env()")), " by default. This\n", 
#&gt;                   "argument is only used when ", list("x"), " is data actually coerced to an\n", 
#&gt;                   "environment (as opposed to data representing an environment, like\n", 
#&gt;                   list("NULL"), " representing the empty environment).")), 
#&gt;                 "\n"), "\n", list("\n", list("as_environment()"), 
#&gt;                 " coerces named vectors (including lists) to an\n", 
#&gt;                 "environment. The names must be unique. If supplied an unnamed\n", 
#&gt;                 "string, it returns the corresponding package environment (see\n", 
#&gt;                 list(list("pkg_env()")), ").\n"), "\n", list(
#&gt;                 "\n", "If ", list("x"), " is an environment and ", 
#&gt;                 list("parent"), " is not ", list("NULL"), ", the\n", 
#&gt;                 "environment is duplicated before being set a new parent. The return\n", 
#&gt;                 "value is therefore a different environment than ", 
#&gt;                 list("x"), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("as_env()"), " was soft-deprecated and renamed to ", 
#&gt;                   list("as_environment()"), " in\n", "rlang 0.2.0. This is for consistency as type predicates should not\n", 
#&gt;                   "be abbreviated.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Coerce a named vector to an environment:\n", 
#&gt;                 "env &lt;- as_environment(mtcars)\n", "\n", "# By default it gets the empty environment as parent:\n", 
#&gt;                 "identical(env_parent(env), empty_env())\n", 
#&gt;                 "\n", "\n", "# With strings it is a handy shortcut for pkg_env():\n", 
#&gt;                 "as_environment(\"base\")\n", "as_environment(\"rlang\")\n", 
#&gt;                 "\n", "# With NULL it returns the empty environment:\n", 
#&gt;                 "as_environment(NULL)\n"), "\n"), as_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "as_function"), "\n", list("as_function"), "\n", 
#&gt;             list("is_lambda"), "\n", list("as_closure"), "\n", 
#&gt;             list("Convert to function or closure"), "\n", list(
#&gt;                 "\n", "as_function(x, env = caller_env())\n", 
#&gt;                 "\n", "is_lambda(x)\n", "\n", "as_closure(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function or formula.\n", 
#&gt;                 "\n", "If a ", list("function"), ", it is used as is.\n", 
#&gt;                 "\n", "If a ", list("formula"), ", e.g. ", list(
#&gt;                   "~ .x + 2"), ", it is converted to a function\n", 
#&gt;                 "with up to two arguments: ", list(".x"), " (single argument) or ", 
#&gt;                 list(".x"), " and ", list(".y"), "\n", "(two arguments). The ", 
#&gt;                 list("."), " placeholder can be used instead of ", 
#&gt;                 list(".x"), ".\n", "This allows you to create very compact anonymous functions (lambdas) with up\n", 
#&gt;                 "to two inputs. Functions created from formulas have a special\n", 
#&gt;                 "class. Use ", list("is_lambda()"), " to test for it.\n", 
#&gt;                 "\n", "Lambdas currently do not support ", list(
#&gt;                   "quasiquotation"), ",\n", "due to the way the arguments are handled internally.")), 
#&gt;                 "\n", "\n", list(list("env"), list("Environment in which to fetch the function in case ", 
#&gt;                   list("x"), "\n", "is a string.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("as_function()"), 
#&gt;                   " transforms a one-sided formula into a function.\n", 
#&gt;                   "This powers the lambda syntax in packages like purrr.\n", 
#&gt;                   list(), " ", list("as_closure()"), " first passes its argument to ", 
#&gt;                   list("as_function()"), ". If\n", "the result is a primitive function, it regularises it to a proper\n", 
#&gt;                   list("closure"), " (see ", list(list("is_function()")), 
#&gt;                   " about primitive functions). Some\n", "special control flow primitives like ", 
#&gt;                   list("if"), ", ", list("for"), ", or ", list(
#&gt;                     "break"), "\n", "can't be coerced to a closure.\n"), 
#&gt;                 "\n"), "\n", list("\n", "f &lt;- as_function(~ .x + 1)\n", 
#&gt;                 "f(10)\n", "\n", "g &lt;- as_function(~ -1 * .)\n", 
#&gt;                 "g(4)\n", "\n", "h &lt;- as_function(~ .x - .y)\n", 
#&gt;                 "h(6, 3)\n", "\n", "# Functions created from a formula have a special class:\n", 
#&gt;                 "is_lambda(f)\n", "is_lambda(as_function(function() \"foo\"))\n", 
#&gt;                 "\n", "# Primitive functions are regularised as closures\n", 
#&gt;                 "as_closure(list)\n", "as_closure(\"list\")\n", 
#&gt;                 "\n", "# Operators have `.x` and `.y` as arguments, just like lambda\n", 
#&gt;                 "# functions created with the formula syntax:\n", 
#&gt;                 "as_closure(`+`)\n", "as_closure(`~`)\n", "\n", 
#&gt;                 "# Use a regular function for tidy evaluation, also when calling functions\n", 
#&gt;                 "# that use tidy evaluation:\n", "## Bad:\n", 
#&gt;                 "e &lt;- as_function(~ as_label(ensym(.x)))\n", 
#&gt;                 "## Good:\n", "e &lt;- as_function(function(x) as_label(ensym(x)))\n", 
#&gt;                 "\n", "e(y)\n"), "\n"), as_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/deparse.R", 
#&gt;             "\n", list("as_label"), "\n", list("as_label"), "\n", 
#&gt;             list("Create a default name for an R object"), "\n", 
#&gt;             list("\n", "as_label(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object.")), "\n"), "\n", 
#&gt;             list("\n", list("as_label()"), " transforms R objects into a short, human-readable\n", 
#&gt;                 "description. You can use labels to:\n", list(
#&gt;                   "\n", list(), " Display an object in a concise way, for example to labellise axes\n", 
#&gt;                   "in a graphical plot.\n", list(), " Give default names to columns in a data frame. In this case,\n", 
#&gt;                   "labelling is the first step before name repair.\n"), 
#&gt;                 "\n", "\n", "See also ", list(list("as_name()")), 
#&gt;                 " for transforming symbols back to a\n", "string. Unlike ", 
#&gt;                 list("as_label()"), ", ", list("as_string()"), 
#&gt;                 " is a well defined\n", "operation that guarantees the roundtrip symbol -&gt; string -&gt;\n", 
#&gt;                 "symbol.\n", "\n", "In general, if you don't know for sure what kind of object you're\n", 
#&gt;                 "dealing with (a call, a symbol, an unquoted constant), use\n", 
#&gt;                 list("as_label()"), " and make no assumption about the resulting string. If\n", 
#&gt;                 "you know you have a symbol and need the name of the object it\n", 
#&gt;                 "refers to, use ", list(list("as_string()")), 
#&gt;                 ". For instance, use ", list("as_label()"), " with\n", 
#&gt;                 "objects captured with ", list("enquo()"), " and ", 
#&gt;                 list("as_string()"), " with symbols\n", "captured with ", 
#&gt;                 list("ensym()"), ".\n"), "\n", list(list("Transformation to string"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Quosures are ", 
#&gt;                   list("squashed"), " before being labelled.\n", 
#&gt;                   list(), " Symbols are transformed to string with ", 
#&gt;                   list("as_string()"), ".\n", list(), " Calls are abbreviated.\n", 
#&gt;                   list(), " Numbers are represented as such.\n", 
#&gt;                   list(), " Other constants are represented by their type, such as ", 
#&gt;                   list("&lt;dbl&gt;"), "\n", "or ", list("&lt;data.frame&gt;"), 
#&gt;                   ".\n"), "\n", "\n", "Note that simple symbols should generally be transformed to strings\n", 
#&gt;                   "with ", list(list("as_name()")), ". Labelling is not a well defined operation and\n", 
#&gt;                   "no assumption should be made about how the label is created. On the\n", 
#&gt;                   "other hand, ", list("as_name()"), " only works with symbols and is a well\n", 
#&gt;                   "defined, deterministic operation.\n")), "\n", 
#&gt;             "\n", list("\n", "# as_label() is useful with quoted expressions:\n", 
#&gt;                 "as_label(expr(foo(bar)))\n", "as_label(expr(foobar))\n", 
#&gt;                 "\n", "# It works with any R object. This is also useful for quoted\n", 
#&gt;                 "# arguments because the user might unquote constant objects:\n", 
#&gt;                 "as_label(1:3)\n", "as_label(base::list)\n"), 
#&gt;             "\n", list("\n", list(list("as_name()")), " for transforming symbols back to a string\n", 
#&gt;                 "deterministically.\n"), "\n"), as_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/deparse.R", "\n", 
#&gt;             list("as_name"), "\n", list("as_name"), "\n", list(
#&gt;                 "Extract names from symbols"), "\n", list("\n", 
#&gt;                 "as_name(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("A string or symbol, possibly wrapped in a ", 
#&gt;                   list("quosure"), ".\n", "If a string, the attributes are removed, if any.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of length 1.\n"), 
#&gt;             "\n", list("\n", list("as_name()"), " converts ", 
#&gt;                 list("symbols"), " to character strings. The\n", 
#&gt;                 "conversion is deterministic. That is, the roundtrip symbol -&gt; name\n", 
#&gt;                 "-&gt; symbol always gets the same result.\n", list(
#&gt;                   "\n", list(), " Use ", list("as_name()"), " when you need to transform a symbol to a string\n", 
#&gt;                   "to ", list("refer"), " to an object by its name.\n", 
#&gt;                   list(), " Use ", list(list("as_label()")), 
#&gt;                   " when you need to transform any kind of object to\n", 
#&gt;                   "a string to ", list("represent"), " that object with a short description.\n"), 
#&gt;                 "\n", "\n", "Expect ", list("as_name()"), " to gain\n", 
#&gt;                 list(list("https://principles.tidyverse.org/names-attribute.html#minimal-unique-universal"), 
#&gt;                   list("name-repairing")), "\n", "features in the future.\n", 
#&gt;                 "\n", "Note that ", list("rlang::as_name()"), 
#&gt;                 " is the ", list("opposite"), " of\n", list(list(
#&gt;                   "base::as.name()")), ". If you're writing base R code, we recommend\n", 
#&gt;                 "using ", list(list("base::as.symbol()")), " which is an alias of ", 
#&gt;                 list("as.name()"), " that\n", "follows a more modern terminology (R types instead of S modes).\n"), 
#&gt;             "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_name() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_name(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_name(bar))\n", "\n", "# as_name() unwraps quosured symbols automatically:\n", 
#&gt;                 "as_name(quo(foo))\n"), "\n", list("\n", list(
#&gt;                 list("as_label()")), " for converting any object to a single string\n", 
#&gt;                 "suitable as a label. ", list(list("as_string()")), 
#&gt;                 " for a lower-level version that\n", "doesn't unwrap quosures.\n"), 
#&gt;             "\n"), as_overscope.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_overscope"), "\n", list("as_overscope"), 
#&gt;             "\n", list("new_overscope"), "\n", list("overscope_clean"), 
#&gt;             "\n", list("Create an overscope"), "\n", list("\n", 
#&gt;                 "as_overscope(quo, data = NULL)\n", "\n", "new_overscope(bottom, top = NULL, enclosure = NULL)\n", 
#&gt;                 "\n", "overscope_clean(overscope)\n"), "\n", 
#&gt;             list("\n", list(list("quo"), list("A ", list("quosure"), 
#&gt;                 ".")), "\n", "\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n", "\n", list(list("enclosure"), 
#&gt;                   list("The ", list("parent"), " argument of ", 
#&gt;                     list(list("new_data_mask()")), ".")), "\n", 
#&gt;                 "\n", list(list("overscope"), list("A data mask.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions have been deprecated in rlang 0.2.0. Please use\n", 
#&gt;                 list(list("as_data_mask()")), " and ", list(list(
#&gt;                   "new_data_mask()")), " instead. We no longer\n", 
#&gt;                 "require the mask to be cleaned up so ", list(
#&gt;                   "overscope_clean()"), " does not\n", "have a replacement.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_pairlist.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/node.R", "\n", 
#&gt;             list("as_pairlist"), "\n", list("as_pairlist"), "\n", 
#&gt;             list("Coerce to pairlist"), "\n", list("\n", "as_pairlist(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", "This transforms vector objects to a linked pairlist of nodes. See\n", 
#&gt;                 "the ", list("pairlist"), " type help page.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("as_pairlist()"), " is experimental because we are still figuring out\n", 
#&gt;                 "the naming scheme for pairlists and node-like objects.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "as_quosure"), "\n", list("as_quosure"), "\n", 
#&gt;             list("new_quosure"), "\n", list("Coerce object to quosure"), 
#&gt;             "\n", list("\n", "as_quosure(x, env = NULL)\n", "\n", 
#&gt;                 "new_quosure(expr, env = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to convert. Either an ", 
#&gt;                 list("expression"), " or a\n", "formula.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which the expression should be\n", 
#&gt;                   "evaluated. Only used for symbols and calls. This should typically\n", 
#&gt;                   "be the environment in which the expression was created.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("The expression wrapped by the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "While ", list("new_quosure()"), 
#&gt;                 " wraps any R object (including expressions,\n", 
#&gt;                 "formulas, or other quosures) into a quosure, ", 
#&gt;                 list("as_quosure()"), "\n", "converts formulas and quosures and does not double-wrap.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("as_quosure()"), " now requires an explicit default environment for\n", 
#&gt;                 "creating quosures from symbols and calls.\n", 
#&gt;                 list(), " ", list("as_quosureish()"), " is deprecated as of rlang 0.2.0. This function\n", 
#&gt;                 "assumes that quosures are formulas which is currently true but\n", 
#&gt;                 "might not be in the future.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "# as_quosure() converts expressions or any R object to a validly\n", 
#&gt;                 "# scoped quosure:\n", "env &lt;- env(var = \"thing\")\n", 
#&gt;                 "as_quosure(quote(var), env)\n", "\n", "\n", 
#&gt;                 "# The environment is ignored for formulas:\n", 
#&gt;                 "as_quosure(~foo, env)\n", "as_quosure(~foo)\n", 
#&gt;                 "\n", "# However you must supply it for symbols and calls:\n", 
#&gt;                 "try(as_quosure(quote(var)))\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), ", ", list(list("is_quosure()")), 
#&gt;                 "\n"), "\n"), as_string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("as_string"), "\n", list("as_string"), "\n", 
#&gt;             list("Cast symbol to string"), "\n", list("\n", "as_string(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or symbol. If a string, the attributes are\n", 
#&gt;                 "removed, if any.")), "\n"), "\n", list("\n", 
#&gt;                 "A character vector of length 1.\n"), "\n", list(
#&gt;                 "\n", list("as_string()"), " converts ", list(
#&gt;                   "symbols"), " to character strings.\n"), "\n", 
#&gt;             list(list("Unicode tags"), list("\n", "\n", "\n", 
#&gt;                 "Unlike ", list(list("base::as.symbol()")), " and ", 
#&gt;                 list(list("base::as.name()")), ", ", list("as_string()"), 
#&gt;                 "\n", "automatically transforms unicode tags such as ", 
#&gt;                 list("\"&lt;U+5E78&gt;\""), " to the\n", "proper UTF-8 character. This is important on Windows because:\n", 
#&gt;                 list("\n", list(), " R on Windows has no UTF-8 support, and uses native encoding instead.\n", 
#&gt;                   list(), " The native encodings do not cover all Unicode characters. For\n", 
#&gt;                   "example, Western encodings do not support CKJ characters.\n", 
#&gt;                   list(), " When a lossy UTF-8 -&gt; native transformation occurs, uncovered\n", 
#&gt;                   "characters are transformed to an ASCII unicode tag like ", 
#&gt;                   list("\"&lt;U+5E78&gt;\""), ".\n", list(), " Symbols are always encoded in native. This means that\n", 
#&gt;                   "transforming the column names of a data frame to symbols might be\n", 
#&gt;                   "a lossy operation.\n", list(), " This operation is very common in the tidyverse because of data\n", 
#&gt;                   "masking APIs like dplyr where data frames are transformed to\n", 
#&gt;                   "environments. While the names of a data frame are stored as a\n", 
#&gt;                   "character vector, the bindings of environments are stored as\n", 
#&gt;                   "symbols.\n"), "\n", "\n", "Because it reencodes the ASCII unicode tags to their UTF-8\n", 
#&gt;                 "representation, the string -&gt; symbol -&gt; string roundtrip is\n", 
#&gt;                 "more stable with ", list("as_string()"), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_string() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_string(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_string(bar))\n"), "\n", list("\n", 
#&gt;                 list(list("as_name()")), " for a higher-level variant of ", 
#&gt;                 list("as_string()"), "\n", "that automatically unwraps quosures.\n"), 
#&gt;             "\n"), as_utf8_character.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_utf8_character"), "\n", list("as_utf8_character"), 
#&gt;             "\n", list("Coerce to a character vector and attempt encoding conversion"), 
#&gt;             "\n", list("\n", "as_utf8_character(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Unlike specifying the ", list("encoding"), 
#&gt;                 " argument in ", list("as_string()"), " and\n", 
#&gt;                 list("as_character()"), ", which is only declarative, these functions\n", 
#&gt;                 "actually attempt to convert the encoding of their input. There are\n", 
#&gt;                 "two possible cases:\n", list("\n", list(), " The string is tagged as UTF-8 or latin1, the only two encodings\n", 
#&gt;                   "for which R has specific support. In this case, converting to the\n", 
#&gt;                   "same encoding is a no-op, and converting to native always works\n", 
#&gt;                   "as expected, as long as the native encoding, the one specified by\n", 
#&gt;                   "the ", list("LC_CTYPE"), " locale has support for all characters occurring in\n", 
#&gt;                   "the strings. Unrepresentable characters are serialised as unicode\n", 
#&gt;                   "points: \"&lt;U+xxxx&gt;\".\n", list(), " The string is not tagged. R assumes that it is encoded in the\n", 
#&gt;                   "native encoding. Conversion to native is a no-op, and conversion\n", 
#&gt;                   "to UTF-8 should work as long as the string is actually encoded in\n", 
#&gt;                   "the locale codeset.\n"), "\n", "\n", "When translating to UTF-8, the strings are parsed for serialised\n", 
#&gt;                 "unicode points (e.g. strings looking like \"U+xxxx\") with\n", 
#&gt;                 list(list("chr_unserialise_unicode()")), ". This helps to alleviate the effects of\n", 
#&gt;                 "character-to-symbol-to-character roundtrips on systems with\n", 
#&gt;                 "non-UTF-8 native encoding.\n"), "\n", list("\n", 
#&gt;                 "# Let's create a string marked as UTF-8 (which is guaranteed by the\n", 
#&gt;                 "# Unicode escaping in the string):\n", "utf8 &lt;- \"caf\\uE9\"\n", 
#&gt;                 "Encoding(utf8)\n", "as_bytes(utf8)\n"), "\n", 
#&gt;             list("internal"), "\n"), `bare-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("bare-type-predicates"), "\n", list("bare-type-predicates"), 
#&gt;             "\n", list("is_bare_list"), "\n", list("is_bare_atomic"), 
#&gt;             "\n", list("is_bare_vector"), "\n", list("is_bare_double"), 
#&gt;             "\n", list("is_bare_integer"), "\n", list("is_bare_numeric"), 
#&gt;             "\n", list("is_bare_character"), "\n", list("is_bare_logical"), 
#&gt;             "\n", list("is_bare_raw"), "\n", list("is_bare_string"), 
#&gt;             "\n", list("is_bare_bytes"), "\n", list("Bare type predicates"), 
#&gt;             "\n", list("\n", "is_bare_list(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_atomic(x, n = NULL)\n", "\n", "is_bare_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_double(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_integer(x, n = NULL)\n", "\n", "is_bare_numeric(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_bare_logical(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_raw(x, n = NULL)\n", "\n", "is_bare_string(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_bytes(x, n = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check for a given type but only return ", 
#&gt;                 list("TRUE"), " for\n", "bare R objects. Bare objects have no class attributes. For example,\n", 
#&gt;                 "a data frame is a list, but not a bare list.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " The predicates for vectors include the ", 
#&gt;                 list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                 list(), " Like ", list(list("is_atomic()")), 
#&gt;                 " and unlike base R ", list("is.atomic()"), ",\n", 
#&gt;                 list("is_bare_atomic()"), " does not return ", 
#&gt;                 list("TRUE"), " for ", list("NULL"), ".\n", list(), 
#&gt;                 " Unlike base R ", list("is.numeric()"), ", ", 
#&gt;                 list("is_bare_double()"), " only returns\n", 
#&gt;                 list("TRUE"), " for floating point numbers.\n"), 
#&gt;                 "\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("scalar-type-predicates"), "\n"), 
#&gt;             "\n"), box.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("box"), "\n", list("box"), "\n", list("new_box"), 
#&gt;             "\n", list("is_box"), "\n", list("unbox"), "\n", 
#&gt;             list("Box a value"), "\n", list("\n", "new_box(.x, class = NULL, ...)\n", 
#&gt;                 "\n", "is_box(x, class = NULL)\n", "\n", "unbox(box)\n"), 
#&gt;             "\n", list("\n", list(list("class"), list("For ", 
#&gt;                 list("new_box()"), ", an additional class for the\n", 
#&gt;                 "boxed value (in addition to ", list("rlang_box"), 
#&gt;                 "). For ", list("is_box()"), ", a class\n", "or vector of classes passed to ", 
#&gt;                 list(list("inherits_all()")), ".")), "\n", "\n", 
#&gt;                 list(list("..."), list("Additional attributes passed to ", 
#&gt;                   list(list("base::structure()")), ".")), "\n", 
#&gt;                 "\n", list(list("x, .x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("box"), list("A boxed value to unbox.")), 
#&gt;                 "\n"), "\n", list("\n", list("new_box()"), " is similar to ", 
#&gt;                 list(list("base::I()")), " but it protects a value by\n", 
#&gt;                 "wrapping it in a scalar list rather than by adding an attribute.\n", 
#&gt;                 list("unbox()"), " retrieves the boxed value. ", 
#&gt;                 list("is_box()"), " tests whether an\n", "object is boxed with optional class. ", 
#&gt;                 list("as_box()"), " ensures that a\n", "value is wrapped in a box. ", 
#&gt;                 list("as_box_if()"), " does the same but only if\n", 
#&gt;                 "the value matches a predicate.\n"), "\n", list(
#&gt;                 "\n", "boxed &lt;- new_box(letters, \"mybox\")\n", 
#&gt;                 "is_box(boxed)\n", "is_box(boxed, \"mybox\")\n", 
#&gt;                 "is_box(boxed, \"otherbox\")\n", "\n", "unbox(boxed)\n", 
#&gt;                 "\n", "# as_box() avoids double-boxing:\n", "boxed2 &lt;- as_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed2\n", "unbox(boxed2)\n", "\n", "# Compare to:\n", 
#&gt;                 "boxed_boxed &lt;- new_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed_boxed\n", "unbox(unbox(boxed_boxed))\n", 
#&gt;                 "\n", "# Use `as_box_if()` with a predicate if you need to ensure a box\n", 
#&gt;                 "# only for a subset of values:\n", "as_box_if(NULL, is_null, \"null_box\")\n", 
#&gt;                 "as_box_if(\"foo\", is_null, \"null_box\")\n"), 
#&gt;             "\n"), call2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call2"), "\n", list("call2"), "\n", list(
#&gt;                 "Create a call"), "\n", list("\n", "call2(.fn, ..., .ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Quoted function calls are one of the two types of\n", 
#&gt;                 list("symbolic"), " objects in R. They represent the action of\n", 
#&gt;                 "calling a function, possibly with arguments. There are two ways of\n", 
#&gt;                 "creating a quoted call:\n", list("\n", list(), 
#&gt;                   " By ", list("quoting"), " it. Quoting prevents functions from being\n", 
#&gt;                   "called. Instead, you get the description of the function call as\n", 
#&gt;                   "an R object. That is, a quoted function call.\n", 
#&gt;                   list(), " By constructing it with ", list(list(
#&gt;                     "base::call()")), ", ", list(list("base::as.call()")), 
#&gt;                   ", or\n", list("call2()"), ". In this case, you pass the call elements (the function\n", 
#&gt;                   "to call and the arguments to call it with) separately.\n"), 
#&gt;                 "\n", "\n", "See section below for the difference between ", 
#&gt;                 list("call2()"), " and the base\n", "constructors.\n"), 
#&gt;             "\n", list(list("Difference with base constructors"), 
#&gt;                 list("\n", "\n", "\n", list("call2()"), " is more flexible and convenient than ", 
#&gt;                   list("base::call()"), ":\n", list("\n", list(), 
#&gt;                     " The function to call can be a string or a ", 
#&gt;                     list("callable"), "\n", "object: a symbol, another call (e.g. a ", 
#&gt;                     list("$"), " or ", list("[["), " call), or a\n", 
#&gt;                     "function to inline. ", list("base::call()"), 
#&gt;                     " only supports strings and you\n", "need to use ", 
#&gt;                     list("base::as.call()"), " to construct a call with a callable\n", 
#&gt;                     "object.", list("call2(list, 1, 2)\n", "\n", 
#&gt;                       "as.call(list(list, 1, 2))\n"), "\n", list(), 
#&gt;                     " The ", list(".ns"), " argument is convenient for creating namespaced calls.", 
#&gt;                     list("call2(\"list\", 1, 2, .ns = \"base\")\n", 
#&gt;                       "\n", "ns_call &lt;- as.call(list(as.name(\"::\"), as.name(\"list\"), as.name(\"base\")))\n", 
#&gt;                       "as.call(list(ns_call, 1, 2))\n"), "\n", 
#&gt;                     list(), " ", list("call2()"), " has ", list(
#&gt;                       "tidy dots"), " support and you can splice lists\n", 
#&gt;                     "of arguments with ", list("!!!"), ". With base R, you need to use ", 
#&gt;                     list("as.call()"), "\n", "instead of ", list(
#&gt;                       "call()"), " if the arguments are in a list.", 
#&gt;                     list("args &lt;- list(na.rm = TRUE, trim = 0)\n", 
#&gt;                       "\n", "call2(\"mean\", 1:10, !!!args)\n", 
#&gt;                       "\n", "as.call(c(list(as.name(\"mean\"), 1:10), args))\n"), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "In rlang 0.2.0 ", list(
#&gt;                   "lang()"), " was soft-deprecated and renamed to\n", 
#&gt;                   list("call2()"), ".\n", "\n", "In early versions of rlang calls were called \"language\" objects in\n", 
#&gt;                   "order to follow the R type nomenclature as returned by\n", 
#&gt;                   list(list("base::typeof()")), ". The goal was to avoid adding to the confusion\n", 
#&gt;                   "between S modes and R types. With hindsight we find it is better to\n", 
#&gt;                   "use more meaningful type names.\n")), "\n", 
#&gt;             "\n", list("\n", "# fn can either be a string, a symbol or a call\n", 
#&gt;                 "call2(\"f\", a = 1)\n", "call2(quote(f), a = 1)\n", 
#&gt;                 "call2(quote(f()), a = 1)\n", "\n", "#' Can supply arguments individually or in a list\n", 
#&gt;                 "call2(quote(f), a = 1, b = 2)\n", "call2(quote(f), !!!list(a = 1, b = 2))\n", 
#&gt;                 "\n", "# Creating namespaced calls is easy:\n", 
#&gt;                 "call2(\"fun\", arg = quote(baz), .ns = \"mypkg\")\n", 
#&gt;                 "\n", "# Empty arguments are preserved:\n", "call2(\"[\", quote(x), , drop = )\n"), 
#&gt;             "\n", list("\n", "call_modify\n"), "\n"), call_args.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_args"), "\n", list("call_args"), "\n", 
#&gt;             list("call_args_names"), "\n", list("Extract arguments from a call"), 
#&gt;             "\n", list("\n", "call_args(call)\n", "\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A named list of arguments.\n"), 
#&gt;             "\n", list("\n", "Extract arguments from a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_args()"), " and ", 
#&gt;                 list("lang_args_names()"), " were\n", "deprecated and renamed to ", 
#&gt;                 list("call_args()"), " and ", list("call_args_names()"), 
#&gt;                 ".\n", "See lifecycle section in ", list(list(
#&gt;                   "call2()")), " for more about this change.\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(f(a, b))\n", 
#&gt;                 "\n", "# Subsetting a call returns the arguments converted to a language\n", 
#&gt;                 "# object:\n", "call[-1]\n", "\n", "# On the other hand, call_args() returns a regular list that is\n", 
#&gt;                 "# often easier to work with:\n", "str(call_args(call))\n", 
#&gt;                 "\n", "# When the arguments are unnamed, a vector of empty strings is\n", 
#&gt;                 "# supplied (rather than NULL):\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("fn_fmls()")), " and ", 
#&gt;                 list(list("fn_fmls_names()")), "\n"), "\n"), 
#&gt;         call_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_fn"), "\n", list("call_fn"), "\n", 
#&gt;             list("Extract function from a call"), "\n", list(
#&gt;                 "\n", "call_fn(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "If a frame or formula, the function will be retrieved from the\n", 
#&gt;                 "associated environment. Otherwise, it is looked up in the calling\n", 
#&gt;                 "frame.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", "In rlang 0.2.0, ", list("lang_fn()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_fn()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about this\n", "change.\n")), "\n", 
#&gt;             "\n", list("\n", "# Extract from a quoted call:\n", 
#&gt;                 "call_fn(quote(matrix()))\n", "call_fn(quo(matrix()))\n", 
#&gt;                 "\n", "# Extract the calling function\n", "test &lt;- function() call_fn(call_frame())\n", 
#&gt;                 "test()\n"), "\n", list("\n", list(list("call_name()")), 
#&gt;                 "\n"), "\n"), call_inspect.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("call_inspect"), "\n", list("call_inspect"), 
#&gt;             "\n", list("Inspect a call"), "\n", list("\n", "call_inspect(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Arguments to display in the returned call.")), 
#&gt;                 "\n"), "\n", list("\n", "This function is useful for quick testing and debugging when you\n", 
#&gt;                 "manipulate expressions and calls. It lets you check that a function\n", 
#&gt;                 "is called with the right arguments. This can be useful in unit\n", 
#&gt;                 "tests for instance. Note that this is just a simple wrapper around\n", 
#&gt;                 list(list("base::match.call()")), ".\n"), "\n", 
#&gt;             list("\n", "call_inspect(foo(bar), \"\" %&gt;% identity())\n"), 
#&gt;             "\n"), call_modify.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_modify"), "\n", list("call_modify"), 
#&gt;             "\n", list("Modify the arguments of a call"), "\n", 
#&gt;             list("\n", "call_modify(.call, ..., .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),\n", 
#&gt;                 "  .standardise = NULL, .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".call"), list("Can be a call, a formula quoting a call in the\n", 
#&gt;                 "right-hand side, or a frame object from which to extract the call\n", 
#&gt;                 "expression.")), "\n", "\n", list(list("..."), 
#&gt;                 list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                 list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".standardise, .env"), 
#&gt;                   list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n"), "\n", list("\n", "A quosure if ", 
#&gt;                 list(".call"), " is a quosure, a call otherwise.\n"), 
#&gt;             "\n", list("\n", "If you are working with a user-supplied call, make sure the\n", 
#&gt;                 "arguments are standardised with ", list(list(
#&gt;                   "call_standardise()")), " before\n", "modifying the call.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " The ", list(".standardise"), 
#&gt;                 " argument is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " In rlang 0.2.0, ", list("lang_modify()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_modify()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about\n", "this change.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(mean(x, na.rm = TRUE))\n", 
#&gt;                 "\n", "# Modify an existing argument\n", "call_modify(call, na.rm = FALSE)\n", 
#&gt;                 "call_modify(call, x = quote(y))\n", "\n", "# Remove an argument\n", 
#&gt;                 "call_modify(call, na.rm = zap())\n", "\n", "# Add a new argument\n", 
#&gt;                 "call_modify(call, trim = 0.1)\n", "\n", "# Add an explicit missing argument:\n", 
#&gt;                 "call_modify(call, na.rm = )\n", "\n", "# Supply a list of new arguments with `!!!`\n", 
#&gt;                 "newargs &lt;- list(na.rm = NULL, trim = 0.1)\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "# Remove multiple arguments by splicing zaps:\n", 
#&gt;                 "newargs &lt;- rep_named(c(\"na.rm\", \"trim\"), list(zap()))\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "\n", "# Modify the `...` arguments as if it were a named argument:\n", 
#&gt;                 "call &lt;- call_modify(call, ... = )\n", "call\n", 
#&gt;                 "\n", "call &lt;- call_modify(call, ... = zap())\n", 
#&gt;                 "call\n", "\n", "\n", "# When you're working with a user-supplied call, standardise it\n", 
#&gt;                 "# beforehand because it might contain unmatched arguments:\n", 
#&gt;                 "user_call &lt;- quote(matrix(x, nc = 3))\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "# Standardising applies the usual argument matching rules:\n", 
#&gt;                 "user_call &lt;- call_standardise(user_call)\n", 
#&gt;                 "user_call\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "\n", "# You can also modify quosures inplace:\n", 
#&gt;                 "f &lt;- quo(matrix(bar))\n", "call_modify(f, quote(foo))\n", 
#&gt;                 "\n", "\n", "# By default, arguments with the same name are kept. This has\n", 
#&gt;                 "# subtle implications, for instance you can move an argument to\n", 
#&gt;                 "# last position by removing it and remapping it:\n", 
#&gt;                 "call &lt;- quote(foo(bar = , baz))\n", "call_modify(call, bar = NULL, bar = missing_arg())\n", 
#&gt;                 "\n", "# You can also choose to keep only the first or last homonym\n", 
#&gt;                 "# arguments:\n", "args &lt;-  list(bar = NULL, bar = missing_arg())\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"first\")\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"last\")\n"), 
#&gt;             "\n"), call_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_name"), "\n", list("call_name"), 
#&gt;             "\n", list("call_ns"), "\n", list("Extract function name or namespaced of a call"), 
#&gt;             "\n", list("\n", "call_name(call)\n", "\n", "call_ns(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A string with the function name, or ", 
#&gt;                 list("NULL"), " if the function\n", "is anonymous.\n"), 
#&gt;             "\n", list("\n", "Extract function name or namespaced of a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_name()"), " was deprecated and renamed to\n", 
#&gt;                 list("call_name()"), ". See lifecycle section in ", 
#&gt;                 list(list("call2()")), " for more about\n", "this change.\n")), 
#&gt;             "\n", "\n", list("\n", "# Extract the function name from quoted calls:\n", 
#&gt;                 "call_name(quote(foo(bar)))\n", "call_name(quo(foo(bar)))\n", 
#&gt;                 "\n", "# Namespaced calls are correctly handled:\n", 
#&gt;                 "call_name(~base::matrix(baz))\n", "\n", "# Anonymous and subsetted functions return NULL:\n", 
#&gt;                 "call_name(quote(foo$bar()))\n", "call_name(quote(foo[[bar]]()))\n", 
#&gt;                 "call_name(quote(foo()()))\n", "\n", "# Extract namespace of a call with call_ns():\n", 
#&gt;                 "call_ns(quote(base::bar()))\n", "\n", "# If not namespaced, call_ns() returns NULL:\n", 
#&gt;                 "call_ns(quote(bar()))\n"), "\n", list("\n", 
#&gt;                 list(list("call_fn()")), "\n"), "\n"), call_standardise.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_standardise"), "\n", list("call_standardise"), 
#&gt;             "\n", list("Standardise a call"), "\n", list("\n", 
#&gt;                 "call_standardise(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure if ", list(
#&gt;                 "call"), " is a quosure, a raw call otherwise.\n"), 
#&gt;             "\n", list("\n", "This is essentially equivalent to ", 
#&gt;                 list(list("base::match.call()")), ", but with\n", 
#&gt;                 "experimental handling of primitive functions.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_standardise()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_standardise()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more\n", "about this change.\n")), "\n", 
#&gt;             "\n"), caller_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("caller_env"), "\n", list("caller_env"), 
#&gt;             "\n", list("current_env"), "\n", list("Get the current or caller environment"), 
#&gt;             "\n", list("\n", "caller_env(n = 1)\n", "\n", "current_env()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " The current environment is the execution environment of the\n", 
#&gt;                 "current function (the one currently being evaluated).\n", 
#&gt;                 list(), " The caller environment is the execution environment of the\n", 
#&gt;                 "function that called the current function.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Let's create a function that returns its current environment and\n", 
#&gt;                 "# its caller environment:\n", "fn &lt;- function() list(current = current_env(), caller = caller_env())\n", 
#&gt;                 "\n", "# The current environment is an unique execution environment\n", 
#&gt;                 "# created when `fn()` was called. The caller environment is the\n", 
#&gt;                 "# global env because that's where we called `fn()`.\n", 
#&gt;                 "fn()\n", "\n", "# Let's call `fn()` again but this time within a function:\n", 
#&gt;                 "g &lt;- function() fn()\n", "\n", "# Now the caller environment is also an unique execution environment.\n", 
#&gt;                 "# This is the exec env created by R for our call to g():\n", 
#&gt;                 "g()\n"), "\n", list("\n", list(list("caller_frame()")), 
#&gt;                 " and ", list(list("current_frame()")), "\n"), 
#&gt;             "\n"), caller_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("caller_fn"), "\n", list("caller_fn"), 
#&gt;             "\n", list("current_fn"), "\n", list("Get properties of the current or caller frame"), 
#&gt;             "\n", list("\n", "caller_fn(n = 1)\n", "\n", "current_fn()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The number of generations to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("\n", list(), " The current frame is the execution context of the function that\n", 
#&gt;                   "is currently being evaluated.\n", list(), 
#&gt;                   " The caller frame is the execution context of the function that\n", 
#&gt;                   "called the function currently being evaluated.\n"), 
#&gt;                 "\n", "\n", "See the ", list("call stack"), " topic for more information.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental.\n")), "\n", 
#&gt;             "\n", list("\n", list(list("caller_env()")), " and ", 
#&gt;                 list(list("current_env()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), caller_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("caller_frame"), "\n", list("caller_frame"), 
#&gt;             "\n", list("Get caller frame"), "\n", list("\n", 
#&gt;                 "caller_frame(n = 1)\n"), "\n", list("\n", list(
#&gt;                 list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), catch_cnd.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("catch_cnd"), "\n", list("catch_cnd"), 
#&gt;             "\n", list("Catch a condition"), "\n", list("\n", 
#&gt;                 "catch_cnd(expr, classes = \"condition\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("Expression to be evaluated with a catching condition\n", 
#&gt;                 "handler.")), "\n", "\n", list(list("classes"), 
#&gt;                 list("A character vector of condition classes to catch. By\n", 
#&gt;                   "default, catches all conditions.")), "\n"), 
#&gt;             "\n", list("\n", "A condition if any was signalled, ", 
#&gt;                 list("NULL"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This is a small wrapper around ", list("tryCatch()"), 
#&gt;                 " that captures any\n", "condition signalled while evaluating its argument. It is useful for\n", 
#&gt;                 "situations where you expect a specific condition to be signalled,\n", 
#&gt;                 "for debugging, and for unit testing.\n"), "\n", 
#&gt;             list("\n", "catch_cnd(10)\n", "catch_cnd(abort(\"an error\"))\n", 
#&gt;                 "catch_cnd(cnd_signal(\"my_condition\", .msg = \"a condition\"))\n"), 
#&gt;             "\n"), chr_unserialise_unicode.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("chr_unserialise_unicode"), "\n", list(
#&gt;                 "chr_unserialise_unicode"), "\n", list("Translate unicode points to UTF-8"), 
#&gt;             "\n", list("\n", "chr_unserialise_unicode(chr)\n"), 
#&gt;             "\n", list("\n", list(list("chr"), list("A character vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "For historical reasons, R translates strings to the native encoding\n", 
#&gt;                 "when they are converted to symbols. This string-to-symbol\n", 
#&gt;                 "conversion is not a rare occurrence and happens for instance to the\n", 
#&gt;                 "names of a list of arguments converted to a call by ", 
#&gt;                 list("do.call()"), ".\n", "\n", "If the string contains unicode characters that cannot be\n", 
#&gt;                 "represented in the native encoding, R serialises those as an ASCII\n", 
#&gt;                 "sequence representing the unicode point. This is why Windows users\n", 
#&gt;                 "with western locales often see strings looking like ", 
#&gt;                 list("&lt;U+xxxx&gt;"), ". To\n", "alleviate some of the pain, rlang parses strings and looks for\n", 
#&gt;                 "serialised unicode points to translate them back to the proper\n", 
#&gt;                 "UTF-8 representation. This transformation occurs automatically in\n", 
#&gt;                 "functions like ", list(list("env_names()")), 
#&gt;                 " and can be manually triggered with\n", list(
#&gt;                   "as_utf8_character()"), " and ", list("chr_unserialise_unicode()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "This function is experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "ascii &lt;- \"&lt;U+5E78&gt;\"\n", 
#&gt;                 "chr_unserialise_unicode(ascii)\n", "\n", "identical(chr_unserialise_unicode(ascii), \"\\u5e78\")\n"), 
#&gt;             "\n", list("internal"), "\n"), cnd.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-error.R, R/cnd.R", 
#&gt;             "\n", list("error_cnd"), "\n", list("error_cnd"), 
#&gt;             "\n", list("cnd"), "\n", list("warning_cnd"), "\n", 
#&gt;             list("message_cnd"), "\n", list("Create a condition object"), 
#&gt;             "\n", list("\n", "error_cnd(.subclass = NULL, ..., message = \"\", trace = NULL,\n", 
#&gt;                 "  parent = NULL)\n", "\n", "cnd(.subclass, ..., message = \"\")\n", 
#&gt;                 "\n", "warning_cnd(.subclass = NULL, ..., message = \"\")\n", 
#&gt;                 "\n", "message_cnd(.subclass = NULL, ..., message = \"\")\n"), 
#&gt;             "\n", list("\n", list(list(".subclass"), list("The condition subclass.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named data fields stored inside the condition\n", 
#&gt;                   "object. These dots are evaluated with ", list(
#&gt;                     "explicit splicing"), ".")), "\n", "\n", 
#&gt;                 list(list("message"), list("A default message to inform the user about the\n", 
#&gt;                   "condition when it is signalled.")), "\n", 
#&gt;                 "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                   " object created by ", list(list("trace_back()")), 
#&gt;                   ".")), "\n", "\n", list(list("parent"), list(
#&gt;                   "A parent condition object created by ", list(
#&gt;                     list("abort()")), ".")), "\n"), "\n", list(
#&gt;                 "\n", "These constructors make it easy to create subclassed conditions.\n", 
#&gt;                 "Conditions are objects that power the error system in R. They can\n", 
#&gt;                 "also be used for passing messages to pre-established handlers.\n"), 
#&gt;             "\n", list("\n", list("cnd()"), " creates objects inheriting from ", 
#&gt;                 list("condition"), ". Conditions\n", "created with ", 
#&gt;                 list("error_cnd()"), ", ", list("warning_cnd()"), 
#&gt;                 " and ", list("message_cnd()"), "\n", "inherit from ", 
#&gt;                 list("error"), ", ", list("warning"), " or ", 
#&gt;                 list("message"), ".\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "The ", list(".type"), 
#&gt;                   " and ", list(".msg"), " arguments have been renamed to ", 
#&gt;                   list(".subclass"), "\n", "and ", list("message"), 
#&gt;                   ". They are deprecated as of rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "# Create a condition inheriting from the s3 type \"foo\":\n", 
#&gt;                 "cnd &lt;- cnd(\"foo\")\n", "\n", "# Signal the condition to potential handlers. Since this is a bare\n", 
#&gt;                 "# condition the signal has no effect if no handlers are set up:\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# When a relevant handler is set up, the signal causes the handler\n", 
#&gt;                 "# to be called:\n", "with_handlers(cnd_signal(cnd), foo = exiting(function(c) \"caught!\"))\n", 
#&gt;                 "\n", "# Handlers can be thrown or executed inplace. See with_handlers()\n", 
#&gt;                 "# documentation for more on this.\n", "\n", 
#&gt;                 "# Signalling an error condition aborts the current computation:\n", 
#&gt;                 "err &lt;- error_cnd(\"foo\", message = \"I am an error\")\n", 
#&gt;                 "try(cnd_signal(err))\n"), "\n", list("\n", list(
#&gt;                 list("cnd_signal()")), ", ", list(list("with_handlers()")), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), cnd_message.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-message.R", 
#&gt;             "\n", list("cnd_message"), "\n", list("cnd_message"), 
#&gt;             "\n", list("cnd_issue"), "\n", list("cnd_bullets"), 
#&gt;             "\n", list("format_bullets"), "\n", list("Build an error message from a main issue and bullet messages"), 
#&gt;             "\n", list("\n", "cnd_message(cnd)\n", "\n", "cnd_issue(cnd, ...)\n", 
#&gt;                 "\n", "cnd_bullets(cnd, ...)\n", "\n", "format_bullets(x)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A named character vector of messages. Elements named as\n", 
#&gt;                   list("x"), " or ", list("i"), " are prefixed with the corresponding bullet.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " assembles an error message from two components:\n", 
#&gt;                 list("\n", list(), " The ", list("cnd_issue()"), 
#&gt;                   " generic. Methods should return a single line.\n", 
#&gt;                   list(), " The ", list("cnd_bullets()"), " generic. Methods should return a named vector\n", 
#&gt;                   "of lines. These lines are automatically prefixed with a bullet by\n", 
#&gt;                   list("cnd_message()"), " (see the section on error statements).\n"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " is automatically called by the ", 
#&gt;                 list("conditionMessage()"), "\n", "for rlang errors so that errors thrown with ", 
#&gt;                 list(list("abort()")), " only need to\n", "implement ", 
#&gt;                 list("cnd_issue()"), " and ", list("cnd_bullets()"), 
#&gt;                 ". It can also be called\n", "in custom ", list(
#&gt;                   "conditionMessage()"), " methods.\n", "\n", 
#&gt;                 "Note that if you pass a named character vector to ", 
#&gt;                 list(list("abort()")), ", you\n", "get the same formatting behaviour as ", 
#&gt;                 list("cnd_message()"), ".\n"), "\n", list(list(
#&gt;                 "Error statements"), list("\n", "\n", "\n", "This experimental infrastructure is based on the idea that\n", 
#&gt;                 "sentences in error messages are best kept short and simple. From\n", 
#&gt;                 "this point of view, the best way to present the information is as a\n", 
#&gt;                 "bullet list of simple sentences containing a single clause.\n", 
#&gt;                 list("cnd_message()"), " helps following this structure by building an error\n", 
#&gt;                 "message from two parts: the ", list("issue"), 
#&gt;                 " and the ", list("bullets"), ".\n", "\n", list(
#&gt;                   "cnd_issue()"), " is the generic for the main error message. It should\n", 
#&gt;                 "be as generic as possible, but since it is a generic it is easy to\n", 
#&gt;                 "override by error subclasses.\n", "\n", "The ", 
#&gt;                 list("cnd_bullets()"), " methods should return a character vector of\n", 
#&gt;                 "sentences. These are automatically prefixed with bullets by\n", 
#&gt;                 list("cnd_message()"), ", according to the following scheme:\n", 
#&gt;                 list("\n", list(), " Elements named ", list("\"i\""), 
#&gt;                   " are prefixed with a blue \"info\" symbol.\n", 
#&gt;                   list(), " Elements named ", list("\"x\""), 
#&gt;                   " are prefixed with a red \"cross\" symbol.\n", 
#&gt;                   list(), " Unnamed elements are prefixed with a \"*\" symbol.\n"), 
#&gt;                 "\n", "\n", "While you are free to lay out the bullets in the order that you\n", 
#&gt;                 "like, \"x\" bullets should usually precede \"i\" bullets.\n")), 
#&gt;             "\n", "\n", list(list("Overriding ", list("cnd_bullets()")), 
#&gt;                 list("\n", "\n", "\n", "Sometimes the generation of an error message depends on the state\n", 
#&gt;                   "of the type checking. In that case, it can be tricky to lazily\n", 
#&gt;                   "generate error messages with ", list("cnd_bullets()"), 
#&gt;                   ": you can either\n", "overspecify your error class hierarchies with one class per state,\n", 
#&gt;                   "or replicate the type-checking control flow within the\n", 
#&gt;                   list("cnd_bullets()"), " method. None of these options are ideal.\n", 
#&gt;                   "\n", "A better option is to define a ", list(
#&gt;                     "cnd_bullets"), " field in your error\n", 
#&gt;                   "object. This should be a function (or a lambda-formula which will\n", 
#&gt;                   "be passed to ", list(list("as_function()")), 
#&gt;                   ") with the same signature as\n", list("cnd_bullets()"), 
#&gt;                   " methods. This function overrides the\n", 
#&gt;                   list("cnd_bullets()"), " generic and can generate an error message tailored\n", 
#&gt;                   "to the state in which the error was constructed.\n", 
#&gt;                   "\n", "Note that as a rule, ", list("cnd_issue()"), 
#&gt;                   " should be a general thematic\n", "issues that does not depend on state. For this reason, it isn't\n", 
#&gt;                   "possible to define an overriding method in the condition object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "This infrastructure is experimental. In particular, the output of\n", 
#&gt;                 list("cnd_message()"), " is likely to change in the future and you shouldn't\n", 
#&gt;                 "test it verbatim in a way that makes R CMD check fail. Instead, use\n", 
#&gt;                 list(list("testthat::verify_output()")), " to monitor the output without causing\n", 
#&gt;                 "CRAN check failures when it changes.\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), cnd_muffle.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("cnd_muffle"), "\n", list("cnd_muffle"), 
#&gt;             "\n", list("Muffle a condition"), "\n", list("\n", 
#&gt;                 "cnd_muffle(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition to muffle.")), "\n"), 
#&gt;             "\n", list("\n", "Unlike ", list(list("exiting()")), 
#&gt;                 " handlers, ", list(list("calling()")), " handlers must be explicit\n", 
#&gt;                 "that they have handled a condition to stop it from propagating to\n", 
#&gt;                 "other handlers. Use ", list("cnd_muffle()"), 
#&gt;                 " within a calling handler (or as\n", "a calling handler, see examples) to prevent any other handlers from\n", 
#&gt;                 "being called for that condition.\n"), "\n", 
#&gt;             list(list("Mufflable conditions"), list("\n", "\n", 
#&gt;                 "\n", "Most conditions signalled by base R are muffable, although the name\n", 
#&gt;                 "of the restart varies. cnd_muffle() will automatically call the\n", 
#&gt;                 "correct restart for you. It is compatible with the following\n", 
#&gt;                 "conditions:\n", list("\n", list(), " ", list(
#&gt;                   "warning"), " and ", list("message"), " conditions. In this case ", 
#&gt;                   list("cnd_muffle()"), "\n", "is equivalent to ", 
#&gt;                   list(list("base::suppressMessages()")), " and\n", 
#&gt;                   list(list("base::suppressWarnings()")), ".\n", 
#&gt;                   list(), " Bare conditions signalled with ", 
#&gt;                   list("signal()"), " or ", list(list("cnd_signal()")), 
#&gt;                   ". Note\n", "that conditions signalled with ", 
#&gt;                   list(list("base::signalCondition()")), " are not\n", 
#&gt;                   "mufflable.\n", list(), " Interrupts are sometimes signalled with a ", 
#&gt;                   list("resume"), " restart on\n", "recent R versions. When this is the case, you can muffle the\n", 
#&gt;                   "interrupt with ", list("cnd_muffle()"), ". Check if a restart is available\n", 
#&gt;                   "with ", list("base::findRestart(\"resume\")"), 
#&gt;                   ".\n"), "\n", "\n", "If you call ", list("cnd_muffle()"), 
#&gt;                 " with a condition that is not mufflable\n", 
#&gt;                 "you will cause a new error to be signalled.\n", 
#&gt;                 list("\n", list(), " Errors are not mufflable since they are signalled in critical\n", 
#&gt;                   "situations where execution cannot continue safely.\n", 
#&gt;                   list(), " Conditions captured with ", list(
#&gt;                     list("base::tryCatch()")), ", ", list(list(
#&gt;                     "with_handlers()")), " or\n", list(list("catch_cnd()")), 
#&gt;                   " are no longer mufflable. Muffling restarts ", 
#&gt;                   list("must"), "\n", "be called from a ", list(
#&gt;                     "calling"), " handler.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() {\n", "  inform(\"Beware!\", \"my_particular_msg\")\n", 
#&gt;                 "  inform(\"On your guard!\")\n", "  \"foobar\"\n", 
#&gt;                 "}\n", "\n", "# Let's install a muffling handler for the condition thrown by `fn()`.\n", 
#&gt;                 "# This will suppress all `my_particular_wng` warnings but let other\n", 
#&gt;                 "# types of warnings go through:\n", "with_handlers(fn(),\n", 
#&gt;                 "  my_particular_msg = calling(function(cnd) {\n", 
#&gt;                 "    inform(\"Dealt with this particular message\")\n", 
#&gt;                 "    cnd_muffle(cnd)\n", "  })\n", ")\n", "\n", 
#&gt;                 "# Note how execution of `fn()` continued normally after dealing\n", 
#&gt;                 "# with that particular message.\n", "\n", "# cnd_muffle() can also be passed to with_handlers() as a calling\n", 
#&gt;                 "# handler:\n", "with_handlers(fn(),\n", "  my_particular_msg = calling(cnd_muffle)\n", 
#&gt;                 ")\n"), "\n", list("internal"), "\n"), cnd_signal.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-signal.R", 
#&gt;             "\n", list("cnd_signal"), "\n", list("cnd_signal"), 
#&gt;             "\n", list("Signal a condition object"), "\n", list(
#&gt;                 "\n", "cnd_signal(cnd, .cnd, .mufflable)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object (see ", 
#&gt;                 list(list("cnd()")), ").")), "\n", "\n", list(
#&gt;                 list(".cnd, .mufflable"), list("These arguments are deprecated.")), 
#&gt;                 "\n"), "\n", list("\n", "The type of signal depends on the class of the condition:\n", 
#&gt;                 list("\n", list(), " A message is signalled if the condition inherits from\n", 
#&gt;                   list("\"message\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("inform()")), " or\n", list(list(
#&gt;                     "base::message()")), ".\n", list(), " A warning is signalled if the condition inherits from\n", 
#&gt;                   list("\"warning\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("warn()")), " or\n", list(list("base::warning()")), 
#&gt;                   ".\n", list(), " An error is signalled if the condition inherits from\n", 
#&gt;                   list("\"error\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("abort()")), " or\n", list(list("base::stop()")), 
#&gt;                   ".\n", list(), " An interrupt is signalled if the condition inherits from\n", 
#&gt;                   list("\"interrupt\""), ". This is equivalent to signalling with\n", 
#&gt;                   list(list("interrupt()")), ".\n"), "\n", "\n", 
#&gt;                 "Use ", list(list("cnd_type()")), " to determine the type of a condition.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list(".cnd"), " has been renamed to ", 
#&gt;                 list("cnd"), " and is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " The ", list(".mufflable"), " argument is deprecated as of rlang 0.3.0 and no\n", 
#&gt;                 "longer has any effect. Non-critical conditions are always\n", 
#&gt;                 "signalled with a muffle restart.\n", list(), 
#&gt;                 " Creating a condition object with ", list(list(
#&gt;                   "cnd_signal()")), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                 list(list("signal()")), " instead.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# The type of signal depends on the class. If the condition\n", 
#&gt;                 "# inherits from \"warning\", a warning is issued:\n", 
#&gt;                 "cnd &lt;- warning_cnd(\"my_warning_class\", message = \"This is a warning\")\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# If it inherits from \"error\", an error is raised:\n", 
#&gt;                 "cnd &lt;- error_cnd(\"my_error_class\", message = \"This is an error\")\n", 
#&gt;                 "try(cnd_signal(cnd))\n"), "\n", list("\n", list(
#&gt;                 list("abort()")), ", ", list(list("warn()")), 
#&gt;                 " and ", list(list("inform()")), " for creating and\n", 
#&gt;                 "signalling structured R conditions. See ", list(
#&gt;                   list("with_handlers()")), " for\n", "establishing condition handlers.\n"), 
#&gt;             "\n"), cnd_type.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("cnd_type"), "\n", list("cnd_type"), "\n", list(
#&gt;                 "What type is a condition?"), "\n", list("\n", 
#&gt;                 "cnd_type(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition object.")), "\n"), 
#&gt;             "\n", list("\n", "A string, either ", list("\"condition\""), 
#&gt;                 ", ", list("\"message\""), ", ", list("\"warning\""), 
#&gt;                 ",\n", list("\"error\""), " or ", list("\"interrupt\""), 
#&gt;                 ".\n"), "\n", list("\n", "Use ", list("cnd_type()"), 
#&gt;                 " to check what type a condition is.\n"), "\n", 
#&gt;             list("\n", "cnd_type(catch_cnd(abort(\"Abort!\")))\n", 
#&gt;                 "cnd_type(catch_cnd(interrupt()))\n"), "\n", 
#&gt;             list("internal"), "\n"), done.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("done"), "\n", list("done"), "\n", list("is_done_box"), 
#&gt;             "\n", list("Box a final value for early termination"), 
#&gt;             "\n", list("\n", "done(x)\n", "\n", "is_done_box(x, empty = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("For ", list(
#&gt;                 "done()"), ", a value to box. For ", list("is_done_box()"), 
#&gt;                 ", a\n", "value to test.")), "\n", "\n", list(
#&gt;                 list("empty"), list("Whether the box is empty. If ", 
#&gt;                   list("NULL"), ", ", list("is_done_box()"), 
#&gt;                   "\n", "returns ", list("TRUE"), " for all done boxes. If ", 
#&gt;                   list("TRUE"), ", it returns ", list("TRUE"), 
#&gt;                   "\n", "only for empty boxes. Otherwise it returns ", 
#&gt;                   list("TRUE"), " only for\n", "non-empty boxes.")), 
#&gt;                 "\n"), "\n", list("\n", "A ", list("boxed"), 
#&gt;                 " value.\n"), "\n", list("\n", "A value boxed with ", 
#&gt;                 list("done()"), " signals to its caller that it\n", 
#&gt;                 "should stop iterating. Use it to shortcircuit a loop.\n"), 
#&gt;             "\n", list("\n", "done(3)\n", "\n", "x &lt;- done(3)\n", 
#&gt;                 "is_done_box(x)\n"), "\n"), dots_definitions.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_definitions"), "\n", list("dots_definitions"), 
#&gt;             "\n", list("Capture definition objects"), "\n", list(
#&gt;                 "\n", "dots_definitions(..., .named = FALSE, .ignore_empty = c(\"trailing\",\n", 
#&gt;                 "  \"none\", \"all\"))\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("For ", list("enexprs()"), 
#&gt;                   ", ", list("ensyms()"), " and ", list("enquos()"), 
#&gt;                   ", names of\n", "arguments to capture without evaluation (including ", 
#&gt;                   list("..."), "). For\n", list("exprs()"), " and ", 
#&gt;                   list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                   "(including expressions contained in ", list(
#&gt;                     "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n"), "\n", list("\n", "Capture definition objects\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("dots_definitions()"), " is experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), dots_n.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_n"), "\n", list("dots_n"), "\n", list(
#&gt;                 "How many arguments are currently forwarded in dots?"), 
#&gt;             "\n", list("\n", "dots_n(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Forwarded arguments.")), 
#&gt;                 "\n"), "\n", list("\n", "This returns the number of arguments currently forwarded in ", 
#&gt;                 list("..."), "\n", "as an integer.\n"), "\n", 
#&gt;             list("\n", "fn &lt;- function(...) dots_n(..., baz)\n", 
#&gt;                 "fn(foo, bar)\n"), "\n", list("internal"), "\n"), 
#&gt;         dots_values.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("dots_values"), "\n", list("dots_values"), 
#&gt;             "\n", list("Evaluate dots with preliminary splicing"), 
#&gt;             "\n", list("\n", "dots_values(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("..."), list("Arguments to evaluate and process splicing operators.")), 
#&gt;                 "\n", "\n", list(list(".ignore_empty"), list(
#&gt;                   "Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a tool for advanced users. It captures dots, processes\n", 
#&gt;                 "unquoting and splicing operators, and evaluates them. Unlike\n", 
#&gt;                 list(list("dots_list()")), ", it does not flatten spliced objects, instead they\n", 
#&gt;                 "are attributed a ", list("spliced"), " class (see ", 
#&gt;                 list(list("splice()")), "). You can process\n", 
#&gt;                 "spliced objects manually, perhaps with a custom predicate (see\n", 
#&gt;                 list(list("flatten_if()")), ").\n"), "\n", list(
#&gt;                 "\n", "dots &lt;- dots_values(!!! list(1, 2), 3)\n", 
#&gt;                 "dots\n", "\n", "# Flatten the objects marked as spliced:\n", 
#&gt;                 "flatten_if(dots, is_spliced)\n"), "\n", list(
#&gt;                 "internal"), "\n"), duplicate.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sexp.R", 
#&gt;             "\n", list("duplicate"), "\n", list("duplicate"), 
#&gt;             "\n", list("Duplicate an R object"), "\n", list("\n", 
#&gt;                 "duplicate(x, shallow = FALSE)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("Any R object. However, uncopyable types like symbols and\n", 
#&gt;                   "environments are returned as is (just like with ", 
#&gt;                   list("&lt;-"), ").")), "\n", "\n", list(list("shallow"), 
#&gt;                   list("This is relevant for recursive data structures like\n", 
#&gt;                     "lists, calls and pairlists. A shallow copy only duplicates the\n", 
#&gt;                     "top-level data structure. The objects contained in the list are\n", 
#&gt;                     "still the same.")), "\n"), "\n", list("\n", 
#&gt;                 "In R semantics, objects are copied by value. This means that\n", 
#&gt;                 "modifying the copy leaves the original object intact. Since\n", 
#&gt;                 "copying data in memory is an expensive operation, copies in R are\n", 
#&gt;                 "as lazy as possible. They only happen when the new object is\n", 
#&gt;                 "actually modified. However, some operations (like ", 
#&gt;                 list(list("node_poke_car()")), "\n", "or ", list(
#&gt;                   list("node_poke_cdr()")), ") do not support copy-on-write. In those cases,\n", 
#&gt;                 "it is necessary to duplicate the object manually in order to\n", 
#&gt;                 "preserve copy-by-value semantics.\n"), "\n", 
#&gt;             list("\n", "Some objects are not duplicable, like symbols and environments.\n", 
#&gt;                 list("duplicate()"), " returns its input for these unique objects.\n"), 
#&gt;             "\n", list("\n", "pairlist\n"), "\n", list("internal"), 
#&gt;             "\n"), empty_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("empty_env"), "\n", list("empty_env"), 
#&gt;             "\n", list("Get the empty environment"), "\n", list(
#&gt;                 "\n", "empty_env()\n"), "\n", list("\n", "The empty environment is the only one that does not have a parent.\n", 
#&gt;                 "It is always used as the tail of an environment chain such as the\n", 
#&gt;                 "search path (see ", list(list("search_envs()")), 
#&gt;                 ").\n"), "\n", list("\n", "# Create environments with nothing in scope:\n", 
#&gt;                 "child_env(empty_env())\n"), "\n"), entrace.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("entrace"), "\n", list("entrace"), "\n", 
#&gt;             list("cnd_entrace"), "\n", list("Add backtrace from error handler"), 
#&gt;             "\n", list("\n", "entrace(cnd, ..., top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "cnd_entrace(cnd, ..., top = NULL, bottom = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("When ", 
#&gt;                 list("entrace()"), " is used as a calling handler, ", 
#&gt;                 list("cnd"), " is\n", "the condition to handle.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Unused. These dots are for future extensions.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n"), "\n", 
#&gt;             list("\n", list("entrace()"), " interrupts an error throw to add an ", 
#&gt;                 list("rlang backtrace"), " to the error. The error throw is\n", 
#&gt;                 "immediately resumed. ", list("cnd_entrace()"), 
#&gt;                 " adds a backtrace to a\n", "condition object, without any other effect. Both functions should\n", 
#&gt;                 "be called directly from an error handler.\n", 
#&gt;                 "\n", "Set the ", list("error"), " global option to ", 
#&gt;                 list("quote(rlang::entrace())"), " to\n", "transform base errors to rlang errors. These enriched errors\n", 
#&gt;                 "include a backtrace. The RProfile is a good place to set the\n", 
#&gt;                 "handler. See ", list("rlang_backtrace_on_error"), 
#&gt;                 " for details.\n", "\n", list("entrace()"), " also works as a ", 
#&gt;                 list("calling"), " handler, though it\n", "is often more practical to use the higher-level function\n", 
#&gt;                 list(list("with_abort()")), ".\n"), "\n", list(
#&gt;                 "\n", "if (FALSE) {  # Not run\n", "\n", "# Set the error handler in your RProfile like this:\n", 
#&gt;                 "if (requireNamespace(\"rlang\", quietly = TRUE)) {\n", 
#&gt;                 "  options(error = rlang::entrace)\n", "}\n", 
#&gt;                 "\n", "}\n"), "\n", list("\n", list(list("with_abort()")), 
#&gt;                 " to promote conditions to rlang errors.\n", 
#&gt;                 list(list("cnd_entrace()")), " to manually add a backtrace to a condition.\n"), 
#&gt;             "\n"), env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env"), "\n", list("env"), "\n", list("child_env"), 
#&gt;             "\n", list("new_environment"), "\n", list("Create a new environment"), 
#&gt;             "\n", list("\n", "env(...)\n", "\n", "child_env(.parent, ...)\n", 
#&gt;                 "\n", "new_environment(data = list(), parent = empty_env())\n"), 
#&gt;             "\n", list("\n", list(list("..., data"), list("Named values. You can supply one unnamed to specify\n", 
#&gt;                 "a custom parent, otherwise it defaults to the current\n", 
#&gt;                 "environment. These dots support ", list("tidy dots"), 
#&gt;                 "\n", "features.")), "\n", "\n", list(list(".parent, parent"), 
#&gt;                 list("A parent environment. Can be an object\n", 
#&gt;                   "supported by ", list(list("as_environment()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "These functions create new environments.\n", 
#&gt;                 list("\n", list(), " ", list("env()"), " creates a child of the current environment by default\n", 
#&gt;                   "and takes a variable number of named objects to populate it.\n", 
#&gt;                   list(), " ", list("new_environment()"), " creates a child of the empty environment by\n", 
#&gt;                   "default and takes a named list of objects to populate it.\n"), 
#&gt;                 "\n"), "\n", list(list("Environments as objects"), 
#&gt;                 list("\n", "\n", "\n", "Environments are containers of uniquely named objects. Their most\n", 
#&gt;                   "common use is to provide a scope for the evaluation of R\n", 
#&gt;                   "expressions. Not all languages have first class environments,\n", 
#&gt;                   "i.e. can manipulate scope as regular objects. Reification of scope\n", 
#&gt;                   "is one of the most powerful features of R as it allows you to change\n", 
#&gt;                   "what objects a function or expression sees when it is evaluated.\n", 
#&gt;                   "\n", "Environments also constitute a data structure in their own\n", 
#&gt;                   "right. They are a collection of uniquely named objects, subsettable\n", 
#&gt;                   "by name and modifiable by reference. This latter property (see\n", 
#&gt;                   "section on reference semantics) is especially useful for creating\n", 
#&gt;                   "mutable OO systems (cf the ", list(list("https://github.com/wch/R6"), 
#&gt;                     list("R6 package")), "\n", "and the ", list(
#&gt;                     list("http://ggplot2.tidyverse.org/articles/extending-ggplot2.html"), 
#&gt;                     list("ggproto system")), "\n", "for extending ggplot2).\n")), 
#&gt;             "\n", "\n", list(list("Inheritance"), list("\n", 
#&gt;                 "\n", "\n", "All R environments (except the ", 
#&gt;                 list("empty environment"), ") are\n", "defined with a parent environment. An environment and its\n", 
#&gt;                 "grandparents thus form a linear hierarchy that is the basis for\n", 
#&gt;                 list(list("https://en.wikipedia.org/wiki/Scope_(computer_science)"), 
#&gt;                   list("lexical scoping")), " in\n", "R. When R evaluates an expression, it looks up symbols in a given\n", 
#&gt;                 "environment. If it cannot find these symbols there, it keeps\n", 
#&gt;                 "looking them up in parent environments. This way, objects defined\n", 
#&gt;                 "in child environments have precedence over objects defined in\n", 
#&gt;                 "parent environments.\n", "\n", "The ability of overriding specific definitions is used in the\n", 
#&gt;                 "tidyeval framework to create powerful domain-specific grammars. A\n", 
#&gt;                 "common use of masking is to put data frame columns in scope. See\n", 
#&gt;                 "for example ", list(list("as_data_mask()")), 
#&gt;                 ".\n")), "\n", "\n", list(list("Reference semantics"), 
#&gt;                 list("\n", "\n", "\n", "Unlike regular objects such as vectors, environments are an\n", 
#&gt;                   list("uncopyable"), " object type. This means that if you\n", 
#&gt;                   "have multiple references to a given environment (by assigning the\n", 
#&gt;                   "environment to another symbol with ", list(
#&gt;                     "&lt;-"), " or passing the environment\n", "as argument to a function), modifying the bindings of one of those\n", 
#&gt;                   "references changes all other references as well.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("child_env()"), 
#&gt;                   " is in the questioning stage. It is redundant now\n", 
#&gt;                   "that ", list("env()"), " accepts parent environments.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# env() creates a new environment which has the current environment\n", 
#&gt;                 "# as parent\n", "env &lt;- env(a = 1, b = \"foo\")\n", 
#&gt;                 "env$b\n", "identical(env_parent(env), current_env())\n", 
#&gt;                 "\n", "# Supply one unnamed argument to override the default:\n", 
#&gt;                 "env &lt;- env(base_env(), a = 1, b = \"foo\")\n", 
#&gt;                 "identical(env_parent(env), base_env())\n", "\n", 
#&gt;                 "\n", "# child_env() lets you specify a parent:\n", 
#&gt;                 "child &lt;- child_env(env, c = \"bar\")\n", "identical(env_parent(child), env)\n", 
#&gt;                 "\n", "# This child environment owns `c` but inherits `a` and `b` from `env`:\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# `parent` is passed to as_environment() to provide handy\n", 
#&gt;                 "# shortcuts. Pass a string to create a child of a package\n", 
#&gt;                 "# environment:\n", "child_env(\"rlang\")\n", 
#&gt;                 "env_parent(child_env(\"rlang\"))\n", "\n", "# Or `NULL` to create a child of the empty environment:\n", 
#&gt;                 "child_env(NULL)\n", "env_parent(child_env(NULL))\n", 
#&gt;                 "\n", "# The base package environment is often a good default choice for a\n", 
#&gt;                 "# parent environment because it contains all standard base\n", 
#&gt;                 "# functions. Also note that it will never inherit from other loaded\n", 
#&gt;                 "# package environments since R keeps the base package at the tail\n", 
#&gt;                 "# of the search path:\n", "base_child &lt;- child_env(\"base\")\n", 
#&gt;                 "env_has(base_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# On the other hand, a child of the empty environment doesn't even\n", 
#&gt;                 "# see a definition for `(`\n", "empty_child &lt;- child_env(NULL)\n", 
#&gt;                 "env_has(empty_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# Note that all other package environments inherit from base_env()\n", 
#&gt;                 "# as well:\n", "rlang_child &lt;- child_env(\"rlang\")\n", 
#&gt;                 "env_has(rlang_child, \"env\", inherit = TRUE)     # rlang function\n", 
#&gt;                 "env_has(rlang_child, \"lapply\", inherit = TRUE)  # base function\n", 
#&gt;                 "\n", "\n", "# Both env() and child_env() support tidy dots features:\n", 
#&gt;                 "objs &lt;- list(b = \"foo\", c = \"bar\")\n", "env &lt;- env(a = 1, !!! objs)\n", 
#&gt;                 "env$c\n", "\n", "# You can also unquote names with the definition operator `:=`\n", 
#&gt;                 "var &lt;- \"a\"\n", "env &lt;- env(!!var := \"A\")\n", 
#&gt;                 "env$a\n", "\n", "\n", "# Use new_environment() to create containers with the empty\n", 
#&gt;                 "# environment as parent:\n", "env &lt;- new_environment()\n", 
#&gt;                 "env_parent(env)\n", "\n", "# Like other new_ constructors, it takes an object rather than dots:\n", 
#&gt;                 "new_environment(list(a = \"foo\", b = \"bar\"))\n"), 
#&gt;             "\n", list("\n", list(list("env_has()")), ", ", list(
#&gt;                 list("env_bind()")), ".\n"), "\n"), env_bind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bind"), "\n", list("env_bind"), "\n", 
#&gt;             list("env_bind_lazy"), "\n", list("env_bind_active"), 
#&gt;             "\n", list("Bind symbols to objects in an environment"), 
#&gt;             "\n", list("\n", "env_bind(.env, ...)\n", "\n", "env_bind_lazy(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_active(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", "The input object ", 
#&gt;                 list(".env"), ", with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", "These functions create bindings in an environment. The bindings are\n", 
#&gt;                 "supplied through ", list("..."), " as pairs of names and values or expressions.\n", 
#&gt;                 list("env_bind()"), " is equivalent to evaluating a ", 
#&gt;                 list("&lt;-"), " expression within\n", "the given environment. This function should take care of the\n", 
#&gt;                 "majority of use cases but the other variants can be useful for\n", 
#&gt;                 "specific problems.\n", list("\n", list(), " ", 
#&gt;                   list("env_bind()"), " takes named ", list("values"), 
#&gt;                   " which are bound in ", list(".env"), ".\n", 
#&gt;                   list("env_bind()"), " is equivalent to ", list(
#&gt;                     list("base::assign()")), ".\n", list(), " ", 
#&gt;                   list("env_bind_active()"), " takes named ", 
#&gt;                   list("functions"), " and creates active\n", 
#&gt;                   "bindings in ", list(".env"), ". This is equivalent to\n", 
#&gt;                   list(list("base::makeActiveBinding()")), ". An active binding executes a\n", 
#&gt;                   "function each time it is evaluated. The arguments are passed to\n", 
#&gt;                   list(list("as_function()")), " so you can supply formulas instead of functions.\n", 
#&gt;                   "\n", "Remember that functions are scoped in their own environment.\n", 
#&gt;                   "These functions can thus refer to symbols from this enclosure\n", 
#&gt;                   "that are not actually in scope in the dynamic environment where\n", 
#&gt;                   "the active bindings are invoked. This allows creative solutions\n", 
#&gt;                   "to difficult problems (see the implementations of ", 
#&gt;                   list("dplyr::do()"), "\n", "methods for an example).\n", 
#&gt;                   list(), " ", list("env_bind_lazy()"), " takes named ", 
#&gt;                   list("expressions"), ". This is equivalent\n", 
#&gt;                   "to ", list(list("base::delayedAssign()")), 
#&gt;                   ". The arguments are captured with\n", list(
#&gt;                     list("exprs()")), " (and thus support call-splicing and unquoting) and\n", 
#&gt;                   "assigned to symbols in ", list(".env"), ". These expressions are not\n", 
#&gt;                   "evaluated immediately but lazily. Once a symbol is evaluated, the\n", 
#&gt;                   "corresponding expression is evaluated in turn and its value is\n", 
#&gt;                   "bound to the symbol (the expressions are thus evaluated only\n", 
#&gt;                   "once, if at all).\n"), "\n"), "\n", list(list(
#&gt;                 "Side effects"), list("\n", "\n", "\n", "Since environments have reference semantics (see relevant section\n", 
#&gt;                 "in ", list(list("env()")), " documentation), modifying the bindings of an environment\n", 
#&gt;                 "produces effects in all other references to that environment. In\n", 
#&gt;                 "other words, ", list("env_bind()"), " and its variants have side effects.\n", 
#&gt;                 "\n", "Like other side-effecty functions like ", 
#&gt;                 list("par()"), " and ", list("options()"), ",\n", 
#&gt;                 list("env_bind()"), " and variants return the old values invisibly.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "Passing an environment wrapper like a formula or a function instead\n", 
#&gt;                 "of an environment is soft-deprecated as of rlang 0.3.0. This\n", 
#&gt;                 "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                 "should now extract the environment separately before calling these\n", 
#&gt;                 "functions.\n")), "\n", "\n", list("\n", "# env_bind() is a programmatic way of assigning values to symbols\n", 
#&gt;                 "# with `&lt;-`. We can add bindings in the current environment:\n", 
#&gt;                 "env_bind(current_env(), foo = \"bar\")\n", "foo\n", 
#&gt;                 "\n", "# Or modify those bindings:\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "env_bind(current_env(), bar = \"BAR\")\n", "bar\n", 
#&gt;                 "\n", "# You can remove bindings by supplying zap sentinels:\n", 
#&gt;                 "env_bind(current_env(), foo = zap())\n", "try(foo)\n", 
#&gt;                 "\n", "# Unquote-splice a named list of zaps\n", 
#&gt;                 "zaps &lt;- rep_named(c(\"foo\", \"bar\"), list(zap()))\n", 
#&gt;                 "env_bind(current_env(), !!!zaps)\n", "try(bar)\n", 
#&gt;                 "\n", "# It is most useful to change other environments:\n", 
#&gt;                 "my_env &lt;- env()\n", "env_bind(my_env, foo = \"foo\")\n", 
#&gt;                 "my_env$foo\n", "\n", "# A useful feature is to splice lists of named values:\n", 
#&gt;                 "vals &lt;- list(a = 10, b = 20)\n", "env_bind(my_env, !!!vals, c = 30)\n", 
#&gt;                 "my_env$b\n", "my_env$c\n", "\n", "# You can also unquote a variable referring to a symbol or a string\n", 
#&gt;                 "# as binding name:\n", "var &lt;- \"baz\"\n", "env_bind(my_env, !!var := \"BAZ\")\n", 
#&gt;                 "my_env$baz\n", "\n", "\n", "# The old values of the bindings are returned invisibly:\n", 
#&gt;                 "old &lt;- env_bind(my_env, a = 1, b = 2, baz = \"baz\")\n", 
#&gt;                 "old\n", "\n", "# You can restore the original environment state by supplying the\n", 
#&gt;                 "# old values back:\n", "env_bind(my_env, !!!old)\n", 
#&gt;                 "\n", "# env_bind_lazy() assigns expressions lazily:\n", 
#&gt;                 "env &lt;- env()\n", "env_bind_lazy(env, name = { cat(\"forced!\\n\"); \"value\" })\n", 
#&gt;                 "\n", "# Referring to the binding will cause evaluation:\n", 
#&gt;                 "env$name\n", "\n", "# But only once, subsequent references yield the final value:\n", 
#&gt;                 "env$name\n", "\n", "# You can unquote expressions:\n", 
#&gt;                 "expr &lt;- quote(message(\"forced!\"))\n", "env_bind_lazy(env, name = !!expr)\n", 
#&gt;                 "env$name\n", "\n", "\n", "# By default the expressions are evaluated in the current\n", 
#&gt;                 "# environment. For instance we can create a local binding and refer\n", 
#&gt;                 "# to it, even though the variable is bound in a different\n", 
#&gt;                 "# environment:\n", "who &lt;- \"mickey\"\n", "env_bind_lazy(env, name = paste(who, \"mouse\"))\n", 
#&gt;                 "env$name\n", "\n", "# You can specify another evaluation environment with `.eval_env`:\n", 
#&gt;                 "eval_env &lt;- env(who = \"minnie\")\n", "env_bind_lazy(env, name = paste(who, \"mouse\"), .eval_env = eval_env)\n", 
#&gt;                 "env$name\n", "\n", "# Or by unquoting a quosure:\n", 
#&gt;                 "quo &lt;- local({\n", "  who &lt;- \"fievel\"\n", 
#&gt;                 "  quo(paste(who, \"mouse\"))\n", "})\n", "env_bind_lazy(env, name = !!quo)\n", 
#&gt;                 "env$name\n", "\n", "# You can create active bindings with env_bind_active(). Active\n", 
#&gt;                 "# bindings execute a function each time they are evaluated:\n", 
#&gt;                 "fn &lt;- function() {\n", "  cat(\"I have been called\\n\")\n", 
#&gt;                 "  rnorm(1)\n", "}\n", "\n", "env &lt;- env()\n", 
#&gt;                 "env_bind_active(env, symbol = fn)\n", "\n", 
#&gt;                 "# `fn` is executed each time `symbol` is evaluated or retrieved:\n", 
#&gt;                 "env$symbol\n", "env$symbol\n", "eval_bare(quote(symbol), env)\n", 
#&gt;                 "eval_bare(quote(symbol), env)\n", "\n", "# All arguments are passed to as_function() so you can use the\n", 
#&gt;                 "# formula shortcut:\n", "env_bind_active(env, foo = ~ runif(1))\n", 
#&gt;                 "env$foo\n", "env$foo\n"), "\n"), env_bind_exprs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("env_bind_exprs"), "\n", list("env_bind_exprs"), 
#&gt;             "\n", list("env_bind_fns"), "\n", list("Bind a promise or active binding"), 
#&gt;             "\n", list("\n", "env_bind_exprs(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_fns(.env, ...)\n"), "\n", list(
#&gt;                 "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.3.0, ", list("env_bind_exprs()"), 
#&gt;                 " and ", list("env_bind_fns()"), " have\n", "been renamed to ", 
#&gt;                 list(list("env_bind_lazy()")), " and ", list(
#&gt;                   list("env_bind_active()")), " for\n", "consistency.\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_are_active.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_are_active"), "\n", list(
#&gt;                 "env_binding_are_active"), "\n", list("env_binding_are_lazy"), 
#&gt;             "\n", list("What kind of environment binding?"), 
#&gt;             "\n", list("\n", "env_binding_are_active(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_lazy(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "A logical vector as long as ", list("nms"), 
#&gt;                 " and named after it.\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_lock.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_lock"), "\n", list("env_binding_lock"), 
#&gt;             "\n", list("env_binding_unlock"), "\n", list("env_binding_are_locked"), 
#&gt;             "\n", list("Lock or unlock environment bindings"), 
#&gt;             "\n", list("\n", "env_binding_lock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_unlock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_locked(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("env_binding_are_unlocked()"), " returns a logical vector as\n", 
#&gt;                 "long as ", list("nms"), " and named after it. ", 
#&gt;                 list("env_binding_lock()"), " and\n", list("env_binding_unlock()"), 
#&gt;                 " return the old value of\n", list("env_binding_are_unlocked()"), 
#&gt;                 " invisibly.\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environment bindings trigger an error when an attempt is\n", 
#&gt;                 "made to redefine the binding.\n"), "\n", list(
#&gt;                 "\n", "# Bindings are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = \"A\", b = \"B\")\n", "env_binding_are_locked(env)\n", 
#&gt;                 "\n", "# But can optionally be locked:\n", "env_binding_lock(env, \"a\")\n", 
#&gt;                 "env_binding_are_locked(env)\n", "\n", "# If run, the following would now return an error because `a` is locked:\n", 
#&gt;                 "# env_bind(env, a = \"foo\")\n", "# with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "\n", "# Let's unlock it. Note that the return value indicate which\n", 
#&gt;                 "# bindings were locked:\n", "were_locked &lt;- env_binding_unlock(env)\n", 
#&gt;                 "were_locked\n", "\n", "# Now that it is unlocked we can modify it again:\n", 
#&gt;                 "env_bind(env, a = \"foo\")\n", "with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "env$a\n"), "\n", list("\n", list(list("env_lock()")), 
#&gt;                 " for locking an environment.\n"), "\n", list(
#&gt;                 "internal"), "\n"), env_bury.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bury"), "\n", list("env_bury"), "\n", 
#&gt;             list("Mask bindings by defining symbols deeper in a scope"), 
#&gt;             "\n", list("\n", "env_bury(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n"), "\n", list("\n", "A copy of ", 
#&gt;                 list(".env"), " enclosing the new environment containing\n", 
#&gt;                 "bindings to ", list("..."), " arguments.\n"), 
#&gt;             "\n", list("\n", list("env_bury()"), " is like ", 
#&gt;                 list(list("env_bind()")), " but it creates the bindings in a\n", 
#&gt;                 "new child environment. This makes sure the new bindings have\n", 
#&gt;                 "precedence over old ones, without altering existing environments.\n", 
#&gt;                 "Unlike ", list("env_bind()"), ", this function does not have side effects and\n", 
#&gt;                 "returns a new environment (or object wrapping that environment).\n"), 
#&gt;             "\n", list("\n", "orig_env &lt;- env(a = 10)\n", "fn &lt;- set_env(function() a, orig_env)\n", 
#&gt;                 "\n", "# fn() currently sees `a` as the value `10`:\n", 
#&gt;                 "fn()\n", "\n", "# env_bury() will bury the current scope of fn() behind a new\n", 
#&gt;                 "# environment:\n", "fn &lt;- env_bury(fn, a = 1000)\n", 
#&gt;                 "fn()\n", "\n", "# Even though the symbol `a` is still defined deeper in the scope:\n", 
#&gt;                 "orig_env$a\n"), "\n", list("\n", list(list("env_bind()")), 
#&gt;                 ", ", list(list("env_unbind()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), env_clone.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_clone"), "\n", list("env_clone"), "\n", 
#&gt;             list("Clone an environment"), "\n", list("\n", "env_clone(env, parent = env_parent(env))\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("The parent of the cloned environment.")), 
#&gt;                 "\n"), "\n", list("\n", "This creates a new environment containing exactly the same objects,\n", 
#&gt;                 "optionally with a new parent.\n"), "\n", list(
#&gt;                 "\n", "env &lt;- env(!!! mtcars)\n", "clone &lt;- env_clone(env)\n", 
#&gt;                 "identical(env, clone)\n", "identical(env$cyl, clone$cyl)\n"), 
#&gt;             "\n"), env_depth.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_depth"), "\n", list("env_depth"), "\n", 
#&gt;             list("Depth of an environment chain"), "\n", list(
#&gt;                 "\n", "env_depth(env)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n"), 
#&gt;             "\n", list("\n", "An integer.\n"), "\n", list("\n", 
#&gt;                 "This function returns the number of environments between ", 
#&gt;                 list("env"), " and\n", "the ", list("empty environment"), 
#&gt;                 ", including ", list("env"), ". The depth of\n", 
#&gt;                 list("env"), " is also the number of parents of ", 
#&gt;                 list("env"), " (since the empty\n", "environment counts as a parent).\n"), 
#&gt;             "\n", list("\n", "env_depth(empty_env())\n", "env_depth(pkg_env(\"rlang\"))\n"), 
#&gt;             "\n", list("\n", "The section on inheritance in ", 
#&gt;                 list(list("env()")), " documentation.\n"), "\n"), 
#&gt;         env_get.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_get"), "\n", list("env_get"), "\n", 
#&gt;             list("env_get_list"), "\n", list("Get an object in an environment"), 
#&gt;             "\n", list("\n", "env_get(env = caller_env(), nm, default, inherit = FALSE)\n", 
#&gt;                 "\n", "env_get_list(env = caller_env(), nms, default, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nm, nms"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default value in case there is no binding for ", 
#&gt;                   list("nm"), "\n", "in ", list("env"), ".")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "An object if it exists. Otherwise, throws an error.\n"), 
#&gt;             "\n", list("\n", list("env_get()"), " extracts an object from an enviroment ", 
#&gt;                 list("env"), ". By\n", "default, it does not look in the parent environments.\n", 
#&gt;                 list("env_get_list()"), " extracts multiple objects from an environment into\n", 
#&gt;                 "a named list.\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# This throws an error because `foo` is not directly defined in env:\n", 
#&gt;                 "# env_get(env, \"foo\")\n", "\n", "# However `foo` can be fetched in the parent environment:\n", 
#&gt;                 "env_get(env, \"foo\", inherit = TRUE)\n", "\n", 
#&gt;                 "# You can also avoid an error by supplying a default value:\n", 
#&gt;                 "env_get(env, \"foo\", default = \"FOO\")\n"), 
#&gt;             "\n"), env_has.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_has"), "\n", list("env_has"), "\n", 
#&gt;             list("Does an environment have or see bindings?"), 
#&gt;             "\n", list("\n", "env_has(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "A named logical vector as long as ", list("nms"), 
#&gt;                 ".\n"), "\n", list("\n", list("env_has()"), " is a vectorised predicate that queries whether an\n", 
#&gt;                 "environment owns bindings personally (with ", 
#&gt;                 list("inherit"), " set to\n", list("FALSE"), 
#&gt;                 ", the default), or sees them in its own environment or in\n", 
#&gt;                 "any of its parents (with ", list("inherit = TRUE"), 
#&gt;                 ").\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# env does not own `foo` but sees it in its parent environment:\n", 
#&gt;                 "env_has(env, \"foo\")\n", "env_has(env, \"foo\", inherit = TRUE)\n"), 
#&gt;             "\n"), env_inherits.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_inherits"), "\n", list("env_inherits"), 
#&gt;             "\n", list("Does environment inherit from another environment?"), 
#&gt;             "\n", list("\n", "env_inherits(env, ancestor)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("ancestor"), list("Another environment from which ", 
#&gt;                   list("x"), " might inherit.")), "\n"), "\n", 
#&gt;             list("\n", "This returns ", list("TRUE"), " if ", 
#&gt;                 list("x"), " has ", list("ancestor"), " among its parents.\n"), 
#&gt;             "\n"), env_lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_lock"), "\n", list("env_lock"), "\n", list(
#&gt;                 "env_is_locked"), "\n", list("Lock an environment"), 
#&gt;             "\n", list("\n", "env_lock(env)\n", "\n", "env_is_locked(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "The old value of ", 
#&gt;                 list("env_is_locked()"), " invisibly.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environments cannot be modified. An important example is\n", 
#&gt;                 "namespace environments which are locked by R when loaded in a\n", 
#&gt;                 "session. Once an environment is locked it normally cannot be\n", 
#&gt;                 "unlocked.\n", "\n", "Note that only the environment as a container is locked, not the\n", 
#&gt;                 "individual bindings. You can't remove or add a binding but you can\n", 
#&gt;                 "still modify the values of existing bindings. See\n", 
#&gt;                 list(list("env_binding_lock()")), " for locking individual bindings.\n"), 
#&gt;             "\n", list("\n", "# New environments are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = 1)\n", "env_is_locked(env)\n", 
#&gt;                 "\n", "# Use env_lock() to lock them:\n", "env_lock(env)\n", 
#&gt;                 "env_is_locked(env)\n", "\n", "# Now that `env` is locked, it is no longer possible to remove or\n", 
#&gt;                 "# add bindings. If run, the following would fail:\n", 
#&gt;                 "# env_unbind(env, \"a\")\n", "# env_bind(env, b = 2)\n", 
#&gt;                 "\n", "# Note that even though the environment as a container is locked,\n", 
#&gt;                 "# the individual bindings are still unlocked and can be modified:\n", 
#&gt;                 "env$a &lt;- 10\n"), "\n", list("\n", list(list(
#&gt;                 "env_binding_lock()")), "\n"), "\n", list("internal"), 
#&gt;             "\n"), env_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("env_name"), "\n", list("env_name"), "\n", 
#&gt;             list("env_label"), "\n", list("Label of an environment"), 
#&gt;             "\n", list("\n", "env_name(env)\n", "\n", "env_label(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Special environments like the global environment have their own\n", 
#&gt;                 "names. ", list("env_name()"), " returns:\n", 
#&gt;                 list("\n", list(), " \"global\" for the global environment.\n", 
#&gt;                   list(), " \"empty\" for the empty environment.\n", 
#&gt;                   list(), " \"base\" for the base package environment (the last environment on\n", 
#&gt;                   "the search path).\n", list(), " \"namespace:pkg\" if ", 
#&gt;                   list("env"), " is the namespace of the package \"pkg\".\n", 
#&gt;                   list(), " The ", list("name"), " attribute of ", 
#&gt;                   list("env"), " if it exists. This is how the\n", 
#&gt;                   list("package environments"), " and the ", 
#&gt;                   list("imports environments"), " store their names. The name of package\n", 
#&gt;                   "environments is typically \"package:pkg\".\n", 
#&gt;                   list(), " The empty string ", list("\"\""), 
#&gt;                   " otherwise.\n"), "\n", "\n", list("env_label()"), 
#&gt;                 " is exactly like ", list("env_name()"), " but returns the memory\n", 
#&gt;                 "address of anonymous environments as fallback.\n"), 
#&gt;             "\n", list("\n", "# Some environments have specific names:\n", 
#&gt;                 "env_name(global_env())\n", "env_name(ns_env(\"rlang\"))\n", 
#&gt;                 "\n", "# Anonymous environments don't have names but are labelled by their\n", 
#&gt;                 "# address in memory:\n", "env_name(env())\n", 
#&gt;                 "env_label(env())\n"), "\n"), env_names.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_names"), "\n", list("env_names"), 
#&gt;             "\n", list("env_length"), "\n", list("Names and numbers of symbols bound in an environment"), 
#&gt;             "\n", list("\n", "env_names(env)\n", "\n", "env_length(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of object names.\n"), 
#&gt;             "\n", list("\n", list("env_names()"), " returns object names from an enviroment ", 
#&gt;                 list("env"), " as a\n", "character vector. All names are returned, even those starting with\n", 
#&gt;                 "a dot. ", list("env_length()"), " returns the number of bindings.\n"), 
#&gt;             "\n", list(list("Names of symbols and objects"), 
#&gt;                 list("\n", "\n", "\n", "Technically, objects are bound to symbols rather than strings,\n", 
#&gt;                   "since the R interpreter evaluates symbols (see ", 
#&gt;                   list(list("is_expression()")), " for a\n", 
#&gt;                   "discussion of symbolic objects versus literal objects). However it\n", 
#&gt;                   "is often more convenient to work with strings. In rlang\n", 
#&gt;                   "terminology, the string corresponding to a symbol is called the\n", 
#&gt;                   list("name"), " of the symbol (or by extension the name of an object bound\n", 
#&gt;                   "to a symbol).\n")), "\n", "\n", list(list(
#&gt;                 "Encoding"), list("\n", "\n", "\n", "There are deep encoding issues when you convert a string to symbol\n", 
#&gt;                 "and vice versa. Symbols are ", list("always"), 
#&gt;                 " in the native encoding. If\n", "that encoding (let's say latin1) cannot support some characters,\n", 
#&gt;                 "these characters are serialised to ASCII. That's why you sometimes\n", 
#&gt;                 "see strings looking like ", list("&lt;U+1234&gt;"), 
#&gt;                 ", especially if you're running\n", "Windows (as R doesn't support UTF-8 as native encoding on that\n", 
#&gt;                 "platform).\n", "\n", "To alleviate some of the encoding pain, ", 
#&gt;                 list("env_names()"), " always\n", "returns a UTF-8 character vector (which is fine even on Windows)\n", 
#&gt;                 "with ASCII unicode points translated back to UTF-8.\n")), 
#&gt;             "\n", "\n", list("\n", "env &lt;- env(a = 1, b = 2)\n", 
#&gt;                 "env_names(env)\n"), "\n"), env_parent.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "env_parent"), "\n", list("env_parent"), "\n", 
#&gt;             list("env_tail"), "\n", list("env_parents"), "\n", 
#&gt;             list("Get parent environments"), "\n", list("\n", 
#&gt;                 "env_parent(env = caller_env(), n = 1)\n", "\n", 
#&gt;                 "env_tail(env = caller_env(), last = global_env(), sentinel = NULL)\n", 
#&gt;                 "\n", "env_parents(env = caller_env(), last = global_env())\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of generations to go up.")), 
#&gt;                 "\n", "\n", list(list("last"), list("The environment at which to stop. Defaults to the\n", 
#&gt;                   "global environment. The empty environment is always a stopping\n", 
#&gt;                   "condition so it is safe to leave the default even when taking the\n", 
#&gt;                   "tail or the parents of an environment on the search path.\n", 
#&gt;                   "\n", list("env_tail()"), " returns the environment which has ", 
#&gt;                   list("last"), " as parent\n", "and ", list(
#&gt;                     "env_parents()"), " returns the list of environments up to ", 
#&gt;                   list("last"), ".")), "\n", "\n", list(list(
#&gt;                   "sentinel"), list("This argument is defunct, please use ", 
#&gt;                   list("last"), " instead.")), "\n"), "\n", list(
#&gt;                 "\n", "An environment for ", list("env_parent()"), 
#&gt;                 " and ", list("env_tail()"), ", a list\n", "of environments for ", 
#&gt;                 list("env_parents()"), ".\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("env_parent()"), 
#&gt;                   " returns the parent environment of ", list(
#&gt;                     "env"), " if called\n", "with ", list("n = 1"), 
#&gt;                   ", the grandparent with ", list("n = 2"), ", etc.\n", 
#&gt;                   list(), " ", list("env_tail()"), " searches through the parents and returns the one\n", 
#&gt;                   "which has ", list(list("empty_env()")), " as parent.\n", 
#&gt;                   list(), " ", list("env_parents()"), " returns the list of all parents, including the\n", 
#&gt;                   "empty environment. This list is named using ", 
#&gt;                   list(list("env_name()")), ".\n"), "\n", "\n", 
#&gt;                 "See the section on ", list("inheritance"), " in ", 
#&gt;                 list(list("env()")), "'s documentation.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "The ", list("sentinel"), " argument of ", list(
#&gt;                   "env_tail()"), " has been deprecated in\n", 
#&gt;                 "rlang 0.2.0 and renamed to ", list("last"), 
#&gt;                 ". It is defunct as of rlang 0.4.0.\n")), "\n", 
#&gt;             "\n", list("\n", "# Get the parent environment with env_parent():\n", 
#&gt;                 "env_parent(global_env())\n", "\n", "# Or the tail environment with env_tail():\n", 
#&gt;                 "env_tail(global_env())\n", "\n", "# By default, env_parent() returns the parent environment of the\n", 
#&gt;                 "# current evaluation frame. If called at top-level (the global\n", 
#&gt;                 "# frame), the following two expressions are equivalent:\n", 
#&gt;                 "env_parent()\n", "env_parent(base_env())\n", 
#&gt;                 "\n", "# This default is more handy when called within a function. In this\n", 
#&gt;                 "# case, the enclosure environment of the function is returned\n", 
#&gt;                 "# (since it is the parent of the evaluation frame):\n", 
#&gt;                 "enclos_env &lt;- env()\n", "fn &lt;- set_env(function() env_parent(), enclos_env)\n", 
#&gt;                 "identical(enclos_env, fn())\n"), "\n"), env_poke.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_poke"), "\n", list("env_poke"), "\n", 
#&gt;             list("Poke an object in an environment"), "\n", list(
#&gt;                 "\n", "env_poke(env = caller_env(), nm, value, inherit = FALSE,\n", 
#&gt;                 "  create = !inherit)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n", 
#&gt;                 "\n", list(list("nm"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for a new binding.")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n", "\n", list(list("create"), 
#&gt;                   list("Whether to create a binding if it does not already\n", 
#&gt;                     "exist in the environment.")), "\n"), "\n", 
#&gt;             list("\n", "The old value of ", list("nm"), " or a ", 
#&gt;                 list("zap sentinel"), " if the\n", "binding did not exist yet.\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("env_poke()"), " will assign or reassign a binding in ", 
#&gt;                 list("env"), " if ", list("create"), "\n", "is ", 
#&gt;                 list("TRUE"), ". If ", list("create"), " is ", 
#&gt;                 list("FALSE"), " and a binding does not already\n", 
#&gt;                 "exists, an error is issued.\n"), "\n", list(
#&gt;                 "\n", "If ", list("inherit"), " is ", list("TRUE"), 
#&gt;                 ", the parents environments are checked for\n", 
#&gt;                 "an existing binding to reassign. If not found and ", 
#&gt;                 list("create"), " is\n", list("TRUE"), ", a new binding is created in ", 
#&gt;                 list("env"), ". The default value for\n", list(
#&gt;                   "create"), " is a function of ", list("inherit"), 
#&gt;                 ": ", list("FALSE"), " when inheriting,\n", list(
#&gt;                   "TRUE"), " otherwise.\n", "\n", "This default makes sense because the inheriting case is mostly\n", 
#&gt;                 "for overriding an existing binding. If not found, something\n", 
#&gt;                 "probably went wrong and it is safer to issue an error. Note that\n", 
#&gt;                 "this is different to the base R operator ", 
#&gt;                 list("&lt;&lt;-"), " which will create\n", "a binding in the global environment instead of the current\n", 
#&gt;                 "environment when no existing binding is found in the parents.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("env_poke()"), " is experimental. We are still experimenting with\n", 
#&gt;                 "reducing the number of redundant functions by using quasiquotation.\n", 
#&gt;                 "It is possible ", list("env_poke()"), " will be deprecated in favour of\n", 
#&gt;                 list("env_bind()"), " and name-unquoting with ", 
#&gt;                 list(":="), ".\n")), "\n", "\n", list("internal"), 
#&gt;             "\n"), env_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_print"), "\n", list("env_print"), "\n", 
#&gt;             list("Pretty-print an environment"), "\n", list("\n", 
#&gt;                 "env_print(env = caller_env())\n"), "\n", list(
#&gt;                 "\n", list(list("env"), list("An environment, or object that can be converted to an\n", 
#&gt;                   "environment by ", list(list("get_env()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This prints:\n", 
#&gt;                 list("\n", list(), " The ", list("label"), " and the parent label.\n", 
#&gt;                   list(), " Whether the environment is ", list(
#&gt;                     "locked"), ".\n", list(), " The bindings in the environment (up to 20 bindings). They are\n", 
#&gt;                   "printed succintly using ", list("pillar::type_sum()"), 
#&gt;                   " (if available,\n", "otherwise uses an internal version of that generic). In addition\n", 
#&gt;                   list("fancy bindings"), " (actives and promises) are\n", 
#&gt;                   "indicated as such.\n", list(), " Locked bindings get a ", 
#&gt;                   list("[L]"), " tag\n"), "\n"), "\n"), env_unbind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_unbind"), "\n", list("env_unbind"), 
#&gt;             "\n", list("Remove bindings from an environment"), 
#&gt;             "\n", list("\n", "env_unbind(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "The input object ", list("env"), " with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", list("env_unbind()"), " is the complement of ", 
#&gt;                 list(list("env_bind()")), ". Like ", list("env_has()"), 
#&gt;                 ",\n", "it ignores the parent environments of ", 
#&gt;                 list("env"), " by default. Set\n", list("inherit"), 
#&gt;                 " to ", list("TRUE"), " to track down bindings in parent environments.\n"), 
#&gt;             "\n", list("\n", "data &lt;- set_names(as.list(letters), letters)\n", 
#&gt;                 "env_bind(environment(), !!! data)\n", "env_has(environment(), letters)\n", 
#&gt;                 "\n", "# env_unbind() removes bindings:\n", "env_unbind(environment(), letters)\n", 
#&gt;                 "env_has(environment(), letters)\n", "\n", "# With inherit = TRUE, it removes bindings in parent environments\n", 
#&gt;                 "# as well:\n", "parent &lt;- child_env(NULL, foo = \"a\")\n", 
#&gt;                 "env &lt;- child_env(parent, foo = \"b\")\n", "env_unbind(env, \"foo\", inherit = TRUE)\n", 
#&gt;                 "env_has(env, \"foo\", inherit = TRUE)\n"), "\n"), 
#&gt;         env_unlock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_unlock"), "\n", list("env_unlock"), "\n", 
#&gt;             list("Unlock an environment"), "\n", list("\n", "env_unlock(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Whether the environment has been unlocked.\n"), 
#&gt;             "\n", list("\n", "This function should only be used in development tools or\n", 
#&gt;                 "interactively.\n"), "\n", list("internal"), 
#&gt;             "\n"), eval_bare.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("eval_bare"), "\n", list("eval_bare"), 
#&gt;             "\n", list("Evaluate an expression in an environment"), 
#&gt;             "\n", list("\n", "eval_bare(expr, env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate the expression.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_bare()"), " is a lower-level version of function ", 
#&gt;                 list(list("base::eval()")), ".\n", "Technically, it is a simple wrapper around the C function\n", 
#&gt;                 list("Rf_eval()"), ". You generally don't need to use ", 
#&gt;                 list("eval_bare()"), " instead\n", "of ", list(
#&gt;                   "eval()"), ". Its main advantage is that it handles stack-sensitive\n", 
#&gt;                 "(calls such as ", list("return()"), ", ", list(
#&gt;                   "on.exit()"), " or ", list("parent.frame()"), 
#&gt;                 ") more\n", "consistently when you pass an enviroment of a frame on the call\n", 
#&gt;                 "stack.\n"), "\n", list("\n", "These semantics are possible because ", 
#&gt;                 list("eval_bare()"), " creates only one\n", "frame on the call stack whereas ", 
#&gt;                 list("eval()"), " creates two frames, the\n", 
#&gt;                 "second of which has the user-supplied environment as frame\n", 
#&gt;                 "environment. When you supply an existing frame environment to\n", 
#&gt;                 list("base::eval()"), " there will be two frames on the stack with the same\n", 
#&gt;                 "frame environment. Stack-sensitive functions only detect the\n", 
#&gt;                 "topmost of these frames. We call these evaluation semantics\n", 
#&gt;                 "\"stack inconsistent\".\n", "\n", "Evaluating expressions in the actual frame environment has useful\n", 
#&gt;                 "practical implications for ", list("eval_bare()"), 
#&gt;                 ":\n", list("\n", list(), " ", list("return()"), 
#&gt;                   " calls are evaluated in frame environments that might\n", 
#&gt;                   "be burried deep in the call stack. This causes a long return that\n", 
#&gt;                   "unwinds multiple frames (triggering the ", 
#&gt;                   list("on.exit()"), " event for\n", "each frame). By contrast ", 
#&gt;                   list("eval()"), " only returns from the ", 
#&gt;                   list("eval()"), "\n", "call, one level up.\n", 
#&gt;                   list(), " ", list("on.exit()"), ", ", list(
#&gt;                     "parent.frame()"), ", ", list("sys.call()"), 
#&gt;                   ", and generally all\n", "the stack inspection functions ", 
#&gt;                   list("sys.xxx()"), " are evaluated in the\n", 
#&gt;                   "correct frame environment. This is similar to how this type of\n", 
#&gt;                   "calls can be evaluated deep in the call stack because of lazy\n", 
#&gt;                   "evaluation, when you force an argument that has been passed\n", 
#&gt;                   "around several times.\n"), "\n", "\n", "The flip side of the semantics of ", 
#&gt;                 list("eval_bare()"), " is that it can't\n", "evaluate ", 
#&gt;                 list("break"), " or ", list("next"), " expressions even if called within a\n", 
#&gt;                 "loop.\n"), "\n", list("\n", "# eval_bare() works just like base::eval() but you have to create\n", 
#&gt;                 "# the evaluation environment yourself:\n", "eval_bare(quote(foo), env(foo = \"bar\"))\n", 
#&gt;                 "\n", "# eval() has different evaluation semantics than eval_bare(). It\n", 
#&gt;                 "# can return from the supplied environment even if its an\n", 
#&gt;                 "# environment that is not on the call stack (i.e. because you've\n", 
#&gt;                 "# created it yourself). The following would trigger an error with\n", 
#&gt;                 "# eval_bare():\n", "ret &lt;- quote(return(\"foo\"))\n", 
#&gt;                 "eval(ret, env())\n", "# eval_bare(ret, env())  # \"no function to return from\" error\n", 
#&gt;                 "\n", "# Another feature of eval() is that you can control surround loops:\n", 
#&gt;                 "bail &lt;- quote(break)\n", "while (TRUE) {\n", 
#&gt;                 "  eval(bail)\n", "  # eval_bare(bail)  # \"no loop for break/next\" error\n", 
#&gt;                 "}\n", "\n", "# To explore the consequences of stack inconsistent semantics, let's\n", 
#&gt;                 "# create a function that evaluates `parent.frame()` deep in the call\n", 
#&gt;                 "# stack, in an environment corresponding to a frame in the middle of\n", 
#&gt;                 "# the stack. For consistency with R's lazy evaluation semantics, we'd\n", 
#&gt;                 "# expect to get the caller of that frame as result:\n", 
#&gt;                 "fn &lt;- function(eval_fn) {\n", "  list(\n", "    returned_env = middle(eval_fn),\n", 
#&gt;                 "    actual_env = current_env()\n", "  )\n", 
#&gt;                 "}\n", "middle &lt;- function(eval_fn) {\n", "  deep(eval_fn, current_env())\n", 
#&gt;                 "}\n", "deep &lt;- function(eval_fn, eval_env) {\n", 
#&gt;                 "  expr &lt;- quote(parent.frame())\n", "  eval_fn(expr, eval_env)\n", 
#&gt;                 "}\n", "\n", "# With eval_bare(), we do get the expected environment:\n", 
#&gt;                 "fn(rlang::eval_bare)\n", "\n", "# But that's not the case with base::eval():\n", 
#&gt;                 "fn(base::eval)\n"), "\n", list("\n", list(list(
#&gt;                 "eval_tidy()")), " for evaluation with data mask and quosure\n", 
#&gt;                 "support.\n"), "\n"), eval_tidy.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("eval_tidy"), "\n", list("eval_tidy"), 
#&gt;             "\n", list("Evaluate an expression with quosures and pronoun support"), 
#&gt;             "\n", list("\n", "eval_tidy(expr, data = NULL, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression or quosure to evaluate.")), 
#&gt;                 "\n", "\n", list(list("data"), list("A data frame, or named list or vector. Alternatively, a\n", 
#&gt;                   "data mask created with ", list(list("as_data_mask()")), 
#&gt;                   " or\n", list(list("new_data_mask()")), ". Objects in ", 
#&gt;                   list("data"), " have priority over those in\n", 
#&gt;                   list("env"), ". See the section about data masking.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate ", 
#&gt;                   list("expr"), ". This\n", "environment is not applicable for quosures because they have\n", 
#&gt;                   "their own environments.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_tidy()"), " is a variant of ", 
#&gt;                 list(list("base::eval()")), " that powers the tidy\n", 
#&gt;                 "evaluation framework. Like ", list("eval()"), 
#&gt;                 " it accepts user data as\n", "argument. Whereas ", 
#&gt;                 list("eval()"), " simply transforms the data to an\n", 
#&gt;                 "environment, ", list("eval_tidy()"), " transforms it to a ", 
#&gt;                 list("data mask"), " with\n", list(list("as_data_mask()")), 
#&gt;                 ". Evaluating in a data mask enables the following\n", 
#&gt;                 "features:\n", list("\n", list(), " ", list("Quosures"), 
#&gt;                   ". Quosures are expressions bundled with an\n", 
#&gt;                   "environment. If ", list("data"), " is supplied, objects in the data mask\n", 
#&gt;                   "always have precedence over the quosure environment, i.e. the\n", 
#&gt;                   "data masks the environment.\n", list(), " ", 
#&gt;                   list("Pronouns"), ". If ", list("data"), " is supplied, the ", 
#&gt;                   list(".env"), " and ", list(".data"), "\n", 
#&gt;                   "pronouns are installed in the data mask. ", 
#&gt;                   list(".env"), " is a reference to\n", "the calling environment and ", 
#&gt;                   list(".data"), " refers to the ", list("data"), 
#&gt;                   " argument.\n", "These pronouns lets you be explicit about where to find\n", 
#&gt;                   "values and throw errors if you try to access non-existent values.\n"), 
#&gt;                 "\n"), "\n", list(list("Data masking"), list(
#&gt;                 "\n", "\n", "\n", "Data masking refers to how columns or objects inside ", 
#&gt;                 list("data"), " have\n", "priority over objects defined in ", 
#&gt;                 list("env"), " (or in the quosure\n", "environment, if applicable). If there is a column ", 
#&gt;                 list("var"), " in ", list("data"), "\n", "and an object ", 
#&gt;                 list("var"), " in ", list("env"), ", and ", list(
#&gt;                   "expr"), " refers to ", list("var"), ", the\n", 
#&gt;                 "column has priority:", list("var &lt;- \"this one?\"\n", 
#&gt;                   "data &lt;- data.frame(var = rep(\"Or that one?\", 3))\n", 
#&gt;                   "\n", "within &lt;- function(data, expr) {\n", 
#&gt;                   "  eval_tidy(enquo(expr), data)\n", "}\n", 
#&gt;                   "\n", "within(data, toupper(var))\n", "#&gt; [1] \"OR THAT ONE?\" \"OR THAT ONE?\" \"OR THAT ONE?\"\n"), 
#&gt;                 "\n", "\n", "Because the columns or objects in ", 
#&gt;                 list("data"), " are always found first,\n", "before objects from ", 
#&gt;                 list("env"), ", we say that the data \"masks\" the\n", 
#&gt;                 "environment.\n")), "\n", "\n", list(list("When should eval_tidy() be used instead of eval()?"), 
#&gt;                 list("\n", "\n", "\n", list("base::eval()"), 
#&gt;                   " is sufficient for simple evaluation. Use\n", 
#&gt;                   list("eval_tidy()"), " when you'd like to support expressions referring to\n", 
#&gt;                   "the ", list(".data"), " pronoun, or when you need to support quosures.\n", 
#&gt;                   "\n", "If you're evaluating an expression captured with quasiquotation\n", 
#&gt;                   "support, it is recommended to use ", list(
#&gt;                     "eval_tidy()"), " because users will\n", 
#&gt;                   "likely unquote quosures.\n", "\n", "Note that unwrapping a quosure with ", 
#&gt;                   list(list("quo_get_expr()")), " does not\n", 
#&gt;                   "guarantee that there is no quosures inside the expression. Quosures\n", 
#&gt;                   "might be unquoted anywhere. For instance, the following does not\n", 
#&gt;                   "work reliably in the presence of nested quosures:", 
#&gt;                   list("my_quoting_fn &lt;- function(x) {\n", "  x &lt;- enquo(x)\n", 
#&gt;                     "  expr &lt;- quo_get_expr(x)\n", "  env &lt;- quo_get_env(x)\n", 
#&gt;                     "  eval(expr, env)\n", "}\n", "\n", "# Works:\n", 
#&gt;                     "my_quoting_fn(toupper(letters))\n", "\n", 
#&gt;                     "# Fails because of a nested quosure:\n", 
#&gt;                     "my_quoting_fn(toupper(!!quo(letters)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("rlang 0.3.0"), "\n", 
#&gt;                   "\n", "Passing an environment to ", list("data"), 
#&gt;                   " is deprecated. Please construct an\n", "rlang data mask with ", 
#&gt;                   list(list("new_data_mask()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "\n", "# With simple quoted expressions eval_tidy() works the same way as\n", 
#&gt;                 "# eval():\n", "apple &lt;- \"apple\"\n", "kiwi &lt;- \"kiwi\"\n", 
#&gt;                 "expr &lt;- quote(paste(apple, kiwi))\n", "expr\n", 
#&gt;                 "\n", "eval(expr)\n", "eval_tidy(expr)\n", "\n", 
#&gt;                 "# Both accept a data mask as argument:\n", "data &lt;- list(apple = \"CARROT\", kiwi = \"TOMATO\")\n", 
#&gt;                 "eval(expr, data)\n", "eval_tidy(expr, data)\n", 
#&gt;                 "\n", "\n", "# In addition eval_tidy() has support for quosures:\n", 
#&gt;                 "with_data &lt;- function(data, expr) {\n", "  quo &lt;- enquo(expr)\n", 
#&gt;                 "  eval_tidy(quo, data)\n", "}\n", "with_data(NULL, apple)\n", 
#&gt;                 "with_data(data, apple)\n", "with_data(data, list(apple, kiwi))\n", 
#&gt;                 "\n", "# Secondly eval_tidy() installs handy pronouns that allow users to\n", 
#&gt;                 "# be explicit about where to find symbols:\n", 
#&gt;                 "with_data(data, .data$apple)\n", "with_data(data, .env$apple)\n", 
#&gt;                 "\n", "\n", "# Note that instead of using `.env` it is often equivalent and may\n", 
#&gt;                 "# be preferred to unquote a value. There are two differences. First\n", 
#&gt;                 "# unquoting happens earlier, when the quosure is created. Secondly,\n", 
#&gt;                 "# subsetting `.env` with the `$` operator may be brittle because\n", 
#&gt;                 "# `$` does not look through the parents of the environment.\n", 
#&gt;                 "#\n", "# For instance using `.env$name` in a magrittr pipeline is an\n", 
#&gt;                 "# instance where this poses problem, because the magrittr pipe\n", 
#&gt;                 "# currently (as of v1.5.0) evaluates its operands in a *child* of\n", 
#&gt;                 "# the current environment (this child environment is where it\n", 
#&gt;                 "# defines the pronoun `.`).\n", list("\n", "  data %&gt;% with_data(!!kiwi)     # \"kiwi\"\n", 
#&gt;                   "  data %&gt;% with_data(.env$kiwi)  # NULL\n"), 
#&gt;                 "\n"), "\n", list("\n", list("quasiquotation"), 
#&gt;                 " for the second leg of the tidy evaluation\n", 
#&gt;                 "framework.\n"), "\n"), exec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("exec"), "\n", list("exec"), "\n", list(
#&gt;                 "Execute a function"), "\n", list("\n", "exec(.fn, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("A function, or function name as a string.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to function.\n", 
#&gt;                   "\n", "These dots support ", list("tidy-dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".env"), 
#&gt;                   list("Environment in which to evaluate the call. This will be\n", 
#&gt;                     "most useful if ", list("f"), " is a string, or the function has side-effects.")), 
#&gt;                 "\n"), "\n", list("\n", "This function constructs and evaluates a call to ", 
#&gt;                 list(".fn"), ".\n", "It has two primary uses:\n", 
#&gt;                 list("\n", list(), " To call a function with arguments stored in a list (if the function\n", 
#&gt;                   "doesn't support ", list("tidy-dots"), ")\n", 
#&gt;                   list(), " To call every function stored in a list (in conjunction with ", 
#&gt;                   list("map()"), "/\n", list(list("lapply()")), 
#&gt;                   ")\n"), "\n"), "\n", list("\n", "args &lt;- list(x = c(1:10, 100, NA), na.rm = TRUE)\n", 
#&gt;                 "exec(\"mean\", !!!args)\n", "exec(\"mean\", !!!args, trim = 0.2)\n", 
#&gt;                 "\n", "fs &lt;- list(a = function() \"a\", b = function() \"b\")\n", 
#&gt;                 "lapply(fs, exec)\n", "\n", "# Compare to do.call it will not automatically inline expressions\n", 
#&gt;                 "# into the evaluated call.\n", "x &lt;- 10\n", 
#&gt;                 "args &lt;- exprs(x1 = x + 1, x2 = x * 2)\n", "exec(list, !!!args)\n", 
#&gt;                 "do.call(list, args)\n", "\n", "# exec() is not designed to generate pretty function calls. This is\n", 
#&gt;                 "# most easily seen if you call a function that captures the call:\n", 
#&gt;                 "f &lt;- disp ~ cyl\n", "exec(\"lm\", f, data = mtcars)\n", 
#&gt;                 "\n", "# If you need finer control over the generated call, you'll need to\n", 
#&gt;                 "# construct it yourself. This may require creating a new environment\n", 
#&gt;                 "# with carefully constructed bindings\n", "data_env &lt;- env(data = mtcars)\n", 
#&gt;                 "eval(expr(lm(!!f, data)), data_env)\n"), "\n"), 
#&gt;         exiting.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("exiting"), "\n", list("exiting"), "\n", 
#&gt;             list("Exiting handler"), "\n", list("\n", "exiting(handler)\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", list("exiting()"), " is no longer necessary as handlers are exiting by default.\n"), 
#&gt;             "\n", list("internal"), "\n"), expr_interp.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("expr_interp"), "\n", list("expr_interp"), 
#&gt;             "\n", list("Process unquote operators in a captured expression"), 
#&gt;             "\n", list("\n", "expr_interp(x, env = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function, raw expression, or formula to interpolate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which unquoted expressions should be\n", 
#&gt;                   "evaluated. By default, the formula or closure environment if a\n", 
#&gt;                   "formula or a function, or the current environment otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "While all capturing functions in the tidy evaluation framework\n", 
#&gt;                 "perform unquote on capture (most notably ", 
#&gt;                 list(list("quo()")), "),\n", list("expr_interp()"), 
#&gt;                 " manually processes unquoting operators in\n", 
#&gt;                 "expressions that are already captured. ", list(
#&gt;                   "expr_interp()"), " should be\n", "called in all user-facing functions expecting a formula as argument\n", 
#&gt;                 "to provide the same quasiquotation functionality as NSE functions.\n"), 
#&gt;             "\n", list("\n", "# All tidy NSE functions like quo() unquote on capture:\n", 
#&gt;                 "quo(list(!!(1 + 2)))\n", "\n", "# expr_interp() is meant to provide the same functionality when you\n", 
#&gt;                 "# have a formula or expression that might contain unquoting\n", 
#&gt;                 "# operators:\n", "f &lt;- ~list(!!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "# Note that only the outer formula is unquoted (which is a reason\n", 
#&gt;                 "# to use expr_interp() as early as possible in all user-facing\n", 
#&gt;                 "# functions):\n", "f &lt;- ~list(~!!(1 + 2), !!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "\n", "# Another purpose for expr_interp() is to interpolate a closure's\n", 
#&gt;                 "# body. This is useful to inline a function within another. The\n", 
#&gt;                 "# important limitation is that all formal arguments of the inlined\n", 
#&gt;                 "# function should be defined in the receiving function:\n", 
#&gt;                 "other_fn &lt;- function(x) toupper(x)\n", "\n", 
#&gt;                 "fn &lt;- expr_interp(function(x) {\n", "  x &lt;- paste0(x, \"_suffix\")\n", 
#&gt;                 "  !!! body(other_fn)\n", "})\n", "fn\n", "fn(\"foo\")\n"), 
#&gt;             "\n"), expr_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_label"), "\n", list("expr_label"), 
#&gt;             "\n", list("expr_name"), "\n", list("expr_text"), 
#&gt;             "\n", list("Turn an expression to a label"), "\n", 
#&gt;             list("\n", "expr_label(expr)\n", "\n", "expr_name(expr)\n", 
#&gt;                 "\n", "expr_text(expr, width = 60L, nlines = Inf)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to labellise.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("expr_text()"), " turns the expression into a single string, which\n", 
#&gt;                 "might be multi-line. ", list("expr_name()"), 
#&gt;                 " is suitable for formatting\n", "names. It works best with symbols and scalar types, but also\n", 
#&gt;                 "accepts calls. ", list("expr_label()"), " formats the expression nicely for use\n", 
#&gt;                 "in messages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are in the questioning stage because they are\n", 
#&gt;                   "redundant with the ", list("quo_"), " variants and do not handle quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# To labellise a function argument, first capture it with\n", 
#&gt;                 "# substitute():\n", "fn &lt;- function(x) expr_label(substitute(x))\n", 
#&gt;                 "fn(x:y)\n", "\n", "# Strings are encoded\n", 
#&gt;                 "expr_label(\"a\\nb\")\n", "\n", "# Names and expressions are quoted with ``\n", 
#&gt;                 "expr_label(quote(x))\n", "expr_label(quote(a + b + c))\n", 
#&gt;                 "\n", "# Long expressions are collapsed\n", "expr_label(quote(foo({\n", 
#&gt;                 "  1 + 2\n", "  print(x)\n", "})))\n"), "\n"), 
#&gt;         expr_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_print"), "\n", list("expr_print"), 
#&gt;             "\n", list("expr_deparse"), "\n", list("Print an expression"), 
#&gt;             "\n", list("\n", "expr_print(x, width = peek_option(\"width\"))\n", 
#&gt;                 "\n", "expr_deparse(x, width = peek_option(\"width\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object or expression to print.")), 
#&gt;                 "\n", "\n", list(list("width"), list("The width of the deparsed or printed expression.\n", 
#&gt;                   "Defaults to the global option ", list("width"), 
#&gt;                   ".")), "\n"), "\n", list("\n", list("expr_print()"), 
#&gt;                 ", powered by ", list("expr_deparse()"), ", is an alternative\n", 
#&gt;                 "printer for R expressions with a few improvements over the base R\n", 
#&gt;                 "printer.\n", list("\n", list(), " It colourises ", 
#&gt;                   list("quosures"), " according to their environment.\n", 
#&gt;                   "Quosures from the global environment are printed normally while\n", 
#&gt;                   "quosures from local environments are printed in unique colour (or\n", 
#&gt;                   "in italic when all colours are taken).\n", 
#&gt;                   list(), " It wraps inlined objects in angular brackets. For instance, an\n", 
#&gt;                   "integer vector unquoted in a function call (e.g.\n", 
#&gt;                   list("expr(foo(!!(1:3)))"), ") is printed like this: ", 
#&gt;                   list("foo(&lt;int: 1L, 2L, 3L&gt;)"), " while by default R prints the code to create that vector:\n", 
#&gt;                   list("foo(1:3)"), " which is ambiguous.\n", 
#&gt;                   list(), " It respects the width boundary (from the global option ", 
#&gt;                   list("width"), ")\n", "in more cases.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# It supports any object. Non-symbolic objects are always printed\n", 
#&gt;                 "# within angular brackets:\n", "expr_print(1:3)\n", 
#&gt;                 "expr_print(function() NULL)\n", "\n", "# Contrast this to how the code to create these objects is printed:\n", 
#&gt;                 "expr_print(quote(1:3))\n", "expr_print(quote(function() NULL))\n", 
#&gt;                 "\n", "# The main cause of non-symbolic objects in expressions is\n", 
#&gt;                 "# quasiquotation:\n", "expr_print(expr(foo(!!(1:3))))\n", 
#&gt;                 "\n", "\n", "# Quosures from the global environment are printed normally:\n", 
#&gt;                 "expr_print(quo(foo))\n", "expr_print(quo(foo(!!quo(bar))))\n", 
#&gt;                 "\n", "# Quosures from local environments are colourised according to\n", 
#&gt;                 "# their environments (if you have crayon installed):\n", 
#&gt;                 "local_quo &lt;- local(quo(foo))\n", "expr_print(local_quo)\n", 
#&gt;                 "\n", "wrapper_quo &lt;- local(quo(bar(!!local_quo, baz)))\n", 
#&gt;                 "expr_print(wrapper_quo)\n"), "\n"), exprs_auto_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quotation.R", "\n", 
#&gt;             list("exprs_auto_name"), "\n", list("exprs_auto_name"), 
#&gt;             "\n", list("quos_auto_name"), "\n", list("Ensure that all elements of a list of expressions are named"), 
#&gt;             "\n", list("\n", "exprs_auto_name(exprs, width = NULL, printer = NULL)\n", 
#&gt;                 "\n", "quos_auto_name(quos, width = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("exprs"), list("A list of expressions.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Deprecated. Maximum width of names.")), 
#&gt;                 "\n", "\n", list(list("printer"), list("Deprecated. A function that takes an expression\n", 
#&gt;                   "and converts it to a string. This function must take an\n", 
#&gt;                   "expression as the first argument and ", list(
#&gt;                     "width"), " as the second\n", "argument.")), 
#&gt;                 "\n", "\n", list(list("quos"), list("A list of quosures.")), 
#&gt;                 "\n"), "\n", list("\n", "This gives default names to unnamed elements of a list of\n", 
#&gt;                 "expressions (or expression wrappers such as formulas or\n", 
#&gt;                 "quosures). ", list("exprs_auto_name()"), " deparses the expressions with\n", 
#&gt;                 list(list("expr_name()")), " by default. ", list(
#&gt;                   "quos_auto_name()"), " deparses with\n", list(
#&gt;                   list("quo_name()")), ".\n"), "\n"), f_rhs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("f_rhs"), "\n", list("f_rhs"), "\n", list("f_rhs&lt;-"), 
#&gt;             "\n", list("f_lhs"), "\n", list("f_lhs&lt;-"), "\n", 
#&gt;             list("f_env"), "\n", list("f_env&lt;-"), "\n", list(
#&gt;                 "Get or set formula components"), "\n", list(
#&gt;                 "\n", "f_rhs(f)\n", "\n", "f_rhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_lhs(f)\n", "\n", "f_lhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_env(f)\n", "\n", "f_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("f, x"), list("A formula")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value to replace with.")), 
#&gt;                 "\n"), "\n", list("\n", list("f_rhs"), " and ", 
#&gt;                 list("f_lhs"), " return language objects (i.e.  atomic\n", 
#&gt;                 "vectors of length 1, a name, or a call). ", 
#&gt;                 list("f_env"), " returns an\n", "environment.\n"), 
#&gt;             "\n", list("\n", list("f_rhs"), " extracts the righthand side, ", 
#&gt;                 list("f_lhs"), " extracts the lefthand\n", "side, and ", 
#&gt;                 list("f_env"), " extracts the environment. All functions throw an\n", 
#&gt;                 "error if ", list("f"), " is not a formula.\n"), 
#&gt;             "\n", list("\n", "f_rhs(~ 1 + 2 + 3)\n", "f_rhs(~ x)\n", 
#&gt;                 "f_rhs(~ \"A\")\n", "f_rhs(1 ~ 2)\n", "\n", "f_lhs(~ y)\n", 
#&gt;                 "f_lhs(x ~ y)\n", "\n", "f_env(~ x)\n"), "\n"), 
#&gt;         f_text.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("f_text"), "\n", list("f_text"), "\n", 
#&gt;             list("f_name"), "\n", list("f_label"), "\n", list(
#&gt;                 "Turn RHS of formula into a string or label"), 
#&gt;             "\n", list("\n", "f_text(x, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "f_name(x)\n", "\n", "f_label(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A formula.")), "\n", 
#&gt;                 "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", "Equivalent of ", list(
#&gt;                 list("expr_text()")), " and ", list(list("expr_label()")), 
#&gt;                 " for formulas.\n"), "\n", list("\n", "f &lt;- ~ a + b + bc\n", 
#&gt;                 "f_text(f)\n", "f_label(f)\n", "\n", "# Names a quoted with ``\n", 
#&gt;                 "f_label(~ x)\n", "# Strings are encoded\n", 
#&gt;                 "f_label(~ \"a\\nb\")\n", "# Long expressions are collapsed\n", 
#&gt;                 "f_label(~ foo({\n", "  1 + 2\n", "  print(x)\n", 
#&gt;                 "}))\n"), "\n"), flatten.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-squash.R", 
#&gt;             "\n", list("flatten"), "\n", list("flatten"), "\n", 
#&gt;             list("flatten_lgl"), "\n", list("flatten_int"), "\n", 
#&gt;             list("flatten_dbl"), "\n", list("flatten_cpl"), "\n", 
#&gt;             list("flatten_chr"), "\n", list("flatten_raw"), "\n", 
#&gt;             list("squash"), "\n", list("squash_lgl"), "\n", list(
#&gt;                 "squash_int"), "\n", list("squash_dbl"), "\n", 
#&gt;             list("squash_cpl"), "\n", list("squash_chr"), "\n", 
#&gt;             list("squash_raw"), "\n", list("flatten_if"), "\n", 
#&gt;             list("squash_if"), "\n", list("Flatten or squash a list of lists into a simpler vector"), 
#&gt;             "\n", list("\n", "flatten(x)\n", "\n", "flatten_lgl(x)\n", 
#&gt;                 "\n", "flatten_int(x)\n", "\n", "flatten_dbl(x)\n", 
#&gt;                 "\n", "flatten_cpl(x)\n", "\n", "flatten_chr(x)\n", 
#&gt;                 "\n", "flatten_raw(x)\n", "\n", "squash(x)\n", 
#&gt;                 "\n", "squash_lgl(x)\n", "\n", "squash_int(x)\n", 
#&gt;                 "\n", "squash_dbl(x)\n", "\n", "squash_cpl(x)\n", 
#&gt;                 "\n", "squash_chr(x)\n", "\n", "squash_raw(x)\n", 
#&gt;                 "\n", "flatten_if(x, predicate = is_spliced)\n", 
#&gt;                 "\n", "squash_if(x, predicate = is_spliced)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A list to flatten or squash. The contents of the list can\n", 
#&gt;                 "be anything for unsuffixed functions ", list(
#&gt;                   "flatten()"), " and ", list("squash()"), "\n", 
#&gt;                 "(as a list is returned), but the contents must match the type for\n", 
#&gt;                 "the other functions.")), "\n", "\n", list(list(
#&gt;                 "predicate"), list("A function of one argument returning whether it\n", 
#&gt;                 "should be spliced.")), "\n"), "\n", list("\n", 
#&gt;                 list("flatten()"), " returns a list, ", list(
#&gt;                   "flatten_lgl()"), " a logical\n", "vector, ", 
#&gt;                 list("flatten_int()"), " an integer vector, ", 
#&gt;                 list("flatten_dbl()"), " a\n", "double vector, and ", 
#&gt;                 list("flatten_chr()"), " a character vector. Similarly\n", 
#&gt;                 "for ", list("squash()"), " and the typed variants (", 
#&gt;                 list("squash_lgl()"), " etc).\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("flatten()"), " removes one level hierarchy from a list, while\n", 
#&gt;                 list("squash()"), " removes all levels. These functions are similar to\n", 
#&gt;                 list(list("unlist()")), " but they are type-stable so you always know what the\n", 
#&gt;                 "type of the output is.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "These functions are in the questioning stage. They have slightly\n", 
#&gt;                 "different semantics than the flattening functions in purrr and we\n", 
#&gt;                 "are currently rethinking our approach to flattening with the new\n", 
#&gt;                 "typing facilities of the vctrs package.\n")), 
#&gt;             "\n", "\n", list("\n", "x &lt;- replicate(2, sample(4), simplify = FALSE)\n", 
#&gt;                 "x\n", "\n", "flatten(x)\n", "flatten_int(x)\n", 
#&gt;                 "\n", "# With flatten(), only one level gets removed at a time:\n", 
#&gt;                 "deep &lt;- list(1, list(2, list(3)))\n", "flatten(deep)\n", 
#&gt;                 "flatten(flatten(deep))\n", "\n", "# But squash() removes all levels:\n", 
#&gt;                 "squash(deep)\n", "squash_dbl(deep)\n", "\n", 
#&gt;                 "# The typed flatten functions remove one level and coerce to an atomic\n", 
#&gt;                 "# vector at the same time:\n", "flatten_dbl(list(1, list(2)))\n", 
#&gt;                 "\n", "# Only bare lists are flattened, but you can splice S3 lists\n", 
#&gt;                 "# explicitly:\n", "foo &lt;- set_attrs(list(\"bar\"), class = \"foo\")\n", 
#&gt;                 "str(flatten(list(1, foo, list(100))))\n", "str(flatten(list(1, splice(foo), list(100))))\n", 
#&gt;                 "\n", "# Instead of splicing manually, flatten_if() and squash_if() let\n", 
#&gt;                 "# you specify a predicate function:\n", "is_foo &lt;- function(x) inherits(x, \"foo\") || is_bare_list(x)\n", 
#&gt;                 "str(flatten_if(list(1, foo, list(100)), is_foo))\n", 
#&gt;                 "\n", "# squash_if() does the same with deep lists:\n", 
#&gt;                 "deep_foo &lt;- list(1, list(foo, list(foo, 100)))\n", 
#&gt;                 "str(deep_foo)\n", "\n", "str(squash(deep_foo))\n", 
#&gt;                 "str(squash_if(deep_foo, is_foo))\n"), "\n", 
#&gt;             list("internal"), "\n"), fn_body.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_body"), "\n", list("fn_body"), "\n", list(
#&gt;                 "fn_body&lt;-"), "\n", list("Get or set function body"), 
#&gt;             "\n", list("\n", "fn_body(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_body(fn) &lt;- value\n"), "\n", list("\n", list(
#&gt;                 list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                   "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_body()"), " is a simple wrapper around ", 
#&gt;                 list(list("base::body()")), ". It always\n", 
#&gt;                 "returns a ", list("{"), " expression and throws an error when the input is a\n", 
#&gt;                 "primitive function (whereas ", list("body()"), 
#&gt;                 " returns ", list("NULL"), "). The setter\n", 
#&gt;                 "version preserves attributes, unlike ", list(
#&gt;                   "body&lt;-"), ".\n"), "\n", list("\n", "# fn_body() is like body() but always returns a block:\n", 
#&gt;                 "fn &lt;- function() do()\n", "body(fn)\n", "fn_body(fn)\n", 
#&gt;                 "\n", "# It also throws an error when used on a primitive function:\n", 
#&gt;                 "try(fn_body(base::list))\n"), "\n"), fn_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "fn_env"), "\n", list("fn_env"), "\n", list("fn_env&lt;-"), 
#&gt;             "\n", list("Return the closure environment of a function"), 
#&gt;             "\n", list("\n", "fn_env(fn)\n", "\n", "fn_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn, x"), list("A function.")), 
#&gt;                 "\n", "\n", list(list("value"), list("A new closure environment for the function.")), 
#&gt;                 "\n"), "\n", list("\n", "Closure environments define the scope of functions (see ", 
#&gt;                 list(list("env()")), ").\n", "When a function call is evaluated, R creates an evaluation frame\n", 
#&gt;                 "(see ", list(list("ctxt_stack()")), ") that inherits from the closure environment.\n", 
#&gt;                 "This makes all objects defined in the closure environment and all\n", 
#&gt;                 "its parents available to code executed within the function.\n"), 
#&gt;             "\n", list("\n", list("fn_env()"), " returns the closure environment of ", 
#&gt;                 list("fn"), ". There is also\n", "an assignment method to set a new closure environment.\n"), 
#&gt;             "\n", list("\n", "env &lt;- child_env(\"base\")\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(fn_env(fn), env)\n", 
#&gt;                 "\n", "other_env &lt;- child_env(\"base\")\n", "fn_env(fn) &lt;- other_env\n", 
#&gt;                 "identical(fn_env(fn), other_env)\n"), "\n"), 
#&gt;         fn_fmls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_fmls"), "\n", list("fn_fmls"), "\n", list(
#&gt;                 "fn_fmls_names"), "\n", list("fn_fmls_syms"), 
#&gt;             "\n", list("fn_fmls&lt;-"), "\n", list("fn_fmls_names&lt;-"), 
#&gt;             "\n", list("Extract arguments from a function"), 
#&gt;             "\n", list("\n", "fn_fmls(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_fmls_names(fn = caller_fn())\n", "\n", "fn_fmls_syms(fn = caller_fn())\n", 
#&gt;                 "\n", "fn_fmls(fn) &lt;- value\n", "\n", "fn_fmls_names(fn) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                 "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_fmls()"), " returns a named list of formal arguments.\n", 
#&gt;                 list("fn_fmls_names()"), " returns the names of the arguments.\n", 
#&gt;                 list("fn_fmls_syms()"), " returns formals as a named list of symbols. This\n", 
#&gt;                 "is especially useful for forwarding arguments in ", 
#&gt;                 list("constructed calls"), ".\n"), "\n", list(
#&gt;                 "\n", "Unlike ", list("formals()"), ", these helpers throw an error with primitive\n", 
#&gt;                 "functions instead of returning ", list("NULL"), 
#&gt;                 ".\n"), "\n", list("\n", "# Extract from current call:\n", 
#&gt;                 "fn &lt;- function(a = 1, b = 2) fn_fmls()\n", "fn()\n", 
#&gt;                 "\n", "# fn_fmls_syms() makes it easy to forward arguments:\n", 
#&gt;                 "call2(\"apply\", !!! fn_fmls_syms(lapply))\n", 
#&gt;                 "\n", "# You can also change the formals:\n", 
#&gt;                 "fn_fmls(fn) &lt;- list(A = 10, B = 20)\n", "fn()\n", 
#&gt;                 "\n", "fn_fmls_names(fn) &lt;- c(\"foo\", \"bar\")\n", 
#&gt;                 "fn()\n"), "\n", list("\n", list(list("call_args()")), 
#&gt;                 " and ", list(list("call_args_names()")), "\n"), 
#&gt;             "\n"), frame_position.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("frame_position"), "\n", list("frame_position"), 
#&gt;             "\n", list("Find the position or distance of a frame on the evaluation stack"), 
#&gt;             "\n", list("\n", "frame_position(frame, from = c(\"global\", \"current\"))\n"), 
#&gt;             "\n", list("\n", list(list("frame"), list("The environment of a frame. Can be any object with a\n", 
#&gt;                 list(list("get_env()")), " method. Note that for frame objects, the position from\n", 
#&gt;                 "the global frame is simply ", list("frame$pos"), 
#&gt;                 ". Alternatively, ", list("frame"), "\n", "can be an integer that represents the position on the stack (and\n", 
#&gt;                 "is thus returned as is if ", list("from"), " is \"global\".")), 
#&gt;                 "\n", "\n", list(list("from"), list("Whether to compute distance from the global frame (the\n", 
#&gt;                   "bottom of the evaluation stack), or from the current frame (the\n", 
#&gt;                   "top of the evaluation stack).")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "The frame position on the stack can be computed by counting frames\n", 
#&gt;                 "from the global frame (the bottom of the stack, the default) or\n", 
#&gt;                 "from the current frame (the top of the stack).\n"), 
#&gt;             "\n", list("\n", "While this function returns the position of the frame on the\n", 
#&gt;                 "evaluation stack, it can safely be called with intervening frames\n", 
#&gt;                 "as those will be discarded.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are deprecated and replaced by ", 
#&gt;                   list(list("trace_back()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) frame_position(env)\n", "\n", 
#&gt;                 "# frame_position() returns the position of the frame on the evaluation stack:\n", 
#&gt;                 "fn()\n", "identity(identity(fn()))\n", "\n", 
#&gt;                 "# Note that it trims off intervening calls before counting so you\n", 
#&gt;                 "# can safely nest it within other calls:\n", 
#&gt;                 "g &lt;- function(env) identity(identity(frame_position(env)))\n", 
#&gt;                 "fn()\n", "\n", "# You can also ask for the position from the current frame rather\n", 
#&gt;                 "# than the global frame:\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) frame_position(env, from = \"current\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), friendly_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("friendly_type"), "\n", list("friendly_type"), 
#&gt;             "\n", list("Format a type for error messages"), "\n", 
#&gt;             list("\n", "friendly_type(type)\n"), "\n", list("\n", 
#&gt;                 list(list("type"), list("A type as returned by ", 
#&gt;                   list(list("typeof()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "A string of the prettified type, qualified with an\n", 
#&gt;                 "indefinite article.\n"), "\n", list("\n", "Format a type for error messages\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("friendly_type()"), " is experimental.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "friendly_type(\"logical\")\n", 
#&gt;                 "friendly_type(\"integer\")\n", "friendly_type(\"string\")\n"), 
#&gt;             "\n", list("internal"), "\n"), get_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "get_env"), "\n", list("get_env"), "\n", list(
#&gt;                 "set_env"), "\n", list("env_poke_parent"), "\n", 
#&gt;             list("Get or set the environment of an object"), 
#&gt;             "\n", list("\n", "get_env(env, default = NULL)\n", 
#&gt;                 "\n", "set_env(env, new_env = caller_env())\n", 
#&gt;                 "\n", "env_poke_parent(env, new_env)\n"), "\n", 
#&gt;             list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The default environment in case ", 
#&gt;                   list("env"), " does not wrap\n", "an environment. If ", 
#&gt;                   list("NULL"), " and no environment could be extracted,\n", 
#&gt;                   "an error is issued.")), "\n", "\n", list(list(
#&gt;                   "new_env"), list("An environment to replace ", 
#&gt;                   list("env"), " with.")), "\n"), "\n", list(
#&gt;                 "\n", "These functions dispatch internally with methods for functions,\n", 
#&gt;                 "formulas and frames. If called with a missing argument, the\n", 
#&gt;                 "environment of the current evaluation frame (see ", 
#&gt;                 list(list("ctxt_stack()")), ") is\n", "returned. If you call ", 
#&gt;                 list("get_env()"), " with an environment, it acts as\n", 
#&gt;                 "the identity function and the environment is simply returned (this\n", 
#&gt;                 "helps simplifying code when writing generic functions for\n", 
#&gt;                 "environments).\n"), "\n", list("\n", "While ", 
#&gt;                 list("set_env()"), " returns a modified copy and does not have side\n", 
#&gt;                 "effects, ", list("env_poke_parent()"), " operates changes the environment by\n", 
#&gt;                 "side effect. This is because environments are\n", 
#&gt;                 list("uncopyable"), ". Be careful not to change environments\n", 
#&gt;                 "that you don't own, e.g. a parent environment of a function from a\n", 
#&gt;                 "package.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Using ", 
#&gt;                   list("get_env()"), " without supplying ", list(
#&gt;                     "env"), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                   list(list("current_env()")), " to retrieve the\n", 
#&gt;                   "current environment.\n", list(), " Passing environment wrappers like formulas or functions instead\n", 
#&gt;                   "of bare environments is deprecated as of rlang 0.3.0. This\n", 
#&gt;                   "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                   "should now extract the environment separately before calling\n", 
#&gt;                   "these functions.\n"), "\n")), "\n", "\n", 
#&gt;             list("\n", "# Environment of closure functions:\n", 
#&gt;                 "fn &lt;- function() \"foo\"\n", "get_env(fn)\n", 
#&gt;                 "\n", "# Or of quosures or formulas:\n", "get_env(~foo)\n", 
#&gt;                 "get_env(quo(foo))\n", "\n", "\n", "# Provide a default in case the object doesn't bundle an environment.\n", 
#&gt;                 "# Let's create an unevaluated formula:\n", "f &lt;- quote(~foo)\n", 
#&gt;                 "\n", "# The following line would fail if run because unevaluated formulas\n", 
#&gt;                 "# don't bundle an environment (they didn't have the chance to\n", 
#&gt;                 "# record one yet):\n", "# get_env(f)\n", "\n", 
#&gt;                 "# It is often useful to provide a default when you're writing\n", 
#&gt;                 "# functions accepting formulas as input:\n", 
#&gt;                 "default &lt;- env()\n", "identical(get_env(f, default), default)\n", 
#&gt;                 "\n", "# set_env() can be used to set the enclosure of functions and\n", 
#&gt;                 "# formulas. Let's create a function with a particular environment:\n", 
#&gt;                 "env &lt;- child_env(\"base\")\n", "fn &lt;- set_env(function() NULL, env)\n", 
#&gt;                 "\n", "# That function now has `env` as enclosure:\n", 
#&gt;                 "identical(get_env(fn), env)\n", "identical(get_env(fn), current_env())\n", 
#&gt;                 "\n", "# set_env() does not work by side effect. Setting a new environment\n", 
#&gt;                 "# for fn has no effect on the original function:\n", 
#&gt;                 "other_env &lt;- child_env(NULL)\n", "set_env(fn, other_env)\n", 
#&gt;                 "identical(get_env(fn), other_env)\n", "\n", 
#&gt;                 "# Since set_env() returns a new function with a different\n", 
#&gt;                 "# environment, you'll need to reassign the result:\n", 
#&gt;                 "fn &lt;- set_env(fn, other_env)\n", "identical(get_env(fn), other_env)\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_env()")), " and ", 
#&gt;                 list(list("quo_set_env()")), " for versions of\n", 
#&gt;                 list(list("get_env()")), " and ", list(list("set_env()")), 
#&gt;                 " that only work on quosures.\n"), "\n"), has_length.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/attr.R", "\n", 
#&gt;             list("has_length"), "\n", list("has_length"), "\n", 
#&gt;             list("How long is an object?"), "\n", list("\n", 
#&gt;                 "has_length(x, n = NULL)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("A R object.")), "\n", "\n", 
#&gt;                 list(list("n"), list("A specific length to test ", 
#&gt;                   list("x"), " with. If ", list("NULL"), ",\n", 
#&gt;                   list("has_length()"), " returns ", list("TRUE"), 
#&gt;                   " if ", list("x"), " has length greater than\n", 
#&gt;                   "zero, and ", list("FALSE"), " otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a function for the common task of testing the length of an\n", 
#&gt;                 "object. It checks the length of an object in a non-generic way:\n", 
#&gt;                 list(list("base::length()")), " methods are ignored.\n"), 
#&gt;             "\n", list("\n", "has_length(list())\n", "has_length(list(), 0)\n", 
#&gt;                 "\n", "has_length(letters)\n", "has_length(letters, 20)\n", 
#&gt;                 "has_length(letters, 26)\n"), "\n", list("internal"), 
#&gt;             "\n"), has_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("has_name"), "\n", list("has_name"), "\n", 
#&gt;             list("Does an object have an element with this name?"), 
#&gt;             "\n", list("\n", "has_name(x, name)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A data frame or another named object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Element name(s) to check")), 
#&gt;                 "\n"), "\n", list("\n", "A logical vector of the same length as ", 
#&gt;                 list("name"), "\n"), "\n", list("\n", "This function returns a logical value that indicates if a data\n", 
#&gt;                 "frame or another named object contains an element with a specific\n", 
#&gt;                 "name. Note that ", list("has_name()"), " only works with vectors. For instance,\n", 
#&gt;                 "environments need the specialised function ", 
#&gt;                 list(list("env_has()")), ".\n"), "\n", list("\n", 
#&gt;                 "Unnamed objects are treated as if all names are empty strings. ", 
#&gt;                 list("NA"), "\n", "input gives ", list("FALSE"), 
#&gt;                 " as output.\n"), "\n", list("\n", "has_name(iris, \"Species\")\n", 
#&gt;                 "has_name(mtcars, \"gears\")\n"), "\n"), inherits_any.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "inherits_any"), "\n", list("inherits_any"), 
#&gt;             "\n", list("inherits_all"), "\n", list("inherits_only"), 
#&gt;             "\n", list("Does an object inherit from a set of classes?"), 
#&gt;             "\n", list("\n", "inherits_any(x, class)\n", "\n", 
#&gt;                 "inherits_all(x, class)\n", "\n", "inherits_only(x, class)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test for inheritance.")), 
#&gt;                 "\n", "\n", list(list("class"), list("A character vector of classes.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " ", 
#&gt;                 list("inherits_any()"), " is like ", list(list(
#&gt;                   "base::inherits()")), " but is more explicit\n", 
#&gt;                 "about its behaviour with multiple classes. If ", 
#&gt;                 list("classes"), " contains\n", "several elements and the object inherits from at least one of\n", 
#&gt;                 "them, ", list("inherits_any()"), " returns ", 
#&gt;                 list("TRUE"), ".\n", list(), " ", list("inherits_all()"), 
#&gt;                 " tests that an object inherits from all of the\n", 
#&gt;                 "classes in the supplied order. This is usually the best way to\n", 
#&gt;                 "test for inheritance of multiple classes.\n", 
#&gt;                 list(), " ", list("inherits_only()"), " tests that the class vectors are identical. It\n", 
#&gt;                 "is a shortcut for ", list("identical(class(x), class)"), 
#&gt;                 ".\n"), "\n"), "\n", list("\n", "obj &lt;- structure(list(), class = c(\"foo\", \"bar\", \"baz\"))\n", 
#&gt;                 "\n", "# With the _any variant only one class must match:\n", 
#&gt;                 "inherits_any(obj, c(\"foobar\", \"bazbaz\"))\n", 
#&gt;                 "inherits_any(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "\n", "# With the _all variant all classes must match:\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"baz\"))\n", "\n", 
#&gt;                 "# The order of classes must match as well:\n", 
#&gt;                 "inherits_all(obj, c(\"baz\", \"foo\"))\n", "\n", 
#&gt;                 "# inherits_only() checks that the class vectors are identical:\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"baz\"))\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"bar\", \"baz\"))\n"), 
#&gt;             "\n"), invoke.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("invoke"), "\n", list("invoke"), "\n", 
#&gt;             list("Invoke a function with a list of arguments"), 
#&gt;             "\n", list("\n", "invoke(.fn, .args = list(), ..., .env = caller_env(),\n", 
#&gt;                 "  .bury = c(\".fn\", \"\"))\n"), "\n", list(
#&gt;                 "\n", list(list(".fn"), list("A function to invoke. Can be a function object or the\n", 
#&gt;                   "name of a function in scope of ", list(".env"), 
#&gt;                   ".")), "\n", "\n", list(list(".args, ..."), 
#&gt;                   list("List of arguments (possibly named) to be passed to\n", 
#&gt;                     list(".fn"), ".")), "\n", "\n", list(list(
#&gt;                   ".env"), list("The environment in which to call ", 
#&gt;                   list(".fn"), ".")), "\n", "\n", list(list(".bury"), 
#&gt;                   list("A character vector of length 2. The first string\n", 
#&gt;                     "specifies which name should the function have in the call\n", 
#&gt;                     "recorded in the evaluation stack. The second string specifies a\n", 
#&gt;                     "prefix for the argument names. Set ", list(
#&gt;                       ".bury"), " to ", list("NULL"), " if you\n", 
#&gt;                     "prefer to inline the function and its arguments in the call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "Normally, you invoke a R function by typing arguments manually. A\n", 
#&gt;                 "powerful alternative is to call a function with a list of arguments\n", 
#&gt;                 "assembled programmatically. This is the purpose of ", 
#&gt;                 list("invoke()"), ".\n"), "\n", list("\n", "Technically, ", 
#&gt;                 list("invoke()"), " is basically a version of ", 
#&gt;                 list(list("base::do.call()")), "\n", "that creates cleaner call traces because it does not inline the\n", 
#&gt;                 "function and the arguments in the call (see examples). To achieve\n", 
#&gt;                 "this, ", list("invoke()"), " creates a child environment of ", 
#&gt;                 list(".env"), " with ", list(".fn"), "\n", "and all arguments bound to new symbols (see ", 
#&gt;                 list(list("env_bury()")), "). It then\n", "uses the same strategy as ", 
#&gt;                 list(list("eval_bare()")), " to evaluate with minimal\n", 
#&gt;                 "noise.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", list("invoke()"), " is soft-deprecated in favour of ", 
#&gt;                 list(list("exec()")), ". Now that we\n", "understand better the interaction between unquoting and dots\n", 
#&gt;                 "capture, we can take a simpler approach in ", 
#&gt;                 list("exec()"), ".\n", "\n", "If you need finer control over the generated call, you should construct\n", 
#&gt;                 "an environment and call yourself, manually burying large objects\n", 
#&gt;                 "or complex expressions.\n")), "\n", "\n", list(
#&gt;                 "\n", "# invoke() has the same purpose as do.call():\n", 
#&gt;                 "invoke(paste, letters)\n", "\n", "# But it creates much cleaner calls:\n", 
#&gt;                 "invoke(call_inspect, mtcars)\n", "\n", "# and stacktraces:\n", 
#&gt;                 "fn &lt;- function(...) sys.calls()\n", "invoke(fn, list(mtcars))\n", 
#&gt;                 "\n", "# Compare to do.call():\n", "do.call(call_inspect, mtcars)\n", 
#&gt;                 "do.call(fn, list(mtcars))\n", "\n", "\n", "# Specify the function name either by supplying a string\n", 
#&gt;                 "# identifying the function (it should be visible in .env):\n", 
#&gt;                 "invoke(\"call_inspect\", letters)\n", "\n", 
#&gt;                 "# Or by changing the .bury argument, with which you can also change\n", 
#&gt;                 "# the argument prefix:\n", "invoke(call_inspect, mtcars, .bury = c(\"inspect!\", \"col\"))\n"), 
#&gt;             "\n", list("internal"), "\n"), is_call.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("is_call"), "\n", list("is_call"), "\n", list(
#&gt;                 "Is object a call?"), "\n", list("\n", "is_call(x, name = NULL, n = NULL, ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                 "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                 list("An optional name that the call should match. It is\n", 
#&gt;                   "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                   "and you can supply a vector of names to match. In this case,\n", 
#&gt;                   list("is_call()"), " returns ", list("TRUE"), 
#&gt;                   " if at least one name matches.")), "\n", "\n", 
#&gt;                 list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This function tests if ", 
#&gt;                 list("x"), " is a ", list("call"), ". This is a\n", 
#&gt;                 "pattern-matching predicate that returns ", list(
#&gt;                   "FALSE"), " if ", list("name"), " and ", list(
#&gt;                   "n"), "\n", "are supplied and the call does not match these properties.\n", 
#&gt;                 list("is_unary_call()"), " and ", list("is_binary_call()"), 
#&gt;                 " hardcode ", list("n"), " to 1 and 2.\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                 "is_lang()"), " has been soft-deprecated and renamed to ", 
#&gt;                 list("is_call()"), " in\n", "rlang 0.2.0 and similarly for ", 
#&gt;                 list("is_unary_lang()"), " and\n", list("is_binary_lang()"), 
#&gt;                 ". This renaming follows the general switch from\n", 
#&gt;                 "\"language\" to \"call\" in the rlang type nomenclature. See lifecycle\n", 
#&gt;                 "section in ", list(list("call2()")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "is_call(quote(foo(bar)))\n", 
#&gt;                 "\n", "# You can pattern-match the call with additional arguments:\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\")\n", "is_call(quote(foo(bar)), \"bar\")\n", 
#&gt;                 "is_call(quote(foo(bar)), quote(foo))\n", "\n", 
#&gt;                 "# Match the number of arguments with is_call():\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\", 1)\n", "is_call(quote(foo(bar)), \"foo\", 2)\n", 
#&gt;                 "\n", "\n", "# By default, namespaced calls are tested unqualified:\n", 
#&gt;                 "ns_expr &lt;- quote(base::list())\n", "is_call(ns_expr, \"list\")\n", 
#&gt;                 "\n", "# You can also specify whether the call shouldn't be namespaced by\n", 
#&gt;                 "# supplying an empty string:\n", "is_call(ns_expr, \"list\", ns = \"\")\n", 
#&gt;                 "\n", "# Or if it should have a namespace:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"utils\")\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"base\")\n", 
#&gt;                 "\n", "# You can supply multiple namespaces:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"base\"))\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"stats\"))\n", 
#&gt;                 "\n", "# If one of them is \"\", unnamespaced calls will match as well:\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = \"base\")\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "is_call(quote(base::list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "\n", "\n", "# The name argument is vectorised so you can supply a list of names\n", 
#&gt;                 "# to match with:\n", "is_call(quote(foo(bar)), c(\"bar\", \"baz\"))\n", 
#&gt;                 "is_call(quote(foo(bar)), c(\"bar\", \"foo\"))\n", 
#&gt;                 "is_call(quote(base::list), c(\"::\", \":::\", \"$\", \"@\"))\n"), 
#&gt;             "\n", list("\n", list(list("is_expression()")), "\n"), 
#&gt;             "\n"), is_callable.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("is_callable"), "\n", list("is_callable"), 
#&gt;             "\n", list("Is an object callable?"), "\n", list(
#&gt;                 "\n", "is_callable(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", "A callable object is an object that can appear in the function\n", 
#&gt;                 "position of a call (as opposed to argument position). This includes\n", 
#&gt;                 list("symbolic objects"), " that evaluate to a function or\n", 
#&gt;                 "literal functions embedded in the call.\n"), 
#&gt;             "\n", list("\n", "Note that strings may look like callable objects because\n", 
#&gt;                 "expressions of the form ", list("\"list\"()"), 
#&gt;                 " are valid R code. However,\n", "that's only because the R parser transforms strings to symbols. It\n", 
#&gt;                 "is not legal to manually set language heads to strings.\n"), 
#&gt;             "\n", list("\n", "# Symbolic objects and functions are callable:\n", 
#&gt;                 "is_callable(quote(foo))\n", "is_callable(base::identity)\n", 
#&gt;                 "\n", "# node_poke_car() lets you modify calls without any checking:\n", 
#&gt;                 "lang &lt;- quote(foo(10))\n", "node_poke_car(lang, current_env())\n", 
#&gt;                 "\n", "# Use is_callable() to check an input object is safe to put as CAR:\n", 
#&gt;                 "obj &lt;- base::identity\n", "\n", "if (is_callable(obj)) {\n", 
#&gt;                 "  lang &lt;- node_poke_car(lang, obj)\n", "} else {\n", 
#&gt;                 "  abort(\"`obj` must be callable\")\n", "}\n", 
#&gt;                 "\n", "eval_bare(lang)\n"), "\n", list("internal"), 
#&gt;             "\n"), is_condition.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("is_condition"), "\n", list("is_condition"), 
#&gt;             "\n", list("Is object a condition?"), "\n", list(
#&gt;                 "\n", "is_condition(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is object a condition?\n"), 
#&gt;             "\n", list("internal"), "\n"), is_copyable.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_copyable"), "\n", list("is_copyable"), "\n", 
#&gt;             list("Is an object copyable?"), "\n", list("\n", 
#&gt;                 "is_copyable(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "When an object is modified, R generally copies it (sometimes\n", 
#&gt;                 "lazily) to enforce ", list(list("https://en.wikipedia.org/wiki/Value_semantics"), 
#&gt;                   list("value semantics")), ".\n", "However, some internal types are uncopyable. If you try to copy\n", 
#&gt;                 "them, either with ", list("&lt;-"), " or by argument passing, you actually create\n", 
#&gt;                 "references to the original object rather than actual\n", 
#&gt;                 "copies. Modifying these references can thus have far reaching side\n", 
#&gt;                 "effects.\n"), "\n", list("\n", "# Let's add attributes with structure() to uncopyable types. Since\n", 
#&gt;                 "# they are not copied, the attributes are changed in place:\n", 
#&gt;                 "env &lt;- env()\n", "structure(env, foo = \"bar\")\n", 
#&gt;                 "env\n", "\n", "# These objects that can only be changed with side effect are not\n", 
#&gt;                 "# copyable:\n", "is_copyable(env)\n", "\n", 
#&gt;                 "structure(base::list, foo = \"bar\")\n", "str(base::list)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_empty.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_empty"), "\n", list("is_empty"), "\n", list(
#&gt;                 "Is object an empty vector or NULL?"), "\n", 
#&gt;             list("\n", "is_empty(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("object to test")), "\n"), "\n", 
#&gt;             list("\n", "Is object an empty vector or NULL?\n"), 
#&gt;             "\n", list("\n", "is_empty(NULL)\n", "is_empty(list())\n", 
#&gt;                 "is_empty(list(NULL))\n"), "\n"), is_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_env"), "\n", list("is_env"), "\n", 
#&gt;             list("is_bare_env"), "\n", list("Is an object an environment?"), 
#&gt;             "\n", list("\n", "is_env(x)\n", "\n", "is_bare_env(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("is_environment()")), "\n", "and ", 
#&gt;                 list(list("is_bare_environment()")), " in rlang 0.2.0. This is for consistency\n", 
#&gt;                 "with other type predicates which are not abbreviated.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_environment"), "\n", list("is_environment"), 
#&gt;             "\n", list("is_bare_environment"), "\n", list("Is object an environment?"), 
#&gt;             "\n", list("\n", "is_environment(x)\n", "\n", "is_bare_environment(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("is_bare_environment()"), 
#&gt;                 " tests whether ", list("x"), " is an environment without a s3 or\n", 
#&gt;                 "s4 class.\n"), "\n"), is_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_expr"), "\n", list("is_expr"), "\n", 
#&gt;             list("Is an object an expression?"), "\n", list("\n", 
#&gt;                 "is_expr(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to test.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "This function was deprecated and renamed to ", 
#&gt;                 list(list("is_expression()")), " in\n", "rlang 0.2.0. This is for consistency with other type predicates\n", 
#&gt;                 "which are not abbreviated.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_expression.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("is_expression"), "\n", list("is_expression"), 
#&gt;             "\n", list("is_syntactic_literal"), "\n", list("is_symbolic"), 
#&gt;             "\n", list("Is an object an expression?"), "\n", 
#&gt;             list("\n", "is_expression(x)\n", "\n", "is_syntactic_literal(x)\n", 
#&gt;                 "\n", "is_symbolic(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_expression()"), " tests for expressions, the set of objects that can be\n", 
#&gt;                 "obtained from parsing R code. An expression can be one of two\n", 
#&gt;                 "things: either a symbolic object (for which ", 
#&gt;                 list("is_symbolic()"), " returns\n", list("TRUE"), 
#&gt;                 "), or a syntactic literal (testable with\n", 
#&gt;                 list("is_syntactic_literal()"), "). Technically, calls can contain any R\n", 
#&gt;                 "object, not necessarily symbolic objects or syntactic\n", 
#&gt;                 "literals. However, this only happens in artificial\n", 
#&gt;                 "situations. Expressions as we define them only contain numbers,\n", 
#&gt;                 "strings, ", list("NULL"), ", symbols, and calls: this is the complete set of R\n", 
#&gt;                 "objects that can be created when R parses source code (e.g. from\n", 
#&gt;                 "using ", list(list("parse_expr()")), ").\n", 
#&gt;                 "\n", "Note that we are using the term expression in its colloquial sense\n", 
#&gt;                 "and not to refer to ", list(list("expression()")), 
#&gt;                 " vectors, a data type that wraps\n", "expressions in a vector and which isn't used much in modern R code.\n"), 
#&gt;             "\n", list("\n", list("is_symbolic()"), " returns ", 
#&gt;                 list("TRUE"), " for symbols and calls (objects with\n", 
#&gt;                 "type ", list("language"), "). Symbolic objects are replaced by their value\n", 
#&gt;                 "during evaluation. Literals are the complement of symbolic\n", 
#&gt;                 "objects. They are their own value and return themselves during\n", 
#&gt;                 "evaluation.\n", "\n", list("is_syntactic_literal()"), 
#&gt;                 " is a predicate that returns ", list("TRUE"), 
#&gt;                 " for the\n", "subset of literals that are created by R when parsing text (see\n", 
#&gt;                 list(list("parse_expr()")), "): numbers, strings and ", 
#&gt;                 list("NULL"), ". Along with symbols,\n", "these literals are the terminating nodes in an AST.\n", 
#&gt;                 "\n", "Note that in the most general sense, a literal is any R object that\n", 
#&gt;                 "evaluates to itself and that can be evaluated in the empty\n", 
#&gt;                 "environment. For instance, ", list("quote(c(1, 2))"), 
#&gt;                 " is not a literal, it is\n", "a call. However, the result of evaluating it in ", 
#&gt;                 list(list("base_env()")), " is a\n", "literal(in this case an atomic vector).\n", 
#&gt;                 "\n", "Pairlists are also a kind of language objects. However, since they\n", 
#&gt;                 "are mostly an internal data structure, ", list(
#&gt;                   "is_expression()"), " returns ", list("FALSE"), 
#&gt;                 "\n", "for pairlists. You can use ", list("is_pairlist()"), 
#&gt;                 " to explicitly check for\n", "them. Pairlists are the data structure for function arguments. They\n", 
#&gt;                 "usually do not arise from R code because subsetting a call is a\n", 
#&gt;                 "type-preserving operation. However, you can obtain the pairlist of\n", 
#&gt;                 "arguments by taking the CDR of the call object from C code. The\n", 
#&gt;                 "rlang function ", list(list("node_cdr()")), 
#&gt;                 " will do it from R. Another way in\n", "which pairlist of arguments arise is by extracting the argument\n", 
#&gt;                 "list of a closure with ", list(list("base::formals()")), 
#&gt;                 " or ", list(list("fn_fmls()")), ".\n"), "\n", 
#&gt;             list("\n", "q1 &lt;- quote(1)\n", "is_expression(q1)\n", 
#&gt;                 "is_syntactic_literal(q1)\n", "\n", "q2 &lt;- quote(x)\n", 
#&gt;                 "is_expression(q2)\n", "is_symbol(q2)\n", "\n", 
#&gt;                 "q3 &lt;- quote(x + 1)\n", "is_expression(q3)\n", 
#&gt;                 "is_call(q3)\n", "\n", "\n", "# Atomic expressions are the terminating nodes of a call tree:\n", 
#&gt;                 "# NULL or a scalar atomic vector:\n", "is_syntactic_literal(\"string\")\n", 
#&gt;                 "is_syntactic_literal(NULL)\n", "\n", "is_syntactic_literal(letters)\n", 
#&gt;                 "is_syntactic_literal(quote(call()))\n", "\n", 
#&gt;                 "# Parsable literals have the property of being self-quoting:\n", 
#&gt;                 "identical(\"foo\", quote(\"foo\"))\n", "identical(1L, quote(1L))\n", 
#&gt;                 "identical(NULL, quote(NULL))\n", "\n", "# Like any literals, they can be evaluated within the empty\n", 
#&gt;                 "# environment:\n", "eval_bare(quote(1L), empty_env())\n", 
#&gt;                 "\n", "# Whereas it would fail for symbolic expressions:\n", 
#&gt;                 "# eval_bare(quote(c(1L, 2L)), empty_env())\n", 
#&gt;                 "\n", "\n", "# Pairlists are also language objects representing argument lists.\n", 
#&gt;                 "# You will usually encounter them with extracted formals:\n", 
#&gt;                 "fmls &lt;- formals(is_expression)\n", "typeof(fmls)\n", 
#&gt;                 "\n", "# Since they are mostly an internal data structure, is_expression()\n", 
#&gt;                 "# returns FALSE for pairlists, so you will have to check explicitly\n", 
#&gt;                 "# for them:\n", "is_expression(fmls)\n", "is_pairlist(fmls)\n"), 
#&gt;             "\n", list("\n", list(list("is_call()")), " for a call predicate.\n"), 
#&gt;             "\n"), is_formula.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("is_formula"), "\n", list("is_formula"), 
#&gt;             "\n", list("is_bare_formula"), "\n", list("Is object a formula?"), 
#&gt;             "\n", list("\n", "is_formula(x, scoped = NULL, lhs = NULL)\n", 
#&gt;                 "\n", "is_bare_formula(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("scoped"), list("A boolean indicating whether the quosure is scoped,\n", 
#&gt;                   "that is, has a valid environment attribute. If ", 
#&gt;                   list("NULL"), ", the scope\n", "is not inspected.")), 
#&gt;                 "\n", "\n", list(list("lhs"), list("A boolean indicating whether the ", 
#&gt;                   list("formula"), "\n", "or ", list("definition"), 
#&gt;                   " has a left-hand side. If ", list("NULL"), 
#&gt;                   ",\n", "the LHS is not inspected.")), "\n"), 
#&gt;             "\n", list("\n", list("is_formula()"), " tests if ", 
#&gt;                 list("x"), " is a call to ", list("~"), ". ", 
#&gt;                 list("is_bare_formula()"), "\n", "tests in addition that ", 
#&gt;                 list("x"), " does not inherit from anything else than\n", 
#&gt;                 list("\"formula\""), ".\n"), "\n", list("\n", 
#&gt;                 "The ", list("scoped"), " argument patterns-match on whether the scoped bundled\n", 
#&gt;                 "with the quosure is valid or not. Invalid scopes may happen in\n", 
#&gt;                 "nested quotations like ", list("~~expr"), ", where the outer quosure is validly\n", 
#&gt;                 "scoped but not the inner one. This is because ", 
#&gt;                 list("~"), " saves the\n", "environment when it is evaluated, and quoted formulas are by\n", 
#&gt;                 "definition not evaluated.\n"), "\n", list("\n", 
#&gt;                 "x &lt;- disp ~ am\n", "is_formula(x)\n", "\n", 
#&gt;                 "is_formula(~10)\n", "is_formula(10)\n", "\n", 
#&gt;                 "is_formula(quo(foo))\n", "is_bare_formula(quo(foo))\n", 
#&gt;                 "\n", "# Note that unevaluated formulas are treated as bare formulas even\n", 
#&gt;                 "# though they don't inherit from \"formula\":\n", 
#&gt;                 "f &lt;- quote(~foo)\n", "is_bare_formula(f)\n", 
#&gt;                 "\n", "# However you can specify `scoped` if you need the predicate to\n", 
#&gt;                 "# return FALSE for these unevaluated formulas:\n", 
#&gt;                 "is_bare_formula(f, scoped = TRUE)\n", "is_bare_formula(eval(f), scoped = TRUE)\n"), 
#&gt;             "\n"), is_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_frame"), "\n", list("is_frame"), "\n", 
#&gt;             list("Is object a frame?"), "\n", list("\n", "is_frame(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "is_function"), "\n", list("is_function"), "\n", 
#&gt;             list("is_closure"), "\n", list("is_primitive"), "\n", 
#&gt;             list("is_primitive_eager"), "\n", list("is_primitive_lazy"), 
#&gt;             "\n", list("Is object a function?"), "\n", list("\n", 
#&gt;                 "is_function(x)\n", "\n", "is_closure(x)\n", 
#&gt;                 "\n", "is_primitive(x)\n", "\n", "is_primitive_eager(x)\n", 
#&gt;                 "\n", "is_primitive_lazy(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n"), "\n", list("\n", "The R language defines two different types of functions: primitive\n", 
#&gt;                 "functions, which are low-level, and closures, which are the regular\n", 
#&gt;                 "kind of functions.\n"), "\n", list("\n", "Closures are functions written in R, named after the way their\n", 
#&gt;                 "arguments are scoped within nested environments (see\n", 
#&gt;                 "https://en.wikipedia.org/wiki/Closure_(computer_programming)). The\n", 
#&gt;                 "root environment of the closure is called the closure\n", 
#&gt;                 "environment. When closures are evaluated, a new environment called\n", 
#&gt;                 "the evaluation frame is created with the closure environment as\n", 
#&gt;                 "parent. This is where the body of the closure is evaluated. These\n", 
#&gt;                 "closure frames appear on the evaluation stack (see ", 
#&gt;                 list(list("ctxt_stack()")), "),\n", "as opposed to primitive functions which do not necessarily have\n", 
#&gt;                 "their own evaluation frame and never appear on the stack.\n", 
#&gt;                 "\n", "Primitive functions are more efficient than closures for two\n", 
#&gt;                 "reasons. First, they are written entirely in fast low-level\n", 
#&gt;                 "code. Second, the mechanism by which they are passed arguments is\n", 
#&gt;                 "more efficient because they often do not need the full procedure of\n", 
#&gt;                 "argument matching (dealing with positional versus named arguments,\n", 
#&gt;                 "partial matching, etc). One practical consequence of the special\n", 
#&gt;                 "way in which primitives are passed arguments is that they\n", 
#&gt;                 "technically do not have formal arguments, and ", 
#&gt;                 list(list("formals()")), " will\n", "return ", 
#&gt;                 list("NULL"), " if called on a primitive function. Finally, primitive\n", 
#&gt;                 "functions can either take arguments lazily, like R closures do,\n", 
#&gt;                 "or evaluate them eagerly before being passed on to the C code.\n", 
#&gt;                 "The former kind of primitives are called \"special\" in R terminology,\n", 
#&gt;                 "while the latter is referred to as \"builtin\". ", 
#&gt;                 list("is_primitive_eager()"), "\n", "and ", list(
#&gt;                   "is_primitive_lazy()"), " allow you to check whether a primitive\n", 
#&gt;                 "function evaluates arguments eagerly or lazily.\n", 
#&gt;                 "\n", "You will also encounter the distinction between primitive and\n", 
#&gt;                 "internal functions in technical documentation. Like primitive\n", 
#&gt;                 "functions, internal functions are defined at a low level and\n", 
#&gt;                 "written in C. However, internal functions have no representation in\n", 
#&gt;                 "the R language. Instead, they are called via a call to\n", 
#&gt;                 list(list("base::.Internal()")), " within a regular closure. This ensures that\n", 
#&gt;                 "they appear as normal R function objects: they obey all the usual\n", 
#&gt;                 "rules of argument passing, and they appear on the evaluation stack\n", 
#&gt;                 "as any other closures. As a result, ", list(
#&gt;                   list("fn_fmls()")), " does not need to\n", 
#&gt;                 "look in the ", list(".ArgsEnv"), " environment to obtain a representation of\n", 
#&gt;                 "their arguments, and there is no way of querying from R whether\n", 
#&gt;                 "they are lazy ('special' in R terminology) or eager ('builtin').\n", 
#&gt;                 "\n", "You can call primitive functions with ", 
#&gt;                 list(list(".Primitive()")), " and internal\n", 
#&gt;                 "functions with ", list(list(".Internal()")), 
#&gt;                 ". However, calling internal functions\n", "in a package is forbidden by CRAN's policy because they are\n", 
#&gt;                 "considered part of the private API. They often assume that they\n", 
#&gt;                 "have been called with correctly formed arguments, and may cause R\n", 
#&gt;                 "to crash if you call them with unexpected objects.\n"), 
#&gt;             "\n", list("\n", "# Primitive functions are not closures:\n", 
#&gt;                 "is_closure(base::c)\n", "is_primitive(base::c)\n", 
#&gt;                 "\n", "# On the other hand, internal functions are wrapped in a closure\n", 
#&gt;                 "# and appear as such from the R side:\n", "is_closure(base::eval)\n", 
#&gt;                 "\n", "# Both closures and primitives are functions:\n", 
#&gt;                 "is_function(base::c)\n", "is_function(base::eval)\n", 
#&gt;                 "\n", "# Primitive functions never appear in evaluation stacks:\n", 
#&gt;                 "is_primitive(base::`[[`)\n", "is_primitive(base::list)\n", 
#&gt;                 "list(ctxt_stack())[[1]]\n", "\n", "# While closures do:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# Many primitive functions evaluate arguments eagerly:\n", 
#&gt;                 "is_primitive_eager(base::c)\n", "is_primitive_eager(base::list)\n", 
#&gt;                 "is_primitive_eager(base::`+`)\n", "\n", "# However, primitives that operate on expressions, like quote() or\n", 
#&gt;                 "# substitute(), are lazy:\n", "is_primitive_lazy(base::quote)\n", 
#&gt;                 "is_primitive_lazy(base::substitute)\n"), "\n"), 
#&gt;         is_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_installed"), "\n", list("is_installed"), 
#&gt;             "\n", list("Is a package installed in the library?"), 
#&gt;             "\n", list("\n", "is_installed(pkg)\n"), "\n", list(
#&gt;                 "\n", list(list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", list("TRUE"), " if the package is installed, ", 
#&gt;                 list("FALSE"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This checks that a package is installed with minimal side effects.\n", 
#&gt;                 "If installed, the package will be loaded but not attached.\n"), 
#&gt;             "\n", list("\n", "is_installed(\"utils\")\n", "is_installed(\"ggplot5\")\n"), 
#&gt;             "\n"), is_integerish.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/types.R", 
#&gt;             "\n", list("is_integerish"), "\n", list("is_integerish"), 
#&gt;             "\n", list("is_bare_integerish"), "\n", list("is_scalar_integerish"), 
#&gt;             "\n", list("Is a vector integer-like?"), "\n", list(
#&gt;                 "\n", "is_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_bare_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_scalar_integerish(x, finite = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check whether R considers a number vector to be\n", 
#&gt;                 "integer-like, according to its own tolerance check (which is in\n", 
#&gt;                 "fact delegated to the C library). This function is not adapted to\n", 
#&gt;                 "data analysis, see the help for ", list(list(
#&gt;                   "base::is.integer()")), " for examples\n", 
#&gt;                 "of how to check for whole numbers.\n", "\n", 
#&gt;                 "Things to consider when checking for integer-like doubles:\n", 
#&gt;                 list("\n", list(), " This check can be expensive because the whole double vector has\n", 
#&gt;                   "to be traversed and checked.\n", list(), " Large double values may be integerish but may still not be\n", 
#&gt;                   "coercible to integer. This is because integers in R only support\n", 
#&gt;                   "values up to ", list("2^31 - 1"), " while numbers stored as double can be\n", 
#&gt;                   "much larger.\n"), "\n"), "\n", list("\n", 
#&gt;                 "is_integerish(10L)\n", "is_integerish(10.0)\n", 
#&gt;                 "is_integerish(10.0, n = 2)\n", "is_integerish(10.000001)\n", 
#&gt;                 "is_integerish(TRUE)\n"), "\n", list("\n", list(
#&gt;                 list("is_bare_numeric()")), " for testing whether an object is a\n", 
#&gt;                 "base numeric type (a bare double or integer vector).\n"), 
#&gt;             "\n"), is_interactive.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/state.R", 
#&gt;             "\n", list("is_interactive"), "\n", list("is_interactive"), 
#&gt;             "\n", list("scoped_interactive"), "\n", list("with_interactive"), 
#&gt;             "\n", list("Is R running interactively?"), "\n", 
#&gt;             list("\n", "is_interactive()\n", "\n", "scoped_interactive(value = TRUE, frame = caller_env())\n", 
#&gt;                 "\n", "with_interactive(expr, value = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("value"), list("A single ", 
#&gt;                 list("TRUE"), " or ", list("FALSE"), ". This overrides the return\n", 
#&gt;                 "value of ", list("is_interactive()"), ".")), 
#&gt;                 "\n", "\n", list(list("frame"), list("The environment of a running function which defines\n", 
#&gt;                   "the scope of the temporary options. When the function returns,\n", 
#&gt;                   "the options are reset to their original values.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("An expression to evaluate with interactivity set to\n", 
#&gt;                   list("value"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "Like ", list(list("base::interactive()")), ", ", 
#&gt;                 list("is_interactive()"), " returns ", list("TRUE"), 
#&gt;                 " when\n", "the function runs interactively and ", 
#&gt;                 list("FALSE"), " when it runs in batch\n", "mode. It also checks, in this order:\n", 
#&gt;                 list("\n", list(), " The ", list("rlang_interactive"), 
#&gt;                   " global option. If set to a single ", list(
#&gt;                     "TRUE"), "\n", "or ", list("FALSE"), ", ", 
#&gt;                   list("is_interactive()"), " returns that value immediately. This\n", 
#&gt;                   "escape hatch is useful in unit tests or to manually turn on\n", 
#&gt;                   "interactive features in RMarkdown outputs.\n", 
#&gt;                   list(), " Whether knitr, an RStudio notebook, or testthat is in progress.\n"), 
#&gt;                 "\n", "\n", list("with_interactive()"), " and ", 
#&gt;                 list("scoped_interactive()"), " set the global\n", 
#&gt;                 "option conveniently.\n"), "\n"), is_lang.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_lang"), "\n", list("is_lang"), "\n", 
#&gt;             list("is_unary_lang"), "\n", list("is_binary_lang"), 
#&gt;             "\n", list("quo_is_lang"), "\n", list("Is object a call?"), 
#&gt;             "\n", list("\n", "is_lang(x, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_unary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_binary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_lang(quo)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                   "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                   list("An optional name that the call should match. It is\n", 
#&gt;                     "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                     "and you can supply a vector of names to match. In this case,\n", 
#&gt;                     list("is_call()"), " returns ", list("TRUE"), 
#&gt;                     " if at least one name matches.")), "\n", 
#&gt;                 "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("is_call()")), " and its ", list("n"), 
#&gt;                 "\n", "argument instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_named.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("is_named"), "\n", list("is_named"), "\n", 
#&gt;             list("is_dictionaryish"), "\n", list("have_name"), 
#&gt;             "\n", list("Is object named?"), "\n", list("\n", 
#&gt;                 "is_named(x)\n", "\n", "is_dictionaryish(x)\n", 
#&gt;                 "\n", "have_name(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " and ", list(
#&gt;                 "is_dictionaryish()"), " are scalar predicates\n", 
#&gt;                 "and return ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ". ", list("have_name()"), " is vectorised and\n", 
#&gt;                 "returns a logical vector as long as the input.\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " checks that ", 
#&gt;                 list("x"), " has names attributes, and that none of\n", 
#&gt;                 "the names are missing or empty (", list("NA"), 
#&gt;                 " or ", list("\"\""), "). ", list("is_dictionaryish()"), 
#&gt;                 "\n", "checks that an object is a dictionary: that it has actual names and\n", 
#&gt;                 "in addition that there are no duplicated names. ", 
#&gt;                 list("have_name()"), "\n", "is a vectorised version of ", 
#&gt;                 list("is_named()"), ".\n"), "\n", list("\n", 
#&gt;                 "# A data frame usually has valid, unique names\n", 
#&gt;                 "is_named(mtcars)\n", "have_name(mtcars)\n", 
#&gt;                 "is_dictionaryish(mtcars)\n", "\n", "# But data frames can also have duplicated columns:\n", 
#&gt;                 "dups &lt;- cbind(mtcars, cyl = seq_len(nrow(mtcars)))\n", 
#&gt;                 "is_dictionaryish(dups)\n", "\n", "# The names are still valid:\n", 
#&gt;                 "is_named(dups)\n", "have_name(dups)\n", "\n", 
#&gt;                 "\n", "# For empty objects the semantics are slightly different.\n", 
#&gt;                 "# is_dictionaryish() returns TRUE for empty objects:\n", 
#&gt;                 "is_dictionaryish(list())\n", "\n", "# But is_named() will only return TRUE if there is a names\n", 
#&gt;                 "# attribute (a zero-length character vector in this case):\n", 
#&gt;                 "x &lt;- set_names(list(), character(0))\n", "is_named(x)\n", 
#&gt;                 "\n", "\n", "# Empty and missing names are invalid:\n", 
#&gt;                 "invalid &lt;- dups\n", "names(invalid)[2] &lt;- \"\"\n", 
#&gt;                 "names(invalid)[5] &lt;- NA\n", "\n", "# is_named() performs a global check while have_name() can show you\n", 
#&gt;                 "# where the problem is:\n", "is_named(invalid)\n", 
#&gt;                 "have_name(invalid)\n", "\n", "# have_name() will work even with vectors that don't have a names\n", 
#&gt;                 "# attribute:\n", "have_name(letters)\n"), "\n"), 
#&gt;         is_namespace.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_namespace"), "\n", list("is_namespace"), 
#&gt;             "\n", list("Is an object a namespace environment?"), 
#&gt;             "\n", list("\n", "is_namespace(x)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is an object a namespace environment?\n"), 
#&gt;             "\n"), is_pairlist.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("is_pairlist"), "\n", list("is_pairlist"), 
#&gt;             "\n", list("is_node"), "\n", list("is_node_list"), 
#&gt;             "\n", list("Is object a node or pairlist?"), "\n", 
#&gt;             list("\n", "is_pairlist(x)\n", "\n", "is_node(x)\n", 
#&gt;                 "\n", "is_node_list(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("is_pairlist()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), ".\n", list(), " ", list("is_node()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), " or ", list("language"), ".\n", 
#&gt;                 "It tests whether ", list("x"), " is a node that has a CAR and a CDR,\n", 
#&gt;                 "including callable nodes (language objects).\n", 
#&gt;                 list(), " ", list("is_node_list()"), " checks that ", 
#&gt;                 list("x"), " has type ", list("pairlist"), " or ", 
#&gt;                 list("NULL"), ".\n", list("NULL"), " is the empty node list.\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are experimental. We are still figuring out a good\n", 
#&gt;                 "naming convention to refer to the different lisp-like lists in R.\n")), 
#&gt;             "\n", "\n", list("\n", list(list("is_call()")), " tests for language nodes.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_reference.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_reference"), "\n", list("is_reference"), 
#&gt;             "\n", list("Is an object referencing another?"), 
#&gt;             "\n", list("\n", "is_reference(x, y)\n"), "\n", list(
#&gt;                 "\n", list(list("x, y"), list("R objects.")), 
#&gt;                 "\n"), "\n", list("\n", "There are typically two situations where two symbols may refer to\n", 
#&gt;                 "the same object.\n", list("\n", list(), " R objects usually have copy-on-write semantics. This is an\n", 
#&gt;                   "optimisation that ensures that objects are only copied if\n", 
#&gt;                   "needed. When you copy a vector, no memory is actually copied\n", 
#&gt;                   "until you modify either the original object or the copy is\n", 
#&gt;                   "modified.\n", "\n", "Note that the copy-on-write optimisation is an implementation\n", 
#&gt;                   "detail that is not guaranteed by the specification of the R\n", 
#&gt;                   "language.\n", list(), " Assigning an ", list(
#&gt;                     "uncopyable"), " object (like an\n", "environment) creates a reference. These objects are never copied\n", 
#&gt;                   "even if you modify one of the references.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Reassigning an uncopyable object such as an environment creates a\n", 
#&gt;                 "# reference:\n", "env &lt;- env()\n", "ref &lt;- env\n", 
#&gt;                 "is_reference(ref, env)\n", "\n", "# Due to copy-on-write optimisation, a copied vector can\n", 
#&gt;                 "# temporarily reference the original vector:\n", 
#&gt;                 "vec &lt;- 1:10\n", "copy &lt;- vec\n", "is_reference(copy, vec)\n", 
#&gt;                 "\n", "# Once you modify on of them, the copy is triggered in the\n", 
#&gt;                 "# background and the objects cease to reference each other:\n", 
#&gt;                 "vec[[1]] &lt;- 100\n", "is_reference(copy, vec)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_stack.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_stack"), "\n", list("is_stack"), "\n", 
#&gt;             list("is_eval_stack"), "\n", list("is_call_stack"), 
#&gt;             "\n", list("Is object a stack?"), "\n", list("\n", 
#&gt;                 "is_stack(x)\n", "\n", "is_eval_stack(x)\n", 
#&gt;                 "\n", "is_call_stack(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_symbol.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/sym.R", "\n", list(
#&gt;                 "is_symbol"), "\n", list("is_symbol"), "\n", 
#&gt;             list("Is object a symbol?"), "\n", list("\n", "is_symbol(x, name = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An optional name or vector of names that the symbol\n", 
#&gt;                   "should match.")), "\n"), "\n", list("\n", 
#&gt;                 "Is object a symbol?\n"), "\n"), is_true.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_true"), "\n", list("is_true"), "\n", list(
#&gt;                 "is_false"), "\n", list("Is object identical to TRUE or FALSE?"), 
#&gt;             "\n", list("\n", "is_true(x)\n", "\n", "is_false(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", "These functions bypass R's automatic conversion rules and check\n", 
#&gt;                 "that ", list("x"), " is literally ", list("TRUE"), 
#&gt;                 " or ", list("FALSE"), ".\n"), "\n", list("\n", 
#&gt;                 "is_true(TRUE)\n", "is_true(1)\n", "\n", "is_false(FALSE)\n", 
#&gt;                 "is_false(0)\n"), "\n"), is_weakref.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("is_weakref"), "\n", list("is_weakref"), "\n", 
#&gt;             list("Is object a weak reference?"), "\n", list("\n", 
#&gt;                 "is_weakref(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "Is object a weak reference?\n"), "\n"), 
#&gt;         lang.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang"), "\n", list("lang"), "\n", list(
#&gt;                 "new_language"), "\n", list("Create a call"), 
#&gt;             "\n", list("\n", "lang(.fn, ..., .ns = NULL)\n", 
#&gt;                 "\n", "new_language(head, tail = NULL)\n"), "\n", 
#&gt;             list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call2()")), " and\n", list(list("new_call()")), 
#&gt;                 " instead.\n"), "\n", list("internal"), "\n"), 
#&gt;         lang_head.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_head"), "\n", list("lang_head"), 
#&gt;             "\n", list("lang_tail"), "\n", list("Return the head or tail of a call"), 
#&gt;             "\n", list("\n", "lang_head(lang)\n", "\n", "lang_tail(lang)\n"), 
#&gt;             "\n", list("\n", list(list("lang"), list("A call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.2.0 these functions are retired (deprecated for now)\n", 
#&gt;                 "because they are low level accessors that are rarely needed for end\n", 
#&gt;                 "users.\n"), "\n", list("internal"), "\n"), lang_modify.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_modify"), "\n", list("lang_modify"), 
#&gt;             "\n", list("lang_standardise"), "\n", list("lang_fn"), 
#&gt;             "\n", list("lang_name"), "\n", list("lang_args"), 
#&gt;             "\n", list("lang_args_names"), "\n", list("Manipulate or access a call"), 
#&gt;             "\n", list("\n", "lang_modify(.lang, ..., .standardise = FALSE)\n", 
#&gt;                 "\n", "lang_standardise(lang)\n", "\n", "lang_fn(lang)\n", 
#&gt;                 "\n", "lang_name(lang)\n", "\n", "lang_args(lang)\n", 
#&gt;                 "\n", "lang_args_names(lang)\n"), "\n", list(
#&gt;                 "\n", list(list("..."), list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                   list(".standardise"), list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n", "\n", list(list("lang, .lang"), 
#&gt;                   list("The ", list("call"), " or ", list(".call"), 
#&gt;                     " argument of the renamed\n", "functions.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call_modify()")), ",\n", list(list(
#&gt;                   "call_standardise()")), ", or ", list(list(
#&gt;                   "call_fn()")), " instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), last_error.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-abort.R", 
#&gt;             "\n", list("last_error"), "\n", list("last_error"), 
#&gt;             "\n", list("last_trace"), "\n", list("Last ", list(
#&gt;                 "abort()"), " error"), "\n", list("\n", "last_error()\n", 
#&gt;                 "\n", "last_trace()\n"), "\n", list("\n", list(
#&gt;                 "\n", list(), " ", list("last_error()"), " returns the last error thrown with ", 
#&gt;                 list(list("abort()")), ". The\n", "error is printed with a backtrace in simplified form.\n", 
#&gt;                 list(), " ", list("last_trace()"), " is a shortcut to return the backtrace stored in\n", 
#&gt;                 "the last error. This backtrace is printed in full form.\n"), 
#&gt;                 "\n"), "\n"), lifecycle.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle.R", 
#&gt;             "\n", list("lifecycle"), "\n", list("lifecycle"), 
#&gt;             "\n", list("Life cycle of the rlang package"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"maturing\")"), 
#&gt;                 "\n", "\n", "The rlang package is currently maturing. Unless otherwise stated,\n", 
#&gt;                 "this applies to all its exported functions. Maturing functions are\n", 
#&gt;                 "susceptible to API changes. Only use these in packages if you're\n", 
#&gt;                 "prepared to make changes as the package evolves. See sections below\n", 
#&gt;                 "for a list of functions marked as stable.\n", 
#&gt;                 "\n", "The documentation pages of retired functions contain life cycle\n", 
#&gt;                 "sections that explain the reasons for their retirements.\n"), 
#&gt;             "\n", list(list("Stable functions"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("eval_tidy()")), 
#&gt;                   "\n", list(), " ", list("!!"), ", ", list("!!!"), 
#&gt;                   "\n", list(), " ", list(list("enquo()")), ", ", 
#&gt;                   list(list("quo()")), ", ", list(list("quos()")), 
#&gt;                   "\n", list(), " ", list(list("enexpr()")), 
#&gt;                   ", ", list(list("expr()")), ", ", list(list(
#&gt;                     "exprs()")), "\n", list(), " ", list(list(
#&gt;                     "sym()")), ", ", list(list("syms()")), "\n", 
#&gt;                   list(), " ", list(list("new_quosure()")), ", ", 
#&gt;                   list(list("is_quosure()")), "\n", list(), " ", 
#&gt;                   list(list("missing_arg()")), ", ", list(list(
#&gt;                     "is_missing()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_expr()")), ", ", list(list(
#&gt;                     "quo_set_expr()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_env()")), ", ", list(list("quo_set_env()")), 
#&gt;                   "\n", list(), " ", list(list("eval_bare()")), 
#&gt;                   "\n", list(), " ", list(list("set_names()")), 
#&gt;                   ", ", list(list("names2()")), "\n", list(), 
#&gt;                   " ", list(list("as_function()")), ", ", list(
#&gt;                     list("new_function()")), "\n"), "\n")), "\n", 
#&gt;             "\n", list(list("Experimental functions"), list("\n", 
#&gt;                 "\n", "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These functions are not yet part of the rlang API. Expect breaking\n", 
#&gt;                 "changes.\n", list("\n", list(), " ", list(list(
#&gt;                   "with_env()")), ", ", list(list("locally()")), 
#&gt;                   ", ", list(list("env_poke()")), "\n", list(), 
#&gt;                   " ", list(list("pkg_env()")), ", ", list(list(
#&gt;                     "pkg_env_name()")), ", ", list(list("ns_env()")), 
#&gt;                   ", ", list(list("ns_imports_env()")), ", ", 
#&gt;                   list(list("ns_env_name()")), "\n", list(), 
#&gt;                   " ", list(list("is_pairlist()")), ", ", list(
#&gt;                     list("as_pairlist()")), ", ", list(list("is_node()")), 
#&gt;                   ", ", list(list("is_node_list()")), "\n", list(), 
#&gt;                   " ", list(list("is_definition()")), ", ", list(
#&gt;                     list("new_definition()")), ", ", list(list(
#&gt;                     "is_formulaish()")), ",\n", list(list("dots_definitions()")), 
#&gt;                   "\n", list(), " ", list(list("scoped_options()")), 
#&gt;                   ", ", list(list("with_options()")), ", ", list(
#&gt;                     list("push_options()")), ",\n", list(list(
#&gt;                     "peek_options()")), ", ", list(list("peek_option()")), 
#&gt;                   "\n", list(), " ", list(list("as_bytes()")), 
#&gt;                   ", ", list(list("chr_unserialise_unicode()")), 
#&gt;                   "\n", list(), " ", list(list("caller_fn()")), 
#&gt;                   ", ", list(list("current_fn()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Questioning stage"), list(
#&gt;                 "\n", "\n", "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("In the questioning stage as of rlang 0.4.0"), 
#&gt;                 "\n", "\n", "These functions are likely to be moved to the vctrs package:\n", 
#&gt;                 list("\n", list(), " ", list(list("lgl()")), 
#&gt;                   ", ", list(list("int()")), ", etc.\n", list(), 
#&gt;                   " ", list(list("new_logical()")), ", ", list(
#&gt;                     list("new_integer()")), ", etc.\n", list(), 
#&gt;                   " ", list("na_lgl"), ", ", list("na_int"), 
#&gt;                   ", ", list(list("is_lgl_na()")), ", ", list(
#&gt;                     list("is_int_na()")), ", etc.\n"), "\n", 
#&gt;                 "\n", list("In the questioning stage as of rlang 0.3.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("child_env()")), 
#&gt;                   "\n", list(), " ", list(list("flatten()")), 
#&gt;                   ", ", list(list("squash()")), ", and their atomic vector variants\n", 
#&gt;                   list(), " ", list(list("modify()")), " and ", 
#&gt;                   list(list("prepend()")), "\n", list(), " ", 
#&gt;                   list(list("with_restarts()")), ", ", list(list(
#&gt;                     "rst_list()")), ", ", list(list("rst_exists()")), 
#&gt;                   ", ", list(list("rst_jump()")), ",\n", list(
#&gt;                     list("rst_maybe_jump()")), ", ", list(list(
#&gt;                     "rst_abort()")), ". It is not clear yet whether we\n", 
#&gt;                   "want to recommend restarts as a style of programming in R.\n", 
#&gt;                   list(), " ", list(list("return_from()")), " and ", 
#&gt;                   list(list("return_to()")), ".\n", list(), " ", 
#&gt;                   list(list("expr_label()")), ", ", list(list(
#&gt;                     "expr_name()")), ", and ", list(list("expr_text()")), 
#&gt;                   ".\n"), "\n", "\n", list("In the questioning stage as of rlang 0.2.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("UQ()")), 
#&gt;                   ", ", list(list("UQS()")), "\n", list(), " ", 
#&gt;                   list(list("dots_splice()")), ", ", list(list(
#&gt;                     "splice()")), "\n"), "\n")), "\n", "\n", 
#&gt;             list(list("Soft-deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                   "\n", "\n", list("Soft-deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("exiting()")), 
#&gt;                     ": Handlers are now treated as exiting by default.\n", 
#&gt;                     list(), " ", list(list("invoke()")), ": Use the simpler ", 
#&gt;                     list(list("exec()")), " instead.\n", list(), 
#&gt;                     " ", list(list("as_logical()")), ", ", list(
#&gt;                       list("as_integer()")), ", etc. =&gt; ", list(
#&gt;                       "vctrs::vec_cast()"), ".\n", list(), " ", 
#&gt;                     list(list("type_of()")), ", ", list(list(
#&gt;                       "switch_type()")), ", ", list(list("coerce_type()")), 
#&gt;                     ", ", list(list("switch_class()")), ",\n", 
#&gt;                     list(list("coerce_class()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                   "\n", "\n", list("Bumped to deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("modify()")), 
#&gt;                     " and ", list(list("prepend()")), ".\n", 
#&gt;                     list(), " ", list("new_logical_along()"), 
#&gt;                     ", ", list("new_integer_along()"), ",\n", 
#&gt;                     list("new_double_along()"), ", ", list("new_complex_along()"), 
#&gt;                     ",\n", list("new_character_along()"), ", ", 
#&gt;                     list("new_raw_along()"), ", ", list("new_list_along()"), 
#&gt;                     ".\n", list(), " ", list(list("lang_modify()")), 
#&gt;                     " =&gt; ", list(list("call_modify()")), "\n", 
#&gt;                     list(), " ", list(list("lang_standardise()")), 
#&gt;                     " =&gt; ", list(list("call_standardise()")), 
#&gt;                     "\n", list(), " ", list(list("lang_fn()")), 
#&gt;                     " =&gt; ", list(list("call_fn()")), "\n", list(), 
#&gt;                     " ", list(list("lang_name()")), " =&gt; ", list(
#&gt;                       list("call_name()")), "\n", list(), " ", 
#&gt;                     list(list("lang_args()")), " =&gt; ", list(list(
#&gt;                       "call_args()")), "\n", list(), " ", list(
#&gt;                       list("lang_args_names()")), " =&gt; ", list(
#&gt;                       list("call_args_names()")), "\n", list(), 
#&gt;                     " ", list(list("lang_head()")), ", ", list(
#&gt;                       list("lang_tail()")), "\n", list(), " ", 
#&gt;                     list(list("lang()")), " =&gt; ", list(list("call2()")), 
#&gt;                     "\n", list(), " ", list(list("new_language()")), 
#&gt;                     " =&gt; ", list(list("new_call()")), "\n", list(), 
#&gt;                     " ", list(list("is_lang()")), " =&gt; ", list(
#&gt;                       list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("is_unary_lang()")), " =&gt; Use the ", 
#&gt;                     list("n"), " argument of ", list(list("is_call()")), 
#&gt;                     "\n", list(), " ", list(list("is_binary_lang()")), 
#&gt;                     " =&gt; Use the ", list("n"), " argument of ", 
#&gt;                     list(list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("quo_is_lang()")), " =&gt; ", list(
#&gt;                       list("quo_is_call()")), "\n", list(), " ", 
#&gt;                     list(list("call_modify()")), ": ", list(".standardise"), 
#&gt;                     " and ", list(".env"), " arguments.\n", list(), 
#&gt;                     " ", list(list("is_expr()")), " =&gt; ", list(
#&gt;                       list("is_expression()")), "\n", list(), 
#&gt;                     " ", list("quo_expr()"), " =&gt; ", list(list(
#&gt;                       "quo_squash()")), "\n", list(), " ", list(
#&gt;                       list("parse_quosure()")), " =&gt; ", list(
#&gt;                       list("parse_quo()")), "\n", list(), " ", 
#&gt;                     list(list("parse_quosures()")), " =&gt; ", list(
#&gt;                       list("parse_quos()")), "\n", list(), " Assigning non-quosure objects to quosure lists.\n", 
#&gt;                     list(), " ", list("as.character()"), " on quosures.\n", 
#&gt;                     list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": ", list(".cnd"), " =&gt; ", list("cnd"), 
#&gt;                     "\n", list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": The ", list(".mufflable"), " argument no longer has any effect\n", 
#&gt;                     list(), " ", list("scoped_names()"), " =&gt; ", 
#&gt;                     list(list("base::search()")), "\n", list(), 
#&gt;                     " ", list("is_scoped()"), " =&gt; ", list(list(
#&gt;                       "is_attached()")), "\n", list(), " ", list(
#&gt;                       "scoped_env()"), " =&gt; ", list(list("search_env()")), 
#&gt;                     "\n", list(), " ", list("scoped_envs()"), 
#&gt;                     " =&gt; ", list(list("search_envs()")), "\n", 
#&gt;                     list(), " ", list("env_bind_exprs()"), " =&gt; ", 
#&gt;                     list(list("env_bind_lazy()")), "\n", list(), 
#&gt;                     " ", list("env_bind_fns()"), " =&gt; ", list(
#&gt;                       list("env_bind_active()")), "\n", list(), 
#&gt;                     " Passing a function or formula to ", list(
#&gt;                       "env_depth()"), ",\n", list("env_poke_parent()"), 
#&gt;                     ", ", list("env_parent&lt;-"), ", ", list("env_tail()"), 
#&gt;                     ", ", list("set_env()"), ",\n", list("env_clone()"), 
#&gt;                     ", ", list("env_inherits()"), ", ", list(
#&gt;                       "env_bind()"), ",\n", list("scoped_bindings()"), 
#&gt;                     ", ", list("with_bindings()"), ", ", list(
#&gt;                       "env_poke()"), ",\n", list("env_has()"), 
#&gt;                     ", ", list("env_get()"), ", ", list("env_names()"), 
#&gt;                     ", ", list("env_bind_exprs()"), " and\n", 
#&gt;                     list("env_bind_fns()"), ". This internal genericity was causing confusion\n", 
#&gt;                     "(see issue #427). You should now extract the environment\n", 
#&gt;                     "separately before calling these functions.\n", 
#&gt;                     list(), " ", list(list("get_env()")), ": The ", 
#&gt;                     list("env"), " argument no longer has a default and must be supplied\n", 
#&gt;                     list(), " ", list(list("is_frame()")), ", ", 
#&gt;                     list(list("global_frame()")), ", ", list(
#&gt;                       list("current_frame()")), ",\n", list(list(
#&gt;                       "ctxt_frame()")), ", ", list(list("call_frame()")), 
#&gt;                     ", ", list(list("frame_position()")), ",\n", 
#&gt;                     list(list("caller_frame()")), "\n", list(), 
#&gt;                     " ", list(list("ctxt_depth()")), ", ", list(
#&gt;                       list("call_depth()")), ", ", list(list(
#&gt;                       "ctxt_stack()")), ", ", list(list("call_stack()")), 
#&gt;                     ",\n", list(list("stack_trim()")), "\n", 
#&gt;                     list(), " ", list(list("set_attrs()")), ", ", 
#&gt;                     list(list("mut_attrs()")), "\n", list(), 
#&gt;                     " The ", list("width"), " and ", list("printer"), 
#&gt;                     " arguments of ", list(list("exprs_auto_name()")), 
#&gt;                     " and\n", list(list("quos_auto_name()")), 
#&gt;                     " no longer have any effect. For the same\n", 
#&gt;                     "reason, passing a width as ", list(".named"), 
#&gt;                     " argument of dots collectors\n", "like ", 
#&gt;                     list("quos()"), " is deprecated.\n", list(), 
#&gt;                     " ", list("as_overscope()"), " =&gt; ", list(
#&gt;                       list("as_data_mask()")), "\n", list(), 
#&gt;                     " ", list("new_overscope()"), " =&gt; ", list(
#&gt;                       list("new_data_mask()")), "\n", list(), 
#&gt;                     " ", list("overscope_eval_next()"), " =&gt; ", 
#&gt;                     list(list("eval_tidy()")), "\n", list(), 
#&gt;                     " ", list("overscope_clean()"), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Defunct functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"defunct\")"), 
#&gt;                   "\n", "\n", list("Defunct as of rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list("length()"), 
#&gt;                     " and ", list("names()"), " on tidy eval ", 
#&gt;                     list(".data"), " pronouns.\n", list(), " Supplying a named ", 
#&gt;                     list("!!!"), " call.\n", list(), " ", list(
#&gt;                       list("as_data_mask()")), ": ", list("parent"), 
#&gt;                     " argument\n", list(), " ", list(list("new_data_mask()")), 
#&gt;                     ": ", list("parent"), " argument\n", list(), 
#&gt;                     " ", list(list("env_tail()")), ": ", list(
#&gt;                       "sentinel"), " =&gt; ", list("last"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ": ", list("msg"), ", ", list("type"), " =&gt; ", 
#&gt;                     list(".msg"), ", ", list(".type"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ", ", list(list("cnd()")), ", ", list(list(
#&gt;                       "error_cnd()")), ",\n", list(list("warning_cnd()")), 
#&gt;                     ", ", list(list("message_cnd()")), ": ", 
#&gt;                     list("call"), " argument.\n", list(), " ", 
#&gt;                     list(list("is_character()")), ", ", list(
#&gt;                       list("is_string()")), ", and variants: The ", 
#&gt;                     list("encoding"), "\n", "argument.\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Archived"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"archived\")"), 
#&gt;                 "\n", "\n", "These functions were entirely removed from the package. You will\n", 
#&gt;                 "find them in the commit history and previous releases.\n", 
#&gt;                 "\n", list("Archived as of rlang 0.4.0"), "\n", 
#&gt;                 list("\n", list(), " ", list("UQE()"), "\n", 
#&gt;                   list(), " ", list("as_dictionary()"), ", ", 
#&gt;                   list("is_dictionary()"), "\n", list(), " ", 
#&gt;                   list("as_quosureish()"), ", ", list("is_quosureish()"), 
#&gt;                   "\n", list(), " ", list("eval_tidy_()"), "\n", 
#&gt;                   list(), " ", list("mut_utf8_locale()"), ", ", 
#&gt;                   list("mut_latin1_locale()"), ", ", list("mut_mbcs_locale()"), 
#&gt;                   "\n", list(), " ", list("set_chr_encoding()"), 
#&gt;                   ", ", list("chr_encoding()"), ", ", list("set_str_encoding()"), 
#&gt;                   ", ", list("str_encoding()"), "\n", list(), 
#&gt;                   " ", list("as_native_character()"), ", ", list(
#&gt;                     "as_utf8_string()"), ", ", list("as_native_string()"), 
#&gt;                   "\n", list(), " ", list("lang_type_of()"), 
#&gt;                   ", ", list("switch_lang()"), ", ", list("coerce_lang()"), 
#&gt;                   "\n"), "\n", "\n", list("Archived as of rlang 0.3.0:"), 
#&gt;                 "\n", list("\n", list(), " ", list("cnd_inform()"), 
#&gt;                   ", ", list("cnd_warn()"), " and ", list("cnd_abort()"), 
#&gt;                   "\n", list(), " ", list("new_cnd()"), " =&gt; ", 
#&gt;                   list(list("cnd()")), "\n", list(), " ", list(
#&gt;                     "cnd_message()"), " =&gt; ", list(list("message_cnd()")), 
#&gt;                   "\n", list(), " ", list("cnd_warning()"), " =&gt; ", 
#&gt;                   list(list("warning_cnd()")), "\n", list(), 
#&gt;                   " ", list("cnd_error()"), " =&gt; ", list(list(
#&gt;                     "error_cnd()")), "\n", list(), " ", list(
#&gt;                     "rst_muffle()"), " =&gt; ", list(list("cnd_muffle()")), 
#&gt;                   "\n", list(), " ", list("inplace()"), " =&gt; ", 
#&gt;                   list(list("calling()")), ". The ", list("muffle"), 
#&gt;                   " argument of ", list("inplace()"), "\n", "has not been implemented in ", 
#&gt;                   list("calling()"), " and is now defunct.\n", 
#&gt;                   list(), " ", list(list("cnd_signal()")), ": ", 
#&gt;                   list(".msg"), " and ", list(".call"), ".\n", 
#&gt;                   list(), " ", list(list("cnd()")), ", ", list(
#&gt;                     list("error_cnd()")), ", ", list(list("warning_cnd()")), 
#&gt;                   " and ", list(list("message_cnd()")), ":\n", 
#&gt;                   list(".msg"), " =&gt; ", list("message"), ".\n"), 
#&gt;                 "\n")), "\n", "\n", list("internal"), "\n"), 
#&gt;         missing.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-na.R", 
#&gt;             "\n", list("data"), "\n", list("missing"), "\n", 
#&gt;             list("missing"), "\n", list("na_lgl"), "\n", list(
#&gt;                 "na_int"), "\n", list("na_dbl"), "\n", list("na_chr"), 
#&gt;             "\n", list("na_cpl"), "\n", list("Missing values"), 
#&gt;             "\n", list("An object of class ", list("logical"), 
#&gt;                 " of length 1."), "\n", list("\n", "na_lgl\n", 
#&gt;                 "\n", "na_int\n", "\n", "na_dbl\n", "\n", "na_chr\n", 
#&gt;                 "\n", "na_cpl\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Missing values are represented in R with the general symbol\n", 
#&gt;                 list("NA"), ". They can be inserted in almost all data containers: all\n", 
#&gt;                 "atomic vectors except raw vectors can contain missing values. To\n", 
#&gt;                 "achieve this, R automatically converts the general ", 
#&gt;                 list("NA"), " symbol to a\n", "typed missing value appropriate for the target vector. The objects\n", 
#&gt;                 "provided here are aliases for those typed ", 
#&gt;                 list("NA"), " objects.\n"), "\n", list("\n", 
#&gt;                 "Typed missing values are necessary because R needs sentinel values\n", 
#&gt;                 "of the same type (i.e. the same machine representation of the data)\n", 
#&gt;                 "as the containers into which they are inserted. The official typed\n", 
#&gt;                 "missing values are ", list("NA_integer_"), ", ", 
#&gt;                 list("NA_real_"), ", ", list("NA_character_"), 
#&gt;                 " and\n", list("NA_complex_"), ". The missing value for logical vectors is simply the\n", 
#&gt;                 "default ", list("NA"), ". The aliases provided in rlang are consistently named\n", 
#&gt;                 "and thus simpler to remember. Also, ", list(
#&gt;                   "na_lgl"), " is provided as an\n", "alias to ", 
#&gt;                 list("NA"), " that makes intent clearer.\n", 
#&gt;                 "\n", "Since ", list("na_lgl"), " is the default ", 
#&gt;                 list("NA"), ", expressions such as ", list("c(NA, NA)"), 
#&gt;                 "\n", "yield logical vectors as no data is available to give a clue of the\n", 
#&gt;                 "target type. In the same way, since lists and environments can\n", 
#&gt;                 "contain any types, expressions like ", list(
#&gt;                   "list(NA)"), " store a logical\n", list("NA"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These shortcuts might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;             "\n", "\n", list("\n", "typeof(NA)\n", "typeof(na_lgl)\n", 
#&gt;                 "typeof(na_int)\n", "\n", "# Note that while the base R missing symbols cannot be overwritten,\n", 
#&gt;                 "# that's not the case for rlang's aliases:\n", 
#&gt;                 "na_dbl &lt;- NA\n", "typeof(na_dbl)\n"), "\n", 
#&gt;             list("datasets"), "\n", list("internal"), "\n"), 
#&gt;         missing_arg.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("missing_arg"), "\n", list("missing_arg"), "\n", 
#&gt;             list("is_missing"), "\n", list("maybe_missing"), 
#&gt;             "\n", list("Generate or handle a missing argument"), 
#&gt;             "\n", list("\n", "missing_arg()\n", "\n", "is_missing(x)\n", 
#&gt;                 "\n", "maybe_missing(x, default = missing_arg())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object that might be the missing argument.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The object to return if the input is missing,\n", 
#&gt;                   "defaults to ", list("missing_arg()"), ".")), 
#&gt;                 "\n"), "\n", list("\n", "These functions help using the missing argument as a regular R\n", 
#&gt;                 "object.\n", list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " generates a missing argument.\n", list(), 
#&gt;                   " ", list("is_missing()"), " is like ", list(
#&gt;                     list("base::missing()")), " but also supports\n", 
#&gt;                   "testing for missing arguments contained in other objects like\n", 
#&gt;                   "lists.\n", list(), " ", list("maybe_missing()"), 
#&gt;                   " is useful to pass down an input that might be\n", 
#&gt;                   "missing to another function, potentially substituting by a\n", 
#&gt;                   "default value. It avoids triggering an \"argument is missing\" error.\n"), 
#&gt;                 "\n"), "\n", list(list("Other ways to reify the missing argument"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "base::quote(expr = )"), " is the canonical way to create a missing\n", 
#&gt;                   "argument object.\n", list(), " ", list("expr()"), 
#&gt;                   " called without argument creates a missing argument.\n", 
#&gt;                   list(), " ", list("quo()"), " called without argument creates an empty quosure, i.e. a\n", 
#&gt;                   "quosure containing the missing argument object.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Fragility of the missing argument object"), 
#&gt;                 list("\n", "\n", "\n", "The missing argument is an object that triggers an error if and\n", 
#&gt;                   "only if it is the result of evaluating a symbol. No error is\n", 
#&gt;                   "produced when a function call evaluates to the missing argument\n", 
#&gt;                   "object. This means that expressions like ", 
#&gt;                   list("x[[1]] &lt;- missing_arg()"), "\n", "are perfectly safe. Likewise, ", 
#&gt;                   list("x[[1]]"), " is safe even if the result\n", 
#&gt;                   "is the missing object.\n", "\n", "However, as soon as the missing argument is passed down between\n", 
#&gt;                   "functions through an argument, you're at risk of triggering a\n", 
#&gt;                   "missing error. This is because arguments are passed through\n", 
#&gt;                   "symbols. To work around this, ", list("is_missing()"), 
#&gt;                   " and ", list("maybe_missing(x)"), "\n", "use a bit of magic to determine if the input is the missing\n", 
#&gt;                   "argument without triggering a missing error.\n", 
#&gt;                   "\n", list("maybe_missing()"), " is particularly useful for prototyping\n", 
#&gt;                   "meta-programming algorithms in R. The missing argument is a likely\n", 
#&gt;                   "input when computing on the language because it is a standard\n", 
#&gt;                   "object in formals lists. While C functions are always allowed to\n", 
#&gt;                   "return the missing argument and pass it to other C functions, this\n", 
#&gt;                   "is not the case on the R side. If you're implementing your\n", 
#&gt;                   "meta-programming algorithm in R, use ", list(
#&gt;                     "maybe_missing()"), " when an\n", "input might be the missing argument object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " and ", list("is_missing()"), " are stable.\n", 
#&gt;                   list(), " Like the rest of rlang, ", list("maybe_missing()"), 
#&gt;                   " is maturing.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# The missing argument usually arises inside a function when the\n", 
#&gt;                 "# user omits an argument that does not have a default:\n", 
#&gt;                 "fn &lt;- function(x) is_missing(x)\n", "fn()\n", 
#&gt;                 "\n", "# Creating a missing argument can also be useful to generate calls\n", 
#&gt;                 "args &lt;- list(1, missing_arg(), 3, missing_arg())\n", 
#&gt;                 "quo(fn(!!! args))\n", "\n", "# Other ways to create that object include:\n", 
#&gt;                 "quote(expr = )\n", "expr()\n", "\n", "# It is perfectly valid to generate and assign the missing\n", 
#&gt;                 "# argument in a list.\n", "x &lt;- missing_arg()\n", 
#&gt;                 "l &lt;- list(missing_arg())\n", "\n", "# Just don't evaluate a symbol that contains the empty argument.\n", 
#&gt;                 "# Evaluating the object `x` that we created above would trigger an\n", 
#&gt;                 "# error.\n", "# x  # Not run\n", "\n", "# On the other hand accessing a missing argument contained in a\n", 
#&gt;                 "# list does not trigger an error because subsetting is a function\n", 
#&gt;                 "# call:\n", "l[[1]]\n", "is.null(l[[1]])\n", 
#&gt;                 "\n", "# In case you really need to access a symbol that might contain the\n", 
#&gt;                 "# empty argument object, use maybe_missing():\n", 
#&gt;                 "maybe_missing(x)\n", "is.null(maybe_missing(x))\n", 
#&gt;                 "is_missing(maybe_missing(x))\n", "\n", "\n", 
#&gt;                 "# Note that base::missing() only works on symbols and does not\n", 
#&gt;                 "# support complex expressions. For this reason the following lines\n", 
#&gt;                 "# would throw an error:\n", "\n", "#&gt; missing(missing_arg())\n", 
#&gt;                 "#&gt; missing(l[[1]])\n", "\n", "# while is_missing() will work as expected:\n", 
#&gt;                 "is_missing(missing_arg())\n", "is_missing(l[[1]])\n"), 
#&gt;             "\n"), mut_node_car.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("mut_node_car"), "\n", list("mut_node_car"), 
#&gt;             "\n", list("mut_node_cdr"), "\n", list("mut_node_caar"), 
#&gt;             "\n", list("mut_node_cadr"), "\n", list("mut_node_cdar"), 
#&gt;             "\n", list("mut_node_cddr"), "\n", list("mut_node_tag"), 
#&gt;             "\n", list("Mutate node components"), "\n", list(
#&gt;                 "\n", "mut_node_car(x, newcar)\n", "\n", "mut_node_cdr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_caar(x, newcar)\n", "\n", "mut_node_cadr(x, newcar)\n", 
#&gt;                 "\n", "mut_node_cdar(x, newcdr)\n", "\n", "mut_node_cddr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_tag(x, newtag)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newcar"), list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newcdr"), list("The new CAR or CDR for the node. These\n", 
#&gt;                     "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("node_poke_"), "\n", "prefix in rlang 0.2.0. This change follows a new naming convention\n", 
#&gt;                 "where mutation is referred to as \"poking\".\n"), 
#&gt;             "\n", list("internal"), "\n"), names2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("names2"), "\n", list("names2"), "\n", 
#&gt;             list("Get names of a vector"), "\n", list("\n", "names2(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This names getter always returns a character vector, even when an\n", 
#&gt;                 "object does not have a ", list("names"), " attribute. In this case, it returns\n", 
#&gt;                 "a vector of empty names ", list("\"\""), ". It also standardises missing names to\n", 
#&gt;                 list("\"\""), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("names2()"), " is stable.\n")), 
#&gt;             "\n", "\n", list("\n", "names2(letters)\n", "\n", 
#&gt;                 "# It also takes care of standardising missing names:\n", 
#&gt;                 "x &lt;- set_names(1:3, c(\"a\", NA, \"b\"))\n", 
#&gt;                 "names2(x)\n"), "\n"), `new-vector-along-retired.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("new-vector-along-retired"), "\n", list(
#&gt;                 "new-vector-along-retired"), "\n", list("new_logical_along"), 
#&gt;             "\n", list("new_integer_along"), "\n", list("new_double_along"), 
#&gt;             "\n", list("new_character_along"), "\n", list("new_complex_along"), 
#&gt;             "\n", list("new_raw_along"), "\n", list("new_list_along"), 
#&gt;             "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "new_logical_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_integer_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_double_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_character_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_complex_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_raw_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_list_along(x, names = base::names(x))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions are deprecated as of rlang 0.3.0 because they\n", 
#&gt;                 "are longer to type than the equivalent ", list(
#&gt;                   list("rep_along()")), " or\n", list(list("rep_named()")), 
#&gt;                 " calls without added clarity.\n"), "\n", list(
#&gt;                 "internal"), "\n"), `new-vector.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("new-vector"), "\n", list("new-vector"), 
#&gt;             "\n", list("new_logical"), "\n", list("new_integer"), 
#&gt;             "\n", list("new_double"), "\n", list("new_character"), 
#&gt;             "\n", list("new_complex"), "\n", list("new_raw"), 
#&gt;             "\n", list("new_list"), "\n", list("Create vectors matching a given length"), 
#&gt;             "\n", list("\n", "new_logical(n, names = NULL)\n", 
#&gt;                 "\n", "new_integer(n, names = NULL)\n", "\n", 
#&gt;                 "new_double(n, names = NULL)\n", "\n", "new_character(n, names = NULL)\n", 
#&gt;                 "\n", "new_complex(n, names = NULL)\n", "\n", 
#&gt;                 "new_raw(n, names = NULL)\n", "\n", "new_list(n, names = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The vector length.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "These functions construct vectors of a given length, with attributes\n", 
#&gt;                 "specified via dots. Except for ", list("new_list()"), 
#&gt;                 " and ", list("new_raw()"), ", the\n", "empty vectors are filled with typed ", 
#&gt;                 list("missing"), " values. This is in\n", "contrast to the base function ", 
#&gt;                 list(list("base::vector()")), " which creates\n", 
#&gt;                 "zero-filled vectors.\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are likely to be replaced by a vctrs equivalent in\n", 
#&gt;                   "the future. They are in the questioning lifecycle stage.\n")), 
#&gt;             "\n", "\n", list("\n", "new_list(10)\n", "new_logical(10)\n"), 
#&gt;             "\n", list("\n", "rep_along\n"), "\n", list("internal"), 
#&gt;             "\n"), new_call.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_call"), "\n", list("new_call"), "\n", 
#&gt;             list("Create a new call from components"), "\n", 
#&gt;             list("\n", "new_call(car, cdr = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("car"), list("The head of the call. It should be a\n", 
#&gt;                 list("callable"), " object: a symbol, call, or literal\n", 
#&gt;                 "function.")), "\n", "\n", list(list("cdr"), 
#&gt;                 list("The tail of the call, i.e. a ", list("node list"), 
#&gt;                   " of\n", "arguments.")), "\n"), "\n", list(
#&gt;                 "\n", "Create a new call from components\n"), 
#&gt;             "\n", list("internal"), "\n"), new_formula.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("new_formula"), "\n", list("new_formula"), "\n", 
#&gt;             list("Create a formula"), "\n", list("\n", "new_formula(lhs, rhs, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("lhs, rhs"), list("A call, name, or atomic vector.")), 
#&gt;                 "\n", "\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A formula object.\n"), 
#&gt;             "\n", list("\n", "Create a formula\n"), "\n", list(
#&gt;                 "\n", "new_formula(quote(a), quote(b))\n", "new_formula(NULL, quote(b))\n"), 
#&gt;             "\n", list("\n", list(list("new_quosure()")), "\n"), 
#&gt;             "\n"), new_function.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("new_function"), "\n", list("new_function"), 
#&gt;             "\n", list("Create a function"), "\n", list("\n", 
#&gt;                 "new_function(args, body, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("args"), list("A named list or pairlist of default arguments. Note\n", 
#&gt;                 "that if you want arguments that don't have defaults, you'll need\n", 
#&gt;                 "to use the special function ", list(list("pairlist2()")), 
#&gt;                 ". If you need quoted\n", "defaults, use ", list(
#&gt;                   list("exprs()")), ".")), "\n", "\n", list(list(
#&gt;                 "body"), list("A language object representing the code inside the\n", 
#&gt;                 "function. Usually this will be most easily generated with\n", 
#&gt;                 list(list("base::quote()")))), "\n", "\n", list(
#&gt;                 list("env"), list("The parent environment of the function, defaults to the\n", 
#&gt;                   "calling environment of ", list("new_function()"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This constructs a new function given its three components:\n", 
#&gt;                 "list of arguments, body code and parent environment.\n"), 
#&gt;             "\n", list("\n", "f &lt;- function() letters\n", "g &lt;- new_function(NULL, quote(letters))\n", 
#&gt;                 "identical(f, g)\n", "\n", "# Pass a list or pairlist of named arguments to create a function\n", 
#&gt;                 "# with parameters. The name becomes the parameter name and the\n", 
#&gt;                 "# argument the default value for this parameter:\n", 
#&gt;                 "new_function(list(x = 10), quote(x))\n", "new_function(pairlist2(x = 10), quote(x))\n", 
#&gt;                 "\n", "# Use `exprs()` to create quoted defaults. Compare:\n", 
#&gt;                 "new_function(pairlist2(x = 5 + 5), quote(x))\n", 
#&gt;                 "new_function(exprs(x = 5 + 5), quote(x))\n", 
#&gt;                 "\n", "# Pass empty arguments to omit defaults. `list()` doesn't allow\n", 
#&gt;                 "# empty arguments but `pairlist2()` does:\n", 
#&gt;                 "new_function(pairlist2(x = , y = 5 + 5), quote(x + y))\n", 
#&gt;                 "new_function(exprs(x = , y = 5 + 5), quote(x + y))\n"), 
#&gt;             "\n"), new_node.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_node"), "\n", list("new_node"), "\n", 
#&gt;             list("node_car"), "\n", list("node_cdr"), "\n", list(
#&gt;                 "node_caar"), "\n", list("node_cadr"), "\n", 
#&gt;             list("node_cdar"), "\n", list("node_cddr"), "\n", 
#&gt;             list("node_poke_car"), "\n", list("node_poke_cdr"), 
#&gt;             "\n", list("node_poke_caar"), "\n", list("node_poke_cadr"), 
#&gt;             "\n", list("node_poke_cdar"), "\n", list("node_poke_cddr"), 
#&gt;             "\n", list("node_tag"), "\n", list("node_poke_tag"), 
#&gt;             "\n", list("Helpers for pairlist and language nodes"), 
#&gt;             "\n", list("\n", "new_node(car, cdr = NULL)\n", "\n", 
#&gt;                 "node_car(x)\n", "\n", "node_cdr(x)\n", "\n", 
#&gt;                 "node_caar(x)\n", "\n", "node_cadr(x)\n", "\n", 
#&gt;                 "node_cdar(x)\n", "\n", "node_cddr(x)\n", "\n", 
#&gt;                 "node_poke_car(x, newcar)\n", "\n", "node_poke_cdr(x, newcdr)\n", 
#&gt;                 "\n", "node_poke_caar(x, newcar)\n", "\n", "node_poke_cadr(x, newcar)\n", 
#&gt;                 "\n", "node_poke_cdar(x, newcdr)\n", "\n", "node_poke_cddr(x, newcdr)\n", 
#&gt;                 "\n", "node_tag(x)\n", "\n", "node_poke_tag(x, newtag)\n"), 
#&gt;             "\n", list("\n", list(list("car, newcar, cdr, newcdr"), 
#&gt;                 list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                 list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Setters like ", list(
#&gt;                 "node_poke_car()"), " invisibly return ", list(
#&gt;                 "x"), " modified\n", "in place. Getters return the requested node component.\n"), 
#&gt;             "\n", list("\n", list("Important"), ": These functions are for expert R programmers only.\n", 
#&gt;                 "You should only use them if you feel comfortable manipulating low\n", 
#&gt;                 "level R data structures at the C level. We export them at the R level\n", 
#&gt;                 "in order to make it easy to prototype C code. They don't perform\n", 
#&gt;                 "any type checking and can crash R very easily (try to take the CAR\n", 
#&gt;                 "of an integer vector --- save any important objects beforehand!).\n"), 
#&gt;             "\n", list("\n", list(list("duplicate()")), " for creating copy-safe objects and\n", 
#&gt;                 list(list("base::pairlist()")), " for an easier way of creating a linked list of\n", 
#&gt;                 "nodes.\n"), "\n", list("internal"), "\n"), new_quosures.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "new_quosures"), "\n", list("new_quosures"), 
#&gt;             "\n", list("as_quosures"), "\n", list("is_quosures"), 
#&gt;             "\n", list("Create a list of quosures"), "\n", list(
#&gt;                 "\n", "new_quosures(x)\n", "\n", "as_quosures(x, env, named = FALSE)\n", 
#&gt;                 "\n", "is_quosures(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("A list of quosures or objects to coerce to quosures.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The default environment for the new quosures.")), 
#&gt;                 "\n", "\n", list(list("named"), list("Whether to name the list with ", 
#&gt;                   list(list("quos_auto_name()")), ".")), "\n"), 
#&gt;             "\n", list("\n", "This small S3 class provides methods for ", 
#&gt;                 list("["), " and ", list("c()"), " and ensures\n", 
#&gt;                 "the following invariants:\n", list("\n", list(), 
#&gt;                   " The list only contains quosures.\n", list(), 
#&gt;                   " It is always named, possibly with a vector of empty strings.\n"), 
#&gt;                 "\n", "\n", list("new_quosures()"), " takes a list of quosures and adds the ", 
#&gt;                 list("quosures"), "\n", "class and a vector of empty names if needed. ", 
#&gt;                 list("as_quosures()"), " calls\n", list(list(
#&gt;                   "as_quosure()")), " on all elements before creating the ", 
#&gt;                 list("quosures"), "\n", "object.\n"), "\n"), 
#&gt;         new_weakref.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/weakref.R", 
#&gt;             "\n", list("new_weakref"), "\n", list("new_weakref"), 
#&gt;             "\n", list("Create a weak reference"), "\n", list(
#&gt;                 "\n", "new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("key"), list("The key for the weak reference. Must be a reference object -- that\n", 
#&gt;                 "is, an environment or external pointer.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for the weak reference. This can be ", 
#&gt;                   list("NULL"), ", if you\n", "want to use the weak reference like a weak pointer.")), 
#&gt;                 "\n", "\n", list(list("finalizer"), list("A function that is run after the key becomes unreachable.")), 
#&gt;                 "\n", "\n", list(list("on_quit"), list("Should the finalizer be run when R exits?")), 
#&gt;                 "\n"), "\n", list("\n", "A weak reference is a special R object which makes it possible to keep a\n", 
#&gt;                 "reference to an object without preventing garbage collection of that object.\n", 
#&gt;                 "It can also be used to keep data about an object without preventing GC of the\n", 
#&gt;                 "object, similar to WeakMaps in JavaScript.\n", 
#&gt;                 "\n", "Objects in R are considered ", list("reachable"), 
#&gt;                 " if they can be accessed by following\n", "a chain of references, starting from a ", 
#&gt;                 list("root node"), "; root nodes are\n", "specially-designated R objects, and include the global environment and base\n", 
#&gt;                 "environment. As long as the key is reachable, the value will not be garbage\n", 
#&gt;                 "collected. This is true even if the weak reference object becomes\n", 
#&gt;                 "unreachable. The key effectively prevents the weak reference and its value\n", 
#&gt;                 "from being collected, according to the following chain of ownership:\n", 
#&gt;                 list("weakref &lt;- key -&gt; value"), ".\n", "\n", 
#&gt;                 "When the key becomes unreachable, the key and value in the weak reference\n", 
#&gt;                 "object are replaced by ", list("NULL"), ", and the finalizer is scheduled to execute.\n"), 
#&gt;             "\n", list("\n", "e &lt;- env()\n", "\n", "# Create a weak reference to e\n", 
#&gt;                 "w &lt;- new_weakref(e, finalizer = function(e) message(\"finalized\"))\n", 
#&gt;                 "\n", "# Get the key object from the weak reference\n", 
#&gt;                 "identical(wref_key(w), e)\n", "\n", "# When the regular reference (the `e` binding) is removed and a GC occurs,\n", 
#&gt;                 "# the weak reference will not keep the object alive.\n", 
#&gt;                 "rm(e)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "\n", "\n", "# A weak reference with a key and value. The value contains data about the\n", 
#&gt;                 "# key.\n", "k &lt;- env()\n", "v &lt;- list(1, 2, 3)\n", 
#&gt;                 "w &lt;- new_weakref(k, v)\n", "\n", "identical(wref_key(w), k)\n", 
#&gt;                 "identical(wref_value(w), v)\n", "\n", "# When v is removed, the weak ref keeps it alive because k is still reachable.\n", 
#&gt;                 "rm(v)\n", "gc()\n", "identical(wref_value(w), list(1, 2, 3))\n", 
#&gt;                 "\n", "# When k is removed, the weak ref does not keep k or v alive.\n", 
#&gt;                 "rm(k)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "identical(wref_value(w), NULL)\n"), "\n", list(
#&gt;                 "\n", list(list("is_weakref()")), ", ", list(
#&gt;                   list("wref_key()")), " and ", list(list("wref_value()")), 
#&gt;                 ".\n"), "\n", list("experimental"), "\n"), ns_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("ns_env"), "\n", list("ns_env"), "\n", 
#&gt;             list("ns_imports_env"), "\n", list("ns_env_name"), 
#&gt;             "\n", list("Get the namespace of a package"), "\n", 
#&gt;             list("\n", "ns_env(x = caller_env())\n", "\n", "ns_imports_env(x = caller_env())\n", 
#&gt;                 "\n", "ns_env_name(x = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list(list("\n", list(), 
#&gt;                 " For ", list("ns_env()"), ", the name of a package or an environment as a\n", 
#&gt;                 "string.\n", list("\n", list(), " An environment (the current environment by default).\n", 
#&gt;                   list(), " A function.\n"), "\n", "\n", "In the latter two cases, the environment ancestry is searched for\n", 
#&gt;                 "a namespace with ", list(list("base::topenv()")), 
#&gt;                 ". If the environment doesn't\n", "inherit from a namespace, this is an error.\n"))), 
#&gt;                 "\n", "\n", list(list("env"), list("A namespace environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Namespaces are the environment where all the functions of a package\n", 
#&gt;                 "live. The parent environments of namespaces are the ", 
#&gt;                 list("imports"), "\n", "environments, which contain all the functions imported from other\n", 
#&gt;                 "packages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental and may not belong to the rlang\n", 
#&gt;                   "package. Expect API changes.\n")), "\n", "\n", 
#&gt;             list("\n", list(list("pkg_env()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), `op-definition.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-definition"), "\n", list("op-definition"), 
#&gt;             "\n", list("is_definition"), "\n", list("new_definition"), 
#&gt;             "\n", list("is_formulaish"), "\n", list("Definition operator"), 
#&gt;             "\n", list("\n", "is_definition(x)\n", "\n", "new_definition(lhs, rhs, env = caller_env())\n", 
#&gt;                 "\n", "is_formulaish(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("lhs, rhs"), list("Expressions for the LHS and RHS of the definition.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The evaluation environment bundled with the definition.")), 
#&gt;                 "\n"), "\n", list("\n", "The definition operator is typically used in DSL packages like\n", 
#&gt;                 list("ggvis"), " and ", list("data.table"), ". It is also used in the tidyverse as a way\n", 
#&gt;                 "of unquoting names (see ", list("quasiquotation"), 
#&gt;                 ").\n", list("\n", list(), " ", list("is_definition()"), 
#&gt;                   " returns ", list("TRUE"), " for calls to ", 
#&gt;                   list(":="), ".\n", list(), " ", list("is_formulaish()"), 
#&gt;                   " returns ", list("TRUE"), " for both formulas and\n", 
#&gt;                   "colon-equals operators.\n"), "\n"), "\n", 
#&gt;             list("\n", "The recommended way to use it is to capture arguments as\n", 
#&gt;                 "expressions or quosures. You can then give a special function\n", 
#&gt;                 "definition for the ", list(":="), " symbol in an overscope. Note that if you\n", 
#&gt;                 "capture dots with ", list(list("exprs()")), 
#&gt;                 " or ", list(list("quos()")), ", you need to disable\n", 
#&gt;                 "interpretation of ", list(":="), " by setting ", 
#&gt;                 list(".unquote_names"), " to ", list("FALSE"), 
#&gt;                 ".\n", "\n", "From rlang and data.table perspectives, this operator is not meant\n", 
#&gt;                 "to be evaluated directly at top-level which is why the exported\n", 
#&gt;                 "definitions issue an error.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "\n", "# A predicate is provided to distinguish formulas from the\n", 
#&gt;                 "# colon-equals operator:\n", "is_definition(quote(a := b))\n", 
#&gt;                 "is_definition(a ~ b)\n", "\n", "\n", "# is_formulaish() tests for both definitions and formulas:\n", 
#&gt;                 "is_formulaish(a ~ b)\n", "is_formulaish(quote(a := b))\n"), 
#&gt;             "\n", list("internal"), "\n"), `op-get-attr.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-get-attr"), "\n", list("op-get-attr"), "\n", 
#&gt;             list("%@%"), "\n", list("%@%&lt;-"), "\n", list("Infix attribute accessor and setter"), 
#&gt;             "\n", list("\n", "x %@% name\n", "\n", "x %@% name &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Attribute name")), 
#&gt;                 "\n", "\n", list(list("value"), list("New value for attribute ", 
#&gt;                   list("name"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "This operator extracts or sets attributes for regular objects and\n", 
#&gt;                 "S4 fields for S4 objects.\n"), "\n", list("\n", 
#&gt;                 "# Unlike `@`, this operator extracts attributes for any kind of\n", 
#&gt;                 "# objects:\n", "factor(1:3) %@% \"levels\"\n", 
#&gt;                 "mtcars %@% class\n", "\n", "mtcars %@% class &lt;- NULL\n", 
#&gt;                 "mtcars\n", "\n", "# It also works on S4 objects:\n", 
#&gt;                 ".Person &lt;- setClass(\"Person\", slots = c(name = \"character\", species = \"character\"))\n", 
#&gt;                 "fievel &lt;- .Person(name = \"Fievel\", species = \"mouse\")\n", 
#&gt;                 "fievel %@% name\n"), "\n"), `op-na-default.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-na-default"), "\n", list("op-na-default"), 
#&gt;             "\n", list("%|%"), "\n", list("Replace missing values"), 
#&gt;             "\n", list("\n", "x %|% y\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("The original values.")), "\n", 
#&gt;                 "\n", list(list("y"), list("The replacement values. Must be of length 1 or the same length as ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "This infix function is similar to ", 
#&gt;                 list("%||%"), " but is vectorised\n", "and provides a default value for missing elements. It is faster\n", 
#&gt;                 "than using ", list(list("base::ifelse()")), 
#&gt;                 " and does not perform type conversions.\n"), 
#&gt;             "\n", list("\n", "c(\"a\", \"b\", NA, \"c\") %|% \"default\"\n", 
#&gt;                 "c(1L, NA, 3L, NA, NA) %|% (6L:10L)\n"), "\n", 
#&gt;             list("\n", list("op-null-default"), "\n"), "\n"), 
#&gt;         `op-null-default.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/operators.R", 
#&gt;             "\n", list("op-null-default"), "\n", list("op-null-default"), 
#&gt;             "\n", list("%||%"), "\n", list("Default value for ", 
#&gt;                 list("NULL")), "\n", list("\n", "x %||% y\n"), 
#&gt;             "\n", list("\n", list(list("x, y"), list("If ", list(
#&gt;                 "x"), " is NULL, will return ", list("y"), "; otherwise returns ", 
#&gt;                 list("x"), ".")), "\n"), "\n", list("\n", "This infix function makes it easy to replace ", 
#&gt;                 list("NULL"), "s with a default\n", "value. It's inspired by the way that Ruby's or operation (", 
#&gt;                 list("||"), ")\n", "works.\n"), "\n", list("\n", 
#&gt;                 "1 %||% 2\n", "NULL %||% 2\n"), "\n"), overscope_eval_next.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("overscope_eval_next"), "\n", list("overscope_eval_next"), 
#&gt;             "\n", list("Evaluate next quosure in a data mask"), 
#&gt;             "\n", list("\n", "overscope_eval_next(overscope, quo, env = base_env())\n"), 
#&gt;             "\n", list("\n", list(list("overscope"), list("A valid overscope containing bindings for ", 
#&gt;                 list("~"), ",\n", list(".top_env"), " and ", 
#&gt;                 list("_F"), " and whose parents contain overscoped bindings\n", 
#&gt;                 "for tidy evaluation.")), "\n", "\n", list(list(
#&gt;                 "quo"), list("A quosure.")), "\n", "\n", list(
#&gt;                 list("env"), list("The lexical enclosure in case ", 
#&gt;                   list("quo"), " is not a validly\n", "scoped quosure. This is the ", 
#&gt;                   list("base environment"), " by\n", "default.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("overscope_eval_next()"), " is deprecated as of rlang 0.2.0. Please use\n", 
#&gt;                 list("eval_tidy()"), " to which you can now supply an overscope.\n"), 
#&gt;             "\n", list("internal"), "\n"), pairlist2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("pairlist2"), "\n", list("pairlist2"), "\n", 
#&gt;             list("Create pairlists with splicing support"), "\n", 
#&gt;             list("\n", "pairlist2(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Arguments stored in the pairlist. Empty arguments are\n", 
#&gt;                   "preserved.")), "\n"), "\n", list("\n", "This pairlist constructor supports ", 
#&gt;                 list("tidy dots"), " features\n", "like ", list(
#&gt;                   "!!!"), ". Use it to manually create argument lists for calls or\n", 
#&gt;                 "parameter lists for functions.\n"), "\n", list(
#&gt;                 "\n", "# Unlike `exprs()`, `pairlist2()` evaluates its arguments.\n", 
#&gt;                 "new_function(pairlist2(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "new_function(exprs(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "\n", "# It preserves missing arguments, which is useful for creating\n", 
#&gt;                 "# parameters without defaults:\n", "new_function(pairlist2(x = , y = 3 * 6), quote(x * y))\n"), 
#&gt;             "\n"), parse_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parse.R", 
#&gt;             "\n", list("parse_expr"), "\n", list("parse_expr"), 
#&gt;             "\n", list("parse_exprs"), "\n", list("parse_quo"), 
#&gt;             "\n", list("parse_quos"), "\n", list("Parse R code"), 
#&gt;             "\n", list("\n", "parse_expr(x)\n", "\n", "parse_exprs(x)\n", 
#&gt;                 "\n", "parse_quo(x, env)\n", "\n", "parse_quos(x, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("parse_expr()"), 
#&gt;                 " returns an ", list("expression"), ",\n", list(
#&gt;                   "parse_exprs()"), " returns a list of expressions. Note that for the\n", 
#&gt;                 "plural variants the length of the output may be greater than the\n", 
#&gt;                 "length of the input. This would happen is one of the strings\n", 
#&gt;                 "contain several expressions (such as ", list(
#&gt;                   "\"foo; bar\""), ").\n"), "\n", list("\n", 
#&gt;                 "These functions parse and transform text into R expressions. This\n", 
#&gt;                 "is the first step to interpret or evaluate a piece of R code\n", 
#&gt;                 "written by a programmer.\n"), "\n", list("\n", 
#&gt;                 list("parse_expr()"), " returns one expression. If the text contains more\n", 
#&gt;                 "than one expression (separated by semicolons or new lines), an error is\n", 
#&gt;                 "issued. On the other hand ", list("parse_exprs()"), 
#&gt;                 " can handle multiple\n", "expressions. It always returns a list of expressions (compare to\n", 
#&gt;                 list(list("base::parse()")), " which returns a base::expression vector). All\n", 
#&gt;                 "functions also support R connections.\n", "\n", 
#&gt;                 "The versions suffixed with ", list("_quo"), 
#&gt;                 " and ", list("_quos"), " return\n", list("quosures"), 
#&gt;                 " rather than raw expressions.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " ", list("parse_quosure()"), " and ", 
#&gt;                   list("parse_quosures()"), " were soft-deprecated in\n", 
#&gt;                   "rlang 0.2.0 and renamed to ", list("parse_quo()"), 
#&gt;                   " and ", list("parse_quos()"), ". This\n", 
#&gt;                   "is consistent with the rule that abbreviated suffixes indicate\n", 
#&gt;                   "the return type of a function.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# parse_expr() can parse any R expression:\n", 
#&gt;                 "parse_expr(\"mtcars %&gt;% dplyr::mutate(cyl_prime = cyl / sd(cyl))\")\n", 
#&gt;                 "\n", "# A string can contain several expressions separated by ; or \\n\n", 
#&gt;                 "parse_exprs(\"NULL; list()\\n foo(bar)\")\n", 
#&gt;                 "\n", "# You can also parse source files by passing a R connection. Let's\n", 
#&gt;                 "# create a file containing R code:\n", "path &lt;- tempfile(\"my-file.R\")\n", 
#&gt;                 "cat(\"1; 2; mtcars\", file = path)\n", "\n", 
#&gt;                 "# We can now parse it by supplying a connection:\n", 
#&gt;                 "parse_exprs(file(path))\n"), "\n", list("\n", 
#&gt;                 list(list("base::parse()")), "\n"), "\n"), parse_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("parse_quosure"), "\n", list("parse_quosure"), 
#&gt;             "\n", list("parse_quosures"), "\n", list("Parse text into a quosure"), 
#&gt;             "\n", list("\n", "parse_quosure(x, env = caller_env())\n", 
#&gt;                 "\n", "parse_quosures(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("parse_quo()")), "\n", "and ", list(
#&gt;                   list("parse_quos()")), " in rlang 0.2.0. This is for consistency with the\n", 
#&gt;                 "convention that suffixes indicating return types are not\n", 
#&gt;                 "abbreviated.\n"), "\n", list("internal"), "\n"), 
#&gt;         prepend.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("prepend"), "\n", list("prepend"), "\n", 
#&gt;             list("modify"), "\n", list("Prepend a vector"), "\n", 
#&gt;             list("\n", "prepend(x, values, before = 1)\n", "\n", 
#&gt;                 "modify(.x, ...)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("the vector to be modified.")), "\n", 
#&gt;                 "\n", list(list("values"), list("to be included in the modified vector.")), 
#&gt;                 "\n", "\n", list(list("before"), list("a subscript, before which the values are to be appended.")), 
#&gt;                 "\n", "\n", list(list(".x"), list("A vector to modify.")), 
#&gt;                 "\n", "\n", list(list("..."), list("List of elements to merge into ", 
#&gt;                   list(".x"), ". Named elements\n", "already existing in ", 
#&gt;                   list(".x"), " are used as replacements. Elements that\n", 
#&gt;                   "have new or no names are inserted at the end. These dots support\n", 
#&gt;                   list("tidy dots"), " features.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "Vector functions are now out of scope for rlang. They might be\n", 
#&gt;                 "revived in the vctrs or funs packages.\n"), 
#&gt;             "\n", list("internal"), "\n"), prim_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "prim_name"), "\n", list("prim_name"), "\n", 
#&gt;             list("Name of a primitive function"), "\n", list(
#&gt;                 "\n", "prim_name(prim)\n"), "\n", list("\n", 
#&gt;                 list(list("prim"), list("A primitive function such as ", 
#&gt;                   list(list("base::c()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "Name of a primitive function\n"), "\n", 
#&gt;             list("internal"), "\n"), quasiquotation.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("quasiquotation"), "\n", list("quasiquotation"), 
#&gt;             "\n", list("UQ"), "\n", list("UQS"), "\n", list("{{}}"), 
#&gt;             "\n", list("{{"), "\n", list("!!"), "\n", list("!!!"), 
#&gt;             "\n", list(":="), "\n", list("qq_show"), "\n", list(
#&gt;                 "Quasiquotation of an expression"), "\n", list(
#&gt;                 "\n", "qq_show(expr)\n"), "\n", list("\n", list(
#&gt;                 list("expr"), list("An expression to be quasiquoted.")), 
#&gt;                 "\n"), "\n", list("\n", "Quasiquotation is the mechanism that makes it possible to program\n", 
#&gt;                 "flexibly with tidy evaluation grammars like dplyr. It is enabled in\n", 
#&gt;                 "all functions quoting their arguments with ", 
#&gt;                 list("enquo()"), ", ", list("enexpr()"), ",\n", 
#&gt;                 "or the plural variants.\n", "\n", "Quasiquotation is the combination of quoting an expression while\n", 
#&gt;                 "allowing immediate evaluation (unquoting) of part of that\n", 
#&gt;                 "expression. We provide both syntactic operators and functional\n", 
#&gt;                 "forms for unquoting.\n", list("\n", list(), 
#&gt;                   " The ", list("!!"), " operator unquotes its argument. It gets evaluated\n", 
#&gt;                   "immediately in the surrounding context.\n", 
#&gt;                   list(), " The ", list("!!!"), " operator unquotes and splices its argument. The\n", 
#&gt;                   "argument should represent a list or a vector. Each element will\n", 
#&gt;                   "be embedded in the surrounding call, i.e. each element is\n", 
#&gt;                   "inserted as an argument. If the vector is named, the names are\n", 
#&gt;                   "used as argument names.\n", "\n", "If the vector is a classed object (like a factor), it is\n", 
#&gt;                   "converted to a list with ", list(list("base::as.list()")), 
#&gt;                   " to ensure proper\n", "dispatch. If it is an S4 objects, it is converted to a list with\n", 
#&gt;                   list(list("methods::as()")), ".\n", list(), 
#&gt;                   " The ", list("{{ }}"), " operator quotes and unquotes its argument in one\n", 
#&gt;                   "go, a pattern that we call ", list("interpolation"), 
#&gt;                   ". It is an alias for\n", list("!!enquo(arg)"), 
#&gt;                   ".\n", "\n", "Like ", list("enquo()"), ", ", 
#&gt;                   list("{{ }}"), " is used in functions to capture an\n", 
#&gt;                   "argument as a quoted expression. This expression is immediately\n", 
#&gt;                   "unquoted in place.\n"), "\n", "\n", "Use ", 
#&gt;                 list("qq_show()"), " to experiment with quasiquotation or debug the\n", 
#&gt;                 "effect of unquoting operators. ", list("qq_show()"), 
#&gt;                 " quotes its input,\n", "processes unquoted parts, and prints the result with\n", 
#&gt;                 list(list("expr_print()")), ". This expression printer has a clearer output than\n", 
#&gt;                 "the base R printer (see the ", list("documentation topic"), 
#&gt;                 ").\n"), "\n", list(list("Unquoting names"), 
#&gt;                 list("\n", "\n", "\n", "When a function takes multiple named arguments\n", 
#&gt;                   "(e.g. ", list("dplyr::mutate()"), "), it is difficult to supply a variable as\n", 
#&gt;                   "name. Since the LHS of ", list("="), " is quoted, giving the name of a variable\n", 
#&gt;                   "results in the argument having the name of the variable rather than\n", 
#&gt;                   "the name stored in that variable. This problem is right up the\n", 
#&gt;                   "alley for the unquoting operator ", list("!!"), 
#&gt;                   ". If you were able to unquote\n", "the variable when supplying the name, the argument would be named\n", 
#&gt;                   "after the content of that variable.\n", "\n", 
#&gt;                   "Unfortunately R is very strict about the kind of expressions\n", 
#&gt;                   "supported on the LHS of ", list("="), ". This is why we have made the more\n", 
#&gt;                   "flexible ", list(":="), " operator an alias of ", 
#&gt;                   list("="), ". You can use it to supply\n", 
#&gt;                   "names, e.g. ", list("a := b"), " is equivalent to ", 
#&gt;                   list("a = b"), ". Since its syntax is\n", "more flexible you can unquote on the LHS:", 
#&gt;                   list("name &lt;- \"Jane\"\n", "\n", "list2(!!name := 1 + 2)\n", 
#&gt;                     "exprs(!!name := 1 + 2)\n", "quos(!!name := 1 + 2)\n"), 
#&gt;                   "\n", "\n", "Like ", list("="), ", the ", list(
#&gt;                     ":="), " operator expects strings or symbols on its LHS.\n", 
#&gt;                   "\n", "Note that unquoting on the LHS of ", 
#&gt;                   list(":="), " only works in top level\n", "expressions. These are all valid:", 
#&gt;                   list("exprs(!!nm := x)\n", "tibble(!!nm := x)\n", 
#&gt;                     "list2(!!nm := x)\n"), "\n", "\n", "But deep-unquoting names isn't supported:", 
#&gt;                   list("expr(foo(!!nm := x))\n", "exprs(foo(!!nm := x))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Theory"), list(
#&gt;                 "\n", "\n", "\n", "Formally, ", list("quo()"), 
#&gt;                 " and ", list("expr()"), " are quasiquote functions, ", 
#&gt;                 list("!!"), " is\n", "the unquote operator, and ", 
#&gt;                 list("!!!"), " is the unquote-splice operator.\n", 
#&gt;                 "These terms have a rich history in Lisp languages, and live on in\n", 
#&gt;                 "modern languages like\n", list(list("https://docs.julialang.org/en/v1/manual/metaprogramming/"), 
#&gt;                   list("Julia")), "\n", "and\n", list(list("https://docs.racket-lang.org/reference/quasiquote.html"), 
#&gt;                   list("Racket")), ".\n")), "\n", "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " Calling ", list("UQ()"), " and ", 
#&gt;                   list("UQS()"), " with the rlang namespace qualifier is\n", 
#&gt;                   "deprecated as of rlang 0.3.0. Just use the unqualified forms\n", 
#&gt;                   "instead:", list("# Bad\n", "rlang::expr(mean(rlang::UQ(var) * 100))\n", 
#&gt;                     "\n", "# Ok\n", "rlang::expr(mean(UQ(var) * 100))\n", 
#&gt;                     "\n", "# Good\n", "rlang::expr(mean(!!var * 100))\n"), 
#&gt;                   "\n", "\n", "Supporting namespace qualifiers complicates the implementation of\n", 
#&gt;                   "unquotation and is misleading as to the nature of unquoting\n", 
#&gt;                   "operators (which are syntactic operators that operates at\n", 
#&gt;                   "quotation-time rather than function calls at evaluation-time).\n", 
#&gt;                   list(), " ", list("UQ()"), " and ", list("UQS()"), 
#&gt;                   " were soft-deprecated in rlang 0.2.0 in order\n", 
#&gt;                   "to make the syntax of quasiquotation more consistent. The prefix\n", 
#&gt;                   "forms are now ", list("`!!`()"), " and ", 
#&gt;                   list("`!!!`()"), " which is\n", "consistent with other R operators (e.g. ", 
#&gt;                   list("`+`(a, b)"), " is the\n", "prefix form of ", 
#&gt;                   list("a + b"), ").\n", "\n", "Note that the prefix forms are not as relevant as before because\n", 
#&gt;                   list("!!"), " now has the right operator precedence, i.e. the same as\n", 
#&gt;                   "unary ", list("-"), " or ", list("+"), ". It is thus safe to mingle it with other\n", 
#&gt;                   "operators, e.g. ", list("!!a + !!b"), " does the right thing. In addition the\n", 
#&gt;                   "parser now strips one level of parentheses around unquoted\n", 
#&gt;                   "expressions. This way ", list("(!!\"foo\")(...)"), 
#&gt;                   " expands to ", list("foo(...)"), ".\n", "These changes make the prefix forms less useful.\n", 
#&gt;                   "\n", "Finally, the named functional forms ", 
#&gt;                   list("UQ()"), " and ", list("UQS()"), " were\n", 
#&gt;                   "misleading because they suggested that existing knowledge about\n", 
#&gt;                   "functions is applicable to quasiquotation. This was reinforced by\n", 
#&gt;                   "the visible definitions of these functions exported by rlang and\n", 
#&gt;                   "by the tidy eval parser interpreting ", list(
#&gt;                     "rlang::UQ()"), " as ", list("!!"), ". In\n", 
#&gt;                   "reality unquoting is ", list("not"), " a function call, it is a syntactic\n", 
#&gt;                   "operation. The operator form makes it clearer that unquoting is\n", 
#&gt;                   "special.\n"), "\n")), "\n", "\n", list("\n", 
#&gt;                 "# Interpolation with {{  }} is the easiest way to forward\n", 
#&gt;                 "# arguments to tidy eval functions:\n", "if (is_attached(\"package:dplyr\")) {\n", 
#&gt;                 "\n", "# Forward all arguments involving data frame columns by\n", 
#&gt;                 "# interpolating them within other data masked arguments.\n", 
#&gt;                 "# Here we interpolate `arg` in a `summarise()` call:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean({{ arg }}, na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "my_function(mtcars, cyl * 10)\n", 
#&gt;                 "\n", "# The  operator is just a shortcut for `!!enquo()`:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean(!!enquo(arg), na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "\n", 
#&gt;                 "}\n", "\n", "# Quasiquotation functions quote expressions like base::quote()\n", 
#&gt;                 "quote(how_many(this))\n", "expr(how_many(this))\n", 
#&gt;                 "quo(how_many(this))\n", "\n", "# In addition, they support unquoting. Let's store symbols\n", 
#&gt;                 "# (i.e. object names) in variables:\n", "this &lt;- sym(\"apples\")\n", 
#&gt;                 "that &lt;- sym(\"oranges\")\n", "\n", "# With unquotation you can insert the contents of these variables\n", 
#&gt;                 "# inside the quoted expression:\n", "expr(how_many(!!this))\n", 
#&gt;                 "expr(how_many(!!that))\n", "\n", "# You can also insert values:\n", 
#&gt;                 "expr(how_many(!!(1 + 2)))\n", "quo(how_many(!!(1 + 2)))\n", 
#&gt;                 "\n", "\n", "# Note that when you unquote complex objects into an expression,\n", 
#&gt;                 "# the base R printer may be a bit misleading. For instance compare\n", 
#&gt;                 "# the output of `expr()` and `quo()` (which uses a custom printer)\n", 
#&gt;                 "# when we unquote an integer vector:\n", "expr(how_many(!!(1:10)))\n", 
#&gt;                 "quo(how_many(!!(1:10)))\n", "\n", "# This is why it's often useful to use qq_show() to examine the\n", 
#&gt;                 "# result of unquotation operators. It uses the same printer as\n", 
#&gt;                 "# quosures but does not return anything:\n", 
#&gt;                 "qq_show(how_many(!!(1:10)))\n", "\n", "\n", 
#&gt;                 "# Use `!!!` to add multiple arguments to a function. Its argument\n", 
#&gt;                 "# should evaluate to a list or vector:\n", "args &lt;- list(1:3, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!!args))\n", "\n", "# You can combine the two\n", 
#&gt;                 "var &lt;- quote(xyz)\n", "extra_args &lt;- list(trim = 0.9, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!var , !!!extra_args))\n", "\n", "\n", 
#&gt;                 "# The plural versions have support for the `:=` operator.\n", 
#&gt;                 "# Like `=`, `:=` creates named arguments:\n", 
#&gt;                 "quos(mouse1 := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "# The `:=` is mainly useful to unquote names. Unlike `=` it\n", 
#&gt;                 "# supports `!!` on its LHS:\n", "var &lt;- \"unquote me!\"\n", 
#&gt;                 "quos(!!var := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "\n", "# All these features apply to dots captured by enquos():\n", 
#&gt;                 "fn &lt;- function(...) enquos(...)\n", "fn(!!!args, !!var := penny)\n", 
#&gt;                 "\n", "\n", "# Unquoting is especially useful for building an expression by\n", 
#&gt;                 "# expanding around a variable part (the unquoted part):\n", 
#&gt;                 "quo1 &lt;- quo(toupper(foo))\n", "quo1\n", "\n", 
#&gt;                 "quo2 &lt;- quo(paste(!!quo1, bar))\n", "quo2\n", 
#&gt;                 "\n", "quo3 &lt;- quo(list(!!quo2, !!!syms(letters[1:5])))\n", 
#&gt;                 "quo3\n"), "\n"), quo_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("quo_expr"), "\n", list("quo_expr"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_expr(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated, please use ", 
#&gt;                 list(list("quo_squash()")), " instead.\n"), "\n", 
#&gt;             list("internal"), "\n"), quo_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quo.R", "\n", 
#&gt;             list("quo_label"), "\n", list("quo_label"), "\n", 
#&gt;             list("quo_text"), "\n", list("quo_name"), "\n", list(
#&gt;                 "Format quosures for printing or labelling"), 
#&gt;             "\n", list("\n", "quo_label(quo)\n", "\n", "quo_text(quo, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "quo_name(quo)\n"), "\n", list("\n", list(
#&gt;                 list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("Note:"), " You should now use ", 
#&gt;                 list(list("as_label()")), " or ", list(list("as_name()")), 
#&gt;                 " instead\n", "of ", list("quo_name()"), ". See life cycle section below.\n", 
#&gt;                 "\n", "These functions take an arbitrary R object, typically an\n", 
#&gt;                 list("expression"), ", and represent it as a string.\n", 
#&gt;                 list("\n", list(), " ", list("quo_name()"), " returns an abbreviated representation of the object\n", 
#&gt;                   "as a single line string. It is suitable for default names.\n", 
#&gt;                   list(), " ", list("quo_text()"), " returns a multiline string. For instance block\n", 
#&gt;                   "expressions like ", list("{ foo; bar }"), 
#&gt;                   " are represented on 4 lines (one\n", "for each symbol, and the curly braces on their own lines).\n"), 
#&gt;                 "\n", "\n", "These deparsers are only suitable for creating default names or\n", 
#&gt;                 "printing output at the console. The behaviour of your functions\n", 
#&gt;                 "should not depend on deparsed objects. If you are looking for a way\n", 
#&gt;                 "of transforming symbols to strings, use ", list(
#&gt;                   list("as_string()")), " instead of\n", list(
#&gt;                   "quo_name()"), ". Unlike deparsing, the transformation between symbols\n", 
#&gt;                 "and strings is non-lossy and well defined.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are in the questioning life cycle stage.\n", 
#&gt;                 list("\n", list(), " ", list(list("as_label()")), 
#&gt;                   " and ", list(list("as_name()")), " should be used instead of\n", 
#&gt;                   list("quo_name()"), ". ", list("as_label()"), 
#&gt;                   " transforms any R object to a string\n", "but should only be used to create a default name. Labelisation is\n", 
#&gt;                   "not a well defined operation and no assumption should be made\n", 
#&gt;                   "about the label. On the other hand, ", list(
#&gt;                     "as_name()"), " only works with\n", "(possibly quosured) symbols, but is a well defined and\n", 
#&gt;                   "deterministic operation.\n", list(), " We don't have a good replacement for ", 
#&gt;                   list("quo_text()"), " yet. See\n", list("https://github.com/r-lib/rlang/issues/636"), 
#&gt;                   " to follow discussions\n", "about a new deparsing API.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(foo(!! quo(bar)))\n", "quo\n", "\n", 
#&gt;                 "# quo_squash() unwraps all quosures and returns a raw expression:\n", 
#&gt;                 "quo_squash(quo)\n", "\n", "# This is used by quo_text() and quo_label():\n", 
#&gt;                 "quo_text(quo)\n", "\n", "# Compare to the unwrapped expression:\n", 
#&gt;                 "expr_text(quo)\n", "\n", "# quo_name() is helpful when you need really short labels:\n", 
#&gt;                 "quo_name(quo(sym))\n", "quo_name(quo(!! sym))\n"), 
#&gt;             "\n", list("\n", list(list("expr_label()")), ", ", 
#&gt;                 list(list("f_label()")), "\n"), "\n"), quo_squash.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quo_squash"), "\n", list("quo_squash"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_squash(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("quo_squash()"), " flattens all nested quosures within an expression.\n", 
#&gt;                 "For example it transforms ", list("^foo(^bar(), ^baz)"), 
#&gt;                 " to the bare\n", "expression ", list("foo(bar(), baz)"), 
#&gt;                 ".\n", "\n", "This operation is safe if the squashed quosure is used for\n", 
#&gt;                 "labelling or printing (see ", list(list("quo_label()")), 
#&gt;                 " or ", list(list("quo_name()")), "). However\n", 
#&gt;                 "if the squashed quosure is evaluated, all expressions of the\n", 
#&gt;                 "flattened quosures are resolved in a single environment. This is a\n", 
#&gt;                 "source of bugs so it is good practice to set ", 
#&gt;                 list("warn"), " to ", list("TRUE"), " to\n", 
#&gt;                 "let the user know about the lossy squashing.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "This function replaces ", list("quo_expr()"), 
#&gt;                 " which was deprecated in\n", "rlang 0.2.0. ", 
#&gt;                 list("quo_expr()"), " was a misnomer because it implied that it\n", 
#&gt;                 "was a mere expression acccessor for quosures whereas it was really\n", 
#&gt;                 "a lossy operation that squashed all nested quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(wrapper(!!quo(wrappee)))\n", "quo\n", 
#&gt;                 "\n", "# quo_squash() flattens all the quosures and returns a simple expression:\n", 
#&gt;                 "quo_squash(quo)\n"), "\n"), quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quosure"), "\n", list("quosure"), "\n", list(
#&gt;                 "is_quosure"), "\n", list("quo_is_missing"), 
#&gt;             "\n", list("quo_is_symbol"), "\n", list("quo_is_call"), 
#&gt;             "\n", list("quo_is_symbolic"), "\n", list("quo_is_null"), 
#&gt;             "\n", list("quo_get_expr"), "\n", list("quo_get_env"), 
#&gt;             "\n", list("quo_set_expr"), "\n", list("quo_set_env"), 
#&gt;             "\n", list("Quosure getters, setters and testers"), 
#&gt;             "\n", list("\n", "is_quosure(x)\n", "\n", "quo_is_missing(quo)\n", 
#&gt;                 "\n", "quo_is_symbol(quo, name = NULL)\n", "\n", 
#&gt;                 "quo_is_call(quo, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_symbolic(quo)\n", "\n", "quo_is_null(quo)\n", 
#&gt;                 "\n", "quo_get_expr(quo)\n", "\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo_set_expr(quo, expr)\n", "\n", "quo_set_env(quo, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("The name of the symbol or function call. If ", 
#&gt;                   list("NULL"), " the\n", "name is not tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("expr"), list(
#&gt;                   "A new expression for the quosure.")), "\n", 
#&gt;                 "\n", list(list("env"), list("A new environment for the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure is a type of ", 
#&gt;                 list("quoted expression"), " that includes\n", 
#&gt;                 "a reference to the context where it was created. A quosure is thus\n", 
#&gt;                 "guaranteed to evaluate in its original environment and can refer to\n", 
#&gt;                 "local objects.\n", "\n", "You can access the quosure components (its expression and its\n", 
#&gt;                 "environment) with:\n", list("\n", list(), " ", 
#&gt;                   list(list("get_expr()")), " and ", list(list(
#&gt;                     "get_env()")), ". These getters also support other\n", 
#&gt;                   "kinds of objects such as formulas.\n", list(), 
#&gt;                   " ", list("quo_get_expr()"), " and ", list(
#&gt;                     "quo_get_env()"), ". These getters only work\n", 
#&gt;                   "with quosures and throw an error with other types of input.\n"), 
#&gt;                 "\n", "\n", "Test if an object is a quosure with ", 
#&gt;                 list("is_quosure()"), ". If you know an\n", "object is a quosure, use the ", 
#&gt;                 list("quo_"), " prefixed predicates to check\n", 
#&gt;                 "its contents, ", list("quo_is_missing()"), ", ", 
#&gt;                 list("quo_is_symbol()"), ", etc.\n"), "\n", list(
#&gt;                 list("Quosured constants"), list("\n", "\n", 
#&gt;                   "\n", "A quosure usually does not carry environments for ", 
#&gt;                   list("constant objects"), " like strings or numbers. ", 
#&gt;                   list(list("quo()")), " and\n", list(list("enquo()")), 
#&gt;                   " only capture an environment for ", list("symbolic expressions"), 
#&gt;                   ". For instance, all of these return the\n", 
#&gt;                   list("empty environment"), ":", list("quo_get_env(quo(\"constant\"))\n", 
#&gt;                     "quo_get_env(quo(100))\n", "quo_get_env(quo(NA))\n"), 
#&gt;                   "\n", "\n", "On the other hand, quosures capture the environment of symbolic\n", 
#&gt;                   "expressions, i.e. expressions whose meaning depends on the\n", 
#&gt;                   "environment in which they are evaluated and what objects are\n", 
#&gt;                   "defined there:", list("quo_get_env(quo(some_object))\n", 
#&gt;                     "quo_get_env(quo(some_function()))\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Empty quosures"), list("\n", 
#&gt;                 "\n", "\n", "When missing arguments are captured as quosures, either through\n", 
#&gt;                 list(list("enquo()")), " or ", list(list("quos()")), 
#&gt;                 ", they are returned as an empty quosure. These\n", 
#&gt;                 "quosures contain the ", list("missing argument"), 
#&gt;                 " and typically\n", "have the ", list("empty environment"), 
#&gt;                 " as enclosure.\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "is_quosure()"), " is stable.\n", list(), " ", 
#&gt;                   list("quo_get_expr()"), " and ", list("quo_get_env()"), 
#&gt;                   " are stable.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "quo &lt;- quo(my_quosure)\n", "quo\n", "\n", 
#&gt;                 "\n", "# Access and set the components of a quosure:\n", 
#&gt;                 "quo_get_expr(quo)\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo &lt;- quo_set_expr(quo, quote(baz))\n", 
#&gt;                 "quo &lt;- quo_set_env(quo, empty_env())\n", "quo\n", 
#&gt;                 "\n", "# Test wether an object is a quosure:\n", 
#&gt;                 "is_quosure(quo)\n", "\n", "# If it is a quosure, you can use the specialised type predicates\n", 
#&gt;                 "# to check what is inside it:\n", "quo_is_symbol(quo)\n", 
#&gt;                 "quo_is_call(quo)\n", "quo_is_null(quo)\n", "\n", 
#&gt;                 "# quo_is_missing() checks for a special kind of quosure, the one\n", 
#&gt;                 "# that contains the missing argument:\n", "quo()\n", 
#&gt;                 "quo_is_missing(quo())\n", "\n", "fn &lt;- function(arg) enquo(arg)\n", 
#&gt;                 "fn()\n", "quo_is_missing(fn())\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), " for creating quosures by quotation; ", 
#&gt;                 list(list("as_quosure()")), "\n", "and ", list(
#&gt;                   list("new_quosure()")), " for constructing quosures manually.\n"), 
#&gt;             "\n"), quotation.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quotation.R", 
#&gt;             "\n", list("quotation"), "\n", list("quotation"), 
#&gt;             "\n", list("expr"), "\n", list("enexpr"), "\n", list(
#&gt;                 "exprs"), "\n", list("enexprs"), "\n", list("ensym"), 
#&gt;             "\n", list("ensyms"), "\n", list("quo"), "\n", list(
#&gt;                 "enquo"), "\n", list("quos"), "\n", list("enquos"), 
#&gt;             "\n", list("Quotation"), "\n", list("\n", "expr(expr)\n", 
#&gt;                 "\n", "enexpr(arg)\n", "\n", "exprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE)\n", "\n", 
#&gt;                 "enexprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "ensym(arg)\n", "\n", "ensyms(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "quo(expr)\n", "\n", "enquo(arg)\n", "\n", "quos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .unquote_names = TRUE)\n", "\n", "enquos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An expression.")), 
#&gt;                 "\n", "\n", list(list("arg"), list("A symbol representing an argument. The expression\n", 
#&gt;                   "supplied to that argument will be captured instead of being\n", 
#&gt;                   "evaluated.")), "\n", "\n", list(list("..."), 
#&gt;                   list("For ", list("enexprs()"), ", ", list(
#&gt;                     "ensyms()"), " and ", list("enquos()"), ", names of\n", 
#&gt;                     "arguments to capture without evaluation (including ", 
#&gt;                     list("..."), "). For\n", list("exprs()"), 
#&gt;                     " and ", list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                     "(including expressions contained in ", list(
#&gt;                       "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n", "\n", list(list(".unquote_names"), 
#&gt;                   list("Whether to treat ", list(":="), " as ", 
#&gt;                     list("="), ". Unlike ", list("="), ", the\n", 
#&gt;                     list(":="), " syntax supports ", list("!!"), 
#&gt;                     " unquoting on the LHS.")), "\n", "\n", list(
#&gt;                   list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                     "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                     list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                     " to only keep the first occurrences, to ", 
#&gt;                     list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                     list("\"error\""), " to raise an informative\n", 
#&gt;                     "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "Quotation is a mechanism by which an expression supplied as\n", 
#&gt;                 "argument is captured by a function. Instead of seeing the value of\n", 
#&gt;                 "the argument, the function sees the recipe (the R code) to make\n", 
#&gt;                 "that value. This is possible because R ", list(
#&gt;                   "expressions"), " are\n", "representable as regular objects in R:\n", 
#&gt;                 list("\n", list(), " Calls represent the action of calling a function to\n", 
#&gt;                   "compute a new value. Evaluating a call causes that value to be\n", 
#&gt;                   "computed. Calls typically involve symbols to reference R objects.\n", 
#&gt;                   list(), " Symbols represent the name that is given to an object in a\n", 
#&gt;                   "particular context (an ", list("environment"), 
#&gt;                   ").\n"), "\n", "\n", "We call objects containing calls and symbols ", 
#&gt;                 list("expressions"), ".\n", "There are two ways to create R expressions. First you can ", 
#&gt;                 list("build"), "\n", "calls and symbols from parts and pieces (see ", 
#&gt;                 list(list("sym()")), ", ", list(list("syms()")), 
#&gt;                 " and\n", list(list("call2()")), "). The other way is by ", 
#&gt;                 list("quotation"), " or ", list("quasiquotation"), 
#&gt;                 ",\n", "i.e. by intercepting an expression instead of evaluating it.\n"), 
#&gt;             "\n", list(list("User expressions versus your expressions"), 
#&gt;                 list("\n", "\n", "\n", "There are two points of view when it comes to capturing an\n", 
#&gt;                   "expression:\n", list("\n", list(), " You can capture the expressions supplied by ", 
#&gt;                     list("the user"), " of your\n", "function. This is the purpose of ", 
#&gt;                     list("ensym()"), ", ", list("enexpr()"), 
#&gt;                     " and\n", list("enquo()"), " and their plural variants. These functions take an\n", 
#&gt;                     "argument name and capture the expression that was supplied to\n", 
#&gt;                     "that argument.\n", list(), " You can capture the expressions that ", 
#&gt;                     list("you"), " supply. To this end\n", "use ", 
#&gt;                     list("expr()"), " and ", list("quo()"), " and their plural variants ", 
#&gt;                     list("exprs()"), " and\n", list("quos()"), 
#&gt;                     ".\n"), "\n")), "\n", "\n", list(list("Capture raw expressions"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "enexpr()"), " and ", list("expr()"), " capture a single raw expression.\n", 
#&gt;                   list(), " ", list("enexprs()"), " and ", list(
#&gt;                     "exprs()"), " capture a list of raw expressions\n", 
#&gt;                   "including expressions contained in ", list(
#&gt;                     "..."), ".\n", list(), " ", list("ensym()"), 
#&gt;                   " and ", list("ensyms()"), " are variants of ", 
#&gt;                   list("enexpr()"), " and\n", list("enexprs()"), 
#&gt;                   " that check the captured expression is either a string\n", 
#&gt;                   "(which they convert to symbol) or a symbol. If anything else\n", 
#&gt;                   "is supplied they throw an error.\n"), "\n", 
#&gt;                   "\n", "In terms of base functions, ", list(
#&gt;                     "enexpr(arg)"), " corresponds to\n", list(
#&gt;                     "base::substitute(arg)"), " (though that function also features complex\n", 
#&gt;                   "substitution semantics) and ", list("expr()"), 
#&gt;                   " is like ", list(list("quote()")), " (and\n", 
#&gt;                   list(list("bquote()")), " if we consider unquotation syntax). The plural variant\n", 
#&gt;                   list("exprs()"), " is equivalent to ", list(
#&gt;                     list("base::alist()")), ". Finally there is no\n", 
#&gt;                   "function in base R that is equivalent to ", 
#&gt;                   list("enexprs()"), " but you can\n", "reproduce its behaviour with ", 
#&gt;                   list("eval(substitute(alist(...)))"), ".\n")), 
#&gt;             "\n", "\n", list(list("Capture expressions in quosures"), 
#&gt;                 list("\n", "\n", "\n", list("quo()"), " and ", 
#&gt;                   list("enquo()"), " are similar to their ", 
#&gt;                   list("expr"), " counterparts but\n", "capture both the expression and its environment in an object called\n", 
#&gt;                   "a quosure. This wrapper contains a reference to the original\n", 
#&gt;                   "environment in which that expression was captured. Keeping track of\n", 
#&gt;                   "the environments of expressions is important because this is where\n", 
#&gt;                   "functions and objects mentioned in the expression are defined.\n", 
#&gt;                   "\n", "Quosures are objects that can be evaluated with ", 
#&gt;                   list(list("eval_tidy()")), " just\n", "like symbols or function calls. Since they always evaluate in their\n", 
#&gt;                   "original environment, quosures can be seen as vehicles that allow\n", 
#&gt;                   "expressions to travel from function to function but that beam back\n", 
#&gt;                   "instantly to their original environment upon evaluation.\n", 
#&gt;                   "\n", "See the ", list("quosure"), " help topic about tools to work with quosures.\n")), 
#&gt;             "\n", "\n", list(list("Quasiquotation"), list("\n", 
#&gt;                 "\n", "\n", "All quotation functions in rlang have support for ", 
#&gt;                 list("unquoting operators"), ". The combination of quotation and\n", 
#&gt;                 "unquotation is called ", list("quasiquotation"), 
#&gt;                 ".\n", "\n", "Unquotation provides a way to refer to variables during quotation.\n", 
#&gt;                 "Variables are problematic when quoting because a captured\n", 
#&gt;                 "expression is essentially a constant, just like a string is a\n", 
#&gt;                 "constant. For instance in all the following cases ", 
#&gt;                 list("apple"), " is a\n", "constant: ", list(
#&gt;                   "~apple"), ", ", list("\"apple\""), " and ", 
#&gt;                 list("expr(apple)"), ". Unquoting allows\n", 
#&gt;                 "you to introduce a part of variability within a captured\n", 
#&gt;                 "expression.\n", list("\n", list(), " In the case of ", 
#&gt;                   list("enexpr()"), " and ", list("enquo()"), 
#&gt;                   ", unquoting provides an\n", "escape hatch to the users of your function that allows them to\n", 
#&gt;                   "manipulate the expression that you capture.\n", 
#&gt;                   list(), " In the case of ", list("expr()"), 
#&gt;                   " and ", list("quo()"), ", quasiquotation lets you\n", 
#&gt;                   "build a complex expressions where some parts are constant (the\n", 
#&gt;                   "parts that are captured) and some parts are variable (the parts\n", 
#&gt;                   "that are unquoted).\n"), "\n", "\n", "See the ", 
#&gt;                 list("quasiquotation"), " help topic for more about this as well as\n", 
#&gt;                 list(list("https://adv-r.hadley.nz/quasiquotation.html"), 
#&gt;                   list("the chapter in Advanced R")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# expr() and exprs() capture expressions that you supply:\n", 
#&gt;                 "expr(symbol)\n", "exprs(several, such, symbols)\n", 
#&gt;                 "\n", "# enexpr() and enexprs() capture expressions that your user supplied:\n", 
#&gt;                 "expr_inputs &lt;- function(arg, ...) {\n", "  user_exprs &lt;- enexprs(arg, ...)\n", 
#&gt;                 "  user_exprs\n", "}\n", "expr_inputs(hello)\n", 
#&gt;                 "expr_inputs(hello, bonjour, ciao)\n", "\n", 
#&gt;                 "# ensym() and ensyms() provide additional type checking to ensure\n", 
#&gt;                 "# the user calling your function has supplied bare object names:\n", 
#&gt;                 "sym_inputs &lt;- function(...) {\n", "  user_symbols &lt;- ensyms(...)\n", 
#&gt;                 "  user_symbols\n", "}\n", "sym_inputs(hello, \"bonjour\")\n", 
#&gt;                 "## sym_inputs(say(hello))  # Error: Must supply symbols or strings\n", 
#&gt;                 "expr_inputs(say(hello))\n", "\n", "\n", "# All these quoting functions have quasiquotation support. This\n", 
#&gt;                 "# means that you can unquote (evaluate and inline) part of the\n", 
#&gt;                 "# captured expression:\n", "what &lt;- sym(\"bonjour\")\n", 
#&gt;                 "expr(say(what))\n", "expr(say(!!what))\n", "\n", 
#&gt;                 "# This also applies to expressions supplied by the user. This is\n", 
#&gt;                 "# like an escape hatch that allows control over the captured\n", 
#&gt;                 "# expression:\n", "expr_inputs(say(!!what), !!what)\n", 
#&gt;                 "\n", "\n", "# Finally, you can capture expressions as quosures. A quosure is an\n", 
#&gt;                 "# object that contains both the expression and its environment:\n", 
#&gt;                 "quo &lt;- quo(letters)\n", "quo\n", "\n", "get_expr(quo)\n", 
#&gt;                 "get_env(quo)\n", "\n", "# Quosures can be evaluated with eval_tidy():\n", 
#&gt;                 "eval_tidy(quo)\n", "\n", "# They have the nice property that you can pass them around from\n", 
#&gt;                 "# context to context (that is, from function to function) and they\n", 
#&gt;                 "# still evaluate in their original environment:\n", 
#&gt;                 "multiply_expr_by_10 &lt;- function(expr) {\n", 
#&gt;                 "  # We capture the user expression and its environment:\n", 
#&gt;                 "  expr &lt;- enquo(expr)\n", "\n", "  # Then create an object that only exists in this function:\n", 
#&gt;                 "  local_ten &lt;- 10\n", "\n", "  # Now let's create a multiplication expression that (a) inlines\n", 
#&gt;                 "  # the user expression as LHS (still wrapped in its quosure) and\n", 
#&gt;                 "  # (b) refers to the local object in the RHS:\n", 
#&gt;                 "  quo(!!expr * local_ten)\n", "}\n", "quo &lt;- multiply_expr_by_10(2 + 3)\n", 
#&gt;                 "\n", "# The local parts of the quosure are printed in colour if your\n", 
#&gt;                 "# terminal is capable of displaying colours:\n", 
#&gt;                 "quo\n", "\n", "# All the quosures in the expression evaluate in their original\n", 
#&gt;                 "# context. The local objects are looked up properly and we get the\n", 
#&gt;                 "# expected result:\n", "eval_tidy(quo)\n"), 
#&gt;             "\n"), rep_along.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("rep_along"), "\n", list("rep_along"), 
#&gt;             "\n", list("rep_named"), "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "rep_along(along, x)\n", "\n", "rep_named(names, x)\n"), 
#&gt;             "\n", list("\n", list(list("along"), list("Vector whose length determine how many times ", 
#&gt;                 list("x"), "\n", "is repeated.")), "\n", "\n", 
#&gt;                 list(list("x"), list("Values to repeat.")), "\n", 
#&gt;                 "\n", list(list("names"), list("Names for the new vector. The length of ", 
#&gt;                   list("names"), "\n", "determines how many times ", 
#&gt;                   list("x"), " is repeated.")), "\n"), "\n", 
#&gt;             list("\n", "These functions take the idea of ", list(
#&gt;                 list("seq_along()")), " and apply it to\n", "repeating values.\n"), 
#&gt;             "\n", list("\n", "x &lt;- 0:5\n", "rep_along(x, 1:2)\n", 
#&gt;                 "rep_along(x, 1)\n", "\n", "# Create fresh vectors by repeating missing values:\n", 
#&gt;                 "rep_along(x, na_int)\n", "rep_along(x, na_chr)\n", 
#&gt;                 "\n", "# rep_named() repeats a value along a names vectors\n", 
#&gt;                 "rep_named(c(\"foo\", \"bar\"), list(letters))\n"), 
#&gt;             "\n", list("\n", "new-vector\n"), "\n"), restarting.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("restarting"), "\n", list("restarting"), 
#&gt;             "\n", list("Create a restarting handler"), "\n", 
#&gt;             list("\n", "restarting(.restart, ..., .fields = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Additional arguments passed on the restart\n", 
#&gt;                   "function. These arguments are evaluated only once and\n", 
#&gt;                   "immediately, when creating the restarting handler. Furthermore,\n", 
#&gt;                   "they support ", list("tidy dots"), " features.")), 
#&gt;                 "\n", "\n", list(list(".fields"), list("A character vector specifying the fields of the\n", 
#&gt;                   "condition that should be passed as arguments to the restart. If\n", 
#&gt;                   "named, the names (except empty names ", list(
#&gt;                     "\"\""), ") are used as\n", "argument names for calling the restart function. Otherwise the\n", 
#&gt;                   "the fields themselves are used as argument names.")), 
#&gt;                 "\n"), "\n", list("\n", "This constructor automates the common task of creating an\n", 
#&gt;                 list(list("calling()")), " handler that invokes a restart.\n"), 
#&gt;             "\n", list("\n", "Jumping to a restart point from a calling handler has two\n", 
#&gt;                 "effects. First, the control flow jumps to wherever the restart was\n", 
#&gt;                 "established, and the restart function is called (with ", 
#&gt;                 list("..."), ", or\n", list(".fields"), " as arguments). Execution resumes from the\n", 
#&gt;                 list(list("with_restarts()")), " call. Secondly, the transfer of the control flow\n", 
#&gt;                 "out of the function that signalled the condition means that the\n", 
#&gt;                 "handler has dealt with the condition. Thus the condition will not\n", 
#&gt;                 "be passed on to other potential handlers established on the stack.\n"), 
#&gt;             "\n", list("\n", "# This is a restart that takes a data frame and names as arguments\n", 
#&gt;                 "rst_bar &lt;- function(df, nms) {\n", "  stats::setNames(df, nms)\n", 
#&gt;                 "}\n", "\n", "# This restart is simpler and does not take arguments\n", 
#&gt;                 "rst_baz &lt;- function() \"baz\"\n", "\n", "# Signalling a condition parameterised with a data frame\n", 
#&gt;                 "fn &lt;- function() {\n", "  with_restarts(signal(\"A foobar condition occurred\", \"foo\", foo_field = mtcars),\n", 
#&gt;                 "    rst_bar = rst_bar,\n", "    rst_baz = rst_baz\n", 
#&gt;                 "  )\n", "}\n", "\n", "# Creating a restarting handler that passes arguments `nms` and\n", 
#&gt;                 "# `df`, the latter taken from a data field of the condition object\n", 
#&gt;                 "restart_bar &lt;- restarting(\"rst_bar\",\n", "  nms = LETTERS[1:11], .fields = c(df = \"foo_field\")\n", 
#&gt;                 ")\n", "\n", "# The restarting handlers jumps to `rst_bar` when `foo` is signalled:\n", 
#&gt;                 "with_handlers(fn(), foo = restart_bar)\n", "\n", 
#&gt;                 "# The restarting() constructor is especially nice to use with\n", 
#&gt;                 "# restarts that do not need arguments:\n", "with_handlers(fn(), foo = restarting(\"rst_baz\"))\n"), 
#&gt;             "\n", list("\n", list(list("calling()")), " and ", 
#&gt;                 list(list("exiting()")), ".\n"), "\n", list("internal"), 
#&gt;             "\n"), return_from.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("return_from"), "\n", list("return_from"), 
#&gt;             "\n", list("return_to"), "\n", list("Jump to or from a frame"), 
#&gt;             "\n", list("\n", "return_from(frame, value = NULL)\n", 
#&gt;                 "\n", "return_to(frame, value = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("frame"), list("An environment, a frame object, or any object with an\n", 
#&gt;                 list(list("get_env()")), " method. The environment should be an evaluation\n", 
#&gt;                 "environment currently on the stack.")), "\n", 
#&gt;                 "\n", list(list("value"), list("The return value.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "While ", list(list("base::return()")), 
#&gt;                 " can only return from the current local\n", 
#&gt;                 "frame, these two functions will return from any frame on the\n", 
#&gt;                 "current evaluation stack, between the global and the currently\n", 
#&gt;                 "active context. They provide a way of performing arbitrary\n", 
#&gt;                 "non-local jumps out of the function currently under evaluation.\n"), 
#&gt;             "\n", list("\n", list("return_from()"), " will jump out of ", 
#&gt;                 list("frame"), ". ", list("return_to()"), " is a bit\n", 
#&gt;                 "trickier. It will jump out of the frame located just before ", 
#&gt;                 list("frame"), "\n", "in the evaluation stack, so that control flow ends up in ", 
#&gt;                 list("frame"), ",\n", "at the location where the previous frame was called from.\n", 
#&gt;                 "\n", "These functions should only be used rarely. These sort of non-local\n", 
#&gt;                 "gotos can be hard to reason about in casual code, though they can\n", 
#&gt;                 "sometimes be useful. Also, consider to use the condition system to\n", 
#&gt;                 "perform non-local jumps.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "The support for ", 
#&gt;                 list("frame"), " object is soft-deprecated.  Please pass\n", 
#&gt;                 "simple environments to ", list("return_from()"), 
#&gt;                 " and ", list("return_to()"), ".\n", "\n", "These functions are in the questioning lifecycle because we are\n", 
#&gt;                 "considering simpler alternatives.\n")), "\n", 
#&gt;             "\n", list("\n", "# Passing fn() evaluation frame to g():\n", 
#&gt;                 "fn &lt;- function() {\n", "  val &lt;- g(current_env())\n", 
#&gt;                 "  cat(\"g returned:\", val, \"\\n\")\n", "  \"normal return\"\n", 
#&gt;                 "}\n", "g &lt;- function(env) h(env)\n", "\n", "# Here we return from fn() with a new return value:\n", 
#&gt;                 "h &lt;- function(env) return_from(env, \"early return\")\n", 
#&gt;                 "fn()\n", "\n", "# Here we return to fn(). The call stack unwinds until the last frame\n", 
#&gt;                 "# called by fn(), which is g() in that case.\n", 
#&gt;                 "h &lt;- function(env) return_to(env, \"early return\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), rlang_backtrace_on_error.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-abort.R", "\n", 
#&gt;             list("rlang_backtrace_on_error"), "\n", list("rlang_backtrace_on_error"), 
#&gt;             "\n", list("add_backtrace"), "\n", list("Display backtrace on error"), 
#&gt;             "\n", list("\n", "Errors thrown with ", list(list(
#&gt;                 "abort()")), " automatically save a backtrace that\n", 
#&gt;                 "can be inspected by calling ", list(list("last_error()")), 
#&gt;                 ". Optionally, you can\n", "also display the backtrace alongside the error message by setting\n", 
#&gt;                 "the option ", list("rlang_backtrace_on_error"), 
#&gt;                 " to one of the following\n", "values:\n", list(
#&gt;                   "\n", list(), " ", list("\"reminder\""), ": Display a reminder that the backtrace can be\n", 
#&gt;                   "inspected by calling ", list(list("rlang::last_error()")), 
#&gt;                   ".\n", list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                   list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                   list(), " ", list("\"full\""), ": Display the full backtrace tree.\n"), 
#&gt;                 "\n"), "\n", list(list("Promote base errors to rlang errors"), 
#&gt;                 list("\n", "\n", "\n", "Call ", list("options(error = rlang::enframe)"), 
#&gt;                   " to instrument base\n", "errors with rlang features. This handler does two things:\n", 
#&gt;                   list("\n", list(), " It saves the base error as an rlang object. This allows you to\n", 
#&gt;                     "call ", list(list("last_error()")), " to print the backtrace or inspect its data.\n", 
#&gt;                     list(), " It prints the backtrace for the current error according to the\n", 
#&gt;                     list(list("rlang_backtrace_on_error")), " option.\n"), 
#&gt;                   "\n")), "\n", "\n", list("\n", "# Display a simplified backtrace on error for both base and rlang\n", 
#&gt;                 "# errors:\n", "\n", "# options(\n", "#   rlang_backtrace_on_error = \"branch\",\n", 
#&gt;                 "#   error = rlang::enframe\n", "# )\n", "# stop(\"foo\")\n"), 
#&gt;             "\n"), rst_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_abort"), "\n", list("rst_abort"), 
#&gt;             "\n", list("Jump to the abort restart"), "\n", list(
#&gt;                 "\n", "rst_abort()\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"questioning\")"), "\n", 
#&gt;                 "\n", "The abort restart is the only restart that is established at top\n", 
#&gt;                 "level. It is used by R as a top-level target, most notably when an\n", 
#&gt;                 "error is issued (see ", list(list("abort()")), 
#&gt;                 ") that no handler is able\n", "to deal with (see ", 
#&gt;                 list(list("with_handlers()")), ").\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# The `abort` restart is a bit special in that it is always\n", 
#&gt;                 "# registered in a R session. You will always find it on the restart\n", 
#&gt;                 "# stack because it is established at top level:\n", 
#&gt;                 "rst_list()\n", "\n", "# You can use the `above` restart to jump to top level without\n", 
#&gt;                 "# signalling an error:\n", list("\n", "fn &lt;- function() {\n", 
#&gt;                   "  cat(\"aborting...\\n\")\n", "  rst_abort()\n", 
#&gt;                   "  cat(\"This is never called\\n\")\n", "}\n", 
#&gt;                   "{\n", "  fn()\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# The `above` restart is the target that R uses to jump to top\n", 
#&gt;                 "# level when critical errors are signalled:\n", 
#&gt;                 list("\n", "{\n", "  abort(\"error\")\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# If another `abort` restart is specified, errors are signalled as\n", 
#&gt;                 "# usual but then control flow resumes with from the new restart:\n", 
#&gt;                 list("\n", "out &lt;- NULL\n", "{\n", "  out &lt;- with_restarts(abort(\"error\"), abort = function() \"restart!\")\n", 
#&gt;                   "  cat(\"This is called\\n\")\n", "}\n", "cat(\"`out` has now become:\", out, \"\\n\")\n"), 
#&gt;                 "\n"), "\n", list("\n", list(list("rst_jump()")), 
#&gt;                 ", ", list(list("abort()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), rst_list.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_list"), "\n", list("rst_list"), "\n", 
#&gt;             list("rst_exists"), "\n", list("rst_jump"), "\n", 
#&gt;             list("rst_maybe_jump"), "\n", list("Restarts utilities"), 
#&gt;             "\n", list("\n", "rst_list()\n", "\n", "rst_exists(.restart)\n", 
#&gt;                 "\n", "rst_jump(.restart, ...)\n", "\n", "rst_maybe_jump(.restart, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed on to the restart function. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restarts are named jumping points established by ", 
#&gt;                 list(list("with_restarts()")), ".\n", list("rst_list()"), 
#&gt;                 " returns the names of all restarts currently\n", 
#&gt;                 "established. ", list("rst_exists()"), " checks if a given restart is\n", 
#&gt;                 "established. ", list("rst_jump()"), " stops execution of the current function\n", 
#&gt;                 "and jumps to a restart point. If the restart does not exist, an\n", 
#&gt;                 "error is thrown.  ", list("rst_maybe_jump()"), 
#&gt;                 " first checks that a restart\n", "exists before jumping.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 list(list("with_restarts()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), `scalar-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("scalar-type-predicates"), "\n", list("scalar-type-predicates"), 
#&gt;             "\n", list("is_scalar_list"), "\n", list("is_scalar_atomic"), 
#&gt;             "\n", list("is_scalar_vector"), "\n", list("is_scalar_integer"), 
#&gt;             "\n", list("is_scalar_double"), "\n", list("is_scalar_character"), 
#&gt;             "\n", list("is_scalar_logical"), "\n", list("is_scalar_raw"), 
#&gt;             "\n", list("is_string"), "\n", list("is_scalar_bytes"), 
#&gt;             "\n", list("is_bool"), "\n", list("Scalar type predicates"), 
#&gt;             "\n", list("\n", "is_scalar_list(x)\n", "\n", "is_scalar_atomic(x)\n", 
#&gt;                 "\n", "is_scalar_vector(x)\n", "\n", "is_scalar_integer(x)\n", 
#&gt;                 "\n", "is_scalar_double(x)\n", "\n", "is_scalar_character(x, encoding = NULL)\n", 
#&gt;                 "\n", "is_scalar_logical(x)\n", "\n", "is_scalar_raw(x)\n", 
#&gt;                 "\n", "is_string(x, string = NULL)\n", "\n", 
#&gt;                 "is_scalar_bytes(x)\n", "\n", "is_bool(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to be tested.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n", "\n", list(list("string"), list("A string to compare to ", 
#&gt;                   list("x"), ". If a character vector,\n", "returns ", 
#&gt;                   list("TRUE"), " if at least one element is equal to ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "These predicates check for a given type and whether the vector is\n", 
#&gt;                 "\"scalar\", that is, of length 1.\n", "\n", 
#&gt;                 "In addition to the length check, ", list("is_string()"), 
#&gt;                 " and ", list("is_bool()"), "\n", "return ", 
#&gt;                 list("FALSE"), " if their input is missing. This is useful for\n", 
#&gt;                 "type-checking arguments, when your function expects a single string\n", 
#&gt;                 "or a single ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ".\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("bare-type-predicates"), "\n"), "\n"), 
#&gt;         scoped_bindings.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("scoped_bindings"), "\n", list("scoped_bindings"), 
#&gt;             "\n", list("with_bindings"), "\n", list("Temporarily change bindings of an environment"), 
#&gt;             "\n", list("\n", "scoped_bindings(..., .env = .frame, .frame = caller_env())\n", 
#&gt;                 "\n", "with_bindings(.expr, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Pairs of names and values. These dots support splicing\n", 
#&gt;                 "(with value semantics) and name unquoting.")), 
#&gt;                 "\n", "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The frame environment that determines the scope of\n", 
#&gt;                   "the temporary bindings. When that frame is popped from the call\n", 
#&gt;                   "stack, bindings are switched back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary bindings.")), 
#&gt;                 "\n"), "\n", list("\n", list("scoped_bindings()"), 
#&gt;                 " returns the values of old bindings\n", "invisibly; ", 
#&gt;                 list("with_bindings()"), " returns the value of ", 
#&gt;                 list("expr"), ".\n"), "\n", list("\n", list("\n", 
#&gt;                 list(), " ", list("scoped_bindings()"), " temporarily changes bindings in ", 
#&gt;                 list(".env"), " (which\n", "is by default the caller environment). The bindings are reset to\n", 
#&gt;                 "their original values when the current frame (or an arbitrary one\n", 
#&gt;                 "if you specify ", list(".frame"), ") goes out of scope.\n", 
#&gt;                 list(), " ", list("with_bindings()"), " evaluates ", 
#&gt;                 list("expr"), " with temporary bindings. When\n", 
#&gt;                 list("with_bindings()"), " returns, bindings are reset to their original\n", 
#&gt;                 "values. It is a simple wrapper around ", list(
#&gt;                   "scoped_bindings()"), ".\n"), "\n"), "\n", 
#&gt;             list("\n", "foo &lt;- \"foo\"\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "\n", "# `foo` will be temporarily rebinded while executing `expr`\n", 
#&gt;                 "with_bindings(paste(foo, bar), foo = \"rebinded\")\n", 
#&gt;                 "paste(foo, bar)\n"), "\n"), scoped_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("scoped_env"), "\n", list("scoped_env"), 
#&gt;             "\n", list("is_scoped"), "\n", list("scoped_envs"), 
#&gt;             "\n", list("scoped_names"), "\n", list("Retired ", 
#&gt;                 list("scoped"), " functions"), "\n", list("\n", 
#&gt;                 "scoped_env(nm)\n", "\n", "is_scoped(nm)\n", 
#&gt;                 "\n", "scoped_envs()\n", "\n", "scoped_names()\n"), 
#&gt;             "\n", list("\n", list(list("nm"), list("The name of an environment attached to the search\n", 
#&gt;                 "path. Call ", list(list("base::search()")), 
#&gt;                 " to see what is currently on the path.")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated as of rlang 0.3.0. They are replaced\n", 
#&gt;                 "by ", list(list("is_attached()")), ", ...\n"), 
#&gt;             "\n", list("internal"), "\n"), scoped_options.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/state.R", "\n", 
#&gt;             list("scoped_options"), "\n", list("scoped_options"), 
#&gt;             "\n", list("with_options"), "\n", list("push_options"), 
#&gt;             "\n", list("peek_options"), "\n", list("peek_option"), 
#&gt;             "\n", list("Change global options"), "\n", list("\n", 
#&gt;                 "scoped_options(..., .frame = caller_env())\n", 
#&gt;                 "\n", "with_options(.expr, ...)\n", "\n", "push_options(...)\n", 
#&gt;                 "\n", "peek_options(...)\n", "\n", "peek_option(name)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("For ", list(
#&gt;                 "scoped_options()"), " and ", list("push_options()"), 
#&gt;                 ", named\n", "values defining new option values. For ", 
#&gt;                 list("peek_options()"), ", strings\n", "or character vectors of option names.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The environment of a stack frame which defines the\n", 
#&gt;                   "scope of the temporary options. When the frame returns, the\n", 
#&gt;                   "options are set back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary options.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An option name as string.")), 
#&gt;                 "\n"), "\n", list("\n", "For ", list("scoped_options()"), 
#&gt;                 " and ", list("push_options()"), ", the old option\n", 
#&gt;                 "values. ", list("peek_option()"), " returns the current value of an option\n", 
#&gt;                 "while the plural ", list("peek_options()"), 
#&gt;                 " returns a list of current\n", "option values.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("scoped_options()"), 
#&gt;                 " changes options for the duration of a stack\n", 
#&gt;                 "frame (by default the current one). Options are set back to their\n", 
#&gt;                 "old values when the frame returns.\n", list(), 
#&gt;                 " ", list("with_options()"), " changes options while an expression is\n", 
#&gt;                 "evaluated. Options are restored when the expression returns.\n", 
#&gt;                 list(), " ", list("push_options()"), " adds or changes options permanently.\n", 
#&gt;                 list(), " ", list("peek_option()"), " and ", 
#&gt;                 list("peek_options()"), " return option values. The\n", 
#&gt;                 "former returns the option directly while the latter returns a\n", 
#&gt;                 "list.\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "# Store and retrieve a global option:\n", 
#&gt;                 "push_options(my_option = 10)\n", "peek_option(\"my_option\")\n", 
#&gt;                 "\n", "# Change the option temporarily:\n", "with_options(my_option = 100, peek_option(\"my_option\"))\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The scoped variant is useful within functions:\n", 
#&gt;                 "fn &lt;- function() {\n", "  scoped_options(my_option = 100)\n", 
#&gt;                 "  peek_option(\"my_option\")\n", "}\n", "fn()\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The plural peek returns a named list:\n", 
#&gt;                 "peek_options(\"my_option\")\n", "peek_options(\"my_option\", \"digits\")\n"), 
#&gt;             "\n", list("experimental"), "\n"), search_envs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("search_envs"), "\n", list("search_envs"), 
#&gt;             "\n", list("search_env"), "\n", list("pkg_env"), 
#&gt;             "\n", list("pkg_env_name"), "\n", list("is_attached"), 
#&gt;             "\n", list("base_env"), "\n", list("global_env"), 
#&gt;             "\n", list("Search path environments"), "\n", list(
#&gt;                 "\n", "search_envs()\n", "\n", "search_env(name)\n", 
#&gt;                 "\n", "pkg_env(pkg)\n", "\n", "pkg_env_name(pkg)\n", 
#&gt;                 "\n", "is_attached(x)\n", "\n", "base_env()\n", 
#&gt;                 "\n", "global_env()\n"), "\n", list("\n", list(
#&gt;                 list("name"), list("The name of an environment attached to the search\n", 
#&gt;                   "path. Call ", list(list("base::search()")), 
#&gt;                   " to get the names of environments\n", "currently attached to the search path. Note that the search name\n", 
#&gt;                   "of a package environment is prefixed with ", 
#&gt;                   list("\"package:\""), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", "The search path is a chain of environments containing exported\n", 
#&gt;                 "functions of attached packages.\n", "\n", "The API includes:\n", 
#&gt;                 list("\n", list(), " ", list(list("base::search()")), 
#&gt;                   " to get the names of environments attached to the\n", 
#&gt;                   "search path.\n", list(), " ", list("search_envs()"), 
#&gt;                   " returns the environments on the search path as a\n", 
#&gt;                   "list.\n", list(), " ", list("pkg_env_name()"), 
#&gt;                   " takes a bare package name and prefixes it with\n", 
#&gt;                   list("\"package:\""), ". Attached package environments have search names of\n", 
#&gt;                   "the form ", list("package:name"), ".\n", list(), 
#&gt;                   " ", list("pkg_env()"), " takes a bare package name and returns the scoped\n", 
#&gt;                   "environment of packages if they are attached to the search path,\n", 
#&gt;                   "and throws an error otherwise. It is a shortcut for\n", 
#&gt;                   list("search_env(pkg_env_name(\"pkgname\"))"), 
#&gt;                   ".\n", list(), " ", list("is_attached()"), 
#&gt;                   " returns ", list("TRUE"), " when its argument (a search name\n", 
#&gt;                   "or a package environment) is attached to the search path.\n"), 
#&gt;                 "\n"), "\n", list(list("The search path"), list(
#&gt;                 "\n", "\n", "\n", "This chain of environments determines what objects are visible from\n", 
#&gt;                 "the global workspace. It contains the following elements:\n", 
#&gt;                 list("\n", list(), " The chain always starts with ", 
#&gt;                   list("global_env()"), " and finishes with\n", 
#&gt;                   list("base_env()"), " (technically, it finishes with the ", 
#&gt;                   list("empty_env()"), "\n", "which the base package environment inherits from).\n", 
#&gt;                   list(), " Each ", list(list("base::library()")), 
#&gt;                   " call attaches a new package environment to\n", 
#&gt;                   "the search path. Attached packages are associated with a ", 
#&gt;                   list("search name"), ".\n", list(), " In addition, any list, data frame, or environment can be attached\n", 
#&gt;                   "to the search path with ", list(list("base::attach()")), 
#&gt;                   ".\n"), "\n")), "\n", "\n", list("\n", "# List the search names of environments attached to the search path:\n", 
#&gt;                 "search()\n", "\n", "# Get the corresponding environments:\n", 
#&gt;                 "search_envs()\n", "\n", "# The global environment and the base package are always first and\n", 
#&gt;                 "# last in the chain, respectively:\n", "envs &lt;- search_envs()\n", 
#&gt;                 "envs[[1]]\n", "envs[[length(envs)]]\n", "\n", 
#&gt;                 "# These two environments have their own shortcuts:\n", 
#&gt;                 "global_env()\n", "base_env()\n", "\n", "# Packages appear in the search path with a special name. Use\n", 
#&gt;                 "# pkg_env_name() to create that name:\n", "pkg_env_name(\"rlang\")\n", 
#&gt;                 "search_env(pkg_env_name(\"rlang\"))\n", "\n", 
#&gt;                 "# Alternatively, get the scoped environment of a package with\n", 
#&gt;                 "# pkg_env():\n", "pkg_env(\"utils\")\n"), "\n", 
#&gt;             list("internal"), "\n"), seq2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("seq2"), "\n", list("seq2"), "\n", list("seq2_along"), 
#&gt;             "\n", list("Increasing sequence of integers in an interval"), 
#&gt;             "\n", list("\n", "seq2(from, to)\n", "\n", "seq2_along(from, x)\n"), 
#&gt;             "\n", list("\n", list(list("from"), list("The starting point of the sequence.")), 
#&gt;                 "\n", "\n", list(list("to"), list("The end point.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A vector whose length is the end point.")), 
#&gt;                 "\n"), "\n", list("\n", "An integer vector containing a strictly increasing\n", 
#&gt;                 "sequence.\n"), "\n", list("\n", "These helpers take two endpoints and return the sequence of all\n", 
#&gt;                 "integers within that interval. For ", list("seq2_along()"), 
#&gt;                 ", the upper\n", "endpoint is taken from the length of a vector. Unlike\n", 
#&gt;                 list("base::seq()"), ", they return an empty vector if the starting point is\n", 
#&gt;                 "a larger integer than the end point.\n"), "\n", 
#&gt;             list("\n", "seq2(2, 10)\n", "seq2(10, 2)\n", "seq(10, 2)\n", 
#&gt;                 "\n", "seq2_along(10, letters)\n"), "\n"), set_attrs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("set_attrs"), "\n", list("set_attrs"), 
#&gt;             "\n", list("mut_attrs"), "\n", list("Add attributes to an object"), 
#&gt;             "\n", list("\n", "set_attrs(.x, ...)\n", "\n", "mut_attrs(.x, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("An object to decorate with attributes.")), 
#&gt;                 "\n", "\n", list(list("..."), list("A list of named attributes. These have ", 
#&gt;                   list("explicit splicing semantics"), ". Pass a single unnamed ", 
#&gt;                   list("NULL"), " argument to\n", "zap all attributes from ", 
#&gt;                   list(".x"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("set_attrs()"), " returns a modified ", 
#&gt;                 list("shallow copy"), "\n", "of ", list(".x"), 
#&gt;                 ". ", list("mut_attrs()"), " invisibly returns the original ", 
#&gt;                 list(".x"), "\n", "modified in place.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("set_attrs()"), " adds, changes, or zaps attributes of objects. Pass a\n", 
#&gt;                 "single unnamed ", list("NULL"), " argument to zap all attributes. For\n", 
#&gt;                 list("uncopyable"), " types, use ", list("mut_attrs()"), 
#&gt;                 ".\n"), "\n", list("\n", "Unlike ", list(list(
#&gt;                 "structure()")), ", these setters have no special handling of\n", 
#&gt;                 "internal attributes names like ", list(".Dim"), 
#&gt;                 ", ", list(".Dimnames"), " or ", list(".Names"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are deprecated since rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "set_attrs(letters, names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "\n", "# Splice a list of attributes:\n", "attrs &lt;- list(attr = \"attr\", names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "obj &lt;- set_attrs(letters, splice(attrs))\n", 
#&gt;                 "obj\n", "\n", "# Zap attributes by passing a single unnamed NULL argument:\n", 
#&gt;                 "set_attrs(obj, NULL)\n", "set_attrs(obj, !!! list(NULL))\n", 
#&gt;                 "\n", "# Note that set_attrs() never modifies objects in place:\n", 
#&gt;                 "obj\n", "\n", "# For uncopyable types, mut_attrs() lets you modify in place:\n", 
#&gt;                 "env &lt;- env()\n", "mut_attrs(env, foo = \"bar\")\n", 
#&gt;                 "env\n"), "\n", list("internal"), "\n"), set_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/expr.R", "\n", 
#&gt;             list("set_expr"), "\n", list("set_expr"), "\n", list(
#&gt;                 "get_expr"), "\n", list("Set and get an expression"), 
#&gt;             "\n", list("\n", "set_expr(x, value)\n", "\n", "get_expr(x, default = x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An expression, closure, or one-sided formula. In addition,\n", 
#&gt;                 list("set_expr()"), " accept frames.")), "\n", 
#&gt;                 "\n", list(list("value"), list("An updated expression.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default expression to return when ", 
#&gt;                   list("x"), " is not an\n", "expression wrapper. Defaults to ", 
#&gt;                   list("x"), " itself.")), "\n"), "\n", list(
#&gt;                 "\n", "The updated original input for ", list(
#&gt;                   "set_expr()"), ". A raw\n", "expression for ", 
#&gt;                 list("get_expr()"), ".\n"), "\n", list("\n", 
#&gt;                 "These helpers are useful to make your function work generically\n", 
#&gt;                 "with quosures and raw expressions. First call ", 
#&gt;                 list("get_expr()"), " to\n", "extract an expression. Once you're done processing the expression,\n", 
#&gt;                 "call ", list("set_expr()"), " on the original object to update the expression.\n", 
#&gt;                 "You can return the result of ", list("set_expr()"), 
#&gt;                 ", either a formula or an\n", "expression depending on the input type. Note that ", 
#&gt;                 list("set_expr()"), " does\n", "not change its input, it creates a new object.\n"), 
#&gt;             "\n", list("\n", "f &lt;- ~foo(bar)\n", "e &lt;- quote(foo(bar))\n", 
#&gt;                 "frame &lt;- identity(identity(ctxt_frame()))\n", 
#&gt;                 "\n", "get_expr(f)\n", "get_expr(e)\n", "get_expr(frame)\n", 
#&gt;                 "\n", "set_expr(f, quote(baz))\n", "set_expr(e, quote(baz))\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_expr()")), " and ", 
#&gt;                 list(list("quo_set_expr()")), " for versions of\n", 
#&gt;                 list(list("get_expr()")), " and ", list(list(
#&gt;                   "set_expr()")), " that only work on quosures.\n"), 
#&gt;             "\n"), set_names.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("set_names"), "\n", list("set_names"), 
#&gt;             "\n", list("Set names of a vector"), "\n", list("\n", 
#&gt;                 "set_names(x, nm = x, ...)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Vector to name.")), "\n", 
#&gt;                 "\n", list(list("nm, ..."), list("Vector of names, the same length as ", 
#&gt;                   list("x"), ".\n", "\n", "You can specify names in the following ways:\n", 
#&gt;                   list("\n", list(), " If you do nothing, ", 
#&gt;                     list("x"), " will be named with itself.\n", 
#&gt;                     list(), " If ", list("x"), " already has names, you can provide a function or formula\n", 
#&gt;                     "to transform the existing names. In that case, ", 
#&gt;                     list("..."), " is passed\n", "to the function.\n", 
#&gt;                     list(), " If ", list("nm"), " is ", list(
#&gt;                       "NULL"), ", the names are removed (if present).\n", 
#&gt;                     list(), " In all other cases, ", list("nm"), 
#&gt;                     " and ", list("..."), " are coerced to character.\n"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "stats::setNames()")), ", with more features and\n", 
#&gt;                 "stricter argument checking.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                   "set_names()"), " is stable and exported in purrr.\n")), 
#&gt;             "\n", "\n", list("\n", "set_names(1:4, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "set_names(1:4, letters[1:4])\n", "set_names(1:4, \"a\", \"b\", \"c\", \"d\")\n", 
#&gt;                 "\n", "# If the second argument is ommitted a vector is named with itself\n", 
#&gt;                 "set_names(letters[1:5])\n", "\n", "# Alternatively you can supply a function\n", 
#&gt;                 "set_names(1:10, ~ letters[seq_along(.)])\n", 
#&gt;                 "set_names(head(mtcars), toupper)\n", "\n", "# If the input vector is unnamed, it is first named after itself\n", 
#&gt;                 "# before the function is applied:\n", "set_names(letters, toupper)\n", 
#&gt;                 "\n", "# `...` is passed to the function:\n", 
#&gt;                 "set_names(head(mtcars), paste0, \"_foo\")\n"), 
#&gt;             "\n"), splice.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("splice"), "\n", list("splice"), "\n", 
#&gt;             list("is_spliced"), "\n", list("is_spliced_bare"), 
#&gt;             "\n", list("dots_splice"), "\n", list("Splice lists"), 
#&gt;             "\n", list("\n", "splice(x)\n", "\n", "is_spliced(x)\n", 
#&gt;                 "\n", "is_spliced_bare(x)\n", "\n", "dots_splice(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A list to splice.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to collect with ", 
#&gt;                   list("!!!"), " support.")), "\n", "\n", list(
#&gt;                   list(".ignore_empty"), list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("splice"), 
#&gt;                   " marks an object to be spliced. It is equivalent to using\n", 
#&gt;                   list("!!!"), " in a function with ", list("tidy dots semantics"), 
#&gt;                   ".\n", list(), " ", list("dots_splice()"), 
#&gt;                   " is like ", list(list("dots_list()")), " but automatically splices\n", 
#&gt;                   "list inputs.\n"), "\n"), "\n", list(list("Standard splicing versus quoting splicing"), 
#&gt;                 list("\n", "\n", "\n", "The ", list("!!!"), " operator works differently in ", 
#&gt;                   list("standard"), " functions taking\n", "dots with ", 
#&gt;                   list("dots_list()"), " than in ", list("quoting"), 
#&gt;                   " functions taking dots\n", "with ", list(list(
#&gt;                     "enexprs()")), " or ", list(list("enquos()")), 
#&gt;                   ".\n", list("\n", list(), " In quoting functions ", 
#&gt;                     list("!!!"), " disaggregates its argument (let's call\n", 
#&gt;                     "it ", list("x"), ") into as many objects as there are elements in\n", 
#&gt;                     list("x"), ". E.g. ", list("quo(foo(!!! c(1, 2)))"), 
#&gt;                     " is completely equivalent to\n", list("quo(foo(1, 2))"), 
#&gt;                     ". The creation of those separate objects has an\n", 
#&gt;                     "overhead but is typically not important when manipulating calls\n", 
#&gt;                     "because function calls typically take a small number of\n", 
#&gt;                     "arguments.\n", list(), " In standard functions, disaggregating the spliced collection\n", 
#&gt;                     "would have a negative performance impact in cases where\n", 
#&gt;                     list("dots_list()"), " is used to build up data structures from user\n", 
#&gt;                     "inputs. To avoid this spliced inputs are marked with ", 
#&gt;                     list(list("splice()")), "\n", "and the final list is built with (the equivalent of)\n", 
#&gt;                     list("flatten_if(dots, is_spliced)"), ".\n"), 
#&gt;                   "\n", "\n", "Most of the time you should not care about the difference. However\n", 
#&gt;                   "if you use a standard function taking tidy dots within a quoting\n", 
#&gt;                   "function, the ", list("!!!"), " operator will disaggregate its argument because\n", 
#&gt;                   "the behaviour of the quasiquoting function has priority. You might\n", 
#&gt;                   "then observe some performance cost in edge cases. Here is one\n", 
#&gt;                   "example where this would happen:", list("purrr::rerun(10, dplyr::bind_rows(!!! x))\n"), 
#&gt;                   "\n", "\n", list("purrr::rerun()"), " is a quoting function and ", 
#&gt;                   list("dplyr::bind_rows()"), " is\n", "a standard function. Because ", 
#&gt;                   list("bind_rows()"), " is called ", list("inside"), 
#&gt;                   "\n", list("rerun()"), ", the list ", list(
#&gt;                     "x"), " will be disaggregated into a pairlist of\n", 
#&gt;                   "arguments. To avoid this you can use ", list(
#&gt;                     "splice()"), " instead:", list("purrr::rerun(10, dplyr::bind_rows(splice(x)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "dots_splice()"), " is in the questioning stage. It is part of our\n", 
#&gt;                   "experiments with dots semantics. Compared to ", 
#&gt;                   list("dots_list()"), ",\n", list("dots_splice()"), 
#&gt;                   " automatically splices lists. We now lean towards\n", 
#&gt;                   "adopting a single type of dots semantics (those of ", 
#&gt;                   list("dots_list()"), ")\n", "where splicing is explicit.\n", 
#&gt;                   list(), " ", list("splice()"), " is in the questioning stage. It is not clear whether it is\n", 
#&gt;                   "really needed as there are other ways to avoid the performance\n", 
#&gt;                   "issue discussed above.\n"), "\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), stack.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack"), "\n", list("stack"), "\n", list(
#&gt;                 "global_frame"), "\n", list("current_frame"), 
#&gt;             "\n", list("ctxt_frame"), "\n", list("call_frame"), 
#&gt;             "\n", list("ctxt_depth"), "\n", list("call_depth"), 
#&gt;             "\n", list("ctxt_stack"), "\n", list("call_stack"), 
#&gt;             "\n", list("Call stack information"), "\n", list(
#&gt;                 "\n", "global_frame()\n", "\n", "current_frame()\n", 
#&gt;                 "\n", "ctxt_frame(n = 1)\n", "\n", "call_frame(n = 1, clean = TRUE)\n", 
#&gt;                 "\n", "ctxt_depth()\n", "\n", "call_depth()\n", 
#&gt;                 "\n", "ctxt_stack(n = NULL, trim = 0)\n", "\n", 
#&gt;                 "call_stack(n = NULL, clean = TRUE)\n"), "\n", 
#&gt;             list("\n", list(list("n"), list("The number of frames to go back in the stack.")), 
#&gt;                 "\n", "\n", list(list("clean"), list("Whether to post-process the call stack to clean\n", 
#&gt;                   "non-standard frames. If ", list("TRUE"), ", suboptimal call-stack entries by\n", 
#&gt;                   list(list("base::eval()")), " will be cleaned up: the duplicate frame created by\n", 
#&gt;                   list("eval()"), " is eliminated.")), "\n", 
#&gt;                 "\n", list(list("trim"), list("The number of layers of intervening frames to trim off\n", 
#&gt;                   "the stack. See ", list(list("stack_trim()")), 
#&gt;                   " and examples.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "The ", list("eval_"), " and ", list("call_"), 
#&gt;                 " families of functions provide a replacement\n", 
#&gt;                 "for the base R functions prefixed with ", list(
#&gt;                   "sys."), " (which are all about\n", "the context stack), as well as for ", 
#&gt;                 list(list("parent.frame()")), " (which is the\n", 
#&gt;                 "only base R function for querying the call stack). The context\n", 
#&gt;                 "stack includes all R-level evaluation contexts. It is linear in\n", 
#&gt;                 "terms of execution history but due to lazy evaluation it is\n", 
#&gt;                 "potentially nonlinear in terms of call history. The call stack\n", 
#&gt;                 "history, on the other hand, is homogenous.\n"), 
#&gt;             "\n", list("\n", list("ctxt_frame()"), " and ", list(
#&gt;                 "call_frame()"), " return a ", list("frame"), 
#&gt;                 " object\n", "containing the following fields: ", 
#&gt;                 list("expr"), " and ", list("env"), " (call expression\n", 
#&gt;                 "and evaluation environment), ", list("pos"), 
#&gt;                 " and ", list("caller_pos"), " (position of\n", 
#&gt;                 "current frame in the context stack and position of the caller), and\n", 
#&gt;                 list("fun"), " (function of the current frame). ", 
#&gt;                 list("ctxt_stack()"), " and\n", list("call_stack()"), 
#&gt;                 " return a list of all context or call frames on the\n", 
#&gt;                 "stack. Finally, ", list("ctxt_depth()"), " and ", 
#&gt;                 list("call_depth()"), " report the\n", "current context position or the number of calling frames on the\n", 
#&gt;                 "stack.\n", "\n", "The base R functions take two sorts of arguments to indicate which\n", 
#&gt;                 "frame to query: ", list("which"), " and ", list(
#&gt;                   "n"), ". The ", list("n"), " argument is\n", 
#&gt;                 "straightforward: it's the number of frames to go down the stack,\n", 
#&gt;                 "with ", list("n = 1"), " referring to the current context. The ", 
#&gt;                 list("which"), " argument\n", "is more complicated and changes meaning for values lower than 1.\n", 
#&gt;                 "For the sake of consistency, the rlang functions all take the\n", 
#&gt;                 "same kind of argument ", list("n"), ". This argument has a single meaning (the\n", 
#&gt;                 "number of frames to go down the stack) and cannot be lower than 1.\n", 
#&gt;                 "\n", "Note finally that ", list("parent.frame(1)"), 
#&gt;                 " corresponds to\n", list("call_frame(2)$env"), 
#&gt;                 ", as ", list("n = 1"), " always refers to the current\n", 
#&gt;                 "frame. This makes the ", list("_frame()"), " and ", 
#&gt;                 list("_stack()"), " functions\n", "consistent: ", 
#&gt;                 list("ctxt_frame(2)"), " is the same as ", list(
#&gt;                   "ctxt_stack()[[2]]"), ".\n", "Also, ", list(
#&gt;                   "ctxt_depth()"), " returns one more frame than\n", 
#&gt;                 list(list("base::sys.nframe()")), " because it counts the global frame. That is\n", 
#&gt;                 "consistent with the ", list("_stack()"), " functions which return the global\n", 
#&gt;                 "frame as well. This way, ", list("call_stack(call_depth())"), 
#&gt;                 " is the same as\n", list("global_frame()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are soft-deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Expressions within arguments count as contexts\n", 
#&gt;                 "identity(identity(ctxt_depth())) # returns 2\n", 
#&gt;                 "\n", "# But they are not part of the call stack because arguments are\n", 
#&gt;                 "# evaluated within the calling function (or the global environment\n", 
#&gt;                 "# if called at top level)\n", "identity(identity(call_depth())) # returns 0\n", 
#&gt;                 "\n", "# The context stacks includes all intervening execution frames. The\n", 
#&gt;                 "# call stack doesn't:\n", "f &lt;- function(x) identity(x)\n", 
#&gt;                 "f(f(ctxt_stack()))\n", "f(f(call_stack()))\n", 
#&gt;                 "\n", "g &lt;- function(cmd) cmd()\n", "f(g(ctxt_stack))\n", 
#&gt;                 "f(g(call_stack))\n", "\n", "# The rlang _stack() functions return a list of frame\n", 
#&gt;                 "# objects. Use purrr::transpose() or index a field with\n", 
#&gt;                 "# purrr::map()'s to extract a particular field from a stack:\n", 
#&gt;                 "\n", "# stack &lt;- f(f(call_stack()))\n", "# purrr::map(stack, \"env\")\n", 
#&gt;                 "# purrr::transpose(stack)$expr\n", "\n", "# current_frame() is an alias for ctxt_frame(1)\n", 
#&gt;                 "fn &lt;- function() list(current = current_frame(), first = ctxt_frame(1))\n", 
#&gt;                 "fn()\n", "\n", "# While current_frame() is the top of the stack, global_frame() is\n", 
#&gt;                 "# the bottom:\n", "fn &lt;- function() {\n", "  n &lt;- ctxt_depth()\n", 
#&gt;                 "  ctxt_frame(n)\n", "}\n", "identical(fn(), global_frame())\n", 
#&gt;                 "\n", "\n", "# ctxt_stack() returns a stack with all intervening frames. You can\n", 
#&gt;                 "# trim layers of intervening frames with the trim argument:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "identity(identity(ctxt_stack(trim = 1)))\n", 
#&gt;                 "\n", "# ctxt_stack() is called within fn() with intervening frames:\n", 
#&gt;                 "fn &lt;- function(trim) identity(identity(ctxt_stack(trim = trim)))\n", 
#&gt;                 "fn(0)\n", "\n", "# We can trim the first layer of those:\n", 
#&gt;                 "fn(1)\n", "\n", "# The outside intervening frames (at the fn() call site) are still\n", 
#&gt;                 "# returned, but can be trimmed as well:\n", 
#&gt;                 "identity(identity(fn(1)))\n", "identity(identity(fn(2)))\n", 
#&gt;                 "\n", "g &lt;- function(trim) identity(identity(fn(trim)))\n", 
#&gt;                 "g(2)\n", "g(3)\n"), "\n", list("internal"), 
#&gt;             "\n"), stack_trim.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack_trim"), "\n", list("stack_trim"), 
#&gt;             "\n", list("Trim top call layers from the evaluation stack"), 
#&gt;             "\n", list("\n", "stack_trim(stack, n = 1)\n"), "\n", 
#&gt;             list("\n", list(list("stack"), list("An evaluation stack.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of call frames (not eval frames) to trim off\n", 
#&gt;                   "the top of the stack. In other words, the number of layers of\n", 
#&gt;                   "intervening frames to trim.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list(list("ctxt_stack()")), " can be tricky to use in real code because all\n", 
#&gt;                 "intervening frames are returned with the stack, including those at\n", 
#&gt;                 list("ctxt_stack()"), " own call site. ", list(
#&gt;                   "stack_trim()"), " makes it easy to\n", "remove layers of intervening calls.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Intervening frames appear on the evaluation stack:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# stack_trim() will trim the first n layers of calls:\n", 
#&gt;                 "stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "\n", "# Note that it also takes care of calls intervening at its own call\n", 
#&gt;                 "# site:\n", "identity(identity(\n", "  stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "))\n", "\n", "# It is especially useful when used within a function that needs to\n", 
#&gt;                 "# inspect the evaluation stack but should nonetheless be callable\n", 
#&gt;                 "# within nested calls without side effects:\n", 
#&gt;                 "stack_util &lt;- function() {\n", "  # n = 2 means that two layers of intervening calls should be\n", 
#&gt;                 "  # removed: The layer at ctxt_stack()'s call site (including the\n", 
#&gt;                 "  # stack_trim() call), and the layer at stack_util()'s call.\n", 
#&gt;                 "  stack &lt;- stack_trim(ctxt_stack(), n = 2)\n", 
#&gt;                 "  stack\n", "}\n", "user_fn &lt;- function() {\n", 
#&gt;                 "  # A user calls your stack utility with intervening frames:\n", 
#&gt;                 "  identity(identity(stack_util()))\n", "}\n", 
#&gt;                 "# These intervening frames won't appear in the evaluation stack\n", 
#&gt;                 "identity(user_fn())\n"), "\n", list("internal"), 
#&gt;             "\n"), string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("string"), "\n", list("string"), "\n", 
#&gt;             list("Create a string"), "\n", list("\n", "string(x, encoding = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A character vector or a vector or list of string-like\n", 
#&gt;                 "objects.")), "\n", "\n", list(list("encoding"), 
#&gt;                 list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These base-type constructors allow more control over the creation\n", 
#&gt;                 "of strings in R. They take character vectors or string-like objects\n", 
#&gt;                 "(integerish or raw vectors), and optionally set the encoding. The\n", 
#&gt;                 "string version checks that the input contains a scalar string.\n"), 
#&gt;             "\n", list("\n", "# As everywhere in R, you can specify a string with Unicode\n", 
#&gt;                 "# escapes. The characters corresponding to Unicode codepoints will\n", 
#&gt;                 "# be encoded in UTF-8, and the string will be marked as UTF-8\n", 
#&gt;                 "# automatically:\n", "cafe &lt;- string(\"caf\\uE9\")\n", 
#&gt;                 "Encoding(cafe)\n", "as_bytes(cafe)\n", "\n", 
#&gt;                 "# In addition, string() provides useful conversions to let\n", 
#&gt;                 "# programmers control how the string is represented in memory. For\n", 
#&gt;                 "# encodings other than UTF-8, you'll need to supply the bytes in\n", 
#&gt;                 "# hexadecimal form. If it is a latin1 encoding, you can mark the\n", 
#&gt;                 "# string explicitly:\n", "cafe_latin1 &lt;- string(c(0x63, 0x61, 0x66, 0xE9), \"latin1\")\n", 
#&gt;                 "Encoding(cafe_latin1)\n", "as_bytes(cafe_latin1)\n"), 
#&gt;             "\n", list("internal"), "\n"), switch_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("switch_type"), "\n", list("switch_type"), 
#&gt;             "\n", list("coerce_type"), "\n", list("switch_class"), 
#&gt;             "\n", list("coerce_class"), "\n", list("Dispatch on base types"), 
#&gt;             "\n", list("\n", "switch_type(.x, ...)\n", "\n", 
#&gt;                 "coerce_type(.x, .to, ...)\n", "\n", "switch_class(.x, ...)\n", 
#&gt;                 "\n", "coerce_class(.x, .to, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".x"), list("An object from which to dispatch.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named clauses. The names should be types as returned by\n", 
#&gt;                   list(list("type_of()")), ".")), "\n", "\n", 
#&gt;                 list(list(".to"), list("This is useful when you switchpatch within a coercing\n", 
#&gt;                   "function. If supplied, this should be a string indicating the\n", 
#&gt;                   "target type. A catch-all clause is then added to signal an error\n", 
#&gt;                   "stating the conversion failure. This type is prettified unless\n", 
#&gt;                   list(".to"), " inherits from the S3 class ", 
#&gt;                   list("\"AsIs\""), " (see ", list(list("base::I()")), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("switch_type()"), " is equivalent to\n", 
#&gt;                 list(list("switch"), "(", list("type_of"), "(x, ...))"), 
#&gt;                 ", while\n", list("switch_class()"), " switchpatches based on ", 
#&gt;                 list("class(x)"), ". The ", list("coerce_"), 
#&gt;                 "\n", "versions are intended for type conversion and provide a standard\n", 
#&gt;                 "error message when conversion fails.\n"), "\n", 
#&gt;             list("\n", "switch_type(3L,\n", "  double = \"foo\",\n", 
#&gt;                 "  integer = \"bar\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# Use the coerce_ version to get standardised error handling when no\n", 
#&gt;                 "# type matches:\n", "to_chr &lt;- function(x) {\n", 
#&gt;                 "  coerce_type(x, \"a chr\",\n", "    integer = as.character(x),\n", 
#&gt;                 "    double = as.character(x)\n", "  )\n", "}\n", 
#&gt;                 "to_chr(3L)\n", "\n", "# Strings have their own type:\n", 
#&gt;                 "switch_type(\"str\",\n", "  character = \"foo\",\n", 
#&gt;                 "  string = \"bar\",\n", "  \"default\"\n", ")\n", 
#&gt;                 "\n", "# Use a fallthrough clause if you need to dispatch on all character\n", 
#&gt;                 "# vectors, including strings:\n", "switch_type(\"str\",\n", 
#&gt;                 "  string = ,\n", "  character = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "\n", "# special and builtin functions are treated as primitive, since\n", 
#&gt;                 "# there is usually no reason to treat them differently:\n", 
#&gt;                 "switch_type(base::list,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "switch_type(base::`$`,\n", 
#&gt;                 "  primitive = \"foo\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# closures are not primitives:\n", 
#&gt;                 "switch_type(rlang::switch_type,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n"), "\n", list("internal"), 
#&gt;             "\n"), sym.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("sym"), "\n", list("sym"), "\n", list("syms"), 
#&gt;             "\n", list("Create a symbol or list of symbols"), 
#&gt;             "\n", list("\n", "sym(x)\n", "\n", "syms(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or list of strings.")), 
#&gt;                 "\n"), "\n", list("\n", "A symbol for ", list(
#&gt;                 "sym()"), " and a list of symbols for ", list(
#&gt;                 "syms()"), ".\n"), "\n", list("\n", "These functions take strings as input and turn them into symbols.\n"), 
#&gt;             "\n", list("\n", "# The empty string returns the missing argument:\n", 
#&gt;                 "sym(\"\")\n", "\n", "# This way sym() and as_string() are inverse of each other:\n", 
#&gt;                 "as_string(missing_arg())\n", "sym(as_string(missing_arg()))\n"), 
#&gt;             "\n"), `tidy-dots.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R, R/vec-new.R", 
#&gt;             "\n", list("tidy-dots"), "\n", list("tidy-dots"), 
#&gt;             "\n", list("dots_list"), "\n", list("list2"), "\n", 
#&gt;             list("Collect dots as lists"), "\n", list("\n", "dots_list(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "list2(...)\n"), "\n", list("\n", list(list("..."), 
#&gt;                 list("Arguments to collect with ", list("!!!"), 
#&gt;                   " support.")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                 list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "A list of arguments. This list is always named: unnamed\n", 
#&gt;                 "arguments are named with the empty string ", 
#&gt;                 list("\"\""), ".\n"), "\n", list("\n", list("list2()"), 
#&gt;                 " is equivalent to ", list("list(...)"), " with a few additional\n", 
#&gt;                 "features:\n", list("\n", list(), " You can splice other lists with the\n", 
#&gt;                   list("unquote-splice"), " ", list("!!!"), " operator.\n", 
#&gt;                   list(), " You can unquote names by using the ", 
#&gt;                   list("unquote"), "\n", "operator ", list("!!"), 
#&gt;                   " on the left-hand side of ", list(":="), ".\n", 
#&gt;                   list(), " Trailing commas are ignored, making it easier to copy and paste\n", 
#&gt;                   "arguments.\n"), "\n", "\n", "For lack of a better name, these features are collectively called\n", 
#&gt;                 "\"tidy dots\".\n", "\n", list("dots_list()"), 
#&gt;                 " is a lower-level version of ", list("list2()"), 
#&gt;                 " that offers\n", "additional parameters for dots capture.\n"), 
#&gt;             "\n", list("\n", "# Let's create a function that takes a variable number of arguments:\n", 
#&gt;                 "numeric &lt;- function(...) {\n", "  dots &lt;- list2(...)\n", 
#&gt;                 "  num &lt;- as.numeric(dots)\n", "  set_names(num, names(dots))\n", 
#&gt;                 "}\n", "numeric(1, 2, 3)\n", "\n", "# The main difference with list(...) is that list2(...) enables\n", 
#&gt;                 "# the `!!!` syntax to splice lists:\n", "x &lt;- list(2, 3)\n", 
#&gt;                 "numeric(1, !!! x, 4)\n", "\n", "# As well as unquoting of names:\n", 
#&gt;                 "nm &lt;- \"yup!\"\n", "numeric(!!nm := 1)\n", "\n", 
#&gt;                 "\n", "# One useful application of splicing is to work around exact and\n", 
#&gt;                 "# partial matching of arguments. Let's create a function taking\n", 
#&gt;                 "# named arguments and dots:\n", "fn &lt;- function(data, ...) {\n", 
#&gt;                 "  list2(...)\n", "}\n", "\n", "# You normally cannot pass an argument named `data` through the dots\n", 
#&gt;                 "# as it will match `fn`'s `data` argument. The splicing syntax\n", 
#&gt;                 "# provides a workaround:\n", "fn(\"wrong!\", data = letters)  # exact matching of `data`\n", 
#&gt;                 "fn(\"wrong!\", dat = letters)   # partial matching of `data`\n", 
#&gt;                 "fn(some_data, !!!list(data = letters))  # no matching\n", 
#&gt;                 "\n", "\n", "# Empty arguments trigger an error by default:\n", 
#&gt;                 "try(fn(, ))\n", "\n", "# You can choose to preserve empty arguments instead:\n", 
#&gt;                 "list3 &lt;- function(...) dots_list(..., .preserve_empty = TRUE)\n", 
#&gt;                 "\n", "# Note how the last empty argument is still ignored because\n", 
#&gt;                 "# `.ignore_empty` defaults to \"trailing\":\n", 
#&gt;                 "list3(, )\n", "\n", "# The list with preserved empty arguments is equivalent to:\n", 
#&gt;                 "list(missing_arg())\n", "\n", "\n", "# Arguments with duplicated names are kept by default:\n", 
#&gt;                 "list2(a = 1, a = 2, b = 3, b = 4, 5, 6)\n", 
#&gt;                 "\n", "# Use the `.homonyms` argument to keep only the first of these:\n", 
#&gt;                 "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"first\")\n", 
#&gt;                 "\n", "# Or the last:\n", "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"last\")\n", 
#&gt;                 "\n", "# Or raise an informative error:\n", "try(dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"error\"))\n", 
#&gt;                 "\n", "\n", "# dots_list() can be configured to warn when a `&lt;-` call is\n", 
#&gt;                 "# detected:\n", "my_list &lt;- function(...) dots_list(..., .check_assign = TRUE)\n", 
#&gt;                 "my_list(a &lt;- 1)\n", "\n", "# There is no warning if the assignment is wrapped in braces.\n", 
#&gt;                 "# This requires users to be explicit about their intent:\n", 
#&gt;                 "my_list({ a &lt;- 1 })\n"), "\n", list("\n", list(
#&gt;                 list("exprs()")), " for extracting dots without evaluation.\n"), 
#&gt;             "\n"), `tidyeval-data.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("data"), "\n", list("tidyeval-data"), 
#&gt;             "\n", list("tidyeval-data"), "\n", list(".data"), 
#&gt;             "\n", list("Data pronoun for tidy evaluation"), "\n", 
#&gt;             list("\n", ".data\n"), "\n", list("\n", "This pronoun allows you to be explicit when you refer to an object\n", 
#&gt;                 "inside the data. Referring to the ", list(".data"), 
#&gt;                 " pronoun rather than to\n", "the original data frame has several advantages:\n", 
#&gt;                 list("\n", list(), " It makes it easy to refer to column names stored as strings. If\n", 
#&gt;                   list("var"), " contains the column ", list(
#&gt;                     "\"height\""), ", the pronoun will subset that\n", 
#&gt;                   "column:", list("var &lt;- \"height\"\n", "dplyr::summarise(df, mean(.data[[var]]))\n"), 
#&gt;                   "\n", "\n", "The index variable ", list("var"), 
#&gt;                   " is ", list("unquoted"), ", which\n", "ensures a column named ", 
#&gt;                   list("var"), " in the data frame cannot mask it.\n", 
#&gt;                   "This makes the pronoun safe to use in functions and packages.\n", 
#&gt;                   list(), " Sometimes a computation is not about the whole data but about a\n", 
#&gt;                   "subset. For example if you supply a grouped data frame to a dplyr\n", 
#&gt;                   "verb, the ", list(".data"), " pronoun contains the group subset.\n", 
#&gt;                   list(), " It lets dplyr know that you're referring to a column from the\n", 
#&gt;                   "data which is helpful to generate correct queries when the source\n", 
#&gt;                   "is a database.\n"), "\n", "\n", "The ", list(
#&gt;                   ".data"), " object exported here is useful to import in your\n", 
#&gt;                 "package namespace to avoid a ", list("R CMD check"), 
#&gt;                 " note when referring to\n", "objects from the data mask.\n"), 
#&gt;             "\n", list("datasets"), "\n"), trace_back.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/trace.R", "\n", 
#&gt;             list("trace_back"), "\n", list("trace_back"), "\n", 
#&gt;             list("trace_length"), "\n", list("Capture a backtrace"), 
#&gt;             "\n", list("\n", "trace_back(top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "trace_length(trace)\n"), "\n", list("\n", 
#&gt;                 list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n", "\n", 
#&gt;                 list(list("trace"), list("A backtrace created by ", 
#&gt;                   list("trace_back()"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "A backtrace captures the sequence of calls that lead to the current\n", 
#&gt;                 "function, sometimes called the call stack. Because of lazy\n", 
#&gt;                 "evaluation, the call stack in R is actually a tree, which the\n", 
#&gt;                 list("summary()"), " method of this object will reveal.\n"), 
#&gt;             "\n", list("\n", list("trace_length()"), " returns the number of frames in a backtrace.\n"), 
#&gt;             "\n", list("\n", "# Trim backtraces automatically (this improves the generated\n", 
#&gt;                 "# documentation for the rlang website and the same trick can be\n", 
#&gt;                 "# useful within knitr documents):\n", "options(rlang_trace_top_env = current_env())\n", 
#&gt;                 "\n", "f &lt;- function() g()\n", "g &lt;- function() h()\n", 
#&gt;                 "h &lt;- function() trace_back()\n", "\n", "# When no lazy evaluation is involved the backtrace is linear\n", 
#&gt;                 "# (i.e. every call has only one child)\n", "f()\n", 
#&gt;                 "\n", "# Lazy evaluation introduces a tree like structure\n", 
#&gt;                 "identity(identity(f()))\n", "identity(try(f()))\n", 
#&gt;                 "try(identity(f()))\n", "\n", "# When printing, you can request to simplify this tree to only show\n", 
#&gt;                 "# the direct sequence of calls that lead to `trace_back()`\n", 
#&gt;                 "x &lt;- try(identity(f()))\n", "x\n", "print(x, simplify = \"branch\")\n", 
#&gt;                 "\n", "# With a little cunning you can also use it to capture the\n", 
#&gt;                 "# tree from within a base NSE function\n", "x &lt;- NULL\n", 
#&gt;                 "with(mtcars, {x &lt;&lt;- f(); 10})\n", "x\n", "\n", 
#&gt;                 "\n", "# Restore default top env for next example\n", 
#&gt;                 "options(rlang_trace_top_env = NULL)\n", "\n", 
#&gt;                 "# When code is executed indirectly, i.e. via source or within an\n", 
#&gt;                 "# RMarkdown document, you'll tend to get a lot of guff at the beginning\n", 
#&gt;                 "# related to the execution environment:\n", 
#&gt;                 "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n", "\n", "# To automatically strip this off, specify which frame should be\n", 
#&gt;                 "# the top of the backtrace. This will automatically trim off calls\n", 
#&gt;                 "# prior to that frame:\n", "top &lt;- current_env()\n", 
#&gt;                 "h &lt;- function() trace_back(top)\n", "\n", "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n"), "\n"), `type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("type-predicates"), "\n", list("type-predicates"), 
#&gt;             "\n", list("is_list"), "\n", list("is_atomic"), "\n", 
#&gt;             list("is_vector"), "\n", list("is_integer"), "\n", 
#&gt;             list("is_double"), "\n", list("is_character"), "\n", 
#&gt;             list("is_logical"), "\n", list("is_raw"), "\n", list(
#&gt;                 "is_bytes"), "\n", list("is_null"), "\n", list(
#&gt;                 "Type predicates"), "\n", list("\n", "is_list(x, n = NULL)\n", 
#&gt;                 "\n", "is_atomic(x, n = NULL)\n", "\n", "is_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_integer(x, n = NULL)\n", "\n", "is_double(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_logical(x, n = NULL)\n", "\n", "is_raw(x, n = NULL)\n", 
#&gt;                 "\n", "is_bytes(x, n = NULL)\n", "\n", "is_null(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These type predicates aim to make type testing in R more\n", 
#&gt;                 "consistent. They are wrappers around ", list(
#&gt;                   list("base::typeof()")), ", so operate\n", 
#&gt;                 "at a level beneath S3/S4 etc.\n"), "\n", list(
#&gt;                 "\n", "Compared to base R functions:\n", list(
#&gt;                   "\n", list(), " The predicates for vectors include the ", 
#&gt;                   list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                   list(), " Unlike ", list("is.atomic()"), ", ", 
#&gt;                   list("is_atomic()"), " does not return ", list(
#&gt;                     "TRUE"), " for\n", list("NULL"), ".\n", list(), 
#&gt;                   " Unlike ", list("is.vector()"), ", ", list(
#&gt;                     "is_vector()"), " tests if an object is an\n", 
#&gt;                   "atomic vector or a list. ", list("is.vector"), 
#&gt;                   " checks for the presence of\n", "attributes (other than name).\n"), 
#&gt;                 "\n"), "\n", list("\n", list("bare-type-predicates"), 
#&gt;                 " ", list("scalar-type-predicates"), "\n"), "\n"), 
#&gt;         type_of.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("type_of"), "\n", list("type_of"), "\n", 
#&gt;             list("Base type of an object"), "\n", list("\n", 
#&gt;                 "type_of(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An R object.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "base::typeof()")), " with a few differences that\n", 
#&gt;                 "make dispatching easier:\n", list("\n", list(), 
#&gt;                   " The type of one-sided formulas is \"quote\".\n", 
#&gt;                   list(), " The type of character vectors of length 1 is \"string\".\n", 
#&gt;                   list(), " The type of special and builtin functions is \"primitive\".\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", list("type_of()"), " is an experimental function. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "type_of(10L)\n", "\n", "# Quosures are treated as a new base type but not formulas:\n", 
#&gt;                 "type_of(quo(10L))\n", "type_of(~10L)\n", "\n", 
#&gt;                 "# Compare to base::typeof():\n", "typeof(quo(10L))\n", 
#&gt;                 "\n", "# Strings are treated as a new base type:\n", 
#&gt;                 "type_of(letters)\n", "type_of(letters[[1]])\n", 
#&gt;                 "\n", "# This is a bit inconsistent with the core language tenet that data\n", 
#&gt;                 "# types are vectors. However, treating strings as a different\n", 
#&gt;                 "# scalar type is quite helpful for switching on function inputs\n", 
#&gt;                 "# since so many arguments expect strings:\n", 
#&gt;                 "switch_type(\"foo\", character = abort(\"vector!\"), string = \"result\")\n", 
#&gt;                 "\n", "# Special and builtin primitives are both treated as primitives.\n", 
#&gt;                 "# That's because it is often irrelevant which type of primitive an\n", 
#&gt;                 "# input is:\n", "typeof(list)\n", "typeof(`$`)\n", 
#&gt;                 "type_of(list)\n", "type_of(`$`)\n"), "\n", list(
#&gt;                 "internal"), "\n"), vec_poke_n.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("vec_poke_n"), "\n", list("vec_poke_n"), "\n", 
#&gt;             list("vec_poke_range"), "\n", list("Poke values into a vector"), 
#&gt;             "\n", list("\n", "vec_poke_n(x, start, y, from = 1L, n = length(y))\n", 
#&gt;                 "\n", "vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("The destination vector.")), 
#&gt;                 "\n", "\n", list(list("start"), list("The index indicating where to start modifying ", 
#&gt;                   list("x"), ".")), "\n", "\n", list(list("y"), 
#&gt;                   list("The source vector.")), "\n", "\n", list(
#&gt;                   list("from"), list("The index indicating where to start copying from ", 
#&gt;                     list("y"), ".")), "\n", "\n", list(list("n"), 
#&gt;                   list("How many elements should be copied from ", 
#&gt;                     list("y"), " to ", list("x"), ".")), "\n", 
#&gt;                 "\n", list(list("to"), list("The index indicating the end of the range to copy from ", 
#&gt;                   list("y"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n", 
#&gt;                 "\n", "These tools are for R experts only. They copy elements from ", 
#&gt;                 list("y"), "\n", "into ", list("x"), " by mutation. You should only do this if you own ", 
#&gt;                 list("x"), ",\n", "i.e. if you have created it or if you are certain that it doesn't\n", 
#&gt;                 "exist in any other context. Otherwise you might create unintended\n", 
#&gt;                 "side effects that have undefined consequences.\n"), 
#&gt;             "\n", list("internal"), "\n"), `vector-coercion.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("vector-coercion"), "\n", list("vector-coercion"), 
#&gt;             "\n", list("as_logical"), "\n", list("as_integer"), 
#&gt;             "\n", list("as_double"), "\n", list("as_complex"), 
#&gt;             "\n", list("as_character"), "\n", list("as_list"), 
#&gt;             "\n", list("Coerce an object to a base type"), "\n", 
#&gt;             list("\n", "as_logical(x)\n", "\n", "as_integer(x)\n", 
#&gt;                 "\n", "as_double(x)\n", "\n", "as_complex(x)\n", 
#&gt;                 "\n", "as_character(x, encoding = NULL)\n", "\n", 
#&gt;                 "as_list(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to coerce to a base type.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "These are equivalent to the base functions (e.g. ", 
#&gt;                 list(list("as.logical()")), ",\n", list(list(
#&gt;                   "as.list()")), ", etc), but perform coercion rather than conversion.\n", 
#&gt;                 "This means they are not generic and will not call S3 conversion\n", 
#&gt;                 "methods. They only attempt to coerce the base type of their\n", 
#&gt;                 "input. In addition, they have stricter implicit coercion rules and\n", 
#&gt;                 "will never attempt any kind of parsing. E.g. they will not try to\n", 
#&gt;                 "figure out if a character vector represents integers or booleans.\n", 
#&gt;                 "Finally, they treat attributes consistently, unlike the base R\n", 
#&gt;                 "functions: all attributes except names are removed.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated in favour of ", 
#&gt;                 list("vctrs::vec_cast()"), ".\n")), "\n", "\n", 
#&gt;             list(list("Coercion to logical and numeric atomic vectors"), 
#&gt;                 list("\n", "\n", list("\n", list(), " To logical vectors: Integer and integerish double vectors. See\n", 
#&gt;                   list(list("is_integerish()")), ".\n", list(), 
#&gt;                   " To integer vectors: Logical and integerish double vectors.\n", 
#&gt;                   list(), " To double vectors: Logical and integer vectors.\n", 
#&gt;                   list(), " To complex vectors: Logical, integer and double vectors.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Coercion to character vectors"), 
#&gt;                 list("\n", "\n", "\n", list("as_character()"), 
#&gt;                   " and ", list("as_string()"), " have an optional ", 
#&gt;                   list("encoding"), "\n", "argument to specify the encoding. R uses this information for\n", 
#&gt;                   "internal handling of strings and character vectors. Note that this\n", 
#&gt;                   "is only declarative, no encoding conversion is attempted.\n", 
#&gt;                   "\n", "Note that only ", list("as_string()"), 
#&gt;                   " can coerce symbols to a scalar\n", "character vector. This makes the code more explicit and adds an\n", 
#&gt;                   "extra type check.\n")), "\n", "\n", list(list(
#&gt;                 "Coercion to lists"), list("\n", "\n", "\n", 
#&gt;                 list("as_list()"), " only coerces vector and dictionary types (environments\n", 
#&gt;                 "are an example of dictionary type). Unlike ", 
#&gt;                 list(list("base::as.list()")), ",\n", list("as_list()"), 
#&gt;                 " removes all attributes except names.\n")), 
#&gt;             "\n", "\n", list(list("Effects of removing attributes"), 
#&gt;                 list("\n", "\n", "\n", "A technical side-effect of removing the attributes of the input is\n", 
#&gt;                   "that the underlying objects has to be copied. This has no\n", 
#&gt;                   "performance implications in the case of lists because this is a\n", 
#&gt;                   "shallow copy: only the list structure is copied, not the contents\n", 
#&gt;                   "(see ", list(list("duplicate()")), "). However, be aware that atomic vectors\n", 
#&gt;                   "containing large amounts of data will have to be copied.\n", 
#&gt;                   "\n", "In general, any attribute modification creates a copy, which is why\n", 
#&gt;                   "it is better to avoid using attributes with heavy atomic vectors.\n", 
#&gt;                   "Uncopyable objects like environments and symbols are an exception\n", 
#&gt;                   "to this rule: in this case, attributes modification happens in\n", 
#&gt;                   "place and has side-effects.\n")), "\n", "\n", 
#&gt;             list("\n", "# Coercing atomic vectors removes attributes with both base R and rlang:\n", 
#&gt;                 "x &lt;- structure(TRUE, class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.logical(x)\n", "\n", "# But coercing lists preserves attributes in base R but not rlang:\n", 
#&gt;                 "l &lt;- structure(list(TRUE), class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# Implicit conversions are performed in base R but not rlang:\n", 
#&gt;                 "as.logical(l)\n", list("\n", "as_logical(l)\n"), 
#&gt;                 "\n", "\n", "# Conversion methods are bypassed, making the result of the\n", 
#&gt;                 "# coercion more predictable:\n", "as.list.foo &lt;- function(x) \"wrong\"\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# The input is never parsed. E.g. character vectors of numbers are\n", 
#&gt;                 "# not converted to numeric types:\n", "as.integer(\"33\")\n", 
#&gt;                 list("\n", "as_integer(\"33\")\n"), "\n", "\n", 
#&gt;                 "\n", "# With base R tools there is no way to convert an environment to a\n", 
#&gt;                 "# list without either triggering method dispatch, or changing the\n", 
#&gt;                 "# original environment. as_list() makes it easy:\n", 
#&gt;                 "x &lt;- structure(as_environment(mtcars[1:2]), class = \"foobar\")\n", 
#&gt;                 "as.list.foobar &lt;- function(x) abort(\"dont call me\")\n", 
#&gt;                 "as_list(x)\n"), "\n", list("internal"), "\n"), 
#&gt;         `vector-construction.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("vector-construction"), "\n", list("vector-construction"), 
#&gt;             "\n", list("lgl"), "\n", list("int"), "\n", list(
#&gt;                 "dbl"), "\n", list("cpl"), "\n", list("chr"), 
#&gt;             "\n", list("bytes"), "\n", list("ll"), "\n", list(
#&gt;                 "Create vectors"), "\n", list("\n", "lgl(...)\n", 
#&gt;                 "\n", "int(...)\n", "\n", "dbl(...)\n", "\n", 
#&gt;                 "cpl(...)\n", "\n", "chr(...)\n", "\n", "bytes(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Components of the new vector. Bare lists and explicitly\n", 
#&gt;                 "spliced lists are spliced.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "The atomic vector constructors are equivalent to ", 
#&gt;                 list(list("c()")), " but:\n", list("\n", list(), 
#&gt;                   " They allow you to be more explicit about the output\n", 
#&gt;                   "type. Implicit coercions (e.g. from integer to logical) follow\n", 
#&gt;                   "the rules described in ", list("vector-coercion"), 
#&gt;                   ".\n", list(), " They use ", list("tidy dots"), 
#&gt;                   " and thus support splicing with ", list("!!!"), 
#&gt;                   ".\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " All the abbreviated constructors such as ", 
#&gt;                   list("lgl()"), " will probably be\n", "moved to the vctrs package at some point. This is why they are\n", 
#&gt;                   "marked as questioning.\n", list(), " Automatic splicing is soft-deprecated and will trigger a warning\n", 
#&gt;                   "in a future version. Please splice explicitly with ", 
#&gt;                   list("!!!"), ".\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# These constructors are like a typed version of c():\n", 
#&gt;                 "c(TRUE, FALSE)\n", "lgl(TRUE, FALSE)\n", "\n", 
#&gt;                 "# They follow a restricted set of coercion rules:\n", 
#&gt;                 "int(TRUE, FALSE, 20)\n", "\n", "# Lists can be spliced:\n", 
#&gt;                 "dbl(10, !!! list(1, 2L), TRUE)\n", "\n", "\n", 
#&gt;                 "# They splice names a bit differently than c(). The latter\n", 
#&gt;                 "# automatically composes inner and outer names:\n", 
#&gt;                 "c(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "\n", "# On the other hand, rlang's ctors use the inner names and issue a\n", 
#&gt;                 "# warning to inform the user that the outer names are ignored:\n", 
#&gt;                 "dbl(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "dbl(a = c(1, 2))\n", "\n", "# As an exception, it is allowed to provide an outer name when the\n", 
#&gt;                 "# inner vector is an unnamed scalar atomic:\n", 
#&gt;                 "dbl(a = 1)\n", "\n", "# Spliced lists behave the same way:\n", 
#&gt;                 "dbl(!!! list(a = 1))\n", "dbl(!!! list(a = c(A = 1)))\n", 
#&gt;                 "\n", "# bytes() accepts integerish inputs\n", 
#&gt;                 "bytes(1:10)\n", "bytes(0x01, 0xff, c(0x03, 0x05), list(10, 20, 30L))\n"), 
#&gt;             "\n"), `vector-old-ctors.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("node"), "\n", list("node"), "\n", list(
#&gt;                 "vector-old-ctors"), "\n", list("lgl_len"), "\n", 
#&gt;             list("int_len"), "\n", list("dbl_len"), "\n", list(
#&gt;                 "chr_len"), "\n", list("cpl_len"), "\n", list(
#&gt;                 "raw_len"), "\n", list("bytes_len"), "\n", list(
#&gt;                 "list_len"), "\n", list("lgl_along"), "\n", list(
#&gt;                 "int_along"), "\n", list("dbl_along"), "\n", 
#&gt;             list("chr_along"), "\n", list("cpl_along"), "\n", 
#&gt;             list("raw_along"), "\n", list("bytes_along"), "\n", 
#&gt;             list("list_along"), "\n", list("Retired vector construction by length"), 
#&gt;             "\n", list("\n", "node(car, cdr = NULL)\n", "\n", 
#&gt;                 "lgl_len(.n)\n", "\n", "int_len(.n)\n", "\n", 
#&gt;                 "dbl_len(.n)\n", "\n", "chr_len(.n)\n", "\n", 
#&gt;                 "cpl_len(.n)\n", "\n", "raw_len(.n)\n", "\n", 
#&gt;                 "bytes_len(.n)\n", "\n", "list_len(.n)\n", "\n", 
#&gt;                 "lgl_along(.x)\n", "\n", "int_along(.x)\n", "\n", 
#&gt;                 "dbl_along(.x)\n", "\n", "chr_along(.x)\n", "\n", 
#&gt;                 "cpl_along(.x)\n", "\n", "raw_along(.x)\n", "\n", 
#&gt;                 "bytes_along(.x)\n", "\n", "list_along(.x)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("new_"), " prefix in\n", "rlang 0.2.0. This is for consistency with other non-variadic object\n", 
#&gt;                 "constructors.\n"), "\n", list("internal"), "\n"), 
#&gt;         with_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("with_abort"), "\n", list("with_abort"), 
#&gt;             "\n", list("Promote all errors to rlang errors"), 
#&gt;             "\n", list("\n", "with_abort(expr, classes = \"error\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression run in a context where errors are\n", 
#&gt;                 "promoted to rlang errors.")), "\n", "\n", list(
#&gt;                 list("classes"), list("Character vector of condition classes that should be\n", 
#&gt;                   "promoted to rlang errors.")), "\n"), "\n", 
#&gt;             list("\n", list("with_abort()"), " promotes conditions as if they were thrown with\n", 
#&gt;                 list(list("abort()")), ". These errors embed a ", 
#&gt;                 list("backtrace"), ". They are\n", "particularly suitable to be set as ", 
#&gt;                 list("parent errors"), " (see ", list("parent"), 
#&gt;                 "\n", "argument of ", list(list("abort()")), 
#&gt;                 ").\n"), "\n", list("\n", list("with_abort()"), 
#&gt;                 " installs a ", list("calling handler"), " for errors and\n", 
#&gt;                 "rethrows non-rlang errors with ", list(list(
#&gt;                   "abort()")), ". However, error handlers\n", 
#&gt;                 "installed ", list("within"), " ", list("with_abort()"), 
#&gt;                 " have priority. For this reason,\n", "you should use ", 
#&gt;                 list(list("tryCatch()")), " and ", list("exiting"), 
#&gt;                 " handlers outside\n", list("with_abort()"), 
#&gt;                 " rather than inside.\n"), "\n", list("\n", "# with_abort() automatically casts simple errors thrown by stop()\n", 
#&gt;                 "# to rlang errors. It is is handy for rethrowing low level\n", 
#&gt;                 "# errors. The backtraces are then segmented between the low level\n", 
#&gt;                 "# and high level contexts.\n", "f &lt;- function() g()\n", 
#&gt;                 "g &lt;- function() stop(\"Low level error\")\n", 
#&gt;                 "\n", "high_level &lt;- function() {\n", "  with_handlers(\n", 
#&gt;                 "    with_abort(f()),\n", "    error = ~ abort(\"High level error\", parent = .)\n", 
#&gt;                 "  )\n", "}\n"), "\n"), with_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("with_env"), "\n", list("with_env"), "\n", 
#&gt;             list("locally"), "\n", list("Evaluate an expression within a given environment"), 
#&gt;             "\n", list("\n", "with_env(env, expr)\n", "\n", "locally(expr)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment within which to evaluate ", 
#&gt;                 list("expr"), ". Can be\n", "an object with a ", 
#&gt;                 list(list("get_env()")), " method.")), "\n", 
#&gt;                 "\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions evaluate ", 
#&gt;                 list("expr"), " within a given environment (", 
#&gt;                 list("env"), "\n", "for ", list("with_env()"), 
#&gt;                 ", or the child of the current environment for\n", 
#&gt;                 list("locally"), "). They rely on ", list(list(
#&gt;                   "eval_bare()")), " which features a lighter\n", 
#&gt;                 "evaluation mechanism than base R ", list(list(
#&gt;                   "base::eval()")), ", and which also has\n", 
#&gt;                 "some subtle implications when evaluting stack sensitive functions\n", 
#&gt;                 "(see help for ", list(list("eval_bare()")), 
#&gt;                 ").\n"), "\n", list("\n", list("locally()"), 
#&gt;                 " is equivalent to the base function\n", list(
#&gt;                   list("base::local()")), " but it produces a much cleaner\n", 
#&gt;                 "evaluation stack, and has stack-consistent semantics. It is thus\n", 
#&gt;                 "more suited for experimenting with the R language.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "# with_env() is handy to create formulas with a given environment:\n", 
#&gt;                 "env &lt;- child_env(\"rlang\")\n", "f &lt;- with_env(env, ~new_formula())\n", 
#&gt;                 "identical(f_env(f), env)\n", "\n", "# Or functions with a given enclosure:\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(get_env(fn), env)\n", 
#&gt;                 "\n", "\n", "# Unlike eval() it doesn't create duplicates on the evaluation\n", 
#&gt;                 "# stack. You can thus use it e.g. to create non-local returns:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g(current_env())\n", 
#&gt;                 "  \"normal return\"\n", "}\n", "g &lt;- function(env) {\n", 
#&gt;                 "  with_env(env, return(\"early return\"))\n", 
#&gt;                 "}\n", "fn()\n", "\n", "\n", "# Since env is passed to as_environment(), it can be any object with an\n", 
#&gt;                 "# as_environment() method. For strings, the pkg_env() is returned:\n", 
#&gt;                 "with_env(\"base\", ~mtcars)\n", "\n", "# This can be handy to put dictionaries in scope:\n", 
#&gt;                 "with_env(mtcars, cyl)\n"), "\n", list("internal"), 
#&gt;             "\n"), with_handlers.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("with_handlers"), "\n", list("with_handlers"), 
#&gt;             "\n", list("calling"), "\n", list("Establish handlers on the stack"), 
#&gt;             "\n", list("\n", "with_handlers(.expr, ...)\n", "\n", 
#&gt;                 "calling(handler)\n"), "\n", list("\n", list(
#&gt;                 list(".expr"), list("An expression to execute in a context where new\n", 
#&gt;                   "handlers are established. The underscored version takes a quoted\n", 
#&gt;                   "expression or a quoted formula.")), "\n", 
#&gt;                 "\n", list(list("..."), list("Named handlers. These should be functions of one\n", 
#&gt;                   "argument. These handlers are treated as exiting by default. Use\n", 
#&gt;                   list(list("calling()")), " to specify a calling handler. These dots support\n", 
#&gt;                   list("tidy dots"), " features and are passed to ", 
#&gt;                   list(list("as_function()")), "\n", "to enable the formula shortcut for lambda functions.")), 
#&gt;                 "\n", "\n", list(list("handler"), list("A handler function that takes a condition as\n", 
#&gt;                   "argument. This is passed to ", list(list("as_function()")), 
#&gt;                   " and can thus be a\n", "formula describing a lambda function.")), 
#&gt;                 "\n"), "\n", list("\n", "Condition handlers are functions established on the evaluation\n", 
#&gt;                 "stack (see ", list(list("ctxt_stack()")), ") that are called by R when a condition is\n", 
#&gt;                 "signalled (see ", list(list("cnd_signal()")), 
#&gt;                 " and ", list(list("abort()")), " for two common signal\n", 
#&gt;                 "functions). They come in two types:\n", list(
#&gt;                   "\n", list(), " Exiting handlers aborts all code currently run between\n", 
#&gt;                   list("with_handlers()"), " and the point where the condition has been\n", 
#&gt;                   "raised. ", list("with_handlers()"), " passes the return value of the handler\n", 
#&gt;                   "to its caller.\n", list(), " Calling handlers, which are executed from inside the signalling\n", 
#&gt;                   "functions. Their return values are ignored, only their side\n", 
#&gt;                   "effects matters. Valid side effects are writing a log message, or\n", 
#&gt;                   "jumping out of the signalling context by ", 
#&gt;                   list("invoking a restart"), " or using ", list(
#&gt;                     list("return_from()")), ". If the raised\n", 
#&gt;                   "condition was an error, this interrupts the aborting process.\n", 
#&gt;                   "\n", "If a calling handler returns normally, it effectively declines to\n", 
#&gt;                   "handle the condition and other handlers on the stack (calling or\n", 
#&gt;                   "exiting) are given a chance to handle the condition.\n"), 
#&gt;                 "\n", "\n", "Handlers are exiting by default, use ", 
#&gt;                 list(list("calling()")), " to create a\n", "calling handler.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", " ", list(
#&gt;                 "exiting()"), " is soft-deprecated as of rlang\n", 
#&gt;                 "0.4.0 because ", list(list("with_handlers()")), 
#&gt;                 " now treats handlers as exiting by\n", "default.\n")), 
#&gt;             "\n", "\n", list("\n", "# Signal a condition with signal():\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"called?\\n\")\n", 
#&gt;                 "  \"fn() return value\"\n", "}\n", "g &lt;- function() {\n", 
#&gt;                 "  h()\n", "  cat(\"called?\\n\")\n", "}\n", 
#&gt;                 "h &lt;- function() {\n", "  signal(\"A foobar condition occurred\", \"foo\")\n", 
#&gt;                 "  cat(\"called?\\n\")\n", "}\n", "\n", "# Exiting handlers jump to with_handlers() before being\n", 
#&gt;                 "# executed. Their return value is handed over:\n", 
#&gt;                 "handler &lt;- function(c) \"handler return value\"\n", 
#&gt;                 "with_handlers(fn(), foo = handler)\n", "\n", 
#&gt;                 "# Calling handlers are called in turn and their return value is\n", 
#&gt;                 "# ignored. Returning just means they are declining to take charge of\n", 
#&gt;                 "# the condition. However, they can produce side-effects such as\n", 
#&gt;                 "# displaying a message:\n", "some_handler &lt;- function(c) cat(\"some handler!\\n\")\n", 
#&gt;                 "other_handler &lt;- function(c) cat(\"other handler!\\n\")\n", 
#&gt;                 "with_handlers(fn(), foo = calling(some_handler), foo = calling(other_handler))\n", 
#&gt;                 "\n", "# If a calling handler jumps to an earlier context, it takes\n", 
#&gt;                 "# charge of the condition and no other handler gets a chance to\n", 
#&gt;                 "# deal with it. The canonical way of transferring control is by\n", 
#&gt;                 "# jumping to a restart. See with_restarts() and restarting()\n", 
#&gt;                 "# documentation for more on this:\n", "exiting_handler &lt;- function(c) rst_jump(\"rst_foo\")\n", 
#&gt;                 "fn2 &lt;- function() {\n", "  with_restarts(g(), rst_foo = function() \"restart value\")\n", 
#&gt;                 "}\n", "with_handlers(fn2(), foo = calling(exiting_handler), foo = calling(other_handler))\n"), 
#&gt;             "\n"), with_restarts.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("with_restarts"), "\n", list("with_restarts"), 
#&gt;             "\n", list("Establish a restart point on the stack"), 
#&gt;             "\n", list("\n", "with_restarts(.expr, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".expr"), list("An expression to execute with new restarts established\n", 
#&gt;                 "on the stack. This argument is passed by expression and supports\n", 
#&gt;                 list("unquoting"), ". It is evaluated in a context where\n", 
#&gt;                 "restarts are established.")), "\n", "\n", list(
#&gt;                 list("..."), list("Named restart functions. The name is taken as the\n", 
#&gt;                   "restart name and the function is executed after the jump. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restart points are named functions that are established with\n", 
#&gt;                 list("with_restarts()"), ". Once established, you can interrupt the normal\n", 
#&gt;                 "execution of R code, jump to the restart, and resume execution from\n", 
#&gt;                 "there. Each restart is established along with a restart function\n", 
#&gt;                 "that is executed after the jump and that provides a return value\n", 
#&gt;                 "from the establishing point (i.e., a return value for\n", 
#&gt;                 list("with_restarts()"), ").\n"), "\n", list(
#&gt;                 "\n", "Restarts are not the only way of jumping to a previous call frame\n", 
#&gt;                 "(see ", list(list("return_from()")), " or ", 
#&gt;                 list(list("return_to()")), "). However, they have the\n", 
#&gt;                 "advantage of being callable by name once established.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Restarts are not the only way to jump to a previous frame, but\n", 
#&gt;                 "# they have the advantage of being callable by name:\n", 
#&gt;                 "fn &lt;- function() with_restarts(g(), my_restart = function() \"returned\")\n", 
#&gt;                 "g &lt;- function() h()\n", "h &lt;- function() { rst_jump(\"my_restart\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "# Whereas a non-local return requires to manually pass the calling\n", 
#&gt;                 "# frame to the return function:\n", "fn &lt;- function() g(current_env())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) { return_from(env, \"returned\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "\n", "# rst_maybe_jump() checks that a restart exists before trying to jump:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"will this be called?\\n\")\n", 
#&gt;                 "}\n", "g &lt;- function() {\n", "  rst_maybe_jump(\"my_restart\")\n", 
#&gt;                 "  cat(\"will this be called?\\n\")\n", "}\n", 
#&gt;                 "\n", "# Here no restart are on the stack:\n", 
#&gt;                 "fn()\n", "\n", "# If a restart point called `my_restart` was established on the\n", 
#&gt;                 "# stack before calling fn(), the control flow will jump there:\n", 
#&gt;                 "rst &lt;- function() {\n", "  cat(\"restarting...\\n\")\n", 
#&gt;                 "  \"return value\"\n", "}\n", "with_restarts(fn(), my_restart = rst)\n", 
#&gt;                 "\n", "\n", "# Restarts are particularly useful to provide alternative default\n", 
#&gt;                 "# values when the normal output cannot be computed:\n", 
#&gt;                 "\n", "fn &lt;- function(valid_input) {\n", "  if (valid_input) {\n", 
#&gt;                 "    return(\"normal value\")\n", "  }\n", "\n", 
#&gt;                 "  # We decide to return the empty string \"\" as default value. An\n", 
#&gt;                 "  # altenative strategy would be to signal an error. In any case,\n", 
#&gt;                 "  # we want to provide a way for the caller to get a different\n", 
#&gt;                 "  # output. For this purpose, we provide two restart functions that\n", 
#&gt;                 "  # returns alternative defaults:\n", "  restarts &lt;- list(\n", 
#&gt;                 "    rst_empty_chr = function() character(0),\n", 
#&gt;                 "    rst_null = function() NULL\n", "  )\n", 
#&gt;                 "\n", "  with_restarts(splice(restarts), .expr = {\n", 
#&gt;                 "\n", "    # Signal a typed condition to let the caller know that we are\n", 
#&gt;                 "    # about to return an empty string as default value:\n", 
#&gt;                 "    cnd_signal(\"default_empty_string\")\n", 
#&gt;                 "\n", "    # If no jump to with_restarts, return default value:\n", 
#&gt;                 "    \"\"\n", "  })\n", "}\n", "\n", "# Normal value for valid input:\n", 
#&gt;                 "fn(TRUE)\n", "\n", "# Default value for bad input:\n", 
#&gt;                 "fn(FALSE)\n", "\n", "# Change the default value if you need an empty character vector by\n", 
#&gt;                 "# defining a calling handler that jumps to the restart. It has to\n", 
#&gt;                 "# be calling because exiting handlers jump to the place where they\n", 
#&gt;                 "# are established before being executed, and the restart is not\n", 
#&gt;                 "# defined anymore at that point:\n", "rst_handler &lt;- calling(function(c) rst_jump(\"rst_empty_chr\"))\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = rst_handler)\n", 
#&gt;                 "\n", "# You can use restarting() to create restarting handlers easily:\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = restarting(\"rst_null\"))\n"), 
#&gt;             "\n", list("\n", list(list("return_from()")), " and ", 
#&gt;                 list(list("return_to()")), " for a more flexible way\n", 
#&gt;                 "of performing a non-local jump to an arbitrary call frame.\n"), 
#&gt;             "\n", list("internal"), "\n"), wref_key.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("wref_key"), "\n", list("wref_key"), "\n", list(
#&gt;                 "wref_value"), "\n", list("Get key/value from a weak reference object"), 
#&gt;             "\n", list("\n", "wref_key(x)\n", "\n", "wref_value(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A weak reference object.")), 
#&gt;                 "\n"), "\n", list("\n", "Get key/value from a weak reference object\n"), 
#&gt;             "\n", list("\n", list(list("is_weakref()")), " and ", 
#&gt;                 list(list("new_weakref()")), ".\n"), "\n"), zap.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "zap"), "\n", list("zap"), "\n", list("is_zap"), 
#&gt;             "\n", list("Create zap objects"), "\n", list("\n", 
#&gt;                 "zap()\n", "\n", "is_zap(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("zap()"), " creates a sentinel object that indicates that an object\n", 
#&gt;                 "should be removed. For instance, named zaps instruct ", 
#&gt;                 list(list("env_bind()")), "\n", "and ", list(
#&gt;                   list("call_modify()")), " to remove those objects from the environment or\n", 
#&gt;                 "the call.\n", "\n", "The advantage of zap objects is that they unambiguously signal the\n", 
#&gt;                 "intent of removing an object. Sentinels like ", 
#&gt;                 list("NULL"), " or\n", list(list("missing_arg()")), 
#&gt;                 " are ambiguous because they represent valid R\n", 
#&gt;                 "objects.\n"), "\n", list("\n", "# Create one zap object:\n", 
#&gt;                 "zap()\n", "\n", "# Create a list of zaps:\n", 
#&gt;                 "rep(list(zap()), 3)\n", "rep_named(c(\"foo\", \"bar\"), list(zap()))\n"), 
#&gt;             "\n")), source = list(abort.Rd = c("R/cnd-abort.R", 
#&gt;     "R/cnd-signal.R"), are_na.Rd = "R/vec-na.R", arg_match.Rd = "R/arg.R", 
#&gt;         as_box.Rd = "R/s3.R", as_bytes.Rd = "R/utils-encoding.R", 
#&gt;         as_data_mask.Rd = "R/eval-tidy.R", as_env.Rd = "R/lifecycle-retired.R", 
#&gt;         as_environment.Rd = "R/env.R", as_function.Rd = "R/fn.R", 
#&gt;         as_label.Rd = "R/deparse.R", as_name.Rd = "R/deparse.R", 
#&gt;         as_overscope.Rd = "R/lifecycle-retired.R", as_pairlist.Rd = "R/node.R", 
#&gt;         as_quosure.Rd = "R/quo.R", as_string.Rd = "R/sym.R", 
#&gt;         as_utf8_character.Rd = "R/utils-encoding.R", `bare-type-predicates.Rd` = "R/types.R", 
#&gt;         box.Rd = "R/s3.R", call2.Rd = "R/call.R", call_args.Rd = "R/call.R", 
#&gt;         call_fn.Rd = "R/call.R", call_inspect.Rd = "R/stack.R", 
#&gt;         call_modify.Rd = "R/call.R", call_name.Rd = "R/call.R", 
#&gt;         call_standardise.Rd = "R/call.R", caller_env.Rd = "R/env-special.R", 
#&gt;         caller_fn.Rd = "R/stack.R", caller_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         catch_cnd.Rd = "R/cnd-handlers.R", chr_unserialise_unicode.Rd = "R/utils-encoding.R", 
#&gt;         cnd.Rd = c("R/cnd-error.R", "R/cnd.R"), cnd_message.Rd = "R/cnd-message.R", 
#&gt;         cnd_muffle.Rd = "R/cnd-handlers.R", cnd_signal.Rd = "R/cnd-signal.R", 
#&gt;         cnd_type.Rd = "R/cnd.R", done.Rd = "R/s3.R", dots_definitions.Rd = "R/dots.R", 
#&gt;         dots_n.Rd = "R/dots.R", dots_values.Rd = "R/dots.R", 
#&gt;         duplicate.Rd = "R/sexp.R", empty_env.Rd = "R/env-special.R", 
#&gt;         entrace.Rd = "R/cnd-entrace.R", env.Rd = "R/env.R", env_bind.Rd = "R/env-binding.R", 
#&gt;         env_bind_exprs.Rd = "R/lifecycle-retired.R", env_binding_are_active.Rd = "R/env-binding.R", 
#&gt;         env_binding_lock.Rd = "R/env-binding.R", env_bury.Rd = "R/env-binding.R", 
#&gt;         env_clone.Rd = "R/env.R", env_depth.Rd = "R/env.R", env_get.Rd = "R/env-binding.R", 
#&gt;         env_has.Rd = "R/env-binding.R", env_inherits.Rd = "R/env.R", 
#&gt;         env_lock.Rd = "R/env.R", env_name.Rd = "R/env-special.R", 
#&gt;         env_names.Rd = "R/env-binding.R", env_parent.Rd = "R/env.R", 
#&gt;         env_poke.Rd = "R/env-binding.R", env_print.Rd = "R/env.R", 
#&gt;         env_unbind.Rd = "R/env-binding.R", env_unlock.Rd = "R/env.R", 
#&gt;         eval_bare.Rd = "R/eval.R", eval_tidy.Rd = "R/eval-tidy.R", 
#&gt;         exec.Rd = "R/eval.R", exiting.Rd = "R/lifecycle-retired.R", 
#&gt;         expr_interp.Rd = "R/quasiquotation.R", expr_label.Rd = "R/expr.R", 
#&gt;         expr_print.Rd = "R/expr.R", exprs_auto_name.Rd = "R/quotation.R", 
#&gt;         f_rhs.Rd = "R/formula.R", f_text.Rd = "R/formula.R", 
#&gt;         flatten.Rd = "R/vec-squash.R", fn_body.Rd = "R/fn.R", 
#&gt;         fn_env.Rd = "R/fn.R", fn_fmls.Rd = "R/fn.R", frame_position.Rd = "R/lifecycle-retired.R", 
#&gt;         friendly_type.Rd = "R/types.R", get_env.Rd = "R/env.R", 
#&gt;         has_length.Rd = "R/attr.R", has_name.Rd = "R/attr.R", 
#&gt;         inherits_any.Rd = "R/s3.R", invoke.Rd = "R/eval.R", is_call.Rd = "R/call.R", 
#&gt;         is_callable.Rd = "R/call.R", is_condition.Rd = "R/cnd.R", 
#&gt;         is_copyable.Rd = "R/types.R", is_empty.Rd = "R/types.R", 
#&gt;         is_env.Rd = "R/lifecycle-retired.R", is_environment.Rd = "R/types.R", 
#&gt;         is_expr.Rd = "R/lifecycle-retired.R", is_expression.Rd = "R/expr.R", 
#&gt;         is_formula.Rd = "R/formula.R", is_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         is_function.Rd = "R/fn.R", is_installed.Rd = "R/env-special.R", 
#&gt;         is_integerish.Rd = "R/types.R", is_interactive.Rd = "R/state.R", 
#&gt;         is_lang.Rd = "R/lifecycle-retired.R", is_named.Rd = "R/attr.R", 
#&gt;         is_namespace.Rd = "R/env-special.R", is_pairlist.Rd = "R/node.R", 
#&gt;         is_reference.Rd = "R/types.R", is_stack.Rd = "R/lifecycle-retired.R", 
#&gt;         is_symbol.Rd = "R/sym.R", is_true.Rd = "R/types.R", is_weakref.Rd = "R/weakref.R", 
#&gt;         lang.Rd = "R/lifecycle-retired.R", lang_head.Rd = "R/lifecycle-retired.R", 
#&gt;         lang_modify.Rd = "R/lifecycle-retired.R", last_error.Rd = "R/cnd-abort.R", 
#&gt;         lifecycle.Rd = "R/lifecycle.R", missing.Rd = "R/vec-na.R", 
#&gt;         missing_arg.Rd = "R/arg.R", mut_node_car.Rd = "R/lifecycle-retired.R", 
#&gt;         names2.Rd = "R/attr.R", `new-vector-along-retired.Rd` = "R/lifecycle-retired.R", 
#&gt;         `new-vector.Rd` = "R/vec-new.R", new_call.Rd = "R/node.R", 
#&gt;         new_formula.Rd = "R/formula.R", new_function.Rd = "R/fn.R", 
#&gt;         new_node.Rd = "R/node.R", new_quosures.Rd = "R/quo.R", 
#&gt;         new_weakref.Rd = "R/weakref.R", ns_env.Rd = "R/env-special.R", 
#&gt;         `op-definition.Rd` = "R/operators.R", `op-get-attr.Rd` = "R/operators.R", 
#&gt;         `op-na-default.Rd` = "R/operators.R", `op-null-default.Rd` = "R/operators.R", 
#&gt;         overscope_eval_next.Rd = "R/lifecycle-retired.R", pairlist2.Rd = "R/call.R", 
#&gt;         parse_expr.Rd = "R/parse.R", parse_quosure.Rd = "R/lifecycle-retired.R", 
#&gt;         prepend.Rd = "R/lifecycle-retired.R", prim_name.Rd = "R/fn.R", 
#&gt;         quasiquotation.Rd = "R/quasiquotation.R", quo_expr.Rd = "R/lifecycle-retired.R", 
#&gt;         quo_label.Rd = "R/quo.R", quo_squash.Rd = "R/quo.R", 
#&gt;         quosure.Rd = "R/quo.R", quotation.Rd = "R/quotation.R", 
#&gt;         rep_along.Rd = "R/vec-new.R", restarting.Rd = "R/cnd-handlers.R", 
#&gt;         return_from.Rd = "R/stack.R", rlang_backtrace_on_error.Rd = "R/cnd-abort.R", 
#&gt;         rst_abort.Rd = "R/cnd-restarts.R", rst_list.Rd = "R/cnd-restarts.R", 
#&gt;         `scalar-type-predicates.Rd` = "R/types.R", scoped_bindings.Rd = "R/env-binding.R", 
#&gt;         scoped_env.Rd = "R/lifecycle-retired.R", scoped_options.Rd = "R/state.R", 
#&gt;         search_envs.Rd = "R/env-special.R", seq2.Rd = "R/vec.R", 
#&gt;         set_attrs.Rd = "R/lifecycle-retired.R", set_expr.Rd = "R/expr.R", 
#&gt;         set_names.Rd = "R/attr.R", splice.Rd = "R/dots.R", stack.Rd = "R/lifecycle-retired.R", 
#&gt;         stack_trim.Rd = "R/lifecycle-retired.R", string.Rd = "R/utils-encoding.R", 
#&gt;         switch_type.Rd = "R/lifecycle-retired.R", sym.Rd = "R/sym.R", 
#&gt;         `tidy-dots.Rd` = c("R/dots.R", "R/vec-new.R"), `tidyeval-data.Rd` = "R/eval-tidy.R", 
#&gt;         trace_back.Rd = "R/trace.R", `type-predicates.Rd` = "R/types.R", 
#&gt;         type_of.Rd = "R/lifecycle-retired.R", vec_poke_n.Rd = "R/vec.R", 
#&gt;         `vector-coercion.Rd` = "R/lifecycle-retired.R", `vector-construction.Rd` = "R/vec-new.R", 
#&gt;         `vector-old-ctors.Rd` = "R/lifecycle-retired.R", with_abort.Rd = "R/cnd-entrace.R", 
#&gt;         with_env.Rd = "R/eval.R", with_handlers.Rd = "R/cnd-handlers.R", 
#&gt;         with_restarts.Rd = "R/cnd-restarts.R", wref_key.Rd = "R/weakref.R", 
#&gt;         zap.Rd = "R/s3.R"), concepts = list(abort.Rd = character(0), 
#&gt;         are_na.Rd = character(0), arg_match.Rd = character(0), 
#&gt;         as_box.Rd = character(0), as_bytes.Rd = character(0), 
#&gt;         as_data_mask.Rd = character(0), as_env.Rd = character(0), 
#&gt;         as_environment.Rd = character(0), as_function.Rd = character(0), 
#&gt;         as_label.Rd = character(0), as_name.Rd = character(0), 
#&gt;         as_overscope.Rd = character(0), as_pairlist.Rd = character(0), 
#&gt;         as_quosure.Rd = character(0), as_string.Rd = character(0), 
#&gt;         as_utf8_character.Rd = character(0), `bare-type-predicates.Rd` = character(0), 
#&gt;         box.Rd = character(0), call2.Rd = character(0), call_args.Rd = character(0), 
#&gt;         call_fn.Rd = character(0), call_inspect.Rd = character(0), 
#&gt;         call_modify.Rd = character(0), call_name.Rd = character(0), 
#&gt;         call_standardise.Rd = character(0), caller_env.Rd = character(0), 
#&gt;         caller_fn.Rd = character(0), caller_frame.Rd = character(0), 
#&gt;         catch_cnd.Rd = character(0), chr_unserialise_unicode.Rd = character(0), 
#&gt;         cnd.Rd = character(0), cnd_message.Rd = character(0), 
#&gt;         cnd_muffle.Rd = character(0), cnd_signal.Rd = character(0), 
#&gt;         cnd_type.Rd = character(0), done.Rd = character(0), dots_definitions.Rd = character(0), 
#&gt;         dots_n.Rd = character(0), dots_values.Rd = character(0), 
#&gt;         duplicate.Rd = character(0), empty_env.Rd = character(0), 
#&gt;         entrace.Rd = character(0), env.Rd = character(0), env_bind.Rd = character(0), 
#&gt;         env_bind_exprs.Rd = character(0), env_binding_are_active.Rd = character(0), 
#&gt;         env_binding_lock.Rd = character(0), env_bury.Rd = character(0), 
#&gt;         env_clone.Rd = character(0), env_depth.Rd = character(0), 
#&gt;         env_get.Rd = character(0), env_has.Rd = character(0), 
#&gt;         env_inherits.Rd = character(0), env_lock.Rd = character(0), 
#&gt;         env_name.Rd = character(0), env_names.Rd = character(0), 
#&gt;         env_parent.Rd = character(0), env_poke.Rd = character(0), 
#&gt;         env_print.Rd = character(0), env_unbind.Rd = character(0), 
#&gt;         env_unlock.Rd = character(0), eval_bare.Rd = character(0), 
#&gt;         eval_tidy.Rd = character(0), exec.Rd = character(0), 
#&gt;         exiting.Rd = character(0), expr_interp.Rd = character(0), 
#&gt;         expr_label.Rd = character(0), expr_print.Rd = character(0), 
#&gt;         exprs_auto_name.Rd = character(0), f_rhs.Rd = character(0), 
#&gt;         f_text.Rd = character(0), flatten.Rd = character(0), 
#&gt;         fn_body.Rd = character(0), fn_env.Rd = character(0), 
#&gt;         fn_fmls.Rd = character(0), frame_position.Rd = character(0), 
#&gt;         friendly_type.Rd = character(0), get_env.Rd = character(0), 
#&gt;         has_length.Rd = character(0), has_name.Rd = character(0), 
#&gt;         inherits_any.Rd = character(0), invoke.Rd = character(0), 
#&gt;         is_call.Rd = character(0), is_callable.Rd = character(0), 
#&gt;         is_condition.Rd = character(0), is_copyable.Rd = character(0), 
#&gt;         is_empty.Rd = character(0), is_env.Rd = character(0), 
#&gt;         is_environment.Rd = character(0), is_expr.Rd = character(0), 
#&gt;         is_expression.Rd = character(0), is_formula.Rd = character(0), 
#&gt;         is_frame.Rd = character(0), is_function.Rd = character(0), 
#&gt;         is_installed.Rd = character(0), is_integerish.Rd = character(0), 
#&gt;         is_interactive.Rd = character(0), is_lang.Rd = character(0), 
#&gt;         is_named.Rd = character(0), is_namespace.Rd = character(0), 
#&gt;         is_pairlist.Rd = character(0), is_reference.Rd = character(0), 
#&gt;         is_stack.Rd = character(0), is_symbol.Rd = character(0), 
#&gt;         is_true.Rd = character(0), is_weakref.Rd = character(0), 
#&gt;         lang.Rd = character(0), lang_head.Rd = character(0), 
#&gt;         lang_modify.Rd = character(0), last_error.Rd = character(0), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = character(0), 
#&gt;         missing_arg.Rd = character(0), mut_node_car.Rd = character(0), 
#&gt;         names2.Rd = character(0), `new-vector-along-retired.Rd` = character(0), 
#&gt;         `new-vector.Rd` = character(0), new_call.Rd = character(0), 
#&gt;         new_formula.Rd = character(0), new_function.Rd = character(0), 
#&gt;         new_node.Rd = character(0), new_quosures.Rd = character(0), 
#&gt;         new_weakref.Rd = character(0), ns_env.Rd = character(0), 
#&gt;         `op-definition.Rd` = character(0), `op-get-attr.Rd` = character(0), 
#&gt;         `op-na-default.Rd` = character(0), `op-null-default.Rd` = character(0), 
#&gt;         overscope_eval_next.Rd = character(0), pairlist2.Rd = character(0), 
#&gt;         parse_expr.Rd = character(0), parse_quosure.Rd = character(0), 
#&gt;         prepend.Rd = character(0), prim_name.Rd = character(0), 
#&gt;         quasiquotation.Rd = character(0), quo_expr.Rd = character(0), 
#&gt;         quo_label.Rd = character(0), quo_squash.Rd = character(0), 
#&gt;         quosure.Rd = character(0), quotation.Rd = character(0), 
#&gt;         rep_along.Rd = character(0), restarting.Rd = character(0), 
#&gt;         return_from.Rd = character(0), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = character(0), rst_list.Rd = character(0), 
#&gt;         `scalar-type-predicates.Rd` = character(0), scoped_bindings.Rd = character(0), 
#&gt;         scoped_env.Rd = character(0), scoped_options.Rd = character(0), 
#&gt;         search_envs.Rd = character(0), seq2.Rd = character(0), 
#&gt;         set_attrs.Rd = character(0), set_expr.Rd = character(0), 
#&gt;         set_names.Rd = character(0), splice.Rd = character(0), 
#&gt;         stack.Rd = character(0), stack_trim.Rd = character(0), 
#&gt;         string.Rd = character(0), switch_type.Rd = character(0), 
#&gt;         sym.Rd = character(0), `tidy-dots.Rd` = character(0), 
#&gt;         `tidyeval-data.Rd` = character(0), trace_back.Rd = character(0), 
#&gt;         `type-predicates.Rd` = character(0), type_of.Rd = character(0), 
#&gt;         vec_poke_n.Rd = character(0), `vector-coercion.Rd` = character(0), 
#&gt;         `vector-construction.Rd` = character(0), `vector-old-ctors.Rd` = character(0), 
#&gt;         with_abort.Rd = character(0), with_env.Rd = character(0), 
#&gt;         with_handlers.Rd = character(0), with_restarts.Rd = character(0), 
#&gt;         wref_key.Rd = character(0), zap.Rd = character(0)), internal = c(FALSE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, FALSE, FALSE)), tutorials = list(name = character(0), 
#&gt;         file_out = character(0), title = character(0), pagetitle = character(0), 
#&gt;         url = character(0)), vignettes = list(name = character(0), 
#&gt;         file_in = character(0), file_out = character(0), title = character(0)), 
#&gt;     topic_index = c(`:=` = "quasiquotation", `!!` = "quasiquotation", 
#&gt;     `!!!` = "quasiquotation", .data = "tidyeval-data", `{{` = "quasiquotation", 
#&gt;     `{{}}` = "quasiquotation", `%@%` = "op-get-attr", `%@%&lt;-` = "op-get-attr", 
#&gt;     `%|%` = "op-na-default", `%||%` = "op-null-default", abort = "abort", 
#&gt;     add_backtrace = "rlang_backtrace_on_error", are_na = "are_na", 
#&gt;     arg_match = "arg_match", as_box = "as_box", as_box_if = "as_box", 
#&gt;     as_bytes = "as_bytes", as_character = "vector-coercion", 
#&gt;     as_closure = "as_function", as_complex = "vector-coercion", 
#&gt;     as_data_mask = "as_data_mask", as_data_pronoun = "as_data_mask", 
#&gt;     as_double = "vector-coercion", as_env = "as_env", as_environment = "as_environment", 
#&gt;     as_function = "as_function", as_integer = "vector-coercion", 
#&gt;     as_label = "as_label", as_list = "vector-coercion", as_logical = "vector-coercion", 
#&gt;     as_name = "as_name", as_overscope = "as_overscope", as_pairlist = "as_pairlist", 
#&gt;     as_quosure = "as_quosure", as_quosures = "new_quosures", 
#&gt;     as_string = "as_string", as_utf8_character = "as_utf8_character", 
#&gt;     `bare-type-predicates` = "bare-type-predicates", base_env = "search_envs", 
#&gt;     box = "box", bytes = "vector-construction", bytes_along = "vector-old-ctors", 
#&gt;     bytes_len = "vector-old-ctors", call_args = "call_args", 
#&gt;     call_args_names = "call_args", call_depth = "stack", call_fn = "call_fn", 
#&gt;     call_frame = "stack", call_inspect = "call_inspect", call_modify = "call_modify", 
#&gt;     call_name = "call_name", call_ns = "call_name", call_stack = "stack", 
#&gt;     call_standardise = "call_standardise", call2 = "call2", caller_env = "caller_env", 
#&gt;     caller_fn = "caller_fn", caller_frame = "caller_frame", calling = "with_handlers", 
#&gt;     catch_cnd = "catch_cnd", child_env = "env", chr = "vector-construction", 
#&gt;     chr_along = "vector-old-ctors", chr_len = "vector-old-ctors", 
#&gt;     chr_unserialise_unicode = "chr_unserialise_unicode", cnd = "cnd", 
#&gt;     cnd_bullets = "cnd_message", cnd_entrace = "entrace", cnd_issue = "cnd_message", 
#&gt;     cnd_message = "cnd_message", cnd_muffle = "cnd_muffle", cnd_signal = "cnd_signal", 
#&gt;     cnd_type = "cnd_type", coerce_class = "switch_type", coerce_type = "switch_type", 
#&gt;     cpl = "vector-construction", cpl_along = "vector-old-ctors", 
#&gt;     cpl_len = "vector-old-ctors", ctxt_depth = "stack", ctxt_frame = "stack", 
#&gt;     ctxt_stack = "stack", current_env = "caller_env", current_fn = "caller_fn", 
#&gt;     current_frame = "stack", dbl = "vector-construction", dbl_along = "vector-old-ctors", 
#&gt;     dbl_len = "vector-old-ctors", done = "done", dots_definitions = "dots_definitions", 
#&gt;     dots_list = "tidy-dots", dots_n = "dots_n", dots_splice = "splice", 
#&gt;     dots_values = "dots_values", duplicate = "duplicate", empty_env = "empty_env", 
#&gt;     enexpr = "quotation", enexprs = "quotation", enquo = "quotation", 
#&gt;     enquos = "quotation", ensym = "quotation", ensyms = "quotation", 
#&gt;     entrace = "entrace", env = "env", env_bind = "env_bind", 
#&gt;     env_bind_active = "env_bind", env_bind_exprs = "env_bind_exprs", 
#&gt;     env_bind_fns = "env_bind_exprs", env_bind_lazy = "env_bind", 
#&gt;     env_binding_are_active = "env_binding_are_active", env_binding_are_lazy = "env_binding_are_active", 
#&gt;     env_binding_are_locked = "env_binding_lock", env_binding_lock = "env_binding_lock", 
#&gt;     env_binding_unlock = "env_binding_lock", env_bury = "env_bury", 
#&gt;     env_clone = "env_clone", env_depth = "env_depth", env_get = "env_get", 
#&gt;     env_get_list = "env_get", env_has = "env_has", env_inherits = "env_inherits", 
#&gt;     env_is_locked = "env_lock", env_label = "env_name", env_length = "env_names", 
#&gt;     env_lock = "env_lock", env_name = "env_name", env_names = "env_names", 
#&gt;     env_parent = "env_parent", env_parents = "env_parent", env_poke = "env_poke", 
#&gt;     env_poke_parent = "get_env", env_print = "env_print", env_tail = "env_parent", 
#&gt;     env_unbind = "env_unbind", env_unlock = "env_unlock", error_cnd = "cnd", 
#&gt;     eval_bare = "eval_bare", eval_tidy = "eval_tidy", exec = "exec", 
#&gt;     exiting = "exiting", expr = "quotation", expr_deparse = "expr_print", 
#&gt;     expr_interp = "expr_interp", expr_label = "expr_label", expr_name = "expr_label", 
#&gt;     expr_print = "expr_print", expr_text = "expr_label", exprs = "quotation", 
#&gt;     exprs_auto_name = "exprs_auto_name", f_env = "f_rhs", `f_env&lt;-` = "f_rhs", 
#&gt;     f_label = "f_text", f_lhs = "f_rhs", `f_lhs&lt;-` = "f_rhs", 
#&gt;     f_name = "f_text", f_rhs = "f_rhs", `f_rhs&lt;-` = "f_rhs", 
#&gt;     f_text = "f_text", flatten = "flatten", flatten_chr = "flatten", 
#&gt;     flatten_cpl = "flatten", flatten_dbl = "flatten", flatten_if = "flatten", 
#&gt;     flatten_int = "flatten", flatten_lgl = "flatten", flatten_raw = "flatten", 
#&gt;     fn_body = "fn_body", `fn_body&lt;-` = "fn_body", fn_env = "fn_env", 
#&gt;     `fn_env&lt;-` = "fn_env", fn_fmls = "fn_fmls", fn_fmls_names = "fn_fmls", 
#&gt;     `fn_fmls_names&lt;-` = "fn_fmls", fn_fmls_syms = "fn_fmls", 
#&gt;     `fn_fmls&lt;-` = "fn_fmls", format_bullets = "cnd_message", 
#&gt;     frame_position = "frame_position", friendly_type = "friendly_type", 
#&gt;     get_env = "get_env", get_expr = "set_expr", global_env = "search_envs", 
#&gt;     global_frame = "stack", has_length = "has_length", has_name = "has_name", 
#&gt;     have_name = "is_named", inform = "abort", inherits_all = "inherits_any", 
#&gt;     inherits_any = "inherits_any", inherits_only = "inherits_any", 
#&gt;     int = "vector-construction", int_along = "vector-old-ctors", 
#&gt;     int_len = "vector-old-ctors", interrupt = "abort", invoke = "invoke", 
#&gt;     is_atomic = "type-predicates", is_attached = "search_envs", 
#&gt;     is_bare_atomic = "bare-type-predicates", is_bare_bytes = "bare-type-predicates", 
#&gt;     is_bare_character = "bare-type-predicates", is_bare_double = "bare-type-predicates", 
#&gt;     is_bare_env = "is_env", is_bare_environment = "is_environment", 
#&gt;     is_bare_formula = "is_formula", is_bare_integer = "bare-type-predicates", 
#&gt;     is_bare_integerish = "is_integerish", is_bare_list = "bare-type-predicates", 
#&gt;     is_bare_logical = "bare-type-predicates", is_bare_numeric = "bare-type-predicates", 
#&gt;     is_bare_raw = "bare-type-predicates", is_bare_string = "bare-type-predicates", 
#&gt;     is_bare_vector = "bare-type-predicates", is_binary_lang = "is_lang", 
#&gt;     is_bool = "scalar-type-predicates", is_box = "box", is_bytes = "type-predicates", 
#&gt;     is_call = "is_call", is_call_stack = "is_stack", is_callable = "is_callable", 
#&gt;     is_character = "type-predicates", is_chr_na = "are_na", is_closure = "is_function", 
#&gt;     is_condition = "is_condition", is_copyable = "is_copyable", 
#&gt;     is_cpl_na = "are_na", is_dbl_na = "are_na", is_definition = "op-definition", 
#&gt;     is_dictionaryish = "is_named", is_done_box = "done", is_double = "type-predicates", 
#&gt;     is_empty = "is_empty", is_env = "is_env", is_environment = "is_environment", 
#&gt;     is_eval_stack = "is_stack", is_expr = "is_expr", is_expression = "is_expression", 
#&gt;     is_false = "is_true", is_formula = "is_formula", is_formulaish = "op-definition", 
#&gt;     is_frame = "is_frame", is_function = "is_function", is_installed = "is_installed", 
#&gt;     is_int_na = "are_na", is_integer = "type-predicates", is_integerish = "is_integerish", 
#&gt;     is_interactive = "is_interactive", is_lambda = "as_function", 
#&gt;     is_lang = "is_lang", is_lgl_na = "are_na", is_list = "type-predicates", 
#&gt;     is_logical = "type-predicates", is_missing = "missing_arg", 
#&gt;     is_na = "are_na", is_named = "is_named", is_namespace = "is_namespace", 
#&gt;     is_node = "is_pairlist", is_node_list = "is_pairlist", is_null = "type-predicates", 
#&gt;     is_pairlist = "is_pairlist", is_primitive = "is_function", 
#&gt;     is_primitive_eager = "is_function", is_primitive_lazy = "is_function", 
#&gt;     is_quosure = "quosure", is_quosures = "new_quosures", is_raw = "type-predicates", 
#&gt;     is_reference = "is_reference", is_scalar_atomic = "scalar-type-predicates", 
#&gt;     is_scalar_bytes = "scalar-type-predicates", is_scalar_character = "scalar-type-predicates", 
#&gt;     is_scalar_double = "scalar-type-predicates", is_scalar_integer = "scalar-type-predicates", 
#&gt;     is_scalar_integerish = "is_integerish", is_scalar_list = "scalar-type-predicates", 
#&gt;     is_scalar_logical = "scalar-type-predicates", is_scalar_raw = "scalar-type-predicates", 
#&gt;     is_scalar_vector = "scalar-type-predicates", is_scoped = "scoped_env", 
#&gt;     is_spliced = "splice", is_spliced_bare = "splice", is_stack = "is_stack", 
#&gt;     is_string = "scalar-type-predicates", is_symbol = "is_symbol", 
#&gt;     is_symbolic = "is_expression", is_syntactic_literal = "is_expression", 
#&gt;     is_true = "is_true", is_unary_lang = "is_lang", is_vector = "type-predicates", 
#&gt;     is_weakref = "is_weakref", is_zap = "zap", lang = "lang", 
#&gt;     lang_args = "lang_modify", lang_args_names = "lang_modify", 
#&gt;     lang_fn = "lang_modify", lang_head = "lang_head", lang_modify = "lang_modify", 
#&gt;     lang_name = "lang_modify", lang_standardise = "lang_modify", 
#&gt;     lang_tail = "lang_head", last_error = "last_error", last_trace = "last_error", 
#&gt;     lgl = "vector-construction", lgl_along = "vector-old-ctors", 
#&gt;     lgl_len = "vector-old-ctors", lifecycle = "lifecycle", list_along = "vector-old-ctors", 
#&gt;     list_len = "vector-old-ctors", list2 = "tidy-dots", ll = "vector-construction", 
#&gt;     locally = "with_env", maybe_missing = "missing_arg", message_cnd = "cnd", 
#&gt;     missing = "missing", missing_arg = "missing_arg", modify = "prepend", 
#&gt;     mut_attrs = "set_attrs", mut_node_caar = "mut_node_car", 
#&gt;     mut_node_cadr = "mut_node_car", mut_node_car = "mut_node_car", 
#&gt;     mut_node_cdar = "mut_node_car", mut_node_cddr = "mut_node_car", 
#&gt;     mut_node_cdr = "mut_node_car", mut_node_tag = "mut_node_car", 
#&gt;     na_chr = "missing", na_cpl = "missing", na_dbl = "missing", 
#&gt;     na_int = "missing", na_lgl = "missing", names2 = "names2", 
#&gt;     new_box = "box", new_call = "new_call", new_character = "new-vector", 
#&gt;     new_character_along = "new-vector-along-retired", new_complex = "new-vector", 
#&gt;     new_complex_along = "new-vector-along-retired", new_data_mask = "as_data_mask", 
#&gt;     new_definition = "op-definition", new_double = "new-vector", 
#&gt;     new_double_along = "new-vector-along-retired", new_environment = "env", 
#&gt;     new_formula = "new_formula", new_function = "new_function", 
#&gt;     new_integer = "new-vector", new_integer_along = "new-vector-along-retired", 
#&gt;     new_language = "lang", new_list = "new-vector", new_list_along = "new-vector-along-retired", 
#&gt;     new_logical = "new-vector", new_logical_along = "new-vector-along-retired", 
#&gt;     new_node = "new_node", new_overscope = "as_overscope", new_quosure = "as_quosure", 
#&gt;     new_quosures = "new_quosures", new_raw = "new-vector", new_raw_along = "new-vector-along-retired", 
#&gt;     new_weakref = "new_weakref", `new-vector` = "new-vector", 
#&gt;     `new-vector-along-retired` = "new-vector-along-retired", 
#&gt;     node = "vector-old-ctors", node_caar = "new_node", node_cadr = "new_node", 
#&gt;     node_car = "new_node", node_cdar = "new_node", node_cddr = "new_node", 
#&gt;     node_cdr = "new_node", node_poke_caar = "new_node", node_poke_cadr = "new_node", 
#&gt;     node_poke_car = "new_node", node_poke_cdar = "new_node", 
#&gt;     node_poke_cddr = "new_node", node_poke_cdr = "new_node", 
#&gt;     node_poke_tag = "new_node", node_tag = "new_node", ns_env = "ns_env", 
#&gt;     ns_env_name = "ns_env", ns_imports_env = "ns_env", `op-definition` = "op-definition", 
#&gt;     `op-get-attr` = "op-get-attr", `op-na-default` = "op-na-default", 
#&gt;     `op-null-default` = "op-null-default", overscope_clean = "as_overscope", 
#&gt;     overscope_eval_next = "overscope_eval_next", pairlist2 = "pairlist2", 
#&gt;     parse_expr = "parse_expr", parse_exprs = "parse_expr", parse_quo = "parse_expr", 
#&gt;     parse_quos = "parse_expr", parse_quosure = "parse_quosure", 
#&gt;     parse_quosures = "parse_quosure", peek_option = "scoped_options", 
#&gt;     peek_options = "scoped_options", pkg_env = "search_envs", 
#&gt;     pkg_env_name = "search_envs", prepend = "prepend", prim_name = "prim_name", 
#&gt;     push_options = "scoped_options", qq_show = "quasiquotation", 
#&gt;     quasiquotation = "quasiquotation", quo = "quotation", quo_expr = "quo_expr", 
#&gt;     quo_get_env = "quosure", quo_get_expr = "quosure", quo_is_call = "quosure", 
#&gt;     quo_is_lang = "is_lang", quo_is_missing = "quosure", quo_is_null = "quosure", 
#&gt;     quo_is_symbol = "quosure", quo_is_symbolic = "quosure", quo_label = "quo_label", 
#&gt;     quo_name = "quo_label", quo_set_env = "quosure", quo_set_expr = "quosure", 
#&gt;     quo_squash = "quo_squash", quo_text = "quo_label", quos = "quotation", 
#&gt;     quos_auto_name = "exprs_auto_name", quosure = "quosure", 
#&gt;     quotation = "quotation", raw_along = "vector-old-ctors", 
#&gt;     raw_len = "vector-old-ctors", rep_along = "rep_along", rep_named = "rep_along", 
#&gt;     restarting = "restarting", return_from = "return_from", return_to = "return_from", 
#&gt;     rlang_backtrace_on_error = "rlang_backtrace_on_error", rst_abort = "rst_abort", 
#&gt;     rst_exists = "rst_list", rst_jump = "rst_list", rst_list = "rst_list", 
#&gt;     rst_maybe_jump = "rst_list", `scalar-type-predicates` = "scalar-type-predicates", 
#&gt;     scoped_bindings = "scoped_bindings", scoped_env = "scoped_env", 
#&gt;     scoped_envs = "scoped_env", scoped_interactive = "is_interactive", 
#&gt;     scoped_names = "scoped_env", scoped_options = "scoped_options", 
#&gt;     search_env = "search_envs", search_envs = "search_envs", 
#&gt;     seq2 = "seq2", seq2_along = "seq2", set_attrs = "set_attrs", 
#&gt;     set_env = "get_env", set_expr = "set_expr", set_names = "set_names", 
#&gt;     signal = "abort", splice = "splice", squash = "flatten", 
#&gt;     squash_chr = "flatten", squash_cpl = "flatten", squash_dbl = "flatten", 
#&gt;     squash_if = "flatten", squash_int = "flatten", squash_lgl = "flatten", 
#&gt;     squash_raw = "flatten", stack = "stack", stack_trim = "stack_trim", 
#&gt;     string = "string", switch_class = "switch_type", switch_type = "switch_type", 
#&gt;     sym = "sym", syms = "sym", `tidy-dots` = "tidy-dots", `tidyeval-data` = "tidyeval-data", 
#&gt;     trace_back = "trace_back", trace_length = "trace_back", type_of = "type_of", 
#&gt;     `type-predicates` = "type-predicates", unbox = "box", UQ = "quasiquotation", 
#&gt;     UQS = "quasiquotation", vec_poke_n = "vec_poke_n", vec_poke_range = "vec_poke_n", 
#&gt;     `vector-coercion` = "vector-coercion", `vector-construction` = "vector-construction", 
#&gt;     `vector-old-ctors` = "vector-old-ctors", warn = "abort", 
#&gt;     warning_cnd = "cnd", with_abort = "with_abort", with_bindings = "scoped_bindings", 
#&gt;     with_env = "with_env", with_handlers = "with_handlers", with_interactive = "is_interactive", 
#&gt;     with_options = "scoped_options", with_restarts = "with_restarts", 
#&gt;     wref_key = "wref_key", wref_value = "wref_key", zap = "zap"
#&gt;     ), article_index = character(0)), examples = TRUE, run_dont_run = FALSE, 
#&gt;     seed = 1014, lazy = FALSE, override = list(destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE)
#&gt; 
#&gt; [[13]]
#&gt; pkgdown::build_site(...)
#&gt; 
#&gt; [[14]]
#&gt; build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, lazy = lazy, override = override, preview = preview, 
#&gt;     devel = devel)
#&gt; 
#&gt; [[15]]
#&gt; build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, override = override, preview = FALSE, devel = devel)
#&gt; 
#&gt; [[16]]
#&gt; purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, 
#&gt;     examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[17]]
#&gt; .f(.x[[i]], ...)
#&gt; 
#&gt; [[18]]
#&gt; data_reference_topic(topic, pkg, examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[19]]
#&gt; run_examples(tags$tag_examples[[1]], env = new.env(parent = globalenv()), 
#&gt;     topic = tools::file_path_sans_ext(topic$file_in), run_examples = examples, 
#&gt;     run_dont_run = run_dont_run)
#&gt; 
#&gt; [[20]]
#&gt; highlight_examples(code, topic, env = env)
#&gt; 
#&gt; [[21]]
#&gt; evaluate::evaluate(x, child_env(env), new_device = TRUE)
#&gt; 
#&gt; [[22]]
#&gt; evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
#&gt;     debug = debug, last = i == length(out), use_try = stop_on_error != 
#&gt;         2L, keep_warning = keep_warning, keep_message = keep_message, 
#&gt;     output_handler = output_handler, include_timing = include_timing)
#&gt; 
#&gt; [[23]]
#&gt; timing_fn(handle(ev &lt;- withCallingHandlers(withVisible(eval(expr, 
#&gt;     envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)))
#&gt; 
#&gt; [[24]]
#&gt; handle(ev &lt;- withCallingHandlers(withVisible(eval(expr, envir, 
#&gt;     enclos)), warning = wHandler, error = eHandler, message = mHandler))
#&gt; 
#&gt; [[25]]
#&gt; try(f, silent = TRUE)
#&gt; 
#&gt; [[26]]
#&gt; tryCatch(expr, error = function(e) {
#&gt;     call &lt;- conditionCall(e)
#&gt;     if (!is.null(call)) {
#&gt;         if (identical(call[[1L]], quote(doTryCatch))) 
#&gt;             call &lt;- sys.call(-4L)
#&gt;         dcall &lt;- deparse(call)[1L]
#&gt;         prefix &lt;- paste("Error in", dcall, ": ")
#&gt;         LONG &lt;- 75L
#&gt;         sm &lt;- strsplit(conditionMessage(e), "\n")[[1L]]
#&gt;         w &lt;- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
#&gt;         if (is.na(w)) 
#&gt;             w &lt;- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
#&gt;                 type = "b")
#&gt;         if (w &gt; LONG) 
#&gt;             prefix &lt;- paste0(prefix, "\n  ")
#&gt;     }
#&gt;     else prefix &lt;- "Error : "
#&gt;     msg &lt;- paste0(prefix, conditionMessage(e), "\n")
#&gt;     .Internal(seterrmessage(msg[1L]))
#&gt;     if (!silent &amp;&amp; isTRUE(getOption("show.error.messages"))) {
#&gt;         cat(msg, file = outFile)
#&gt;         .Internal(printDeferredWarnings())
#&gt;     }
#&gt;     invisible(structure(msg, class = "try-error", condition = e))
#&gt; })
#&gt; 
#&gt; [[27]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[28]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[29]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[30]]
#&gt; withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, 
#&gt;     error = eHandler, message = mHandler)
#&gt; 
#&gt; [[31]]
#&gt; withVisible(eval(expr, envir, enclos))
#&gt; 
#&gt; [[32]]
#&gt; eval(expr, envir, enclos)
#&gt; 
#&gt; [[33]]
#&gt; eval(expr, envir, enclos)
#&gt; 
#&gt; [[34]]
#&gt; invoke(fn, list(mtcars))
#&gt; 
#&gt; [[35]]
#&gt; .fn(`1`)
#&gt; </div><div class='input'>
<span class='co'># Compare to do.call():</span>
<span class='fu'><a href='https://rdrr.io/r/base/do.call.html'>do.call</a></span>(<span class='no'>call_inspect</span>, <span class='no'>mtcars</span>)</div><div class='output co'>#&gt; (function (...) 
#&gt; match.call())(mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 
#&gt; 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 30.4, 
#&gt; 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8, 19.7, 
#&gt; 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 
#&gt; 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6, 8, 4), disp = c(160, 
#&gt; 160, 108, 258, 360, 225, 360, 146.7, 140.8, 167.6, 167.6, 275.8, 
#&gt; 275.8, 275.8, 472, 460, 440, 78.7, 75.7, 71.1, 120.1, 318, 304, 
#&gt; 350, 400, 79, 120.3, 95.1, 351, 145, 301, 121), hp = c(110, 110, 
#&gt; 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180, 205, 
#&gt; 215, 230, 66, 52, 65, 97, 150, 150, 245, 175, 66, 91, 113, 264, 
#&gt; 175, 335, 109), drat = c(3.9, 3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 
#&gt; 3.69, 3.92, 3.92, 3.92, 3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08, 
#&gt; 4.93, 4.22, 3.7, 2.76, 3.15, 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 
#&gt; 3.62, 3.54, 4.11), wt = c(2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 
#&gt; 3.57, 3.19, 3.15, 3.44, 3.44, 4.07, 3.73, 3.78, 5.25, 5.424, 
#&gt; 5.345, 2.2, 1.615, 1.835, 2.465, 3.52, 3.435, 3.84, 3.845, 1.935, 
#&gt; 2.14, 1.513, 3.17, 2.77, 3.57, 2.78), qsec = c(16.46, 17.02, 
#&gt; 18.61, 19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3, 18.9, 17.4, 
#&gt; 17.6, 18, 17.98, 17.82, 17.42, 19.47, 18.52, 19.9, 20.01, 16.87, 
#&gt; 17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 14.5, 15.5, 14.6, 18.6), 
#&gt;     vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 
#&gt;     1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1), am = c(1, 1, 
#&gt;     1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 
#&gt;     0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 4, 3, 3, 
#&gt;     3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 
#&gt;     3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4, 2, 
#&gt;     2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, 2, 
#&gt;     2, 4, 6, 8, 2))</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/do.call.html'>do.call</a></span>(<span class='no'>fn</span>, <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span>(<span class='no'>mtcars</span>))</div><div class='output co'>#&gt; [[1]]
#&gt; tryCatch(withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/tmp/RtmpGSP0ZP/file4f5888a103c")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try({
#&gt;         pxlib &lt;- as.environment("tools:callr")$`__callr_data__`$pxlib
#&gt;         if (is.null(e$code)) 
#&gt;             e$code &lt;- "301"
#&gt;         msg &lt;- paste0("base64::", pxlib$base64_encode(serialize(e, 
#&gt;             NULL)))
#&gt;         data &lt;- paste(e$code, msg, "\n")
#&gt;         pxlib$write_fd(3L, data)
#&gt;         if (!is.null(findRestart("muffleMessage"))) {
#&gt;             invokeRestart("muffleMessage")
#&gt;         }
#&gt;     })
#&gt; }), error = function(e) {
#&gt;     NULL
#&gt;     try(stop(e))
#&gt; }, interrupt = function(e) {
#&gt;     NULL
#&gt;     e
#&gt; })
#&gt; 
#&gt; [[2]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[3]]
#&gt; tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
#&gt;     names[nh], parentenv, handlers[[nh]])
#&gt; 
#&gt; [[4]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[5]]
#&gt; tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
#&gt; 
#&gt; [[6]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[7]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[8]]
#&gt; withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/tmp/RtmpGSP0ZP/file4f5888a103c")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e$`_pid` &lt;- Sys.getpid()
#&gt;         e$`_timestamp` &lt;- Sys.time()
#&gt;         e &lt;- err$add_trace_back(e)
#&gt;         saveRDS(list("error", e), file = paste0("/tmp/RtmpGSP0ZP/file4f5888a103c", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try({
#&gt;         pxlib &lt;- as.environment("tools:callr")$`__callr_data__`$pxlib
#&gt;         if (is.null(e$code)) 
#&gt;             e$code &lt;- "301"
#&gt;         msg &lt;- paste0("base64::", pxlib$base64_encode(serialize(e, 
#&gt;             NULL)))
#&gt;         data &lt;- paste(e$code, msg, "\n")
#&gt;         pxlib$write_fd(3L, data)
#&gt;         if (!is.null(findRestart("muffleMessage"))) {
#&gt;             invokeRestart("muffleMessage")
#&gt;         }
#&gt;     })
#&gt; })
#&gt; 
#&gt; [[9]]
#&gt; saveRDS(do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/tmp/RtmpGSP0ZP/file4f5888a103c")
#&gt; 
#&gt; [[10]]
#&gt; do.call(do.call, c(readRDS("/tmp/RtmpGSP0ZP/file4f58185f734"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv)
#&gt; 
#&gt; [[11]]
#&gt; (function (what, args, quote = FALSE, envir = parent.frame()) 
#&gt; {
#&gt;     if (!is.list(args)) 
#&gt;         stop("second argument must be a list")
#&gt;     if (quote) 
#&gt;         args &lt;- lapply(args, enquote)
#&gt;     .Internal(do.call(what, args, envir))
#&gt; })(function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; }, list(pkg = list(package = "rlang", version = list(c(0L, 4L, 
#&gt; 1L)), src_path = "/home/travis/build/r-lib/rlang", dst_path = "/tmp/RtmpGSP0ZP/file4f58692244b4", 
#&gt;     github_url = "https://github.com/r-lib/rlang", desc = &lt;environment&gt;, 
#&gt;     meta = list(url = "https://rlang.r-lib.org", template = list(
#&gt;         params = list(ganalytics = "UA-115082821-1")), home = list(
#&gt;         links = list(list(text = "The tidy eval bookdown", href = "https://tidyeval.tidyverse.org"))), 
#&gt;         navbar = list(structure = list(left = c("home", "reference", 
#&gt;         "lifecycle", "news"), right = "github"), components = list(
#&gt;             lifecycle = list(text = "Life cycle", href = "reference/lifecycle.html"), 
#&gt;             news = list(text = "News", menu = list(list(text = "Release notes"), 
#&gt;                 list(text = "Version 0.4.0", href = "https://www.tidyverse.org/articles/2019/06/rlang-0-4-0/"), 
#&gt;                 list(text = "Version 0.3.1", href = "https://www.tidyverse.org/articles/2019/01/rlang-0-3-1/"), 
#&gt;                 list(text = "Version 0.3.0", href = "https://www.tidyverse.org/articles/2018/10/rlang-0-3-0/"), 
#&gt;                 list(text = "Version 0.2.0", href = "https://www.tidyverse.org/articles/2018/03/rlang-0.2.0/"), 
#&gt;                 list(text = "------------------"), list(text = "Change log", 
#&gt;                   href = "news/index.html"))))), reference = list(
#&gt;             list(title = "Tidy evaluation", desc = "Quote arguments and expressions with unquoting support. The quosure variants wrap an environment with the expression.\n", 
#&gt;                 contents = c("quo", "quos", "enquo", "enquos", 
#&gt;                 "expr", "exprs", "enexpr", "enexprs", "quasiquotation", 
#&gt;                 "as_label", "as_name")), list(title = "Tidy dots", 
#&gt;                 desc = "Collect arguments contained in `...` with `!!!` and name-unquoting support.\n", 
#&gt;                 contents = c("list2", "dots_list", "pairlist2"
#&gt;                 )), list(title = "Errors, conditions, and backtraces", 
#&gt;                 contents = c("abort", "warn", "inform", "signal", 
#&gt;                 "trace_back", "with_abort", "entrace", "cnd_signal", 
#&gt;                 "last_error", "rlang_backtrace_on_error", "catch_cnd"
#&gt;                 )), list(title = "Evaluate expressions", contents = c("eval_tidy", 
#&gt;             "eval_bare", "exec")), list(title = "Symbols", contents = c("sym", 
#&gt;             "syms", "is_symbol", "as_string")), list(title = "Calls", 
#&gt;                 contents = c("starts_with(\"call_\")", "call2", 
#&gt;                 "is_call")), list(title = "Expressions", contents = c("starts_with(\"expr_\")", 
#&gt;             "starts_with(\"exprs_\")", "starts_with(\"parse_\")", 
#&gt;             "is_expression", "is_symbolic", "expr_text", "expr_label", 
#&gt;             "expr_name", "set_expr", "get_expr")), list(title = "Quosures", 
#&gt;                 contents = c("starts_with(\"quo_\")", "new_quosure", 
#&gt;                 "is_quosure", "as_quosure", "is_quosures", "quos_auto_name"
#&gt;                 )), list(title = "Formulas", contents = c("starts_with(\"f_\")", 
#&gt;             "new_formula", "is_formula", "is_bare_formula")), 
#&gt;             list(title = "Functions", contents = c("starts_with(\"fn_\")", 
#&gt;             "new_function", "is_function", "is_closure", "is_primitive", 
#&gt;             "as_function", "as_closure")), list(title = "Environments", 
#&gt;                 contents = c("env", "new_environment", "env_print", 
#&gt;                 "env_parent", "env_tail", "env_parents", "env_depth", 
#&gt;                 "get_env", "set_env", "env_clone", "env_inherits", 
#&gt;                 "is_environment", "is_bare_environment", "as_environment", 
#&gt;                 "caller_env")), list(title = "Environment bindings", 
#&gt;                 contents = c("env_bind", "env_bind_lazy", "env_bind_active", 
#&gt;                 "env_unbind", "with_bindings", "scoped_bindings", 
#&gt;                 "env_has", "env_get", "env_get_list", "env_names", 
#&gt;                 "env_length", "env_poke")), list(title = "Search path and namespaces", 
#&gt;                 contents = c("search_envs", "search_env", "base_env", 
#&gt;                 "global_env", "empty_env", "is_installed", "is_namespace", 
#&gt;                 "ns_env", "pkg_env", "env_name", "env_label")), 
#&gt;             list(title = "S3", contents = c("inherits_any", "inherits_all", 
#&gt;             "inherits_only", "new_box", "is_box", "as_box", "as_box_if", 
#&gt;             "unbox", "zap", "is_zap", "done")), list(title = "Create vectors", 
#&gt;                 desc = "Atomic vector constructors have implicit splicing (i.e. splice lists automatically), while the list constructor has explicit splicing.\n", 
#&gt;                 contents = c("lgl", "int", "dbl", "cpl", "chr", 
#&gt;                 "list2", "rep_along", "rep_named", "seq2", "seq2_along"
#&gt;                 )), list(title = "Attributes", contents = c("set_names", 
#&gt;             "names2", "has_name", "is_named")), list(title = "Type predicates", 
#&gt;                 contents = c("is_list", "is_atomic", "is_vector", 
#&gt;                 "is_integer", "is_double", "is_character", "is_logical", 
#&gt;                 "is_raw", "is_bytes", "is_scalar_list", "is_scalar_atomic", 
#&gt;                 "is_scalar_vector", "is_scalar_integer", "is_scalar_double", 
#&gt;                 "is_scalar_character", "is_scalar_logical", "is_scalar_raw", 
#&gt;                 "is_scalar_bytes", "is_bare_list", "is_bare_atomic", 
#&gt;                 "is_bare_vector", "is_bare_double", "is_bare_integer", 
#&gt;                 "is_bare_numeric", "is_bare_character", "is_bare_logical", 
#&gt;                 "is_bare_raw", "is_bare_bytes", "is_empty", "is_integerish", 
#&gt;                 "is_bare_integerish", "is_scalar_integerish", 
#&gt;                 "is_null", "is_true", "is_false", "is_string", 
#&gt;                 "is_bool", "is_bare_string")), list(title = "Operators", 
#&gt;                 contents = c("`%||%`", "`%|%`", "`%@%`")), list(
#&gt;                 title = "Function arguments", contents = c("arg_match", 
#&gt;                 "missing_arg", "is_missing", "maybe_missing")), 
#&gt;             list(title = "Create tidy evaluation APIs", desc = "Create data masking APIs à-la dplyr or tidyr. These functions are meant for developers rather than users.\n", 
#&gt;                 contents = c("`tidyeval-data`", "eval_tidy", 
#&gt;                 "as_data_mask", "new_data_mask", "as_data_pronoun"
#&gt;                 )), list(title = "Condition handlers", contents = c("with_handlers", 
#&gt;             "calling")), list(title = "Session state", contents = c("matches(\"interactive\")", 
#&gt;             "matches(\"option\")")), list(title = "Weak references", 
#&gt;                 contents = c("matches(\"weakref\")", "matches(\"wref\")"
#&gt;                 ))), destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     figures = list(dev = "grDevices::png", dpi = 96L, dev.args = list(), 
#&gt;         fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, 
#&gt;         fig.retina = 2L, fig.asp = 0.618046971569839), development = list(
#&gt;         destination = "dev", mode = "release", version_label = "default", 
#&gt;         version_tooltip = "Released version", in_dev = FALSE), 
#&gt;     topics = list(name = c("abort", "are_na", "arg_match", "as_box", 
#&gt;     "as_bytes", "as_data_mask", "as_env", "as_environment", "as_function", 
#&gt;     "as_label", "as_name", "as_overscope", "as_pairlist", "as_quosure", 
#&gt;     "as_string", "as_utf8_character", "bare-type-predicates", 
#&gt;     "box", "call2", "call_args", "call_fn", "call_inspect", "call_modify", 
#&gt;     "call_name", "call_standardise", "caller_env", "caller_fn", 
#&gt;     "caller_frame", "catch_cnd", "chr_unserialise_unicode", "error_cnd", 
#&gt;     "cnd_message", "cnd_muffle", "cnd_signal", "cnd_type", "done", 
#&gt;     "dots_definitions", "dots_n", "dots_values", "duplicate", 
#&gt;     "empty_env", "entrace", "env", "env_bind", "env_bind_exprs", 
#&gt;     "env_binding_are_active", "env_binding_lock", "env_bury", 
#&gt;     "env_clone", "env_depth", "env_get", "env_has", "env_inherits", 
#&gt;     "env_lock", "env_name", "env_names", "env_parent", "env_poke", 
#&gt;     "env_print", "env_unbind", "env_unlock", "eval_bare", "eval_tidy", 
#&gt;     "exec", "exiting", "expr_interp", "expr_label", "expr_print", 
#&gt;     "exprs_auto_name", "f_rhs", "f_text", "flatten", "fn_body", 
#&gt;     "fn_env", "fn_fmls", "frame_position", "friendly_type", "get_env", 
#&gt;     "has_length", "has_name", "inherits_any", "invoke", "is_call", 
#&gt;     "is_callable", "is_condition", "is_copyable", "is_empty", 
#&gt;     "is_env", "is_environment", "is_expr", "is_expression", "is_formula", 
#&gt;     "is_frame", "is_function", "is_installed", "is_integerish", 
#&gt;     "is_interactive", "is_lang", "is_named", "is_namespace", 
#&gt;     "is_pairlist", "is_reference", "is_stack", "is_symbol", "is_true", 
#&gt;     "is_weakref", "lang", "lang_head", "lang_modify", "last_error", 
#&gt;     "lifecycle", "missing", "missing_arg", "mut_node_car", "names2", 
#&gt;     "new-vector-along-retired", "new-vector", "new_call", "new_formula", 
#&gt;     "new_function", "new_node", "new_quosures", "new_weakref", 
#&gt;     "ns_env", "op-definition", "op-get-attr", "op-na-default", 
#&gt;     "op-null-default", "overscope_eval_next", "pairlist2", "parse_expr", 
#&gt;     "parse_quosure", "prepend", "prim_name", "quasiquotation", 
#&gt;     "quo_expr", "quo_label", "quo_squash", "quosure", "quotation", 
#&gt;     "rep_along", "restarting", "return_from", "rlang_backtrace_on_error", 
#&gt;     "rst_abort", "rst_list", "scalar-type-predicates", "scoped_bindings", 
#&gt;     "scoped_env", "scoped_options", "search_envs", "seq2", "set_attrs", 
#&gt;     "set_expr", "set_names", "splice", "stack", "stack_trim", 
#&gt;     "string", "switch_type", "sym", "tidy-dots", "tidyeval-data", 
#&gt;     "trace_back", "type-predicates", "type_of", "vec_poke_n", 
#&gt;     "vector-coercion", "vector-construction", "node", "with_abort", 
#&gt;     "with_env", "with_handlers", "with_restarts", "wref_key", 
#&gt;     "zap"), file_in = c("abort.Rd", "are_na.Rd", "arg_match.Rd", 
#&gt;     "as_box.Rd", "as_bytes.Rd", "as_data_mask.Rd", "as_env.Rd", 
#&gt;     "as_environment.Rd", "as_function.Rd", "as_label.Rd", "as_name.Rd", 
#&gt;     "as_overscope.Rd", "as_pairlist.Rd", "as_quosure.Rd", "as_string.Rd", 
#&gt;     "as_utf8_character.Rd", "bare-type-predicates.Rd", "box.Rd", 
#&gt;     "call2.Rd", "call_args.Rd", "call_fn.Rd", "call_inspect.Rd", 
#&gt;     "call_modify.Rd", "call_name.Rd", "call_standardise.Rd", 
#&gt;     "caller_env.Rd", "caller_fn.Rd", "caller_frame.Rd", "catch_cnd.Rd", 
#&gt;     "chr_unserialise_unicode.Rd", "cnd.Rd", "cnd_message.Rd", 
#&gt;     "cnd_muffle.Rd", "cnd_signal.Rd", "cnd_type.Rd", "done.Rd", 
#&gt;     "dots_definitions.Rd", "dots_n.Rd", "dots_values.Rd", "duplicate.Rd", 
#&gt;     "empty_env.Rd", "entrace.Rd", "env.Rd", "env_bind.Rd", "env_bind_exprs.Rd", 
#&gt;     "env_binding_are_active.Rd", "env_binding_lock.Rd", "env_bury.Rd", 
#&gt;     "env_clone.Rd", "env_depth.Rd", "env_get.Rd", "env_has.Rd", 
#&gt;     "env_inherits.Rd", "env_lock.Rd", "env_name.Rd", "env_names.Rd", 
#&gt;     "env_parent.Rd", "env_poke.Rd", "env_print.Rd", "env_unbind.Rd", 
#&gt;     "env_unlock.Rd", "eval_bare.Rd", "eval_tidy.Rd", "exec.Rd", 
#&gt;     "exiting.Rd", "expr_interp.Rd", "expr_label.Rd", "expr_print.Rd", 
#&gt;     "exprs_auto_name.Rd", "f_rhs.Rd", "f_text.Rd", "flatten.Rd", 
#&gt;     "fn_body.Rd", "fn_env.Rd", "fn_fmls.Rd", "frame_position.Rd", 
#&gt;     "friendly_type.Rd", "get_env.Rd", "has_length.Rd", "has_name.Rd", 
#&gt;     "inherits_any.Rd", "invoke.Rd", "is_call.Rd", "is_callable.Rd", 
#&gt;     "is_condition.Rd", "is_copyable.Rd", "is_empty.Rd", "is_env.Rd", 
#&gt;     "is_environment.Rd", "is_expr.Rd", "is_expression.Rd", "is_formula.Rd", 
#&gt;     "is_frame.Rd", "is_function.Rd", "is_installed.Rd", "is_integerish.Rd", 
#&gt;     "is_interactive.Rd", "is_lang.Rd", "is_named.Rd", "is_namespace.Rd", 
#&gt;     "is_pairlist.Rd", "is_reference.Rd", "is_stack.Rd", "is_symbol.Rd", 
#&gt;     "is_true.Rd", "is_weakref.Rd", "lang.Rd", "lang_head.Rd", 
#&gt;     "lang_modify.Rd", "last_error.Rd", "lifecycle.Rd", "missing.Rd", 
#&gt;     "missing_arg.Rd", "mut_node_car.Rd", "names2.Rd", "new-vector-along-retired.Rd", 
#&gt;     "new-vector.Rd", "new_call.Rd", "new_formula.Rd", "new_function.Rd", 
#&gt;     "new_node.Rd", "new_quosures.Rd", "new_weakref.Rd", "ns_env.Rd", 
#&gt;     "op-definition.Rd", "op-get-attr.Rd", "op-na-default.Rd", 
#&gt;     "op-null-default.Rd", "overscope_eval_next.Rd", "pairlist2.Rd", 
#&gt;     "parse_expr.Rd", "parse_quosure.Rd", "prepend.Rd", "prim_name.Rd", 
#&gt;     "quasiquotation.Rd", "quo_expr.Rd", "quo_label.Rd", "quo_squash.Rd", 
#&gt;     "quosure.Rd", "quotation.Rd", "rep_along.Rd", "restarting.Rd", 
#&gt;     "return_from.Rd", "rlang_backtrace_on_error.Rd", "rst_abort.Rd", 
#&gt;     "rst_list.Rd", "scalar-type-predicates.Rd", "scoped_bindings.Rd", 
#&gt;     "scoped_env.Rd", "scoped_options.Rd", "search_envs.Rd", "seq2.Rd", 
#&gt;     "set_attrs.Rd", "set_expr.Rd", "set_names.Rd", "splice.Rd", 
#&gt;     "stack.Rd", "stack_trim.Rd", "string.Rd", "switch_type.Rd", 
#&gt;     "sym.Rd", "tidy-dots.Rd", "tidyeval-data.Rd", "trace_back.Rd", 
#&gt;     "type-predicates.Rd", "type_of.Rd", "vec_poke_n.Rd", "vector-coercion.Rd", 
#&gt;     "vector-construction.Rd", "vector-old-ctors.Rd", "with_abort.Rd", 
#&gt;     "with_env.Rd", "with_handlers.Rd", "with_restarts.Rd", "wref_key.Rd", 
#&gt;     "zap.Rd"), file_out = c("abort.html", "are_na.html", "arg_match.html", 
#&gt;     "as_box.html", "as_bytes.html", "as_data_mask.html", "as_env.html", 
#&gt;     "as_environment.html", "as_function.html", "as_label.html", 
#&gt;     "as_name.html", "as_overscope.html", "as_pairlist.html", 
#&gt;     "as_quosure.html", "as_string.html", "as_utf8_character.html", 
#&gt;     "bare-type-predicates.html", "box.html", "call2.html", "call_args.html", 
#&gt;     "call_fn.html", "call_inspect.html", "call_modify.html", 
#&gt;     "call_name.html", "call_standardise.html", "caller_env.html", 
#&gt;     "caller_fn.html", "caller_frame.html", "catch_cnd.html", 
#&gt;     "chr_unserialise_unicode.html", "cnd.html", "cnd_message.html", 
#&gt;     "cnd_muffle.html", "cnd_signal.html", "cnd_type.html", "done.html", 
#&gt;     "dots_definitions.html", "dots_n.html", "dots_values.html", 
#&gt;     "duplicate.html", "empty_env.html", "entrace.html", "env.html", 
#&gt;     "env_bind.html", "env_bind_exprs.html", "env_binding_are_active.html", 
#&gt;     "env_binding_lock.html", "env_bury.html", "env_clone.html", 
#&gt;     "env_depth.html", "env_get.html", "env_has.html", "env_inherits.html", 
#&gt;     "env_lock.html", "env_name.html", "env_names.html", "env_parent.html", 
#&gt;     "env_poke.html", "env_print.html", "env_unbind.html", "env_unlock.html", 
#&gt;     "eval_bare.html", "eval_tidy.html", "exec.html", "exiting.html", 
#&gt;     "expr_interp.html", "expr_label.html", "expr_print.html", 
#&gt;     "exprs_auto_name.html", "f_rhs.html", "f_text.html", "flatten.html", 
#&gt;     "fn_body.html", "fn_env.html", "fn_fmls.html", "frame_position.html", 
#&gt;     "friendly_type.html", "get_env.html", "has_length.html", 
#&gt;     "has_name.html", "inherits_any.html", "invoke.html", "is_call.html", 
#&gt;     "is_callable.html", "is_condition.html", "is_copyable.html", 
#&gt;     "is_empty.html", "is_env.html", "is_environment.html", "is_expr.html", 
#&gt;     "is_expression.html", "is_formula.html", "is_frame.html", 
#&gt;     "is_function.html", "is_installed.html", "is_integerish.html", 
#&gt;     "is_interactive.html", "is_lang.html", "is_named.html", "is_namespace.html", 
#&gt;     "is_pairlist.html", "is_reference.html", "is_stack.html", 
#&gt;     "is_symbol.html", "is_true.html", "is_weakref.html", "lang.html", 
#&gt;     "lang_head.html", "lang_modify.html", "last_error.html", 
#&gt;     "lifecycle.html", "missing.html", "missing_arg.html", "mut_node_car.html", 
#&gt;     "names2.html", "new-vector-along-retired.html", "new-vector.html", 
#&gt;     "new_call.html", "new_formula.html", "new_function.html", 
#&gt;     "new_node.html", "new_quosures.html", "new_weakref.html", 
#&gt;     "ns_env.html", "op-definition.html", "op-get-attr.html", 
#&gt;     "op-na-default.html", "op-null-default.html", "overscope_eval_next.html", 
#&gt;     "pairlist2.html", "parse_expr.html", "parse_quosure.html", 
#&gt;     "prepend.html", "prim_name.html", "quasiquotation.html", 
#&gt;     "quo_expr.html", "quo_label.html", "quo_squash.html", "quosure.html", 
#&gt;     "quotation.html", "rep_along.html", "restarting.html", "return_from.html", 
#&gt;     "rlang_backtrace_on_error.html", "rst_abort.html", "rst_list.html", 
#&gt;     "scalar-type-predicates.html", "scoped_bindings.html", "scoped_env.html", 
#&gt;     "scoped_options.html", "search_envs.html", "seq2.html", "set_attrs.html", 
#&gt;     "set_expr.html", "set_names.html", "splice.html", "stack.html", 
#&gt;     "stack_trim.html", "string.html", "switch_type.html", "sym.html", 
#&gt;     "tidy-dots.html", "tidyeval-data.html", "trace_back.html", 
#&gt;     "type-predicates.html", "type_of.html", "vec_poke_n.html", 
#&gt;     "vector-coercion.html", "vector-construction.html", "vector-old-ctors.html", 
#&gt;     "with_abort.html", "with_env.html", "with_handlers.html", 
#&gt;     "with_restarts.html", "wref_key.html", "zap.html"), alias = list(
#&gt;         abort.Rd = c("abort", "warn", "inform", "signal", "interrupt"
#&gt;         ), are_na.Rd = c("are_na", "is_na", "is_lgl_na", "is_int_na", 
#&gt;         "is_dbl_na", "is_chr_na", "is_cpl_na"), arg_match.Rd = "arg_match", 
#&gt;         as_box.Rd = c("as_box", "as_box_if"), as_bytes.Rd = "as_bytes", 
#&gt;         as_data_mask.Rd = c("as_data_mask", "as_data_pronoun", 
#&gt;         "new_data_mask"), as_env.Rd = "as_env", as_environment.Rd = "as_environment", 
#&gt;         as_function.Rd = c("as_function", "is_lambda", "as_closure"
#&gt;         ), as_label.Rd = "as_label", as_name.Rd = "as_name", 
#&gt;         as_overscope.Rd = c("as_overscope", "new_overscope", 
#&gt;         "overscope_clean"), as_pairlist.Rd = "as_pairlist", as_quosure.Rd = c("as_quosure", 
#&gt;         "new_quosure"), as_string.Rd = "as_string", as_utf8_character.Rd = "as_utf8_character", 
#&gt;         `bare-type-predicates.Rd` = c("bare-type-predicates", 
#&gt;         "is_bare_list", "is_bare_atomic", "is_bare_vector", "is_bare_double", 
#&gt;         "is_bare_integer", "is_bare_numeric", "is_bare_character", 
#&gt;         "is_bare_logical", "is_bare_raw", "is_bare_string", "is_bare_bytes"
#&gt;         ), box.Rd = c("box", "new_box", "is_box", "unbox"), call2.Rd = "call2", 
#&gt;         call_args.Rd = c("call_args", "call_args_names"), call_fn.Rd = "call_fn", 
#&gt;         call_inspect.Rd = "call_inspect", call_modify.Rd = "call_modify", 
#&gt;         call_name.Rd = c("call_name", "call_ns"), call_standardise.Rd = "call_standardise", 
#&gt;         caller_env.Rd = c("caller_env", "current_env"), caller_fn.Rd = c("caller_fn", 
#&gt;         "current_fn"), caller_frame.Rd = "caller_frame", catch_cnd.Rd = "catch_cnd", 
#&gt;         chr_unserialise_unicode.Rd = "chr_unserialise_unicode", 
#&gt;         cnd.Rd = c("error_cnd", "cnd", "warning_cnd", "message_cnd"
#&gt;         ), cnd_message.Rd = c("cnd_message", "cnd_issue", "cnd_bullets", 
#&gt;         "format_bullets"), cnd_muffle.Rd = "cnd_muffle", cnd_signal.Rd = "cnd_signal", 
#&gt;         cnd_type.Rd = "cnd_type", done.Rd = c("done", "is_done_box"
#&gt;         ), dots_definitions.Rd = "dots_definitions", dots_n.Rd = "dots_n", 
#&gt;         dots_values.Rd = "dots_values", duplicate.Rd = "duplicate", 
#&gt;         empty_env.Rd = "empty_env", entrace.Rd = c("entrace", 
#&gt;         "cnd_entrace"), env.Rd = c("env", "child_env", "new_environment"
#&gt;         ), env_bind.Rd = c("env_bind", "env_bind_lazy", "env_bind_active"
#&gt;         ), env_bind_exprs.Rd = c("env_bind_exprs", "env_bind_fns"
#&gt;         ), env_binding_are_active.Rd = c("env_binding_are_active", 
#&gt;         "env_binding_are_lazy"), env_binding_lock.Rd = c("env_binding_lock", 
#&gt;         "env_binding_unlock", "env_binding_are_locked"), env_bury.Rd = "env_bury", 
#&gt;         env_clone.Rd = "env_clone", env_depth.Rd = "env_depth", 
#&gt;         env_get.Rd = c("env_get", "env_get_list"), env_has.Rd = "env_has", 
#&gt;         env_inherits.Rd = "env_inherits", env_lock.Rd = c("env_lock", 
#&gt;         "env_is_locked"), env_name.Rd = c("env_name", "env_label"
#&gt;         ), env_names.Rd = c("env_names", "env_length"), env_parent.Rd = c("env_parent", 
#&gt;         "env_tail", "env_parents"), env_poke.Rd = "env_poke", 
#&gt;         env_print.Rd = "env_print", env_unbind.Rd = "env_unbind", 
#&gt;         env_unlock.Rd = "env_unlock", eval_bare.Rd = "eval_bare", 
#&gt;         eval_tidy.Rd = "eval_tidy", exec.Rd = "exec", exiting.Rd = "exiting", 
#&gt;         expr_interp.Rd = "expr_interp", expr_label.Rd = c("expr_label", 
#&gt;         "expr_name", "expr_text"), expr_print.Rd = c("expr_print", 
#&gt;         "expr_deparse"), exprs_auto_name.Rd = c("exprs_auto_name", 
#&gt;         "quos_auto_name"), f_rhs.Rd = c("f_rhs", "f_rhs&lt;-", "f_lhs", 
#&gt;         "f_lhs&lt;-", "f_env", "f_env&lt;-"), f_text.Rd = c("f_text", 
#&gt;         "f_name", "f_label"), flatten.Rd = c("flatten", "flatten_lgl", 
#&gt;         "flatten_int", "flatten_dbl", "flatten_cpl", "flatten_chr", 
#&gt;         "flatten_raw", "squash", "squash_lgl", "squash_int", 
#&gt;         "squash_dbl", "squash_cpl", "squash_chr", "squash_raw", 
#&gt;         "flatten_if", "squash_if"), fn_body.Rd = c("fn_body", 
#&gt;         "fn_body&lt;-"), fn_env.Rd = c("fn_env", "fn_env&lt;-"), fn_fmls.Rd = c("fn_fmls", 
#&gt;         "fn_fmls_names", "fn_fmls_syms", "fn_fmls&lt;-", "fn_fmls_names&lt;-"
#&gt;         ), frame_position.Rd = "frame_position", friendly_type.Rd = "friendly_type", 
#&gt;         get_env.Rd = c("get_env", "set_env", "env_poke_parent"
#&gt;         ), has_length.Rd = "has_length", has_name.Rd = "has_name", 
#&gt;         inherits_any.Rd = c("inherits_any", "inherits_all", "inherits_only"
#&gt;         ), invoke.Rd = "invoke", is_call.Rd = "is_call", is_callable.Rd = "is_callable", 
#&gt;         is_condition.Rd = "is_condition", is_copyable.Rd = "is_copyable", 
#&gt;         is_empty.Rd = "is_empty", is_env.Rd = c("is_env", "is_bare_env"
#&gt;         ), is_environment.Rd = c("is_environment", "is_bare_environment"
#&gt;         ), is_expr.Rd = "is_expr", is_expression.Rd = c("is_expression", 
#&gt;         "is_syntactic_literal", "is_symbolic"), is_formula.Rd = c("is_formula", 
#&gt;         "is_bare_formula"), is_frame.Rd = "is_frame", is_function.Rd = c("is_function", 
#&gt;         "is_closure", "is_primitive", "is_primitive_eager", "is_primitive_lazy"
#&gt;         ), is_installed.Rd = "is_installed", is_integerish.Rd = c("is_integerish", 
#&gt;         "is_bare_integerish", "is_scalar_integerish"), is_interactive.Rd = c("is_interactive", 
#&gt;         "scoped_interactive", "with_interactive"), is_lang.Rd = c("is_lang", 
#&gt;         "is_unary_lang", "is_binary_lang", "quo_is_lang"), is_named.Rd = c("is_named", 
#&gt;         "is_dictionaryish", "have_name"), is_namespace.Rd = "is_namespace", 
#&gt;         is_pairlist.Rd = c("is_pairlist", "is_node", "is_node_list"
#&gt;         ), is_reference.Rd = "is_reference", is_stack.Rd = c("is_stack", 
#&gt;         "is_eval_stack", "is_call_stack"), is_symbol.Rd = "is_symbol", 
#&gt;         is_true.Rd = c("is_true", "is_false"), is_weakref.Rd = "is_weakref", 
#&gt;         lang.Rd = c("lang", "new_language"), lang_head.Rd = c("lang_head", 
#&gt;         "lang_tail"), lang_modify.Rd = c("lang_modify", "lang_standardise", 
#&gt;         "lang_fn", "lang_name", "lang_args", "lang_args_names"
#&gt;         ), last_error.Rd = c("last_error", "last_trace"), lifecycle.Rd = "lifecycle", 
#&gt;         missing.Rd = c("missing", "na_lgl", "na_int", "na_dbl", 
#&gt;         "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg", 
#&gt;         "is_missing", "maybe_missing"), mut_node_car.Rd = c("mut_node_car", 
#&gt;         "mut_node_cdr", "mut_node_caar", "mut_node_cadr", "mut_node_cdar", 
#&gt;         "mut_node_cddr", "mut_node_tag"), names2.Rd = "names2", 
#&gt;         `new-vector-along-retired.Rd` = c("new-vector-along-retired", 
#&gt;         "new_logical_along", "new_integer_along", "new_double_along", 
#&gt;         "new_character_along", "new_complex_along", "new_raw_along", 
#&gt;         "new_list_along"), `new-vector.Rd` = c("new-vector", 
#&gt;         "new_logical", "new_integer", "new_double", "new_character", 
#&gt;         "new_complex", "new_raw", "new_list"), new_call.Rd = "new_call", 
#&gt;         new_formula.Rd = "new_formula", new_function.Rd = "new_function", 
#&gt;         new_node.Rd = c("new_node", "node_car", "node_cdr", "node_caar", 
#&gt;         "node_cadr", "node_cdar", "node_cddr", "node_poke_car", 
#&gt;         "node_poke_cdr", "node_poke_caar", "node_poke_cadr", 
#&gt;         "node_poke_cdar", "node_poke_cddr", "node_tag", "node_poke_tag"
#&gt;         ), new_quosures.Rd = c("new_quosures", "as_quosures", 
#&gt;         "is_quosures"), new_weakref.Rd = "new_weakref", ns_env.Rd = c("ns_env", 
#&gt;         "ns_imports_env", "ns_env_name"), `op-definition.Rd` = c("op-definition", 
#&gt;         "is_definition", "new_definition", "is_formulaish"), 
#&gt;         `op-get-attr.Rd` = c("op-get-attr", "%@%", "%@%&lt;-"), 
#&gt;         `op-na-default.Rd` = c("op-na-default", "%|%"), `op-null-default.Rd` = c("op-null-default", 
#&gt;         "%||%"), overscope_eval_next.Rd = "overscope_eval_next", 
#&gt;         pairlist2.Rd = "pairlist2", parse_expr.Rd = c("parse_expr", 
#&gt;         "parse_exprs", "parse_quo", "parse_quos"), parse_quosure.Rd = c("parse_quosure", 
#&gt;         "parse_quosures"), prepend.Rd = c("prepend", "modify"
#&gt;         ), prim_name.Rd = "prim_name", quasiquotation.Rd = c("quasiquotation", 
#&gt;         "UQ", "UQS", "{{}}", "{{", "!!", "!!!", ":=", "qq_show"
#&gt;         ), quo_expr.Rd = "quo_expr", quo_label.Rd = c("quo_label", 
#&gt;         "quo_text", "quo_name"), quo_squash.Rd = "quo_squash", 
#&gt;         quosure.Rd = c("quosure", "is_quosure", "quo_is_missing", 
#&gt;         "quo_is_symbol", "quo_is_call", "quo_is_symbolic", "quo_is_null", 
#&gt;         "quo_get_expr", "quo_get_env", "quo_set_expr", "quo_set_env"
#&gt;         ), quotation.Rd = c("quotation", "expr", "enexpr", "exprs", 
#&gt;         "enexprs", "ensym", "ensyms", "quo", "enquo", "quos", 
#&gt;         "enquos"), rep_along.Rd = c("rep_along", "rep_named"), 
#&gt;         restarting.Rd = "restarting", return_from.Rd = c("return_from", 
#&gt;         "return_to"), rlang_backtrace_on_error.Rd = c("rlang_backtrace_on_error", 
#&gt;         "add_backtrace"), rst_abort.Rd = "rst_abort", rst_list.Rd = c("rst_list", 
#&gt;         "rst_exists", "rst_jump", "rst_maybe_jump"), `scalar-type-predicates.Rd` = c("scalar-type-predicates", 
#&gt;         "is_scalar_list", "is_scalar_atomic", "is_scalar_vector", 
#&gt;         "is_scalar_integer", "is_scalar_double", "is_scalar_character", 
#&gt;         "is_scalar_logical", "is_scalar_raw", "is_string", "is_scalar_bytes", 
#&gt;         "is_bool"), scoped_bindings.Rd = c("scoped_bindings", 
#&gt;         "with_bindings"), scoped_env.Rd = c("scoped_env", "is_scoped", 
#&gt;         "scoped_envs", "scoped_names"), scoped_options.Rd = c("scoped_options", 
#&gt;         "with_options", "push_options", "peek_options", "peek_option"
#&gt;         ), search_envs.Rd = c("search_envs", "search_env", "pkg_env", 
#&gt;         "pkg_env_name", "is_attached", "base_env", "global_env"
#&gt;         ), seq2.Rd = c("seq2", "seq2_along"), set_attrs.Rd = c("set_attrs", 
#&gt;         "mut_attrs"), set_expr.Rd = c("set_expr", "get_expr"), 
#&gt;         set_names.Rd = "set_names", splice.Rd = c("splice", "is_spliced", 
#&gt;         "is_spliced_bare", "dots_splice"), stack.Rd = c("stack", 
#&gt;         "global_frame", "current_frame", "ctxt_frame", "call_frame", 
#&gt;         "ctxt_depth", "call_depth", "ctxt_stack", "call_stack"
#&gt;         ), stack_trim.Rd = "stack_trim", string.Rd = "string", 
#&gt;         switch_type.Rd = c("switch_type", "coerce_type", "switch_class", 
#&gt;         "coerce_class"), sym.Rd = c("sym", "syms"), `tidy-dots.Rd` = c("tidy-dots", 
#&gt;         "dots_list", "list2"), `tidyeval-data.Rd` = c("tidyeval-data", 
#&gt;         ".data"), trace_back.Rd = c("trace_back", "trace_length"
#&gt;         ), `type-predicates.Rd` = c("type-predicates", "is_list", 
#&gt;         "is_atomic", "is_vector", "is_integer", "is_double", 
#&gt;         "is_character", "is_logical", "is_raw", "is_bytes", "is_null"
#&gt;         ), type_of.Rd = "type_of", vec_poke_n.Rd = c("vec_poke_n", 
#&gt;         "vec_poke_range"), `vector-coercion.Rd` = c("vector-coercion", 
#&gt;         "as_logical", "as_integer", "as_double", "as_complex", 
#&gt;         "as_character", "as_list"), `vector-construction.Rd` = c("vector-construction", 
#&gt;         "lgl", "int", "dbl", "cpl", "chr", "bytes", "ll"), `vector-old-ctors.Rd` = c("node", 
#&gt;         "vector-old-ctors", "lgl_len", "int_len", "dbl_len", 
#&gt;         "chr_len", "cpl_len", "raw_len", "bytes_len", "list_len", 
#&gt;         "lgl_along", "int_along", "dbl_along", "chr_along", "cpl_along", 
#&gt;         "raw_along", "bytes_along", "list_along"), with_abort.Rd = "with_abort", 
#&gt;         with_env.Rd = c("with_env", "locally"), with_handlers.Rd = c("with_handlers", 
#&gt;         "calling"), with_restarts.Rd = "with_restarts", wref_key.Rd = c("wref_key", 
#&gt;         "wref_value"), zap.Rd = c("zap", "is_zap")), funs = list(
#&gt;         abort.Rd = c("abort()", "warn()", "inform()", "signal()", 
#&gt;         "interrupt()"), are_na.Rd = c("are_na()", "is_na()", 
#&gt;         "is_lgl_na()", "is_int_na()", "is_dbl_na()", "is_chr_na()", 
#&gt;         "is_cpl_na()"), arg_match.Rd = "arg_match()", as_box.Rd = c("as_box()", 
#&gt;         "as_box_if()"), as_bytes.Rd = "as_bytes()", as_data_mask.Rd = c("as_data_mask()", 
#&gt;         "as_data_pronoun()", "new_data_mask()"), as_env.Rd = "as_env()", 
#&gt;         as_environment.Rd = "as_environment()", as_function.Rd = c("as_function()", 
#&gt;         "is_lambda()", "as_closure()"), as_label.Rd = "as_label()", 
#&gt;         as_name.Rd = "as_name()", as_overscope.Rd = c("as_overscope()", 
#&gt;         "new_overscope()", "overscope_clean()"), as_pairlist.Rd = "as_pairlist()", 
#&gt;         as_quosure.Rd = c("as_quosure()", "new_quosure()"), as_string.Rd = "as_string()", 
#&gt;         as_utf8_character.Rd = "as_utf8_character()", `bare-type-predicates.Rd` = c("is_bare_list()", 
#&gt;         "is_bare_atomic()", "is_bare_vector()", "is_bare_double()", 
#&gt;         "is_bare_integer()", "is_bare_numeric()", "is_bare_character()", 
#&gt;         "is_bare_logical()", "is_bare_raw()", "is_bare_string()", 
#&gt;         "is_bare_bytes()"), box.Rd = c("new_box()", "is_box()", 
#&gt;         "unbox()"), call2.Rd = "call2()", call_args.Rd = c("call_args()", 
#&gt;         "call_args_names()"), call_fn.Rd = "call_fn()", call_inspect.Rd = "call_inspect()", 
#&gt;         call_modify.Rd = "call_modify()", call_name.Rd = c("call_name()", 
#&gt;         "call_ns()"), call_standardise.Rd = "call_standardise()", 
#&gt;         caller_env.Rd = c("caller_env()", "current_env()"), caller_fn.Rd = c("caller_fn()", 
#&gt;         "current_fn()"), caller_frame.Rd = "caller_frame()", 
#&gt;         catch_cnd.Rd = "catch_cnd()", chr_unserialise_unicode.Rd = "chr_unserialise_unicode()", 
#&gt;         cnd.Rd = c("error_cnd()", "cnd()", "warning_cnd()", "message_cnd()"
#&gt;         ), cnd_message.Rd = c("cnd_message()", "cnd_issue()", 
#&gt;         "cnd_bullets()", "format_bullets()"), cnd_muffle.Rd = "cnd_muffle()", 
#&gt;         cnd_signal.Rd = "cnd_signal()", cnd_type.Rd = "cnd_type()", 
#&gt;         done.Rd = c("done()", "is_done_box()"), dots_definitions.Rd = "dots_definitions()", 
#&gt;         dots_n.Rd = "dots_n()", dots_values.Rd = "dots_values()", 
#&gt;         duplicate.Rd = "duplicate()", empty_env.Rd = "empty_env()", 
#&gt;         entrace.Rd = c("entrace()", "cnd_entrace()"), env.Rd = c("env()", 
#&gt;         "child_env()", "new_environment()"), env_bind.Rd = c("env_bind()", 
#&gt;         "env_bind_lazy()", "env_bind_active()"), env_bind_exprs.Rd = c("env_bind_exprs()", 
#&gt;         "env_bind_fns()"), env_binding_are_active.Rd = c("env_binding_are_active()", 
#&gt;         "env_binding_are_lazy()"), env_binding_lock.Rd = c("env_binding_lock()", 
#&gt;         "env_binding_unlock()", "env_binding_are_locked()"), 
#&gt;         env_bury.Rd = "env_bury()", env_clone.Rd = "env_clone()", 
#&gt;         env_depth.Rd = "env_depth()", env_get.Rd = c("env_get()", 
#&gt;         "env_get_list()"), env_has.Rd = "env_has()", env_inherits.Rd = "env_inherits()", 
#&gt;         env_lock.Rd = c("env_lock()", "env_is_locked()"), env_name.Rd = c("env_name()", 
#&gt;         "env_label()"), env_names.Rd = c("env_names()", "env_length()"
#&gt;         ), env_parent.Rd = c("env_parent()", "env_tail()", "env_parents()"
#&gt;         ), env_poke.Rd = "env_poke()", env_print.Rd = "env_print()", 
#&gt;         env_unbind.Rd = "env_unbind()", env_unlock.Rd = "env_unlock()", 
#&gt;         eval_bare.Rd = "eval_bare()", eval_tidy.Rd = "eval_tidy()", 
#&gt;         exec.Rd = "exec()", exiting.Rd = "exiting()", expr_interp.Rd = "expr_interp()", 
#&gt;         expr_label.Rd = c("expr_label()", "expr_name()", "expr_text()"
#&gt;         ), expr_print.Rd = c("expr_print()", "expr_deparse()"
#&gt;         ), exprs_auto_name.Rd = c("exprs_auto_name()", "quos_auto_name()"
#&gt;         ), f_rhs.Rd = c("f_rhs()", "`f_rhs&lt;-`()", "f_lhs()", 
#&gt;         "`f_lhs&lt;-`()", "f_env()", "`f_env&lt;-`()"), f_text.Rd = c("f_text()", 
#&gt;         "f_name()", "f_label()"), flatten.Rd = c("flatten()", 
#&gt;         "flatten_lgl()", "flatten_int()", "flatten_dbl()", "flatten_cpl()", 
#&gt;         "flatten_chr()", "flatten_raw()", "squash()", "squash_lgl()", 
#&gt;         "squash_int()", "squash_dbl()", "squash_cpl()", "squash_chr()", 
#&gt;         "squash_raw()", "flatten_if()", "squash_if()"), fn_body.Rd = c("fn_body()", 
#&gt;         "`fn_body&lt;-`()"), fn_env.Rd = c("fn_env()", "`fn_env&lt;-`()"
#&gt;         ), fn_fmls.Rd = c("fn_fmls()", "fn_fmls_names()", "fn_fmls_syms()", 
#&gt;         "`fn_fmls&lt;-`()", "`fn_fmls_names&lt;-`()"), frame_position.Rd = "frame_position()", 
#&gt;         friendly_type.Rd = "friendly_type()", get_env.Rd = c("get_env()", 
#&gt;         "set_env()", "env_poke_parent()"), has_length.Rd = "has_length()", 
#&gt;         has_name.Rd = "has_name()", inherits_any.Rd = c("inherits_any()", 
#&gt;         "inherits_all()", "inherits_only()"), invoke.Rd = "invoke()", 
#&gt;         is_call.Rd = "is_call()", is_callable.Rd = "is_callable()", 
#&gt;         is_condition.Rd = "is_condition()", is_copyable.Rd = "is_copyable()", 
#&gt;         is_empty.Rd = "is_empty()", is_env.Rd = c("is_env()", 
#&gt;         "is_bare_env()"), is_environment.Rd = c("is_environment()", 
#&gt;         "is_bare_environment()"), is_expr.Rd = "is_expr()", is_expression.Rd = c("is_expression()", 
#&gt;         "is_syntactic_literal()", "is_symbolic()"), is_formula.Rd = c("is_formula()", 
#&gt;         "is_bare_formula()"), is_frame.Rd = "is_frame()", is_function.Rd = c("is_function()", 
#&gt;         "is_closure()", "is_primitive()", "is_primitive_eager()", 
#&gt;         "is_primitive_lazy()"), is_installed.Rd = "is_installed()", 
#&gt;         is_integerish.Rd = c("is_integerish()", "is_bare_integerish()", 
#&gt;         "is_scalar_integerish()"), is_interactive.Rd = c("is_interactive()", 
#&gt;         "scoped_interactive()", "with_interactive()"), is_lang.Rd = c("is_lang()", 
#&gt;         "is_unary_lang()", "is_binary_lang()", "quo_is_lang()"
#&gt;         ), is_named.Rd = c("is_named()", "is_dictionaryish()", 
#&gt;         "have_name()"), is_namespace.Rd = "is_namespace()", is_pairlist.Rd = c("is_pairlist()", 
#&gt;         "is_node()", "is_node_list()"), is_reference.Rd = "is_reference()", 
#&gt;         is_stack.Rd = c("is_stack()", "is_eval_stack()", "is_call_stack()"
#&gt;         ), is_symbol.Rd = "is_symbol()", is_true.Rd = c("is_true()", 
#&gt;         "is_false()"), is_weakref.Rd = "is_weakref()", lang.Rd = c("lang()", 
#&gt;         "new_language()"), lang_head.Rd = c("lang_head()", "lang_tail()"
#&gt;         ), lang_modify.Rd = c("lang_modify()", "lang_standardise()", 
#&gt;         "lang_fn()", "lang_name()", "lang_args()", "lang_args_names()"
#&gt;         ), last_error.Rd = c("last_error()", "last_trace()"), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = c("na_lgl", 
#&gt;         "na_int", "na_dbl", "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg()", 
#&gt;         "is_missing()", "maybe_missing()"), mut_node_car.Rd = c("mut_node_car()", 
#&gt;         "mut_node_cdr()", "mut_node_caar()", "mut_node_cadr()", 
#&gt;         "mut_node_cdar()", "mut_node_cddr()", "mut_node_tag()"
#&gt;         ), names2.Rd = "names2()", `new-vector-along-retired.Rd` = c("new_logical_along()", 
#&gt;         "new_integer_along()", "new_double_along()", "new_character_along()", 
#&gt;         "new_complex_along()", "new_raw_along()", "new_list_along()"
#&gt;         ), `new-vector.Rd` = c("new_logical()", "new_integer()", 
#&gt;         "new_double()", "new_character()", "new_complex()", "new_raw()", 
#&gt;         "new_list()"), new_call.Rd = "new_call()", new_formula.Rd = "new_formula()", 
#&gt;         new_function.Rd = "new_function()", new_node.Rd = c("new_node()", 
#&gt;         "node_car()", "node_cdr()", "node_caar()", "node_cadr()", 
#&gt;         "node_cdar()", "node_cddr()", "node_poke_car()", "node_poke_cdr()", 
#&gt;         "node_poke_caar()", "node_poke_cadr()", "node_poke_cdar()", 
#&gt;         "node_poke_cddr()", "node_tag()", "node_poke_tag()"), 
#&gt;         new_quosures.Rd = c("new_quosures()", "as_quosures()", 
#&gt;         "is_quosures()"), new_weakref.Rd = "new_weakref()", ns_env.Rd = c("ns_env()", 
#&gt;         "ns_imports_env()", "ns_env_name()"), `op-definition.Rd` = c("is_definition()", 
#&gt;         "new_definition()", "is_formulaish()"), `op-get-attr.Rd` = c("`%@%`", 
#&gt;         "`%@%&lt;-`()"), `op-na-default.Rd` = "`%|%`", `op-null-default.Rd` = "`%||%`", 
#&gt;         overscope_eval_next.Rd = "overscope_eval_next()", pairlist2.Rd = "pairlist2()", 
#&gt;         parse_expr.Rd = c("parse_expr()", "parse_exprs()", "parse_quo()", 
#&gt;         "parse_quos()"), parse_quosure.Rd = c("parse_quosure()", 
#&gt;         "parse_quosures()"), prepend.Rd = c("prepend()", "modify()"
#&gt;         ), prim_name.Rd = "prim_name()", quasiquotation.Rd = "qq_show()", 
#&gt;         quo_expr.Rd = "quo_expr()", quo_label.Rd = c("quo_label()", 
#&gt;         "quo_text()", "quo_name()"), quo_squash.Rd = "quo_squash()", 
#&gt;         quosure.Rd = c("is_quosure()", "quo_is_missing()", "quo_is_symbol()", 
#&gt;         "quo_is_call()", "quo_is_symbolic()", "quo_is_null()", 
#&gt;         "quo_get_expr()", "quo_get_env()", "quo_set_expr()", 
#&gt;         "quo_set_env()"), quotation.Rd = c("expr()", "enexpr()", 
#&gt;         "exprs()", "enexprs()", "ensym()", "ensyms()", "quo()", 
#&gt;         "enquo()", "quos()", "enquos()"), rep_along.Rd = c("rep_along()", 
#&gt;         "rep_named()"), restarting.Rd = "restarting()", return_from.Rd = c("return_from()", 
#&gt;         "return_to()"), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = "rst_abort()", rst_list.Rd = c("rst_list()", 
#&gt;         "rst_exists()", "rst_jump()", "rst_maybe_jump()"), `scalar-type-predicates.Rd` = c("is_scalar_list()", 
#&gt;         "is_scalar_atomic()", "is_scalar_vector()", "is_scalar_integer()", 
#&gt;         "is_scalar_double()", "is_scalar_character()", "is_scalar_logical()", 
#&gt;         "is_scalar_raw()", "is_string()", "is_scalar_bytes()", 
#&gt;         "is_bool()"), scoped_bindings.Rd = c("scoped_bindings()", 
#&gt;         "with_bindings()"), scoped_env.Rd = c("scoped_env()", 
#&gt;         "is_scoped()", "scoped_envs()", "scoped_names()"), scoped_options.Rd = c("scoped_options()", 
#&gt;         "with_options()", "push_options()", "peek_options()", 
#&gt;         "peek_option()"), search_envs.Rd = c("search_envs()", 
#&gt;         "search_env()", "pkg_env()", "pkg_env_name()", "is_attached()", 
#&gt;         "base_env()", "global_env()"), seq2.Rd = c("seq2()", 
#&gt;         "seq2_along()"), set_attrs.Rd = c("set_attrs()", "mut_attrs()"
#&gt;         ), set_expr.Rd = c("set_expr()", "get_expr()"), set_names.Rd = "set_names()", 
#&gt;         splice.Rd = c("splice()", "is_spliced()", "is_spliced_bare()", 
#&gt;         "dots_splice()"), stack.Rd = c("global_frame()", "current_frame()", 
#&gt;         "ctxt_frame()", "call_frame()", "ctxt_depth()", "call_depth()", 
#&gt;         "ctxt_stack()", "call_stack()"), stack_trim.Rd = "stack_trim()", 
#&gt;         string.Rd = "string()", switch_type.Rd = c("switch_type()", 
#&gt;         "coerce_type()", "switch_class()", "coerce_class()"), 
#&gt;         sym.Rd = c("sym()", "syms()"), `tidy-dots.Rd` = c("dots_list()", 
#&gt;         "list2()"), `tidyeval-data.Rd` = ".data", trace_back.Rd = c("trace_back()", 
#&gt;         "trace_length()"), `type-predicates.Rd` = c("is_list()", 
#&gt;         "is_atomic()", "is_vector()", "is_integer()", "is_double()", 
#&gt;         "is_character()", "is_logical()", "is_raw()", "is_bytes()", 
#&gt;         "is_null()"), type_of.Rd = "type_of()", vec_poke_n.Rd = c("vec_poke_n()", 
#&gt;         "vec_poke_range()"), `vector-coercion.Rd` = c("as_logical()", 
#&gt;         "as_integer()", "as_double()", "as_complex()", "as_character()", 
#&gt;         "as_list()"), `vector-construction.Rd` = c("lgl()", "int()", 
#&gt;         "dbl()", "cpl()", "chr()", "bytes()"), `vector-old-ctors.Rd` = c("node()", 
#&gt;         "lgl_len()", "int_len()", "dbl_len()", "chr_len()", "cpl_len()", 
#&gt;         "raw_len()", "bytes_len()", "list_len()", "lgl_along()", 
#&gt;         "int_along()", "dbl_along()", "chr_along()", "cpl_along()", 
#&gt;         "raw_along()", "bytes_along()", "list_along()"), with_abort.Rd = "with_abort()", 
#&gt;         with_env.Rd = c("with_env()", "locally()"), with_handlers.Rd = c("with_handlers()", 
#&gt;         "calling()"), with_restarts.Rd = "with_restarts()", wref_key.Rd = c("wref_key()", 
#&gt;         "wref_value()"), zap.Rd = c("zap()", "is_zap()")), title = c("Signal an error, warning, or message", 
#&gt;     "Test for missing values", "Match an argument to a character vector", 
#&gt;     "Convert object to a box", "Coerce to a raw vector", "Create a data mask", 
#&gt;     "Coerce to an environment", "Coerce to an environment", "Convert to function or closure", 
#&gt;     "Create a default name for an R object", "Extract names from symbols", 
#&gt;     "Create an overscope", "Coerce to pairlist", "Coerce object to quosure", 
#&gt;     "Cast symbol to string", "Coerce to a character vector and attempt encoding conversion", 
#&gt;     "Bare type predicates", "Box a value", "Create a call", "Extract arguments from a call", 
#&gt;     "Extract function from a call", "Inspect a call", "Modify the arguments of a call", 
#&gt;     "Extract function name or namespaced of a call", "Standardise a call", 
#&gt;     "Get the current or caller environment", "Get properties of the current or caller frame", 
#&gt;     "Get caller frame", "Catch a condition", "Translate unicode points to UTF-8", 
#&gt;     "Create a condition object", "Build an error message from a main issue and bullet messages", 
#&gt;     "Muffle a condition", "Signal a condition object", "What type is a condition?", 
#&gt;     "Box a final value for early termination", "Capture definition objects", 
#&gt;     "How many arguments are currently forwarded in dots?", "Evaluate dots with preliminary splicing", 
#&gt;     "Duplicate an R object", "Get the empty environment", "Add backtrace from error handler", 
#&gt;     "Create a new environment", "Bind symbols to objects in an environment", 
#&gt;     "Bind a promise or active binding", "What kind of environment binding?", 
#&gt;     "Lock or unlock environment bindings", "Mask bindings by defining symbols deeper in a scope", 
#&gt;     "Clone an environment", "Depth of an environment chain", 
#&gt;     "Get an object in an environment", "Does an environment have or see bindings?", 
#&gt;     "Does environment inherit from another environment?", "Lock an environment", 
#&gt;     "Label of an environment", "Names and numbers of symbols bound in an environment", 
#&gt;     "Get parent environments", "Poke an object in an environment", 
#&gt;     "Pretty-print an environment", "Remove bindings from an environment", 
#&gt;     "Unlock an environment", "Evaluate an expression in an environment", 
#&gt;     "Evaluate an expression with quosures and pronoun support", 
#&gt;     "Execute a function", "Exiting handler", "Process unquote operators in a captured expression", 
#&gt;     "Turn an expression to a label", "Print an expression", "Ensure that all elements of a list of expressions are named", 
#&gt;     "Get or set formula components", "Turn RHS of formula into a string or label", 
#&gt;     "Flatten or squash a list of lists into a simpler vector", 
#&gt;     "Get or set function body", "Return the closure environment of a function", 
#&gt;     "Extract arguments from a function", "Find the position or distance of a frame on the evaluation stack", 
#&gt;     "Format a type for error messages", "Get or set the environment of an object", 
#&gt;     "How long is an object?", "Does an object have an element with this name?", 
#&gt;     "Does an object inherit from a set of classes?", "Invoke a function with a list of arguments", 
#&gt;     "Is object a call?", "Is an object callable?", "Is object a condition?", 
#&gt;     "Is an object copyable?", "Is object an empty vector or NULL?", 
#&gt;     "Is an object an environment?", "Is object an environment?", 
#&gt;     "Is an object an expression?", "Is an object an expression?", 
#&gt;     "Is object a formula?", "Is object a frame?", "Is object a function?", 
#&gt;     "Is a package installed in the library?", "Is a vector integer-like?", 
#&gt;     "Is R running interactively?", "Is object a call?", "Is object named?", 
#&gt;     "Is an object a namespace environment?", "Is object a node or pairlist?", 
#&gt;     "Is an object referencing another?", "Is object a stack?", 
#&gt;     "Is object a symbol?", "Is object identical to TRUE or FALSE?", 
#&gt;     "Is object a weak reference?", "Create a call", "Return the head or tail of a call", 
#&gt;     "Manipulate or access a call", "Last &lt;code&gt;abort()&lt;/code&gt; error", 
#&gt;     "Life cycle of the rlang package", "Missing values", "Generate or handle a missing argument", 
#&gt;     "Mutate node components", "Get names of a vector", "Create vectors matching the length of a given vector", 
#&gt;     "Create vectors matching a given length", "Create a new call from components", 
#&gt;     "Create a formula", "Create a function", "Helpers for pairlist and language nodes", 
#&gt;     "Create a list of quosures", "Create a weak reference", "Get the namespace of a package", 
#&gt;     "Definition operator", "Infix attribute accessor and setter", 
#&gt;     "Replace missing values", "Default value for &lt;code&gt;NULL&lt;/code&gt;", 
#&gt;     "Evaluate next quosure in a data mask", "Create pairlists with splicing support", 
#&gt;     "Parse R code", "Parse text into a quosure", "Prepend a vector", 
#&gt;     "Name of a primitive function", "Quasiquotation of an expression", 
#&gt;     "Squash a quosure", "Format quosures for printing or labelling", 
#&gt;     "Squash a quosure", "Quosure getters, setters and testers", 
#&gt;     "Quotation", "Create vectors matching the length of a given vector", 
#&gt;     "Create a restarting handler", "Jump to or from a frame", 
#&gt;     "Display backtrace on error", "Jump to the abort restart", 
#&gt;     "Restarts utilities", "Scalar type predicates", "Temporarily change bindings of an environment", 
#&gt;     "Retired &lt;code&gt;scoped&lt;/code&gt; functions", "Change global options", 
#&gt;     "Search path environments", "Increasing sequence of integers in an interval", 
#&gt;     "Add attributes to an object", "Set and get an expression", 
#&gt;     "Set names of a vector", "Splice lists", "Call stack information", 
#&gt;     "Trim top call layers from the evaluation stack", "Create a string", 
#&gt;     "Dispatch on base types", "Create a symbol or list of symbols", 
#&gt;     "Collect dots as lists", "Data pronoun for tidy evaluation", 
#&gt;     "Capture a backtrace", "Type predicates", "Base type of an object", 
#&gt;     "Poke values into a vector", "Coerce an object to a base type", 
#&gt;     "Create vectors", "Retired vector construction by length", 
#&gt;     "Promote all errors to rlang errors", "Evaluate an expression within a given environment", 
#&gt;     "Establish handlers on the stack", "Establish a restart point on the stack", 
#&gt;     "Get key/value from a weak reference object", "Create zap objects"
#&gt;     ), rd = list(abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/cnd-abort.R, R/cnd-signal.R", 
#&gt;         "\n", list("abort"), "\n", list("abort"), "\n", list(
#&gt;             "warn"), "\n", list("inform"), "\n", list("signal"), 
#&gt;         "\n", list("interrupt"), "\n", list("Signal an error, warning, or message"), 
#&gt;         "\n", list("\n", "abort(message = \"\", .subclass = NULL, ..., trace = NULL,\n", 
#&gt;             "  call = NULL, parent = NULL, msg, type)\n", "\n", 
#&gt;             "warn(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "inform(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "signal(message, .subclass, ...)\n", "\n", 
#&gt;             "interrupt()\n"), "\n", list("\n", list(list("message"), 
#&gt;             list("The message to display.\n", "\n", "Experimental: Can also be a named character vector, in which case\n", 
#&gt;                 "the message is assembled as a list of bullets. See\n", 
#&gt;                 list(list("cnd_message()")), " to learn how names control the bulleted output.")), 
#&gt;             "\n", "\n", list(list(".subclass"), list("Subclass of the condition. This allows your users\n", 
#&gt;                 "to selectively handle the conditions signalled by your functions.")), 
#&gt;             "\n", "\n", list(list("..."), list("Additional data to be stored in the condition object.")), 
#&gt;             "\n", "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                 " object created by ", list(list("trace_back()")), 
#&gt;                 ".")), "\n", "\n", list(list("call"), list("Defunct as of rlang 0.4.0. Storing the full\n", 
#&gt;                 "backtrace is now preferred to storing a simple call.")), 
#&gt;             "\n", "\n", list(list("parent"), list("A parent condition object created by ", 
#&gt;                 list(list("abort()")), ".")), "\n", "\n", list(
#&gt;                 list("msg, type"), list("These arguments were renamed to ", 
#&gt;                   list("message"), " and\n", list(".subclass"), 
#&gt;                   " and are defunct as of rlang 0.4.0.")), "\n"), 
#&gt;         "\n", list("\n", "These functions are equivalent to base functions ", 
#&gt;             list(list("base::stop()")), ",\n", list(list("base::warning()")), 
#&gt;             " and ", list(list("base::message()")), ", but make it easy to supply\n", 
#&gt;             "condition metadata:\n", list("\n", list(), " Supply ", 
#&gt;                 list(".subclass"), " to create a classed condition. Typed\n", 
#&gt;                 "conditions can be captured or handled selectively, allowing for\n", 
#&gt;                 "finer-grained error handling.\n", list(), " Supply metadata with named ", 
#&gt;                 list("..."), " arguments. This data will be\n", 
#&gt;                 "stored in the condition object and can be examined by handlers.\n"), 
#&gt;             "\n", "\n", list("interrupt()"), " allows R code to simulate a user interrupt of the\n", 
#&gt;             "kind that is signalled with ", list("Ctrl-C"), ". It is currently not possible\n", 
#&gt;             "to create custom interrupt condition objects.\n"), 
#&gt;         "\n", list(list("Backtrace"), list("\n", "\n", "\n", 
#&gt;             "Unlike ", list("stop()"), " and ", list("warning()"), 
#&gt;             ", these functions don't include call\n", "information by default. This saves you from typing ", 
#&gt;             list("call. = FALSE"), "\n", "and produces cleaner error messages.\n", 
#&gt;             "\n", "A backtrace is always saved into error objects. You can print a\n", 
#&gt;             "simplified backtrace of the last error by calling ", 
#&gt;             list(list("last_error()")), "\n", "and a full backtrace with ", 
#&gt;             list("summary(last_error())"), ".\n", "\n", "You can also display a backtrace with the error message by setting\n", 
#&gt;             "the option ", list("rlang_backtrace_on_error"), 
#&gt;             ". It supports the following\n", "values:\n", list(
#&gt;                 "\n", list(), " ", list("\"reminder\""), ": Invite users to call ", 
#&gt;                 list("rlang::last_error()"), " to see a\n", "backtrace.\n", 
#&gt;                 list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                 list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                 list(), " ", list("\"full\""), ": Display a full backtrace tree.\n", 
#&gt;                 list(), " ", list("\"none\""), ": Display nothing.\n"), 
#&gt;             "\n")), "\n", "\n", list(list("Mufflable conditions"), 
#&gt;             list("\n", "\n", "\n", "Signalling a condition with ", 
#&gt;                 list("inform()"), " or ", list("warn()"), " causes a message\n", 
#&gt;                 "to be displayed in the console. These messages can be muffled with\n", 
#&gt;                 list(list("base::suppressMessages()")), " or ", 
#&gt;                 list(list("base::suppressWarnings()")), ".\n", 
#&gt;                 "\n", "On recent R versions (&gt;= R 3.5.0), interrupts are typically\n", 
#&gt;                 "signalled with a ", list("\"resume\""), " restart. This is however not\n", 
#&gt;                 "guaranteed.\n")), "\n", "\n", list(list("Lifecycle"), 
#&gt;             list("\n", "\n", "\n", "These functions were changed in rlang 0.3.0 to take condition\n", 
#&gt;                 "metadata with ", list("..."), ". Consequently:\n", 
#&gt;                 list("\n", list(), " All arguments were renamed to be prefixed with a dot, except for\n", 
#&gt;                   list("type"), " which was renamed to ", list(
#&gt;                     ".subclass"), ".\n", list(), " ", list(".call"), 
#&gt;                   " (previously ", list("call"), ") can no longer be passed positionally.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# These examples are guarded to avoid throwing errors\n", 
#&gt;             "if (FALSE) {\n", "\n", "# Signal an error with a message just like stop():\n", 
#&gt;             "abort(\"Something bad happened\")\n", "\n", "# Give a class to the error:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\")\n", 
#&gt;             "\n", "# This will allow your users to handle the error selectively\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    warn(err$message) # Demote the error to a warning\n", 
#&gt;             "    NA                # Return an alternative value\n", 
#&gt;             "  }\n", ")\n", "\n", "# You can also specify metadata that will be stored in the condition:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\", data = 1:10)\n", 
#&gt;             "\n", "# This data can then be consulted by user handlers:\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    # Compute an alternative return value with the data:\n", 
#&gt;             "    recover_error(err$data)\n", "  }\n", ")\n", 
#&gt;             "\n", "# If you call low-level APIs it is good practice to catch technical\n", 
#&gt;             "# errors and rethrow them with a more meaningful message. Pass on\n", 
#&gt;             "# the caught error as `parent` to get a nice decomposition of\n", 
#&gt;             "# errors and backtraces:\n", "file &lt;- \"http://foo.bar/baz\"\n", 
#&gt;             "tryCatch(\n", "  download(file),\n", "  error = function(err) {\n", 
#&gt;             "    msg &lt;- sprintf(\"Can't download `%s`\", file)\n", 
#&gt;             "    abort(msg, parent = err)\n", "})\n", "\n", "# Unhandled errors are saved automatically by `abort()` and can be\n", 
#&gt;             "# retrieved with `last_error()`. The error prints with a simplified\n", 
#&gt;             "# backtrace:\n", "abort(\"Saved error?\")\n", "last_error()\n", 
#&gt;             "\n", "# Use `summary()` to print the full backtrace and the condition fields:\n", 
#&gt;             "summary(last_error())\n", "\n", "}\n"), "\n", list(
#&gt;             "\n", list(list("with_abort()")), " to convert all errors to rlang errors.\n"), 
#&gt;         "\n"), are_na.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/vec-na.R", "\n", 
#&gt;         list("are_na"), "\n", list("are_na"), "\n", list("is_na"), 
#&gt;         "\n", list("is_lgl_na"), "\n", list("is_int_na"), "\n", 
#&gt;         list("is_dbl_na"), "\n", list("is_chr_na"), "\n", list(
#&gt;             "is_cpl_na"), "\n", list("Test for missing values"), 
#&gt;         "\n", list("\n", "are_na(x)\n", "\n", "is_na(x)\n", "\n", 
#&gt;             "is_lgl_na(x)\n", "\n", "is_int_na(x)\n", "\n", "is_dbl_na(x)\n", 
#&gt;             "\n", "is_chr_na(x)\n", "\n", "is_cpl_na(x)\n"), 
#&gt;         "\n", list("\n", list(list("x"), list("An object to test")), 
#&gt;             "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;             "\n", "\n", list("are_na()"), " checks for missing values in a vector and is equivalent\n", 
#&gt;             "to ", list(list("base::is.na()")), ". It is a vectorised predicate, meaning that its\n", 
#&gt;             "output is always the same length as its input. On the other hand,\n", 
#&gt;             list("is_na()"), " is a scalar predicate and always returns a scalar\n", 
#&gt;             "boolean, ", list("TRUE"), " or ", list("FALSE"), 
#&gt;             ". If its input is not scalar, it returns\n", list(
#&gt;                 "FALSE"), ". Finally, there are typed versions that check for\n", 
#&gt;             "particular ", list("missing types"), ".\n"), "\n", 
#&gt;         list("\n", "The scalar predicates accept non-vector inputs. They are equivalent\n", 
#&gt;             "to ", list(list("is_null()")), " in that respect. In contrast the vectorised\n", 
#&gt;             "predicate ", list("are_na()"), " requires a vector input since it is defined\n", 
#&gt;             "over vector values.\n"), "\n", list(list("Life cycle"), 
#&gt;             list("\n", "\n", "\n", "These functions might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;         "\n", "\n", list("\n", "# are_na() is vectorised and works regardless of the type\n", 
#&gt;             "are_na(c(1, 2, NA))\n", "are_na(c(1L, NA, 3L))\n", 
#&gt;             "\n", "# is_na() checks for scalar input and works for all types\n", 
#&gt;             "is_na(NA)\n", "is_na(na_dbl)\n", "is_na(character(0))\n", 
#&gt;             "\n", "# There are typed versions as well:\n", "is_lgl_na(NA)\n", 
#&gt;             "is_lgl_na(na_dbl)\n"), "\n", list("internal"), "\n"), 
#&gt;         arg_match.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("arg_match"), "\n", list("arg_match"), "\n", 
#&gt;             list("Match an argument to a character vector"), 
#&gt;             "\n", list("\n", "arg_match(arg, values = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("arg"), list("A symbol referring to an argument accepting strings.")), 
#&gt;                 "\n", "\n", list(list("values"), list("The possible values that ", 
#&gt;                   list("arg"), " can take. If ", list("NULL"), 
#&gt;                   ",\n", "the values are taken from the function definition of the ", 
#&gt;                   list("caller frame"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "The string supplied to ", list("arg"), 
#&gt;                 ".\n"), "\n", list("\n", "This is equivalent to ", 
#&gt;                 list(list("base::match.arg()")), " with a few differences:\n", 
#&gt;                 list("\n", list(), " Partial matches trigger an error.\n", 
#&gt;                   list(), " Error messages are a bit more informative and obey the tidyverse\n", 
#&gt;                   "standards.\n"), "\n"), "\n", list("\n", "fn &lt;- function(x = c(\"foo\", \"bar\")) arg_match(x)\n", 
#&gt;                 "fn(\"bar\")\n", "\n", "# This would throw an informative error if run:\n", 
#&gt;                 "# fn(\"b\")\n", "# fn(\"baz\")\n"), "\n"), as_box.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "as_box"), "\n", list("as_box"), "\n", list("as_box_if"), 
#&gt;             "\n", list("Convert object to a box"), "\n", list(
#&gt;                 "\n", "as_box(x, class = NULL)\n", "\n", "as_box_if(.x, .p, .class = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("class, .class"), list(
#&gt;                   "A box class. If the input is already a box of\n", 
#&gt;                   "that class, it is returned as is. If the input needs to be boxed,\n", 
#&gt;                   list("class"), " is passed to ", list(list(
#&gt;                     "new_box()")), ".")), "\n", "\n", list(list(
#&gt;                   ".x"), list("An R object.")), "\n", "\n", list(
#&gt;                   list(".p"), list("A predicate function.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed to ", 
#&gt;                   list(".p"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("as_box()"), " boxes its input only if it is not already a box. The\n", 
#&gt;                   "class is also checked if supplied.\n", list(), 
#&gt;                   " ", list("as_box_if()"), " boxes its input only if it not already a box, or if\n", 
#&gt;                   "the predicate ", list(".p"), " returns ", 
#&gt;                   list("TRUE"), ".\n"), "\n"), "\n"), as_bytes.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_bytes"), "\n", list("as_bytes"), "\n", 
#&gt;             list("Coerce to a raw vector"), "\n", list("\n", 
#&gt;                 "as_bytes(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("A string.")), "\n"), "\n", list("\n", 
#&gt;                 "A raw vector of bytes.\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This currently only works with strings, and returns its hexadecimal\n", 
#&gt;                 "representation.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "Raw vector functions are experimental.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_data_mask.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/eval-tidy.R", "\n", 
#&gt;             list("as_data_mask"), "\n", list("as_data_mask"), 
#&gt;             "\n", list("as_data_pronoun"), "\n", list("new_data_mask"), 
#&gt;             "\n", list("Create a data mask"), "\n", list("\n", 
#&gt;                 "as_data_mask(data, parent = NULL)\n", "\n", 
#&gt;                 "as_data_pronoun(data)\n", "\n", "new_data_mask(bottom, top = bottom, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("Deprecated. This argument no longer has any effect.\n", 
#&gt;                   "The parent of the data mask is determined from either:\n", 
#&gt;                   list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                     list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"))), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "A data mask that you can supply to ", 
#&gt;                 list(list("eval_tidy()")), ".\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "A data mask is an environment (or possibly multiple environments\n", 
#&gt;                 "forming an ancestry) containing user-supplied objects. Objects in\n", 
#&gt;                 "the mask have precedence over objects in the environment (i.e. they\n", 
#&gt;                 "mask those objects). Many R functions evaluate quoted expressions\n", 
#&gt;                 "in a data mask so these expressions can refer to objects within the\n", 
#&gt;                 "user data.\n", "\n", "These functions let you construct a tidy eval data mask manually.\n", 
#&gt;                 "They are meant for developers of tidy eval interfaces rather than\n", 
#&gt;                 "for end users.\n"), "\n", list(list("Why build a data mask?"), 
#&gt;                 list("\n", "\n", "\n", "Most of the time you can just call ", 
#&gt;                   list(list("eval_tidy()")), " with a list or a\n", 
#&gt;                   "data frame and the data mask will be constructed automatically.\n", 
#&gt;                   "There are three main use cases for manual creation of data masks:\n", 
#&gt;                   list("\n", list(), " When ", list(list("eval_tidy()")), 
#&gt;                     " is called with the same data in a tight loop.\n", 
#&gt;                     "Because there is some overhead to creating tidy eval data masks,\n", 
#&gt;                     "constructing the mask once and reusing it for subsequent\n", 
#&gt;                     "evaluations may improve performance.\n", 
#&gt;                     list(), " When several expressions should be evaluated in the exact same\n", 
#&gt;                     "environment because a quoted expression might create new objects\n", 
#&gt;                     "that can be referred in other quoted expressions evaluated at a\n", 
#&gt;                     "later time. One example of this is ", list(
#&gt;                       "tibble::lst()"), " where new\n", "columns can refer to previous ones.\n", 
#&gt;                     list(), " When your data mask requires special features. For instance the\n", 
#&gt;                     "data frame columns in dplyr data masks are implemented with\n", 
#&gt;                     list("active bindings"), ".\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Building your own data mask"), 
#&gt;                 list("\n", "\n", "\n", "Unlike ", list(list("base::eval()")), 
#&gt;                   " which takes any kind of environments as data\n", 
#&gt;                   "mask, ", list(list("eval_tidy()")), " has specific requirements in order to support\n", 
#&gt;                   list("quosures"), ". For this reason you can't supply bare\n", 
#&gt;                   "environments.\n", "\n", "There are two ways of constructing an rlang data mask manually:\n", 
#&gt;                   list("\n", list(), " ", list("as_data_mask()"), 
#&gt;                     " transforms a list or data frame to a data mask.\n", 
#&gt;                     "It automatically installs the data pronoun ", 
#&gt;                     list(list(".data")), ".\n", list(), " ", 
#&gt;                     list("new_data_mask()"), " is a bare bones data mask constructor for\n", 
#&gt;                     "environments. You can supply a bottom and a top environment in\n", 
#&gt;                     "case your data mask comprises multiple environments (see section\n", 
#&gt;                     "below).\n", "\n", "Unlike ", list("as_data_mask()"), 
#&gt;                     " it does not install the ", list(".data"), 
#&gt;                     " pronoun\n", "so you need to provide one yourself. You can provide a pronoun\n", 
#&gt;                     "constructed with ", list("as_data_pronoun()"), 
#&gt;                     " or your own pronoun class.\n", "\n", list(
#&gt;                       "as_data_pronoun()"), " will create a pronoun from a list, an\n", 
#&gt;                     "environment, or an rlang data mask. In the latter case, the whole\n", 
#&gt;                     "ancestry is looked up from the bottom to the top of the mask.\n", 
#&gt;                     "Functions stored in the mask are bypassed by the pronoun.\n"), 
#&gt;                   "\n", "\n", "Once you have built a data mask, simply pass it to ", 
#&gt;                   list(list("eval_tidy()")), " as\n", "the ", 
#&gt;                   list("data"), " argument. You can repeat this as many times as\n", 
#&gt;                   "needed. Note that any objects created there (perhaps because of a\n", 
#&gt;                   "call to ", list("&lt;-"), ") will persist in subsequent evaluations.\n")), 
#&gt;             "\n", "\n", list(list("Top and bottom of data mask"), 
#&gt;                 list("\n", "\n", "\n", "In some cases you'll need several levels in your data mask. One\n", 
#&gt;                   "good reason is when you include functions in the mask. It's a good\n", 
#&gt;                   "idea to keep data objects one level lower than function objects, so\n", 
#&gt;                   "that the former cannot override the definitions of the latter (see\n", 
#&gt;                   "examples).\n", "\n", "In that case, set up all your environments and keep track of the\n", 
#&gt;                   "bottom child and the top parent. You'll need to pass both to\n", 
#&gt;                   list("new_data_mask()"), ".\n", "\n", "Note that the parent of the top environment is completely\n", 
#&gt;                   "undetermined, you shouldn't expect it to remain the same at all\n", 
#&gt;                   "times. This parent is replaced during evaluation by ", 
#&gt;                   list(list("eval_tidy()")), "\n", "to one of the following environments:\n", 
#&gt;                   list("\n", list(), " The default environment passed as the ", 
#&gt;                     list("env"), " argument of ", list("eval_tidy()"), 
#&gt;                     ".\n", list(), " The environment of the current quosure being evaluated, if applicable.\n"), 
#&gt;                   "\n", "\n", "Consequently, all masking data should be contained between the\n", 
#&gt;                   "bottom and top environment of the data mask.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "The ", list("parent"), " argument no longer has any effect and is defunct as of\n", 
#&gt;                 "rlang 0.4.0. The parent of the data mask is determined from either:\n", 
#&gt;                 list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                   list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"), 
#&gt;                 "\n", "\n", "Passing environments to ", list(
#&gt;                   "as_data_mask()"), " is deprecated as of rlang\n", 
#&gt;                 "0.3.0. Please use ", list("new_data_mask()"), 
#&gt;                 " instead.\n", "\n", list("rlang 0.2.0"), "\n", 
#&gt;                 "\n", "In early versions of rlang data masks were called overscopes. We\n", 
#&gt;                 "think data mask is a more natural name in R. It makes reference to\n", 
#&gt;                 "masking in the search path which occurs through the same mechanism\n", 
#&gt;                 "(in technical terms, lexical scoping with hierarchically nested\n", 
#&gt;                 "environments). We say that objects from user data mask objects\n", 
#&gt;                 "in the current environment.\n", "\n", "Following this change in terminology, ", 
#&gt;                 list("as_overscope()"), " and\n", list("new_overscope()"), 
#&gt;                 " were deprecated in rlang 0.2.0 in favour of\n", 
#&gt;                 list("as_data_mask()"), " and ", list("new_data_mask()"), 
#&gt;                 ".\n")), "\n", "\n", list("\n", "# Evaluating in a tidy evaluation environment enables all tidy\n", 
#&gt;                 "# features:\n", "mask &lt;- as_data_mask(mtcars)\n", 
#&gt;                 "eval_tidy(quo(letters), mask)\n", "\n", "# You can install new pronouns in the mask:\n", 
#&gt;                 "mask$.pronoun &lt;- as_data_pronoun(list(foo = \"bar\", baz = \"bam\"))\n", 
#&gt;                 "eval_tidy(quo(.pronoun$foo), mask)\n", "\n", 
#&gt;                 "# In some cases the data mask can leak to the user, for example if\n", 
#&gt;                 "# a function or formula is created in the data mask environment:\n", 
#&gt;                 "cyl &lt;- \"user variable from the context\"\n", 
#&gt;                 "fn &lt;- eval_tidy(quote(function() cyl), mask)\n", 
#&gt;                 "fn()\n", "\n", "# If new objects are created in the mask, they persist in the\n", 
#&gt;                 "# subsequent calls:\n", "eval_tidy(quote(new &lt;- cyl + am), mask)\n", 
#&gt;                 "eval_tidy(quote(new * 2), mask)\n", "\n", "\n", 
#&gt;                 "# In some cases your data mask is a whole chain of environments\n", 
#&gt;                 "# rather than a single environment. You'll have to use\n", 
#&gt;                 "# `new_data_mask()` and let it know about the bottom of the mask\n", 
#&gt;                 "# (the last child of the environment chain) and the topmost parent.\n", 
#&gt;                 "\n", "# A common situation where you'll want a multiple-environment mask\n", 
#&gt;                 "# is when you include functions in your mask. In that case you'll\n", 
#&gt;                 "# put functions in the top environment and data in the bottom. This\n", 
#&gt;                 "# will prevent the data from overwriting the functions.\n", 
#&gt;                 "top &lt;- new_environment(list(`+` = base::paste, c = base::paste))\n", 
#&gt;                 "\n", "# Let's add a middle environment just for sport:\n", 
#&gt;                 "middle &lt;- env(top)\n", "\n", "# And finally the bottom environment containing data:\n", 
#&gt;                 "bottom &lt;- env(middle, a = \"a\", b = \"b\", c = \"c\")\n", 
#&gt;                 "\n", "# We can now create a mask by supplying the top and bottom\n", 
#&gt;                 "# environments:\n", "mask &lt;- new_data_mask(bottom, top = top)\n", 
#&gt;                 "\n", "# This data mask can be passed to eval_tidy() instead of a list or\n", 
#&gt;                 "# data frame:\n", "eval_tidy(quote(a + b + c), data = mask)\n", 
#&gt;                 "\n", "# Note how the function `c()` and the object `c` are looked up\n", 
#&gt;                 "# properly because of the multi-level structure:\n", 
#&gt;                 "eval_tidy(quote(c(a, b, c)), data = mask)\n", 
#&gt;                 "\n", "# new_data_mask() does not create data pronouns, but\n", 
#&gt;                 "# data pronouns can be added manually:\n", "mask$.fns &lt;- as_data_pronoun(top)\n", 
#&gt;                 "\n", "# The `.data` pronoun should generally be created from the\n", 
#&gt;                 "# mask. This will ensure data is looked up throughout the whole\n", 
#&gt;                 "# ancestry. Only non-function objects are looked up from this\n", 
#&gt;                 "# pronoun:\n", "mask$.data &lt;- as_data_pronoun(mask)\n", 
#&gt;                 "mask$.data$c\n", "\n", "# Now we can reference the values with the pronouns:\n", 
#&gt;                 "eval_tidy(quote(c(.data$a, .data$b, .data$c)), data = mask)\n"), 
#&gt;             "\n"), as_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_env"), "\n", list("as_env"), "\n", 
#&gt;             list("Coerce to an environment"), "\n", list("\n", 
#&gt;                 "as_env(x, parent = NULL)\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated as it was renamed to ", 
#&gt;                 list(list("as_environment()")), "\n", "in rlang 0.2.0.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "as_environment"), "\n", list("as_environment"), 
#&gt;             "\n", list("Coerce to an environment"), "\n", list(
#&gt;                 "\n", "as_environment(x, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("A parent environment, ", 
#&gt;                   list(list("empty_env()")), " by default. This\n", 
#&gt;                   "argument is only used when ", list("x"), " is data actually coerced to an\n", 
#&gt;                   "environment (as opposed to data representing an environment, like\n", 
#&gt;                   list("NULL"), " representing the empty environment).")), 
#&gt;                 "\n"), "\n", list("\n", list("as_environment()"), 
#&gt;                 " coerces named vectors (including lists) to an\n", 
#&gt;                 "environment. The names must be unique. If supplied an unnamed\n", 
#&gt;                 "string, it returns the corresponding package environment (see\n", 
#&gt;                 list(list("pkg_env()")), ").\n"), "\n", list(
#&gt;                 "\n", "If ", list("x"), " is an environment and ", 
#&gt;                 list("parent"), " is not ", list("NULL"), ", the\n", 
#&gt;                 "environment is duplicated before being set a new parent. The return\n", 
#&gt;                 "value is therefore a different environment than ", 
#&gt;                 list("x"), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("as_env()"), " was soft-deprecated and renamed to ", 
#&gt;                   list("as_environment()"), " in\n", "rlang 0.2.0. This is for consistency as type predicates should not\n", 
#&gt;                   "be abbreviated.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Coerce a named vector to an environment:\n", 
#&gt;                 "env &lt;- as_environment(mtcars)\n", "\n", "# By default it gets the empty environment as parent:\n", 
#&gt;                 "identical(env_parent(env), empty_env())\n", 
#&gt;                 "\n", "\n", "# With strings it is a handy shortcut for pkg_env():\n", 
#&gt;                 "as_environment(\"base\")\n", "as_environment(\"rlang\")\n", 
#&gt;                 "\n", "# With NULL it returns the empty environment:\n", 
#&gt;                 "as_environment(NULL)\n"), "\n"), as_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "as_function"), "\n", list("as_function"), "\n", 
#&gt;             list("is_lambda"), "\n", list("as_closure"), "\n", 
#&gt;             list("Convert to function or closure"), "\n", list(
#&gt;                 "\n", "as_function(x, env = caller_env())\n", 
#&gt;                 "\n", "is_lambda(x)\n", "\n", "as_closure(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function or formula.\n", 
#&gt;                 "\n", "If a ", list("function"), ", it is used as is.\n", 
#&gt;                 "\n", "If a ", list("formula"), ", e.g. ", list(
#&gt;                   "~ .x + 2"), ", it is converted to a function\n", 
#&gt;                 "with up to two arguments: ", list(".x"), " (single argument) or ", 
#&gt;                 list(".x"), " and ", list(".y"), "\n", "(two arguments). The ", 
#&gt;                 list("."), " placeholder can be used instead of ", 
#&gt;                 list(".x"), ".\n", "This allows you to create very compact anonymous functions (lambdas) with up\n", 
#&gt;                 "to two inputs. Functions created from formulas have a special\n", 
#&gt;                 "class. Use ", list("is_lambda()"), " to test for it.\n", 
#&gt;                 "\n", "Lambdas currently do not support ", list(
#&gt;                   "quasiquotation"), ",\n", "due to the way the arguments are handled internally.")), 
#&gt;                 "\n", "\n", list(list("env"), list("Environment in which to fetch the function in case ", 
#&gt;                   list("x"), "\n", "is a string.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("as_function()"), 
#&gt;                   " transforms a one-sided formula into a function.\n", 
#&gt;                   "This powers the lambda syntax in packages like purrr.\n", 
#&gt;                   list(), " ", list("as_closure()"), " first passes its argument to ", 
#&gt;                   list("as_function()"), ". If\n", "the result is a primitive function, it regularises it to a proper\n", 
#&gt;                   list("closure"), " (see ", list(list("is_function()")), 
#&gt;                   " about primitive functions). Some\n", "special control flow primitives like ", 
#&gt;                   list("if"), ", ", list("for"), ", or ", list(
#&gt;                     "break"), "\n", "can't be coerced to a closure.\n"), 
#&gt;                 "\n"), "\n", list("\n", "f &lt;- as_function(~ .x + 1)\n", 
#&gt;                 "f(10)\n", "\n", "g &lt;- as_function(~ -1 * .)\n", 
#&gt;                 "g(4)\n", "\n", "h &lt;- as_function(~ .x - .y)\n", 
#&gt;                 "h(6, 3)\n", "\n", "# Functions created from a formula have a special class:\n", 
#&gt;                 "is_lambda(f)\n", "is_lambda(as_function(function() \"foo\"))\n", 
#&gt;                 "\n", "# Primitive functions are regularised as closures\n", 
#&gt;                 "as_closure(list)\n", "as_closure(\"list\")\n", 
#&gt;                 "\n", "# Operators have `.x` and `.y` as arguments, just like lambda\n", 
#&gt;                 "# functions created with the formula syntax:\n", 
#&gt;                 "as_closure(`+`)\n", "as_closure(`~`)\n", "\n", 
#&gt;                 "# Use a regular function for tidy evaluation, also when calling functions\n", 
#&gt;                 "# that use tidy evaluation:\n", "## Bad:\n", 
#&gt;                 "e &lt;- as_function(~ as_label(ensym(.x)))\n", 
#&gt;                 "## Good:\n", "e &lt;- as_function(function(x) as_label(ensym(x)))\n", 
#&gt;                 "\n", "e(y)\n"), "\n"), as_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/deparse.R", 
#&gt;             "\n", list("as_label"), "\n", list("as_label"), "\n", 
#&gt;             list("Create a default name for an R object"), "\n", 
#&gt;             list("\n", "as_label(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object.")), "\n"), "\n", 
#&gt;             list("\n", list("as_label()"), " transforms R objects into a short, human-readable\n", 
#&gt;                 "description. You can use labels to:\n", list(
#&gt;                   "\n", list(), " Display an object in a concise way, for example to labellise axes\n", 
#&gt;                   "in a graphical plot.\n", list(), " Give default names to columns in a data frame. In this case,\n", 
#&gt;                   "labelling is the first step before name repair.\n"), 
#&gt;                 "\n", "\n", "See also ", list(list("as_name()")), 
#&gt;                 " for transforming symbols back to a\n", "string. Unlike ", 
#&gt;                 list("as_label()"), ", ", list("as_string()"), 
#&gt;                 " is a well defined\n", "operation that guarantees the roundtrip symbol -&gt; string -&gt;\n", 
#&gt;                 "symbol.\n", "\n", "In general, if you don't know for sure what kind of object you're\n", 
#&gt;                 "dealing with (a call, a symbol, an unquoted constant), use\n", 
#&gt;                 list("as_label()"), " and make no assumption about the resulting string. If\n", 
#&gt;                 "you know you have a symbol and need the name of the object it\n", 
#&gt;                 "refers to, use ", list(list("as_string()")), 
#&gt;                 ". For instance, use ", list("as_label()"), " with\n", 
#&gt;                 "objects captured with ", list("enquo()"), " and ", 
#&gt;                 list("as_string()"), " with symbols\n", "captured with ", 
#&gt;                 list("ensym()"), ".\n"), "\n", list(list("Transformation to string"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Quosures are ", 
#&gt;                   list("squashed"), " before being labelled.\n", 
#&gt;                   list(), " Symbols are transformed to string with ", 
#&gt;                   list("as_string()"), ".\n", list(), " Calls are abbreviated.\n", 
#&gt;                   list(), " Numbers are represented as such.\n", 
#&gt;                   list(), " Other constants are represented by their type, such as ", 
#&gt;                   list("&lt;dbl&gt;"), "\n", "or ", list("&lt;data.frame&gt;"), 
#&gt;                   ".\n"), "\n", "\n", "Note that simple symbols should generally be transformed to strings\n", 
#&gt;                   "with ", list(list("as_name()")), ". Labelling is not a well defined operation and\n", 
#&gt;                   "no assumption should be made about how the label is created. On the\n", 
#&gt;                   "other hand, ", list("as_name()"), " only works with symbols and is a well\n", 
#&gt;                   "defined, deterministic operation.\n")), "\n", 
#&gt;             "\n", list("\n", "# as_label() is useful with quoted expressions:\n", 
#&gt;                 "as_label(expr(foo(bar)))\n", "as_label(expr(foobar))\n", 
#&gt;                 "\n", "# It works with any R object. This is also useful for quoted\n", 
#&gt;                 "# arguments because the user might unquote constant objects:\n", 
#&gt;                 "as_label(1:3)\n", "as_label(base::list)\n"), 
#&gt;             "\n", list("\n", list(list("as_name()")), " for transforming symbols back to a string\n", 
#&gt;                 "deterministically.\n"), "\n"), as_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/deparse.R", "\n", 
#&gt;             list("as_name"), "\n", list("as_name"), "\n", list(
#&gt;                 "Extract names from symbols"), "\n", list("\n", 
#&gt;                 "as_name(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("A string or symbol, possibly wrapped in a ", 
#&gt;                   list("quosure"), ".\n", "If a string, the attributes are removed, if any.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of length 1.\n"), 
#&gt;             "\n", list("\n", list("as_name()"), " converts ", 
#&gt;                 list("symbols"), " to character strings. The\n", 
#&gt;                 "conversion is deterministic. That is, the roundtrip symbol -&gt; name\n", 
#&gt;                 "-&gt; symbol always gets the same result.\n", list(
#&gt;                   "\n", list(), " Use ", list("as_name()"), " when you need to transform a symbol to a string\n", 
#&gt;                   "to ", list("refer"), " to an object by its name.\n", 
#&gt;                   list(), " Use ", list(list("as_label()")), 
#&gt;                   " when you need to transform any kind of object to\n", 
#&gt;                   "a string to ", list("represent"), " that object with a short description.\n"), 
#&gt;                 "\n", "\n", "Expect ", list("as_name()"), " to gain\n", 
#&gt;                 list(list("https://principles.tidyverse.org/names-attribute.html#minimal-unique-universal"), 
#&gt;                   list("name-repairing")), "\n", "features in the future.\n", 
#&gt;                 "\n", "Note that ", list("rlang::as_name()"), 
#&gt;                 " is the ", list("opposite"), " of\n", list(list(
#&gt;                   "base::as.name()")), ". If you're writing base R code, we recommend\n", 
#&gt;                 "using ", list(list("base::as.symbol()")), " which is an alias of ", 
#&gt;                 list("as.name()"), " that\n", "follows a more modern terminology (R types instead of S modes).\n"), 
#&gt;             "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_name() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_name(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_name(bar))\n", "\n", "# as_name() unwraps quosured symbols automatically:\n", 
#&gt;                 "as_name(quo(foo))\n"), "\n", list("\n", list(
#&gt;                 list("as_label()")), " for converting any object to a single string\n", 
#&gt;                 "suitable as a label. ", list(list("as_string()")), 
#&gt;                 " for a lower-level version that\n", "doesn't unwrap quosures.\n"), 
#&gt;             "\n"), as_overscope.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_overscope"), "\n", list("as_overscope"), 
#&gt;             "\n", list("new_overscope"), "\n", list("overscope_clean"), 
#&gt;             "\n", list("Create an overscope"), "\n", list("\n", 
#&gt;                 "as_overscope(quo, data = NULL)\n", "\n", "new_overscope(bottom, top = NULL, enclosure = NULL)\n", 
#&gt;                 "\n", "overscope_clean(overscope)\n"), "\n", 
#&gt;             list("\n", list(list("quo"), list("A ", list("quosure"), 
#&gt;                 ".")), "\n", "\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n", "\n", list(list("enclosure"), 
#&gt;                   list("The ", list("parent"), " argument of ", 
#&gt;                     list(list("new_data_mask()")), ".")), "\n", 
#&gt;                 "\n", list(list("overscope"), list("A data mask.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions have been deprecated in rlang 0.2.0. Please use\n", 
#&gt;                 list(list("as_data_mask()")), " and ", list(list(
#&gt;                   "new_data_mask()")), " instead. We no longer\n", 
#&gt;                 "require the mask to be cleaned up so ", list(
#&gt;                   "overscope_clean()"), " does not\n", "have a replacement.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_pairlist.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/node.R", "\n", 
#&gt;             list("as_pairlist"), "\n", list("as_pairlist"), "\n", 
#&gt;             list("Coerce to pairlist"), "\n", list("\n", "as_pairlist(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", "This transforms vector objects to a linked pairlist of nodes. See\n", 
#&gt;                 "the ", list("pairlist"), " type help page.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("as_pairlist()"), " is experimental because we are still figuring out\n", 
#&gt;                 "the naming scheme for pairlists and node-like objects.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "as_quosure"), "\n", list("as_quosure"), "\n", 
#&gt;             list("new_quosure"), "\n", list("Coerce object to quosure"), 
#&gt;             "\n", list("\n", "as_quosure(x, env = NULL)\n", "\n", 
#&gt;                 "new_quosure(expr, env = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to convert. Either an ", 
#&gt;                 list("expression"), " or a\n", "formula.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which the expression should be\n", 
#&gt;                   "evaluated. Only used for symbols and calls. This should typically\n", 
#&gt;                   "be the environment in which the expression was created.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("The expression wrapped by the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "While ", list("new_quosure()"), 
#&gt;                 " wraps any R object (including expressions,\n", 
#&gt;                 "formulas, or other quosures) into a quosure, ", 
#&gt;                 list("as_quosure()"), "\n", "converts formulas and quosures and does not double-wrap.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("as_quosure()"), " now requires an explicit default environment for\n", 
#&gt;                 "creating quosures from symbols and calls.\n", 
#&gt;                 list(), " ", list("as_quosureish()"), " is deprecated as of rlang 0.2.0. This function\n", 
#&gt;                 "assumes that quosures are formulas which is currently true but\n", 
#&gt;                 "might not be in the future.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "# as_quosure() converts expressions or any R object to a validly\n", 
#&gt;                 "# scoped quosure:\n", "env &lt;- env(var = \"thing\")\n", 
#&gt;                 "as_quosure(quote(var), env)\n", "\n", "\n", 
#&gt;                 "# The environment is ignored for formulas:\n", 
#&gt;                 "as_quosure(~foo, env)\n", "as_quosure(~foo)\n", 
#&gt;                 "\n", "# However you must supply it for symbols and calls:\n", 
#&gt;                 "try(as_quosure(quote(var)))\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), ", ", list(list("is_quosure()")), 
#&gt;                 "\n"), "\n"), as_string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("as_string"), "\n", list("as_string"), "\n", 
#&gt;             list("Cast symbol to string"), "\n", list("\n", "as_string(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or symbol. If a string, the attributes are\n", 
#&gt;                 "removed, if any.")), "\n"), "\n", list("\n", 
#&gt;                 "A character vector of length 1.\n"), "\n", list(
#&gt;                 "\n", list("as_string()"), " converts ", list(
#&gt;                   "symbols"), " to character strings.\n"), "\n", 
#&gt;             list(list("Unicode tags"), list("\n", "\n", "\n", 
#&gt;                 "Unlike ", list(list("base::as.symbol()")), " and ", 
#&gt;                 list(list("base::as.name()")), ", ", list("as_string()"), 
#&gt;                 "\n", "automatically transforms unicode tags such as ", 
#&gt;                 list("\"&lt;U+5E78&gt;\""), " to the\n", "proper UTF-8 character. This is important on Windows because:\n", 
#&gt;                 list("\n", list(), " R on Windows has no UTF-8 support, and uses native encoding instead.\n", 
#&gt;                   list(), " The native encodings do not cover all Unicode characters. For\n", 
#&gt;                   "example, Western encodings do not support CKJ characters.\n", 
#&gt;                   list(), " When a lossy UTF-8 -&gt; native transformation occurs, uncovered\n", 
#&gt;                   "characters are transformed to an ASCII unicode tag like ", 
#&gt;                   list("\"&lt;U+5E78&gt;\""), ".\n", list(), " Symbols are always encoded in native. This means that\n", 
#&gt;                   "transforming the column names of a data frame to symbols might be\n", 
#&gt;                   "a lossy operation.\n", list(), " This operation is very common in the tidyverse because of data\n", 
#&gt;                   "masking APIs like dplyr where data frames are transformed to\n", 
#&gt;                   "environments. While the names of a data frame are stored as a\n", 
#&gt;                   "character vector, the bindings of environments are stored as\n", 
#&gt;                   "symbols.\n"), "\n", "\n", "Because it reencodes the ASCII unicode tags to their UTF-8\n", 
#&gt;                 "representation, the string -&gt; symbol -&gt; string roundtrip is\n", 
#&gt;                 "more stable with ", list("as_string()"), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_string() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_string(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_string(bar))\n"), "\n", list("\n", 
#&gt;                 list(list("as_name()")), " for a higher-level variant of ", 
#&gt;                 list("as_string()"), "\n", "that automatically unwraps quosures.\n"), 
#&gt;             "\n"), as_utf8_character.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_utf8_character"), "\n", list("as_utf8_character"), 
#&gt;             "\n", list("Coerce to a character vector and attempt encoding conversion"), 
#&gt;             "\n", list("\n", "as_utf8_character(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Unlike specifying the ", list("encoding"), 
#&gt;                 " argument in ", list("as_string()"), " and\n", 
#&gt;                 list("as_character()"), ", which is only declarative, these functions\n", 
#&gt;                 "actually attempt to convert the encoding of their input. There are\n", 
#&gt;                 "two possible cases:\n", list("\n", list(), " The string is tagged as UTF-8 or latin1, the only two encodings\n", 
#&gt;                   "for which R has specific support. In this case, converting to the\n", 
#&gt;                   "same encoding is a no-op, and converting to native always works\n", 
#&gt;                   "as expected, as long as the native encoding, the one specified by\n", 
#&gt;                   "the ", list("LC_CTYPE"), " locale has support for all characters occurring in\n", 
#&gt;                   "the strings. Unrepresentable characters are serialised as unicode\n", 
#&gt;                   "points: \"&lt;U+xxxx&gt;\".\n", list(), " The string is not tagged. R assumes that it is encoded in the\n", 
#&gt;                   "native encoding. Conversion to native is a no-op, and conversion\n", 
#&gt;                   "to UTF-8 should work as long as the string is actually encoded in\n", 
#&gt;                   "the locale codeset.\n"), "\n", "\n", "When translating to UTF-8, the strings are parsed for serialised\n", 
#&gt;                 "unicode points (e.g. strings looking like \"U+xxxx\") with\n", 
#&gt;                 list(list("chr_unserialise_unicode()")), ". This helps to alleviate the effects of\n", 
#&gt;                 "character-to-symbol-to-character roundtrips on systems with\n", 
#&gt;                 "non-UTF-8 native encoding.\n"), "\n", list("\n", 
#&gt;                 "# Let's create a string marked as UTF-8 (which is guaranteed by the\n", 
#&gt;                 "# Unicode escaping in the string):\n", "utf8 &lt;- \"caf\\uE9\"\n", 
#&gt;                 "Encoding(utf8)\n", "as_bytes(utf8)\n"), "\n", 
#&gt;             list("internal"), "\n"), `bare-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("bare-type-predicates"), "\n", list("bare-type-predicates"), 
#&gt;             "\n", list("is_bare_list"), "\n", list("is_bare_atomic"), 
#&gt;             "\n", list("is_bare_vector"), "\n", list("is_bare_double"), 
#&gt;             "\n", list("is_bare_integer"), "\n", list("is_bare_numeric"), 
#&gt;             "\n", list("is_bare_character"), "\n", list("is_bare_logical"), 
#&gt;             "\n", list("is_bare_raw"), "\n", list("is_bare_string"), 
#&gt;             "\n", list("is_bare_bytes"), "\n", list("Bare type predicates"), 
#&gt;             "\n", list("\n", "is_bare_list(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_atomic(x, n = NULL)\n", "\n", "is_bare_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_double(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_integer(x, n = NULL)\n", "\n", "is_bare_numeric(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_bare_logical(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_raw(x, n = NULL)\n", "\n", "is_bare_string(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_bytes(x, n = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check for a given type but only return ", 
#&gt;                 list("TRUE"), " for\n", "bare R objects. Bare objects have no class attributes. For example,\n", 
#&gt;                 "a data frame is a list, but not a bare list.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " The predicates for vectors include the ", 
#&gt;                 list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                 list(), " Like ", list(list("is_atomic()")), 
#&gt;                 " and unlike base R ", list("is.atomic()"), ",\n", 
#&gt;                 list("is_bare_atomic()"), " does not return ", 
#&gt;                 list("TRUE"), " for ", list("NULL"), ".\n", list(), 
#&gt;                 " Unlike base R ", list("is.numeric()"), ", ", 
#&gt;                 list("is_bare_double()"), " only returns\n", 
#&gt;                 list("TRUE"), " for floating point numbers.\n"), 
#&gt;                 "\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("scalar-type-predicates"), "\n"), 
#&gt;             "\n"), box.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("box"), "\n", list("box"), "\n", list("new_box"), 
#&gt;             "\n", list("is_box"), "\n", list("unbox"), "\n", 
#&gt;             list("Box a value"), "\n", list("\n", "new_box(.x, class = NULL, ...)\n", 
#&gt;                 "\n", "is_box(x, class = NULL)\n", "\n", "unbox(box)\n"), 
#&gt;             "\n", list("\n", list(list("class"), list("For ", 
#&gt;                 list("new_box()"), ", an additional class for the\n", 
#&gt;                 "boxed value (in addition to ", list("rlang_box"), 
#&gt;                 "). For ", list("is_box()"), ", a class\n", "or vector of classes passed to ", 
#&gt;                 list(list("inherits_all()")), ".")), "\n", "\n", 
#&gt;                 list(list("..."), list("Additional attributes passed to ", 
#&gt;                   list(list("base::structure()")), ".")), "\n", 
#&gt;                 "\n", list(list("x, .x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("box"), list("A boxed value to unbox.")), 
#&gt;                 "\n"), "\n", list("\n", list("new_box()"), " is similar to ", 
#&gt;                 list(list("base::I()")), " but it protects a value by\n", 
#&gt;                 "wrapping it in a scalar list rather than by adding an attribute.\n", 
#&gt;                 list("unbox()"), " retrieves the boxed value. ", 
#&gt;                 list("is_box()"), " tests whether an\n", "object is boxed with optional class. ", 
#&gt;                 list("as_box()"), " ensures that a\n", "value is wrapped in a box. ", 
#&gt;                 list("as_box_if()"), " does the same but only if\n", 
#&gt;                 "the value matches a predicate.\n"), "\n", list(
#&gt;                 "\n", "boxed &lt;- new_box(letters, \"mybox\")\n", 
#&gt;                 "is_box(boxed)\n", "is_box(boxed, \"mybox\")\n", 
#&gt;                 "is_box(boxed, \"otherbox\")\n", "\n", "unbox(boxed)\n", 
#&gt;                 "\n", "# as_box() avoids double-boxing:\n", "boxed2 &lt;- as_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed2\n", "unbox(boxed2)\n", "\n", "# Compare to:\n", 
#&gt;                 "boxed_boxed &lt;- new_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed_boxed\n", "unbox(unbox(boxed_boxed))\n", 
#&gt;                 "\n", "# Use `as_box_if()` with a predicate if you need to ensure a box\n", 
#&gt;                 "# only for a subset of values:\n", "as_box_if(NULL, is_null, \"null_box\")\n", 
#&gt;                 "as_box_if(\"foo\", is_null, \"null_box\")\n"), 
#&gt;             "\n"), call2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call2"), "\n", list("call2"), "\n", list(
#&gt;                 "Create a call"), "\n", list("\n", "call2(.fn, ..., .ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Quoted function calls are one of the two types of\n", 
#&gt;                 list("symbolic"), " objects in R. They represent the action of\n", 
#&gt;                 "calling a function, possibly with arguments. There are two ways of\n", 
#&gt;                 "creating a quoted call:\n", list("\n", list(), 
#&gt;                   " By ", list("quoting"), " it. Quoting prevents functions from being\n", 
#&gt;                   "called. Instead, you get the description of the function call as\n", 
#&gt;                   "an R object. That is, a quoted function call.\n", 
#&gt;                   list(), " By constructing it with ", list(list(
#&gt;                     "base::call()")), ", ", list(list("base::as.call()")), 
#&gt;                   ", or\n", list("call2()"), ". In this case, you pass the call elements (the function\n", 
#&gt;                   "to call and the arguments to call it with) separately.\n"), 
#&gt;                 "\n", "\n", "See section below for the difference between ", 
#&gt;                 list("call2()"), " and the base\n", "constructors.\n"), 
#&gt;             "\n", list(list("Difference with base constructors"), 
#&gt;                 list("\n", "\n", "\n", list("call2()"), " is more flexible and convenient than ", 
#&gt;                   list("base::call()"), ":\n", list("\n", list(), 
#&gt;                     " The function to call can be a string or a ", 
#&gt;                     list("callable"), "\n", "object: a symbol, another call (e.g. a ", 
#&gt;                     list("$"), " or ", list("[["), " call), or a\n", 
#&gt;                     "function to inline. ", list("base::call()"), 
#&gt;                     " only supports strings and you\n", "need to use ", 
#&gt;                     list("base::as.call()"), " to construct a call with a callable\n", 
#&gt;                     "object.", list("call2(list, 1, 2)\n", "\n", 
#&gt;                       "as.call(list(list, 1, 2))\n"), "\n", list(), 
#&gt;                     " The ", list(".ns"), " argument is convenient for creating namespaced calls.", 
#&gt;                     list("call2(\"list\", 1, 2, .ns = \"base\")\n", 
#&gt;                       "\n", "ns_call &lt;- as.call(list(as.name(\"::\"), as.name(\"list\"), as.name(\"base\")))\n", 
#&gt;                       "as.call(list(ns_call, 1, 2))\n"), "\n", 
#&gt;                     list(), " ", list("call2()"), " has ", list(
#&gt;                       "tidy dots"), " support and you can splice lists\n", 
#&gt;                     "of arguments with ", list("!!!"), ". With base R, you need to use ", 
#&gt;                     list("as.call()"), "\n", "instead of ", list(
#&gt;                       "call()"), " if the arguments are in a list.", 
#&gt;                     list("args &lt;- list(na.rm = TRUE, trim = 0)\n", 
#&gt;                       "\n", "call2(\"mean\", 1:10, !!!args)\n", 
#&gt;                       "\n", "as.call(c(list(as.name(\"mean\"), 1:10), args))\n"), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "In rlang 0.2.0 ", list(
#&gt;                   "lang()"), " was soft-deprecated and renamed to\n", 
#&gt;                   list("call2()"), ".\n", "\n", "In early versions of rlang calls were called \"language\" objects in\n", 
#&gt;                   "order to follow the R type nomenclature as returned by\n", 
#&gt;                   list(list("base::typeof()")), ". The goal was to avoid adding to the confusion\n", 
#&gt;                   "between S modes and R types. With hindsight we find it is better to\n", 
#&gt;                   "use more meaningful type names.\n")), "\n", 
#&gt;             "\n", list("\n", "# fn can either be a string, a symbol or a call\n", 
#&gt;                 "call2(\"f\", a = 1)\n", "call2(quote(f), a = 1)\n", 
#&gt;                 "call2(quote(f()), a = 1)\n", "\n", "#' Can supply arguments individually or in a list\n", 
#&gt;                 "call2(quote(f), a = 1, b = 2)\n", "call2(quote(f), !!!list(a = 1, b = 2))\n", 
#&gt;                 "\n", "# Creating namespaced calls is easy:\n", 
#&gt;                 "call2(\"fun\", arg = quote(baz), .ns = \"mypkg\")\n", 
#&gt;                 "\n", "# Empty arguments are preserved:\n", "call2(\"[\", quote(x), , drop = )\n"), 
#&gt;             "\n", list("\n", "call_modify\n"), "\n"), call_args.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_args"), "\n", list("call_args"), "\n", 
#&gt;             list("call_args_names"), "\n", list("Extract arguments from a call"), 
#&gt;             "\n", list("\n", "call_args(call)\n", "\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A named list of arguments.\n"), 
#&gt;             "\n", list("\n", "Extract arguments from a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_args()"), " and ", 
#&gt;                 list("lang_args_names()"), " were\n", "deprecated and renamed to ", 
#&gt;                 list("call_args()"), " and ", list("call_args_names()"), 
#&gt;                 ".\n", "See lifecycle section in ", list(list(
#&gt;                   "call2()")), " for more about this change.\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(f(a, b))\n", 
#&gt;                 "\n", "# Subsetting a call returns the arguments converted to a language\n", 
#&gt;                 "# object:\n", "call[-1]\n", "\n", "# On the other hand, call_args() returns a regular list that is\n", 
#&gt;                 "# often easier to work with:\n", "str(call_args(call))\n", 
#&gt;                 "\n", "# When the arguments are unnamed, a vector of empty strings is\n", 
#&gt;                 "# supplied (rather than NULL):\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("fn_fmls()")), " and ", 
#&gt;                 list(list("fn_fmls_names()")), "\n"), "\n"), 
#&gt;         call_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_fn"), "\n", list("call_fn"), "\n", 
#&gt;             list("Extract function from a call"), "\n", list(
#&gt;                 "\n", "call_fn(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "If a frame or formula, the function will be retrieved from the\n", 
#&gt;                 "associated environment. Otherwise, it is looked up in the calling\n", 
#&gt;                 "frame.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", "In rlang 0.2.0, ", list("lang_fn()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_fn()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about this\n", "change.\n")), "\n", 
#&gt;             "\n", list("\n", "# Extract from a quoted call:\n", 
#&gt;                 "call_fn(quote(matrix()))\n", "call_fn(quo(matrix()))\n", 
#&gt;                 "\n", "# Extract the calling function\n", "test &lt;- function() call_fn(call_frame())\n", 
#&gt;                 "test()\n"), "\n", list("\n", list(list("call_name()")), 
#&gt;                 "\n"), "\n"), call_inspect.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("call_inspect"), "\n", list("call_inspect"), 
#&gt;             "\n", list("Inspect a call"), "\n", list("\n", "call_inspect(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Arguments to display in the returned call.")), 
#&gt;                 "\n"), "\n", list("\n", "This function is useful for quick testing and debugging when you\n", 
#&gt;                 "manipulate expressions and calls. It lets you check that a function\n", 
#&gt;                 "is called with the right arguments. This can be useful in unit\n", 
#&gt;                 "tests for instance. Note that this is just a simple wrapper around\n", 
#&gt;                 list(list("base::match.call()")), ".\n"), "\n", 
#&gt;             list("\n", "call_inspect(foo(bar), \"\" %&gt;% identity())\n"), 
#&gt;             "\n"), call_modify.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_modify"), "\n", list("call_modify"), 
#&gt;             "\n", list("Modify the arguments of a call"), "\n", 
#&gt;             list("\n", "call_modify(.call, ..., .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),\n", 
#&gt;                 "  .standardise = NULL, .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".call"), list("Can be a call, a formula quoting a call in the\n", 
#&gt;                 "right-hand side, or a frame object from which to extract the call\n", 
#&gt;                 "expression.")), "\n", "\n", list(list("..."), 
#&gt;                 list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                 list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".standardise, .env"), 
#&gt;                   list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n"), "\n", list("\n", "A quosure if ", 
#&gt;                 list(".call"), " is a quosure, a call otherwise.\n"), 
#&gt;             "\n", list("\n", "If you are working with a user-supplied call, make sure the\n", 
#&gt;                 "arguments are standardised with ", list(list(
#&gt;                   "call_standardise()")), " before\n", "modifying the call.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " The ", list(".standardise"), 
#&gt;                 " argument is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " In rlang 0.2.0, ", list("lang_modify()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_modify()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about\n", "this change.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(mean(x, na.rm = TRUE))\n", 
#&gt;                 "\n", "# Modify an existing argument\n", "call_modify(call, na.rm = FALSE)\n", 
#&gt;                 "call_modify(call, x = quote(y))\n", "\n", "# Remove an argument\n", 
#&gt;                 "call_modify(call, na.rm = zap())\n", "\n", "# Add a new argument\n", 
#&gt;                 "call_modify(call, trim = 0.1)\n", "\n", "# Add an explicit missing argument:\n", 
#&gt;                 "call_modify(call, na.rm = )\n", "\n", "# Supply a list of new arguments with `!!!`\n", 
#&gt;                 "newargs &lt;- list(na.rm = NULL, trim = 0.1)\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "# Remove multiple arguments by splicing zaps:\n", 
#&gt;                 "newargs &lt;- rep_named(c(\"na.rm\", \"trim\"), list(zap()))\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "\n", "# Modify the `...` arguments as if it were a named argument:\n", 
#&gt;                 "call &lt;- call_modify(call, ... = )\n", "call\n", 
#&gt;                 "\n", "call &lt;- call_modify(call, ... = zap())\n", 
#&gt;                 "call\n", "\n", "\n", "# When you're working with a user-supplied call, standardise it\n", 
#&gt;                 "# beforehand because it might contain unmatched arguments:\n", 
#&gt;                 "user_call &lt;- quote(matrix(x, nc = 3))\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "# Standardising applies the usual argument matching rules:\n", 
#&gt;                 "user_call &lt;- call_standardise(user_call)\n", 
#&gt;                 "user_call\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "\n", "# You can also modify quosures inplace:\n", 
#&gt;                 "f &lt;- quo(matrix(bar))\n", "call_modify(f, quote(foo))\n", 
#&gt;                 "\n", "\n", "# By default, arguments with the same name are kept. This has\n", 
#&gt;                 "# subtle implications, for instance you can move an argument to\n", 
#&gt;                 "# last position by removing it and remapping it:\n", 
#&gt;                 "call &lt;- quote(foo(bar = , baz))\n", "call_modify(call, bar = NULL, bar = missing_arg())\n", 
#&gt;                 "\n", "# You can also choose to keep only the first or last homonym\n", 
#&gt;                 "# arguments:\n", "args &lt;-  list(bar = NULL, bar = missing_arg())\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"first\")\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"last\")\n"), 
#&gt;             "\n"), call_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_name"), "\n", list("call_name"), 
#&gt;             "\n", list("call_ns"), "\n", list("Extract function name or namespaced of a call"), 
#&gt;             "\n", list("\n", "call_name(call)\n", "\n", "call_ns(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A string with the function name, or ", 
#&gt;                 list("NULL"), " if the function\n", "is anonymous.\n"), 
#&gt;             "\n", list("\n", "Extract function name or namespaced of a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_name()"), " was deprecated and renamed to\n", 
#&gt;                 list("call_name()"), ". See lifecycle section in ", 
#&gt;                 list(list("call2()")), " for more about\n", "this change.\n")), 
#&gt;             "\n", "\n", list("\n", "# Extract the function name from quoted calls:\n", 
#&gt;                 "call_name(quote(foo(bar)))\n", "call_name(quo(foo(bar)))\n", 
#&gt;                 "\n", "# Namespaced calls are correctly handled:\n", 
#&gt;                 "call_name(~base::matrix(baz))\n", "\n", "# Anonymous and subsetted functions return NULL:\n", 
#&gt;                 "call_name(quote(foo$bar()))\n", "call_name(quote(foo[[bar]]()))\n", 
#&gt;                 "call_name(quote(foo()()))\n", "\n", "# Extract namespace of a call with call_ns():\n", 
#&gt;                 "call_ns(quote(base::bar()))\n", "\n", "# If not namespaced, call_ns() returns NULL:\n", 
#&gt;                 "call_ns(quote(bar()))\n"), "\n", list("\n", 
#&gt;                 list(list("call_fn()")), "\n"), "\n"), call_standardise.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_standardise"), "\n", list("call_standardise"), 
#&gt;             "\n", list("Standardise a call"), "\n", list("\n", 
#&gt;                 "call_standardise(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure if ", list(
#&gt;                 "call"), " is a quosure, a raw call otherwise.\n"), 
#&gt;             "\n", list("\n", "This is essentially equivalent to ", 
#&gt;                 list(list("base::match.call()")), ", but with\n", 
#&gt;                 "experimental handling of primitive functions.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_standardise()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_standardise()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more\n", "about this change.\n")), "\n", 
#&gt;             "\n"), caller_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("caller_env"), "\n", list("caller_env"), 
#&gt;             "\n", list("current_env"), "\n", list("Get the current or caller environment"), 
#&gt;             "\n", list("\n", "caller_env(n = 1)\n", "\n", "current_env()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " The current environment is the execution environment of the\n", 
#&gt;                 "current function (the one currently being evaluated).\n", 
#&gt;                 list(), " The caller environment is the execution environment of the\n", 
#&gt;                 "function that called the current function.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Let's create a function that returns its current environment and\n", 
#&gt;                 "# its caller environment:\n", "fn &lt;- function() list(current = current_env(), caller = caller_env())\n", 
#&gt;                 "\n", "# The current environment is an unique execution environment\n", 
#&gt;                 "# created when `fn()` was called. The caller environment is the\n", 
#&gt;                 "# global env because that's where we called `fn()`.\n", 
#&gt;                 "fn()\n", "\n", "# Let's call `fn()` again but this time within a function:\n", 
#&gt;                 "g &lt;- function() fn()\n", "\n", "# Now the caller environment is also an unique execution environment.\n", 
#&gt;                 "# This is the exec env created by R for our call to g():\n", 
#&gt;                 "g()\n"), "\n", list("\n", list(list("caller_frame()")), 
#&gt;                 " and ", list(list("current_frame()")), "\n"), 
#&gt;             "\n"), caller_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("caller_fn"), "\n", list("caller_fn"), 
#&gt;             "\n", list("current_fn"), "\n", list("Get properties of the current or caller frame"), 
#&gt;             "\n", list("\n", "caller_fn(n = 1)\n", "\n", "current_fn()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The number of generations to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("\n", list(), " The current frame is the execution context of the function that\n", 
#&gt;                   "is currently being evaluated.\n", list(), 
#&gt;                   " The caller frame is the execution context of the function that\n", 
#&gt;                   "called the function currently being evaluated.\n"), 
#&gt;                 "\n", "\n", "See the ", list("call stack"), " topic for more information.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental.\n")), "\n", 
#&gt;             "\n", list("\n", list(list("caller_env()")), " and ", 
#&gt;                 list(list("current_env()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), caller_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("caller_frame"), "\n", list("caller_frame"), 
#&gt;             "\n", list("Get caller frame"), "\n", list("\n", 
#&gt;                 "caller_frame(n = 1)\n"), "\n", list("\n", list(
#&gt;                 list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), catch_cnd.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("catch_cnd"), "\n", list("catch_cnd"), 
#&gt;             "\n", list("Catch a condition"), "\n", list("\n", 
#&gt;                 "catch_cnd(expr, classes = \"condition\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("Expression to be evaluated with a catching condition\n", 
#&gt;                 "handler.")), "\n", "\n", list(list("classes"), 
#&gt;                 list("A character vector of condition classes to catch. By\n", 
#&gt;                   "default, catches all conditions.")), "\n"), 
#&gt;             "\n", list("\n", "A condition if any was signalled, ", 
#&gt;                 list("NULL"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This is a small wrapper around ", list("tryCatch()"), 
#&gt;                 " that captures any\n", "condition signalled while evaluating its argument. It is useful for\n", 
#&gt;                 "situations where you expect a specific condition to be signalled,\n", 
#&gt;                 "for debugging, and for unit testing.\n"), "\n", 
#&gt;             list("\n", "catch_cnd(10)\n", "catch_cnd(abort(\"an error\"))\n", 
#&gt;                 "catch_cnd(cnd_signal(\"my_condition\", .msg = \"a condition\"))\n"), 
#&gt;             "\n"), chr_unserialise_unicode.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("chr_unserialise_unicode"), "\n", list(
#&gt;                 "chr_unserialise_unicode"), "\n", list("Translate unicode points to UTF-8"), 
#&gt;             "\n", list("\n", "chr_unserialise_unicode(chr)\n"), 
#&gt;             "\n", list("\n", list(list("chr"), list("A character vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "For historical reasons, R translates strings to the native encoding\n", 
#&gt;                 "when they are converted to symbols. This string-to-symbol\n", 
#&gt;                 "conversion is not a rare occurrence and happens for instance to the\n", 
#&gt;                 "names of a list of arguments converted to a call by ", 
#&gt;                 list("do.call()"), ".\n", "\n", "If the string contains unicode characters that cannot be\n", 
#&gt;                 "represented in the native encoding, R serialises those as an ASCII\n", 
#&gt;                 "sequence representing the unicode point. This is why Windows users\n", 
#&gt;                 "with western locales often see strings looking like ", 
#&gt;                 list("&lt;U+xxxx&gt;"), ". To\n", "alleviate some of the pain, rlang parses strings and looks for\n", 
#&gt;                 "serialised unicode points to translate them back to the proper\n", 
#&gt;                 "UTF-8 representation. This transformation occurs automatically in\n", 
#&gt;                 "functions like ", list(list("env_names()")), 
#&gt;                 " and can be manually triggered with\n", list(
#&gt;                   "as_utf8_character()"), " and ", list("chr_unserialise_unicode()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "This function is experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "ascii &lt;- \"&lt;U+5E78&gt;\"\n", 
#&gt;                 "chr_unserialise_unicode(ascii)\n", "\n", "identical(chr_unserialise_unicode(ascii), \"\\u5e78\")\n"), 
#&gt;             "\n", list("internal"), "\n"), cnd.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-error.R, R/cnd.R", 
#&gt;             "\n", list("error_cnd"), "\n", list("error_cnd"), 
#&gt;             "\n", list("cnd"), "\n", list("warning_cnd"), "\n", 
#&gt;             list("message_cnd"), "\n", list("Create a condition object"), 
#&gt;             "\n", list("\n", "error_cnd(.subclass = NULL, ..., message = \"\", trace = NULL,\n", 
#&gt;                 "  parent = NULL)\n", "\n", "cnd(.subclass, ..., message = \"\")\n", 
#&gt;                 "\n", "warning_cnd(.subclass = NULL, ..., message = \"\")\n", 
#&gt;                 "\n", "message_cnd(.subclass = NULL, ..., message = \"\")\n"), 
#&gt;             "\n", list("\n", list(list(".subclass"), list("The condition subclass.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named data fields stored inside the condition\n", 
#&gt;                   "object. These dots are evaluated with ", list(
#&gt;                     "explicit splicing"), ".")), "\n", "\n", 
#&gt;                 list(list("message"), list("A default message to inform the user about the\n", 
#&gt;                   "condition when it is signalled.")), "\n", 
#&gt;                 "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                   " object created by ", list(list("trace_back()")), 
#&gt;                   ".")), "\n", "\n", list(list("parent"), list(
#&gt;                   "A parent condition object created by ", list(
#&gt;                     list("abort()")), ".")), "\n"), "\n", list(
#&gt;                 "\n", "These constructors make it easy to create subclassed conditions.\n", 
#&gt;                 "Conditions are objects that power the error system in R. They can\n", 
#&gt;                 "also be used for passing messages to pre-established handlers.\n"), 
#&gt;             "\n", list("\n", list("cnd()"), " creates objects inheriting from ", 
#&gt;                 list("condition"), ". Conditions\n", "created with ", 
#&gt;                 list("error_cnd()"), ", ", list("warning_cnd()"), 
#&gt;                 " and ", list("message_cnd()"), "\n", "inherit from ", 
#&gt;                 list("error"), ", ", list("warning"), " or ", 
#&gt;                 list("message"), ".\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "The ", list(".type"), 
#&gt;                   " and ", list(".msg"), " arguments have been renamed to ", 
#&gt;                   list(".subclass"), "\n", "and ", list("message"), 
#&gt;                   ". They are deprecated as of rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "# Create a condition inheriting from the s3 type \"foo\":\n", 
#&gt;                 "cnd &lt;- cnd(\"foo\")\n", "\n", "# Signal the condition to potential handlers. Since this is a bare\n", 
#&gt;                 "# condition the signal has no effect if no handlers are set up:\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# When a relevant handler is set up, the signal causes the handler\n", 
#&gt;                 "# to be called:\n", "with_handlers(cnd_signal(cnd), foo = exiting(function(c) \"caught!\"))\n", 
#&gt;                 "\n", "# Handlers can be thrown or executed inplace. See with_handlers()\n", 
#&gt;                 "# documentation for more on this.\n", "\n", 
#&gt;                 "# Signalling an error condition aborts the current computation:\n", 
#&gt;                 "err &lt;- error_cnd(\"foo\", message = \"I am an error\")\n", 
#&gt;                 "try(cnd_signal(err))\n"), "\n", list("\n", list(
#&gt;                 list("cnd_signal()")), ", ", list(list("with_handlers()")), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), cnd_message.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-message.R", 
#&gt;             "\n", list("cnd_message"), "\n", list("cnd_message"), 
#&gt;             "\n", list("cnd_issue"), "\n", list("cnd_bullets"), 
#&gt;             "\n", list("format_bullets"), "\n", list("Build an error message from a main issue and bullet messages"), 
#&gt;             "\n", list("\n", "cnd_message(cnd)\n", "\n", "cnd_issue(cnd, ...)\n", 
#&gt;                 "\n", "cnd_bullets(cnd, ...)\n", "\n", "format_bullets(x)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A named character vector of messages. Elements named as\n", 
#&gt;                   list("x"), " or ", list("i"), " are prefixed with the corresponding bullet.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " assembles an error message from two components:\n", 
#&gt;                 list("\n", list(), " The ", list("cnd_issue()"), 
#&gt;                   " generic. Methods should return a single line.\n", 
#&gt;                   list(), " The ", list("cnd_bullets()"), " generic. Methods should return a named vector\n", 
#&gt;                   "of lines. These lines are automatically prefixed with a bullet by\n", 
#&gt;                   list("cnd_message()"), " (see the section on error statements).\n"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " is automatically called by the ", 
#&gt;                 list("conditionMessage()"), "\n", "for rlang errors so that errors thrown with ", 
#&gt;                 list(list("abort()")), " only need to\n", "implement ", 
#&gt;                 list("cnd_issue()"), " and ", list("cnd_bullets()"), 
#&gt;                 ". It can also be called\n", "in custom ", list(
#&gt;                   "conditionMessage()"), " methods.\n", "\n", 
#&gt;                 "Note that if you pass a named character vector to ", 
#&gt;                 list(list("abort()")), ", you\n", "get the same formatting behaviour as ", 
#&gt;                 list("cnd_message()"), ".\n"), "\n", list(list(
#&gt;                 "Error statements"), list("\n", "\n", "\n", "This experimental infrastructure is based on the idea that\n", 
#&gt;                 "sentences in error messages are best kept short and simple. From\n", 
#&gt;                 "this point of view, the best way to present the information is as a\n", 
#&gt;                 "bullet list of simple sentences containing a single clause.\n", 
#&gt;                 list("cnd_message()"), " helps following this structure by building an error\n", 
#&gt;                 "message from two parts: the ", list("issue"), 
#&gt;                 " and the ", list("bullets"), ".\n", "\n", list(
#&gt;                   "cnd_issue()"), " is the generic for the main error message. It should\n", 
#&gt;                 "be as generic as possible, but since it is a generic it is easy to\n", 
#&gt;                 "override by error subclasses.\n", "\n", "The ", 
#&gt;                 list("cnd_bullets()"), " methods should return a character vector of\n", 
#&gt;                 "sentences. These are automatically prefixed with bullets by\n", 
#&gt;                 list("cnd_message()"), ", according to the following scheme:\n", 
#&gt;                 list("\n", list(), " Elements named ", list("\"i\""), 
#&gt;                   " are prefixed with a blue \"info\" symbol.\n", 
#&gt;                   list(), " Elements named ", list("\"x\""), 
#&gt;                   " are prefixed with a red \"cross\" symbol.\n", 
#&gt;                   list(), " Unnamed elements are prefixed with a \"*\" symbol.\n"), 
#&gt;                 "\n", "\n", "While you are free to lay out the bullets in the order that you\n", 
#&gt;                 "like, \"x\" bullets should usually precede \"i\" bullets.\n")), 
#&gt;             "\n", "\n", list(list("Overriding ", list("cnd_bullets()")), 
#&gt;                 list("\n", "\n", "\n", "Sometimes the generation of an error message depends on the state\n", 
#&gt;                   "of the type checking. In that case, it can be tricky to lazily\n", 
#&gt;                   "generate error messages with ", list("cnd_bullets()"), 
#&gt;                   ": you can either\n", "overspecify your error class hierarchies with one class per state,\n", 
#&gt;                   "or replicate the type-checking control flow within the\n", 
#&gt;                   list("cnd_bullets()"), " method. None of these options are ideal.\n", 
#&gt;                   "\n", "A better option is to define a ", list(
#&gt;                     "cnd_bullets"), " field in your error\n", 
#&gt;                   "object. This should be a function (or a lambda-formula which will\n", 
#&gt;                   "be passed to ", list(list("as_function()")), 
#&gt;                   ") with the same signature as\n", list("cnd_bullets()"), 
#&gt;                   " methods. This function overrides the\n", 
#&gt;                   list("cnd_bullets()"), " generic and can generate an error message tailored\n", 
#&gt;                   "to the state in which the error was constructed.\n", 
#&gt;                   "\n", "Note that as a rule, ", list("cnd_issue()"), 
#&gt;                   " should be a general thematic\n", "issues that does not depend on state. For this reason, it isn't\n", 
#&gt;                   "possible to define an overriding method in the condition object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "This infrastructure is experimental. In particular, the output of\n", 
#&gt;                 list("cnd_message()"), " is likely to change in the future and you shouldn't\n", 
#&gt;                 "test it verbatim in a way that makes R CMD check fail. Instead, use\n", 
#&gt;                 list(list("testthat::verify_output()")), " to monitor the output without causing\n", 
#&gt;                 "CRAN check failures when it changes.\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), cnd_muffle.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("cnd_muffle"), "\n", list("cnd_muffle"), 
#&gt;             "\n", list("Muffle a condition"), "\n", list("\n", 
#&gt;                 "cnd_muffle(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition to muffle.")), "\n"), 
#&gt;             "\n", list("\n", "Unlike ", list(list("exiting()")), 
#&gt;                 " handlers, ", list(list("calling()")), " handlers must be explicit\n", 
#&gt;                 "that they have handled a condition to stop it from propagating to\n", 
#&gt;                 "other handlers. Use ", list("cnd_muffle()"), 
#&gt;                 " within a calling handler (or as\n", "a calling handler, see examples) to prevent any other handlers from\n", 
#&gt;                 "being called for that condition.\n"), "\n", 
#&gt;             list(list("Mufflable conditions"), list("\n", "\n", 
#&gt;                 "\n", "Most conditions signalled by base R are muffable, although the name\n", 
#&gt;                 "of the restart varies. cnd_muffle() will automatically call the\n", 
#&gt;                 "correct restart for you. It is compatible with the following\n", 
#&gt;                 "conditions:\n", list("\n", list(), " ", list(
#&gt;                   "warning"), " and ", list("message"), " conditions. In this case ", 
#&gt;                   list("cnd_muffle()"), "\n", "is equivalent to ", 
#&gt;                   list(list("base::suppressMessages()")), " and\n", 
#&gt;                   list(list("base::suppressWarnings()")), ".\n", 
#&gt;                   list(), " Bare conditions signalled with ", 
#&gt;                   list("signal()"), " or ", list(list("cnd_signal()")), 
#&gt;                   ". Note\n", "that conditions signalled with ", 
#&gt;                   list(list("base::signalCondition()")), " are not\n", 
#&gt;                   "mufflable.\n", list(), " Interrupts are sometimes signalled with a ", 
#&gt;                   list("resume"), " restart on\n", "recent R versions. When this is the case, you can muffle the\n", 
#&gt;                   "interrupt with ", list("cnd_muffle()"), ". Check if a restart is available\n", 
#&gt;                   "with ", list("base::findRestart(\"resume\")"), 
#&gt;                   ".\n"), "\n", "\n", "If you call ", list("cnd_muffle()"), 
#&gt;                 " with a condition that is not mufflable\n", 
#&gt;                 "you will cause a new error to be signalled.\n", 
#&gt;                 list("\n", list(), " Errors are not mufflable since they are signalled in critical\n", 
#&gt;                   "situations where execution cannot continue safely.\n", 
#&gt;                   list(), " Conditions captured with ", list(
#&gt;                     list("base::tryCatch()")), ", ", list(list(
#&gt;                     "with_handlers()")), " or\n", list(list("catch_cnd()")), 
#&gt;                   " are no longer mufflable. Muffling restarts ", 
#&gt;                   list("must"), "\n", "be called from a ", list(
#&gt;                     "calling"), " handler.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() {\n", "  inform(\"Beware!\", \"my_particular_msg\")\n", 
#&gt;                 "  inform(\"On your guard!\")\n", "  \"foobar\"\n", 
#&gt;                 "}\n", "\n", "# Let's install a muffling handler for the condition thrown by `fn()`.\n", 
#&gt;                 "# This will suppress all `my_particular_wng` warnings but let other\n", 
#&gt;                 "# types of warnings go through:\n", "with_handlers(fn(),\n", 
#&gt;                 "  my_particular_msg = calling(function(cnd) {\n", 
#&gt;                 "    inform(\"Dealt with this particular message\")\n", 
#&gt;                 "    cnd_muffle(cnd)\n", "  })\n", ")\n", "\n", 
#&gt;                 "# Note how execution of `fn()` continued normally after dealing\n", 
#&gt;                 "# with that particular message.\n", "\n", "# cnd_muffle() can also be passed to with_handlers() as a calling\n", 
#&gt;                 "# handler:\n", "with_handlers(fn(),\n", "  my_particular_msg = calling(cnd_muffle)\n", 
#&gt;                 ")\n"), "\n", list("internal"), "\n"), cnd_signal.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-signal.R", 
#&gt;             "\n", list("cnd_signal"), "\n", list("cnd_signal"), 
#&gt;             "\n", list("Signal a condition object"), "\n", list(
#&gt;                 "\n", "cnd_signal(cnd, .cnd, .mufflable)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object (see ", 
#&gt;                 list(list("cnd()")), ").")), "\n", "\n", list(
#&gt;                 list(".cnd, .mufflable"), list("These arguments are deprecated.")), 
#&gt;                 "\n"), "\n", list("\n", "The type of signal depends on the class of the condition:\n", 
#&gt;                 list("\n", list(), " A message is signalled if the condition inherits from\n", 
#&gt;                   list("\"message\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("inform()")), " or\n", list(list(
#&gt;                     "base::message()")), ".\n", list(), " A warning is signalled if the condition inherits from\n", 
#&gt;                   list("\"warning\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("warn()")), " or\n", list(list("base::warning()")), 
#&gt;                   ".\n", list(), " An error is signalled if the condition inherits from\n", 
#&gt;                   list("\"error\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("abort()")), " or\n", list(list("base::stop()")), 
#&gt;                   ".\n", list(), " An interrupt is signalled if the condition inherits from\n", 
#&gt;                   list("\"interrupt\""), ". This is equivalent to signalling with\n", 
#&gt;                   list(list("interrupt()")), ".\n"), "\n", "\n", 
#&gt;                 "Use ", list(list("cnd_type()")), " to determine the type of a condition.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list(".cnd"), " has been renamed to ", 
#&gt;                 list("cnd"), " and is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " The ", list(".mufflable"), " argument is deprecated as of rlang 0.3.0 and no\n", 
#&gt;                 "longer has any effect. Non-critical conditions are always\n", 
#&gt;                 "signalled with a muffle restart.\n", list(), 
#&gt;                 " Creating a condition object with ", list(list(
#&gt;                   "cnd_signal()")), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                 list(list("signal()")), " instead.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# The type of signal depends on the class. If the condition\n", 
#&gt;                 "# inherits from \"warning\", a warning is issued:\n", 
#&gt;                 "cnd &lt;- warning_cnd(\"my_warning_class\", message = \"This is a warning\")\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# If it inherits from \"error\", an error is raised:\n", 
#&gt;                 "cnd &lt;- error_cnd(\"my_error_class\", message = \"This is an error\")\n", 
#&gt;                 "try(cnd_signal(cnd))\n"), "\n", list("\n", list(
#&gt;                 list("abort()")), ", ", list(list("warn()")), 
#&gt;                 " and ", list(list("inform()")), " for creating and\n", 
#&gt;                 "signalling structured R conditions. See ", list(
#&gt;                   list("with_handlers()")), " for\n", "establishing condition handlers.\n"), 
#&gt;             "\n"), cnd_type.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("cnd_type"), "\n", list("cnd_type"), "\n", list(
#&gt;                 "What type is a condition?"), "\n", list("\n", 
#&gt;                 "cnd_type(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition object.")), "\n"), 
#&gt;             "\n", list("\n", "A string, either ", list("\"condition\""), 
#&gt;                 ", ", list("\"message\""), ", ", list("\"warning\""), 
#&gt;                 ",\n", list("\"error\""), " or ", list("\"interrupt\""), 
#&gt;                 ".\n"), "\n", list("\n", "Use ", list("cnd_type()"), 
#&gt;                 " to check what type a condition is.\n"), "\n", 
#&gt;             list("\n", "cnd_type(catch_cnd(abort(\"Abort!\")))\n", 
#&gt;                 "cnd_type(catch_cnd(interrupt()))\n"), "\n", 
#&gt;             list("internal"), "\n"), done.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("done"), "\n", list("done"), "\n", list("is_done_box"), 
#&gt;             "\n", list("Box a final value for early termination"), 
#&gt;             "\n", list("\n", "done(x)\n", "\n", "is_done_box(x, empty = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("For ", list(
#&gt;                 "done()"), ", a value to box. For ", list("is_done_box()"), 
#&gt;                 ", a\n", "value to test.")), "\n", "\n", list(
#&gt;                 list("empty"), list("Whether the box is empty. If ", 
#&gt;                   list("NULL"), ", ", list("is_done_box()"), 
#&gt;                   "\n", "returns ", list("TRUE"), " for all done boxes. If ", 
#&gt;                   list("TRUE"), ", it returns ", list("TRUE"), 
#&gt;                   "\n", "only for empty boxes. Otherwise it returns ", 
#&gt;                   list("TRUE"), " only for\n", "non-empty boxes.")), 
#&gt;                 "\n"), "\n", list("\n", "A ", list("boxed"), 
#&gt;                 " value.\n"), "\n", list("\n", "A value boxed with ", 
#&gt;                 list("done()"), " signals to its caller that it\n", 
#&gt;                 "should stop iterating. Use it to shortcircuit a loop.\n"), 
#&gt;             "\n", list("\n", "done(3)\n", "\n", "x &lt;- done(3)\n", 
#&gt;                 "is_done_box(x)\n"), "\n"), dots_definitions.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_definitions"), "\n", list("dots_definitions"), 
#&gt;             "\n", list("Capture definition objects"), "\n", list(
#&gt;                 "\n", "dots_definitions(..., .named = FALSE, .ignore_empty = c(\"trailing\",\n", 
#&gt;                 "  \"none\", \"all\"))\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("For ", list("enexprs()"), 
#&gt;                   ", ", list("ensyms()"), " and ", list("enquos()"), 
#&gt;                   ", names of\n", "arguments to capture without evaluation (including ", 
#&gt;                   list("..."), "). For\n", list("exprs()"), " and ", 
#&gt;                   list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                   "(including expressions contained in ", list(
#&gt;                     "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n"), "\n", list("\n", "Capture definition objects\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("dots_definitions()"), " is experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), dots_n.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_n"), "\n", list("dots_n"), "\n", list(
#&gt;                 "How many arguments are currently forwarded in dots?"), 
#&gt;             "\n", list("\n", "dots_n(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Forwarded arguments.")), 
#&gt;                 "\n"), "\n", list("\n", "This returns the number of arguments currently forwarded in ", 
#&gt;                 list("..."), "\n", "as an integer.\n"), "\n", 
#&gt;             list("\n", "fn &lt;- function(...) dots_n(..., baz)\n", 
#&gt;                 "fn(foo, bar)\n"), "\n", list("internal"), "\n"), 
#&gt;         dots_values.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("dots_values"), "\n", list("dots_values"), 
#&gt;             "\n", list("Evaluate dots with preliminary splicing"), 
#&gt;             "\n", list("\n", "dots_values(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("..."), list("Arguments to evaluate and process splicing operators.")), 
#&gt;                 "\n", "\n", list(list(".ignore_empty"), list(
#&gt;                   "Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a tool for advanced users. It captures dots, processes\n", 
#&gt;                 "unquoting and splicing operators, and evaluates them. Unlike\n", 
#&gt;                 list(list("dots_list()")), ", it does not flatten spliced objects, instead they\n", 
#&gt;                 "are attributed a ", list("spliced"), " class (see ", 
#&gt;                 list(list("splice()")), "). You can process\n", 
#&gt;                 "spliced objects manually, perhaps with a custom predicate (see\n", 
#&gt;                 list(list("flatten_if()")), ").\n"), "\n", list(
#&gt;                 "\n", "dots &lt;- dots_values(!!! list(1, 2), 3)\n", 
#&gt;                 "dots\n", "\n", "# Flatten the objects marked as spliced:\n", 
#&gt;                 "flatten_if(dots, is_spliced)\n"), "\n", list(
#&gt;                 "internal"), "\n"), duplicate.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sexp.R", 
#&gt;             "\n", list("duplicate"), "\n", list("duplicate"), 
#&gt;             "\n", list("Duplicate an R object"), "\n", list("\n", 
#&gt;                 "duplicate(x, shallow = FALSE)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("Any R object. However, uncopyable types like symbols and\n", 
#&gt;                   "environments are returned as is (just like with ", 
#&gt;                   list("&lt;-"), ").")), "\n", "\n", list(list("shallow"), 
#&gt;                   list("This is relevant for recursive data structures like\n", 
#&gt;                     "lists, calls and pairlists. A shallow copy only duplicates the\n", 
#&gt;                     "top-level data structure. The objects contained in the list are\n", 
#&gt;                     "still the same.")), "\n"), "\n", list("\n", 
#&gt;                 "In R semantics, objects are copied by value. This means that\n", 
#&gt;                 "modifying the copy leaves the original object intact. Since\n", 
#&gt;                 "copying data in memory is an expensive operation, copies in R are\n", 
#&gt;                 "as lazy as possible. They only happen when the new object is\n", 
#&gt;                 "actually modified. However, some operations (like ", 
#&gt;                 list(list("node_poke_car()")), "\n", "or ", list(
#&gt;                   list("node_poke_cdr()")), ") do not support copy-on-write. In those cases,\n", 
#&gt;                 "it is necessary to duplicate the object manually in order to\n", 
#&gt;                 "preserve copy-by-value semantics.\n"), "\n", 
#&gt;             list("\n", "Some objects are not duplicable, like symbols and environments.\n", 
#&gt;                 list("duplicate()"), " returns its input for these unique objects.\n"), 
#&gt;             "\n", list("\n", "pairlist\n"), "\n", list("internal"), 
#&gt;             "\n"), empty_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("empty_env"), "\n", list("empty_env"), 
#&gt;             "\n", list("Get the empty environment"), "\n", list(
#&gt;                 "\n", "empty_env()\n"), "\n", list("\n", "The empty environment is the only one that does not have a parent.\n", 
#&gt;                 "It is always used as the tail of an environment chain such as the\n", 
#&gt;                 "search path (see ", list(list("search_envs()")), 
#&gt;                 ").\n"), "\n", list("\n", "# Create environments with nothing in scope:\n", 
#&gt;                 "child_env(empty_env())\n"), "\n"), entrace.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("entrace"), "\n", list("entrace"), "\n", 
#&gt;             list("cnd_entrace"), "\n", list("Add backtrace from error handler"), 
#&gt;             "\n", list("\n", "entrace(cnd, ..., top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "cnd_entrace(cnd, ..., top = NULL, bottom = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("When ", 
#&gt;                 list("entrace()"), " is used as a calling handler, ", 
#&gt;                 list("cnd"), " is\n", "the condition to handle.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Unused. These dots are for future extensions.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n"), "\n", 
#&gt;             list("\n", list("entrace()"), " interrupts an error throw to add an ", 
#&gt;                 list("rlang backtrace"), " to the error. The error throw is\n", 
#&gt;                 "immediately resumed. ", list("cnd_entrace()"), 
#&gt;                 " adds a backtrace to a\n", "condition object, without any other effect. Both functions should\n", 
#&gt;                 "be called directly from an error handler.\n", 
#&gt;                 "\n", "Set the ", list("error"), " global option to ", 
#&gt;                 list("quote(rlang::entrace())"), " to\n", "transform base errors to rlang errors. These enriched errors\n", 
#&gt;                 "include a backtrace. The RProfile is a good place to set the\n", 
#&gt;                 "handler. See ", list("rlang_backtrace_on_error"), 
#&gt;                 " for details.\n", "\n", list("entrace()"), " also works as a ", 
#&gt;                 list("calling"), " handler, though it\n", "is often more practical to use the higher-level function\n", 
#&gt;                 list(list("with_abort()")), ".\n"), "\n", list(
#&gt;                 "\n", "if (FALSE) {  # Not run\n", "\n", "# Set the error handler in your RProfile like this:\n", 
#&gt;                 "if (requireNamespace(\"rlang\", quietly = TRUE)) {\n", 
#&gt;                 "  options(error = rlang::entrace)\n", "}\n", 
#&gt;                 "\n", "}\n"), "\n", list("\n", list(list("with_abort()")), 
#&gt;                 " to promote conditions to rlang errors.\n", 
#&gt;                 list(list("cnd_entrace()")), " to manually add a backtrace to a condition.\n"), 
#&gt;             "\n"), env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env"), "\n", list("env"), "\n", list("child_env"), 
#&gt;             "\n", list("new_environment"), "\n", list("Create a new environment"), 
#&gt;             "\n", list("\n", "env(...)\n", "\n", "child_env(.parent, ...)\n", 
#&gt;                 "\n", "new_environment(data = list(), parent = empty_env())\n"), 
#&gt;             "\n", list("\n", list(list("..., data"), list("Named values. You can supply one unnamed to specify\n", 
#&gt;                 "a custom parent, otherwise it defaults to the current\n", 
#&gt;                 "environment. These dots support ", list("tidy dots"), 
#&gt;                 "\n", "features.")), "\n", "\n", list(list(".parent, parent"), 
#&gt;                 list("A parent environment. Can be an object\n", 
#&gt;                   "supported by ", list(list("as_environment()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "These functions create new environments.\n", 
#&gt;                 list("\n", list(), " ", list("env()"), " creates a child of the current environment by default\n", 
#&gt;                   "and takes a variable number of named objects to populate it.\n", 
#&gt;                   list(), " ", list("new_environment()"), " creates a child of the empty environment by\n", 
#&gt;                   "default and takes a named list of objects to populate it.\n"), 
#&gt;                 "\n"), "\n", list(list("Environments as objects"), 
#&gt;                 list("\n", "\n", "\n", "Environments are containers of uniquely named objects. Their most\n", 
#&gt;                   "common use is to provide a scope for the evaluation of R\n", 
#&gt;                   "expressions. Not all languages have first class environments,\n", 
#&gt;                   "i.e. can manipulate scope as regular objects. Reification of scope\n", 
#&gt;                   "is one of the most powerful features of R as it allows you to change\n", 
#&gt;                   "what objects a function or expression sees when it is evaluated.\n", 
#&gt;                   "\n", "Environments also constitute a data structure in their own\n", 
#&gt;                   "right. They are a collection of uniquely named objects, subsettable\n", 
#&gt;                   "by name and modifiable by reference. This latter property (see\n", 
#&gt;                   "section on reference semantics) is especially useful for creating\n", 
#&gt;                   "mutable OO systems (cf the ", list(list("https://github.com/wch/R6"), 
#&gt;                     list("R6 package")), "\n", "and the ", list(
#&gt;                     list("http://ggplot2.tidyverse.org/articles/extending-ggplot2.html"), 
#&gt;                     list("ggproto system")), "\n", "for extending ggplot2).\n")), 
#&gt;             "\n", "\n", list(list("Inheritance"), list("\n", 
#&gt;                 "\n", "\n", "All R environments (except the ", 
#&gt;                 list("empty environment"), ") are\n", "defined with a parent environment. An environment and its\n", 
#&gt;                 "grandparents thus form a linear hierarchy that is the basis for\n", 
#&gt;                 list(list("https://en.wikipedia.org/wiki/Scope_(computer_science)"), 
#&gt;                   list("lexical scoping")), " in\n", "R. When R evaluates an expression, it looks up symbols in a given\n", 
#&gt;                 "environment. If it cannot find these symbols there, it keeps\n", 
#&gt;                 "looking them up in parent environments. This way, objects defined\n", 
#&gt;                 "in child environments have precedence over objects defined in\n", 
#&gt;                 "parent environments.\n", "\n", "The ability of overriding specific definitions is used in the\n", 
#&gt;                 "tidyeval framework to create powerful domain-specific grammars. A\n", 
#&gt;                 "common use of masking is to put data frame columns in scope. See\n", 
#&gt;                 "for example ", list(list("as_data_mask()")), 
#&gt;                 ".\n")), "\n", "\n", list(list("Reference semantics"), 
#&gt;                 list("\n", "\n", "\n", "Unlike regular objects such as vectors, environments are an\n", 
#&gt;                   list("uncopyable"), " object type. This means that if you\n", 
#&gt;                   "have multiple references to a given environment (by assigning the\n", 
#&gt;                   "environment to another symbol with ", list(
#&gt;                     "&lt;-"), " or passing the environment\n", "as argument to a function), modifying the bindings of one of those\n", 
#&gt;                   "references changes all other references as well.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("child_env()"), 
#&gt;                   " is in the questioning stage. It is redundant now\n", 
#&gt;                   "that ", list("env()"), " accepts parent environments.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# env() creates a new environment which has the current environment\n", 
#&gt;                 "# as parent\n", "env &lt;- env(a = 1, b = \"foo\")\n", 
#&gt;                 "env$b\n", "identical(env_parent(env), current_env())\n", 
#&gt;                 "\n", "# Supply one unnamed argument to override the default:\n", 
#&gt;                 "env &lt;- env(base_env(), a = 1, b = \"foo\")\n", 
#&gt;                 "identical(env_parent(env), base_env())\n", "\n", 
#&gt;                 "\n", "# child_env() lets you specify a parent:\n", 
#&gt;                 "child &lt;- child_env(env, c = \"bar\")\n", "identical(env_parent(child), env)\n", 
#&gt;                 "\n", "# This child environment owns `c` but inherits `a` and `b` from `env`:\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# `parent` is passed to as_environment() to provide handy\n", 
#&gt;                 "# shortcuts. Pass a string to create a child of a package\n", 
#&gt;                 "# environment:\n", "child_env(\"rlang\")\n", 
#&gt;                 "env_parent(child_env(\"rlang\"))\n", "\n", "# Or `NULL` to create a child of the empty environment:\n", 
#&gt;                 "child_env(NULL)\n", "env_parent(child_env(NULL))\n", 
#&gt;                 "\n", "# The base package environment is often a good default choice for a\n", 
#&gt;                 "# parent environment because it contains all standard base\n", 
#&gt;                 "# functions. Also note that it will never inherit from other loaded\n", 
#&gt;                 "# package environments since R keeps the base package at the tail\n", 
#&gt;                 "# of the search path:\n", "base_child &lt;- child_env(\"base\")\n", 
#&gt;                 "env_has(base_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# On the other hand, a child of the empty environment doesn't even\n", 
#&gt;                 "# see a definition for `(`\n", "empty_child &lt;- child_env(NULL)\n", 
#&gt;                 "env_has(empty_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# Note that all other package environments inherit from base_env()\n", 
#&gt;                 "# as well:\n", "rlang_child &lt;- child_env(\"rlang\")\n", 
#&gt;                 "env_has(rlang_child, \"env\", inherit = TRUE)     # rlang function\n", 
#&gt;                 "env_has(rlang_child, \"lapply\", inherit = TRUE)  # base function\n", 
#&gt;                 "\n", "\n", "# Both env() and child_env() support tidy dots features:\n", 
#&gt;                 "objs &lt;- list(b = \"foo\", c = \"bar\")\n", "env &lt;- env(a = 1, !!! objs)\n", 
#&gt;                 "env$c\n", "\n", "# You can also unquote names with the definition operator `:=`\n", 
#&gt;                 "var &lt;- \"a\"\n", "env &lt;- env(!!var := \"A\")\n", 
#&gt;                 "env$a\n", "\n", "\n", "# Use new_environment() to create containers with the empty\n", 
#&gt;                 "# environment as parent:\n", "env &lt;- new_environment()\n", 
#&gt;                 "env_parent(env)\n", "\n", "# Like other new_ constructors, it takes an object rather than dots:\n", 
#&gt;                 "new_environment(list(a = \"foo\", b = \"bar\"))\n"), 
#&gt;             "\n", list("\n", list(list("env_has()")), ", ", list(
#&gt;                 list("env_bind()")), ".\n"), "\n"), env_bind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bind"), "\n", list("env_bind"), "\n", 
#&gt;             list("env_bind_lazy"), "\n", list("env_bind_active"), 
#&gt;             "\n", list("Bind symbols to objects in an environment"), 
#&gt;             "\n", list("\n", "env_bind(.env, ...)\n", "\n", "env_bind_lazy(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_active(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", "The input object ", 
#&gt;                 list(".env"), ", with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", "These functions create bindings in an environment. The bindings are\n", 
#&gt;                 "supplied through ", list("..."), " as pairs of names and values or expressions.\n", 
#&gt;                 list("env_bind()"), " is equivalent to evaluating a ", 
#&gt;                 list("&lt;-"), " expression within\n", "the given environment. This function should take care of the\n", 
#&gt;                 "majority of use cases but the other variants can be useful for\n", 
#&gt;                 "specific problems.\n", list("\n", list(), " ", 
#&gt;                   list("env_bind()"), " takes named ", list("values"), 
#&gt;                   " which are bound in ", list(".env"), ".\n", 
#&gt;                   list("env_bind()"), " is equivalent to ", list(
#&gt;                     list("base::assign()")), ".\n", list(), " ", 
#&gt;                   list("env_bind_active()"), " takes named ", 
#&gt;                   list("functions"), " and creates active\n", 
#&gt;                   "bindings in ", list(".env"), ". This is equivalent to\n", 
#&gt;                   list(list("base::makeActiveBinding()")), ". An active binding executes a\n", 
#&gt;                   "function each time it is evaluated. The arguments are passed to\n", 
#&gt;                   list(list("as_function()")), " so you can supply formulas instead of functions.\n", 
#&gt;                   "\n", "Remember that functions are scoped in their own environment.\n", 
#&gt;                   "These functions can thus refer to symbols from this enclosure\n", 
#&gt;                   "that are not actually in scope in the dynamic environment where\n", 
#&gt;                   "the active bindings are invoked. This allows creative solutions\n", 
#&gt;                   "to difficult problems (see the implementations of ", 
#&gt;                   list("dplyr::do()"), "\n", "methods for an example).\n", 
#&gt;                   list(), " ", list("env_bind_lazy()"), " takes named ", 
#&gt;                   list("expressions"), ". This is equivalent\n", 
#&gt;                   "to ", list(list("base::delayedAssign()")), 
#&gt;                   ". The arguments are captured with\n", list(
#&gt;                     list("exprs()")), " (and thus support call-splicing and unquoting) and\n", 
#&gt;                   "assigned to symbols in ", list(".env"), ". These expressions are not\n", 
#&gt;                   "evaluated immediately but lazily. Once a symbol is evaluated, the\n", 
#&gt;                   "corresponding expression is evaluated in turn and its value is\n", 
#&gt;                   "bound to the symbol (the expressions are thus evaluated only\n", 
#&gt;                   "once, if at all).\n"), "\n"), "\n", list(list(
#&gt;                 "Side effects"), list("\n", "\n", "\n", "Since environments have reference semantics (see relevant section\n", 
#&gt;                 "in ", list(list("env()")), " documentation), modifying the bindings of an environment\n", 
#&gt;                 "produces effects in all other references to that environment. In\n", 
#&gt;                 "other words, ", list("env_bind()"), " and its variants have side effects.\n", 
#&gt;                 "\n", "Like other side-effecty functions like ", 
#&gt;                 list("par()"), " and ", list("options()"), ",\n", 
#&gt;                 list("env_bind()"), " and variants return the old values invisibly.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "Passing an environment wrapper like a formula or a function instead\n", 
#&gt;                 "of an environment is soft-deprecated as of rlang 0.3.0. This\n", 
#&gt;                 "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                 "should now extract the environment separately before calling these\n", 
#&gt;                 "functions.\n")), "\n", "\n", list("\n", "# env_bind() is a programmatic way of assigning values to symbols\n", 
#&gt;                 "# with `&lt;-`. We can add bindings in the current environment:\n", 
#&gt;                 "env_bind(current_env(), foo = \"bar\")\n", "foo\n", 
#&gt;                 "\n", "# Or modify those bindings:\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "env_bind(current_env(), bar = \"BAR\")\n", "bar\n", 
#&gt;                 "\n", "# You can remove bindings by supplying zap sentinels:\n", 
#&gt;                 "env_bind(current_env(), foo = zap())\n", "try(foo)\n", 
#&gt;                 "\n", "# Unquote-splice a named list of zaps\n", 
#&gt;                 "zaps &lt;- rep_named(c(\"foo\", \"bar\"), list(zap()))\n", 
#&gt;                 "env_bind(current_env(), !!!zaps)\n", "try(bar)\n", 
#&gt;                 "\n", "# It is most useful to change other environments:\n", 
#&gt;                 "my_env &lt;- env()\n", "env_bind(my_env, foo = \"foo\")\n", 
#&gt;                 "my_env$foo\n", "\n", "# A useful feature is to splice lists of named values:\n", 
#&gt;                 "vals &lt;- list(a = 10, b = 20)\n", "env_bind(my_env, !!!vals, c = 30)\n", 
#&gt;                 "my_env$b\n", "my_env$c\n", "\n", "# You can also unquote a variable referring to a symbol or a string\n", 
#&gt;                 "# as binding name:\n", "var &lt;- \"baz\"\n", "env_bind(my_env, !!var := \"BAZ\")\n", 
#&gt;                 "my_env$baz\n", "\n", "\n", "# The old values of the bindings are returned invisibly:\n", 
#&gt;                 "old &lt;- env_bind(my_env, a = 1, b = 2, baz = \"baz\")\n", 
#&gt;                 "old\n", "\n", "# You can restore the original environment state by supplying the\n", 
#&gt;                 "# old values back:\n", "env_bind(my_env, !!!old)\n", 
#&gt;                 "\n", "# env_bind_lazy() assigns expressions lazily:\n", 
#&gt;                 "env &lt;- env()\n", "env_bind_lazy(env, name = { cat(\"forced!\\n\"); \"value\" })\n", 
#&gt;                 "\n", "# Referring to the binding will cause evaluation:\n", 
#&gt;                 "env$name\n", "\n", "# But only once, subsequent references yield the final value:\n", 
#&gt;                 "env$name\n", "\n", "# You can unquote expressions:\n", 
#&gt;                 "expr &lt;- quote(message(\"forced!\"))\n", "env_bind_lazy(env, name = !!expr)\n", 
#&gt;                 "env$name\n", "\n", "\n", "# By default the expressions are evaluated in the current\n", 
#&gt;                 "# environment. For instance we can create a local binding and refer\n", 
#&gt;                 "# to it, even though the variable is bound in a different\n", 
#&gt;                 "# environment:\n", "who &lt;- \"mickey\"\n", "env_bind_lazy(env, name = paste(who, \"mouse\"))\n", 
#&gt;                 "env$name\n", "\n", "# You can specify another evaluation environment with `.eval_env`:\n", 
#&gt;                 "eval_env &lt;- env(who = \"minnie\")\n", "env_bind_lazy(env, name = paste(who, \"mouse\"), .eval_env = eval_env)\n", 
#&gt;                 "env$name\n", "\n", "# Or by unquoting a quosure:\n", 
#&gt;                 "quo &lt;- local({\n", "  who &lt;- \"fievel\"\n", 
#&gt;                 "  quo(paste(who, \"mouse\"))\n", "})\n", "env_bind_lazy(env, name = !!quo)\n", 
#&gt;                 "env$name\n", "\n", "# You can create active bindings with env_bind_active(). Active\n", 
#&gt;                 "# bindings execute a function each time they are evaluated:\n", 
#&gt;                 "fn &lt;- function() {\n", "  cat(\"I have been called\\n\")\n", 
#&gt;                 "  rnorm(1)\n", "}\n", "\n", "env &lt;- env()\n", 
#&gt;                 "env_bind_active(env, symbol = fn)\n", "\n", 
#&gt;                 "# `fn` is executed each time `symbol` is evaluated or retrieved:\n", 
#&gt;                 "env$symbol\n", "env$symbol\n", "eval_bare(quote(symbol), env)\n", 
#&gt;                 "eval_bare(quote(symbol), env)\n", "\n", "# All arguments are passed to as_function() so you can use the\n", 
#&gt;                 "# formula shortcut:\n", "env_bind_active(env, foo = ~ runif(1))\n", 
#&gt;                 "env$foo\n", "env$foo\n"), "\n"), env_bind_exprs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("env_bind_exprs"), "\n", list("env_bind_exprs"), 
#&gt;             "\n", list("env_bind_fns"), "\n", list("Bind a promise or active binding"), 
#&gt;             "\n", list("\n", "env_bind_exprs(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_fns(.env, ...)\n"), "\n", list(
#&gt;                 "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.3.0, ", list("env_bind_exprs()"), 
#&gt;                 " and ", list("env_bind_fns()"), " have\n", "been renamed to ", 
#&gt;                 list(list("env_bind_lazy()")), " and ", list(
#&gt;                   list("env_bind_active()")), " for\n", "consistency.\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_are_active.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_are_active"), "\n", list(
#&gt;                 "env_binding_are_active"), "\n", list("env_binding_are_lazy"), 
#&gt;             "\n", list("What kind of environment binding?"), 
#&gt;             "\n", list("\n", "env_binding_are_active(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_lazy(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "A logical vector as long as ", list("nms"), 
#&gt;                 " and named after it.\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_lock.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_lock"), "\n", list("env_binding_lock"), 
#&gt;             "\n", list("env_binding_unlock"), "\n", list("env_binding_are_locked"), 
#&gt;             "\n", list("Lock or unlock environment bindings"), 
#&gt;             "\n", list("\n", "env_binding_lock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_unlock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_locked(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("env_binding_are_unlocked()"), " returns a logical vector as\n", 
#&gt;                 "long as ", list("nms"), " and named after it. ", 
#&gt;                 list("env_binding_lock()"), " and\n", list("env_binding_unlock()"), 
#&gt;                 " return the old value of\n", list("env_binding_are_unlocked()"), 
#&gt;                 " invisibly.\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environment bindings trigger an error when an attempt is\n", 
#&gt;                 "made to redefine the binding.\n"), "\n", list(
#&gt;                 "\n", "# Bindings are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = \"A\", b = \"B\")\n", "env_binding_are_locked(env)\n", 
#&gt;                 "\n", "# But can optionally be locked:\n", "env_binding_lock(env, \"a\")\n", 
#&gt;                 "env_binding_are_locked(env)\n", "\n", "# If run, the following would now return an error because `a` is locked:\n", 
#&gt;                 "# env_bind(env, a = \"foo\")\n", "# with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "\n", "# Let's unlock it. Note that the return value indicate which\n", 
#&gt;                 "# bindings were locked:\n", "were_locked &lt;- env_binding_unlock(env)\n", 
#&gt;                 "were_locked\n", "\n", "# Now that it is unlocked we can modify it again:\n", 
#&gt;                 "env_bind(env, a = \"foo\")\n", "with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "env$a\n"), "\n", list("\n", list(list("env_lock()")), 
#&gt;                 " for locking an environment.\n"), "\n", list(
#&gt;                 "internal"), "\n"), env_bury.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bury"), "\n", list("env_bury"), "\n", 
#&gt;             list("Mask bindings by defining symbols deeper in a scope"), 
#&gt;             "\n", list("\n", "env_bury(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n"), "\n", list("\n", "A copy of ", 
#&gt;                 list(".env"), " enclosing the new environment containing\n", 
#&gt;                 "bindings to ", list("..."), " arguments.\n"), 
#&gt;             "\n", list("\n", list("env_bury()"), " is like ", 
#&gt;                 list(list("env_bind()")), " but it creates the bindings in a\n", 
#&gt;                 "new child environment. This makes sure the new bindings have\n", 
#&gt;                 "precedence over old ones, without altering existing environments.\n", 
#&gt;                 "Unlike ", list("env_bind()"), ", this function does not have side effects and\n", 
#&gt;                 "returns a new environment (or object wrapping that environment).\n"), 
#&gt;             "\n", list("\n", "orig_env &lt;- env(a = 10)\n", "fn &lt;- set_env(function() a, orig_env)\n", 
#&gt;                 "\n", "# fn() currently sees `a` as the value `10`:\n", 
#&gt;                 "fn()\n", "\n", "# env_bury() will bury the current scope of fn() behind a new\n", 
#&gt;                 "# environment:\n", "fn &lt;- env_bury(fn, a = 1000)\n", 
#&gt;                 "fn()\n", "\n", "# Even though the symbol `a` is still defined deeper in the scope:\n", 
#&gt;                 "orig_env$a\n"), "\n", list("\n", list(list("env_bind()")), 
#&gt;                 ", ", list(list("env_unbind()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), env_clone.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_clone"), "\n", list("env_clone"), "\n", 
#&gt;             list("Clone an environment"), "\n", list("\n", "env_clone(env, parent = env_parent(env))\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("The parent of the cloned environment.")), 
#&gt;                 "\n"), "\n", list("\n", "This creates a new environment containing exactly the same objects,\n", 
#&gt;                 "optionally with a new parent.\n"), "\n", list(
#&gt;                 "\n", "env &lt;- env(!!! mtcars)\n", "clone &lt;- env_clone(env)\n", 
#&gt;                 "identical(env, clone)\n", "identical(env$cyl, clone$cyl)\n"), 
#&gt;             "\n"), env_depth.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_depth"), "\n", list("env_depth"), "\n", 
#&gt;             list("Depth of an environment chain"), "\n", list(
#&gt;                 "\n", "env_depth(env)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n"), 
#&gt;             "\n", list("\n", "An integer.\n"), "\n", list("\n", 
#&gt;                 "This function returns the number of environments between ", 
#&gt;                 list("env"), " and\n", "the ", list("empty environment"), 
#&gt;                 ", including ", list("env"), ". The depth of\n", 
#&gt;                 list("env"), " is also the number of parents of ", 
#&gt;                 list("env"), " (since the empty\n", "environment counts as a parent).\n"), 
#&gt;             "\n", list("\n", "env_depth(empty_env())\n", "env_depth(pkg_env(\"rlang\"))\n"), 
#&gt;             "\n", list("\n", "The section on inheritance in ", 
#&gt;                 list(list("env()")), " documentation.\n"), "\n"), 
#&gt;         env_get.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_get"), "\n", list("env_get"), "\n", 
#&gt;             list("env_get_list"), "\n", list("Get an object in an environment"), 
#&gt;             "\n", list("\n", "env_get(env = caller_env(), nm, default, inherit = FALSE)\n", 
#&gt;                 "\n", "env_get_list(env = caller_env(), nms, default, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nm, nms"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default value in case there is no binding for ", 
#&gt;                   list("nm"), "\n", "in ", list("env"), ".")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "An object if it exists. Otherwise, throws an error.\n"), 
#&gt;             "\n", list("\n", list("env_get()"), " extracts an object from an enviroment ", 
#&gt;                 list("env"), ". By\n", "default, it does not look in the parent environments.\n", 
#&gt;                 list("env_get_list()"), " extracts multiple objects from an environment into\n", 
#&gt;                 "a named list.\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# This throws an error because `foo` is not directly defined in env:\n", 
#&gt;                 "# env_get(env, \"foo\")\n", "\n", "# However `foo` can be fetched in the parent environment:\n", 
#&gt;                 "env_get(env, \"foo\", inherit = TRUE)\n", "\n", 
#&gt;                 "# You can also avoid an error by supplying a default value:\n", 
#&gt;                 "env_get(env, \"foo\", default = \"FOO\")\n"), 
#&gt;             "\n"), env_has.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_has"), "\n", list("env_has"), "\n", 
#&gt;             list("Does an environment have or see bindings?"), 
#&gt;             "\n", list("\n", "env_has(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "A named logical vector as long as ", list("nms"), 
#&gt;                 ".\n"), "\n", list("\n", list("env_has()"), " is a vectorised predicate that queries whether an\n", 
#&gt;                 "environment owns bindings personally (with ", 
#&gt;                 list("inherit"), " set to\n", list("FALSE"), 
#&gt;                 ", the default), or sees them in its own environment or in\n", 
#&gt;                 "any of its parents (with ", list("inherit = TRUE"), 
#&gt;                 ").\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# env does not own `foo` but sees it in its parent environment:\n", 
#&gt;                 "env_has(env, \"foo\")\n", "env_has(env, \"foo\", inherit = TRUE)\n"), 
#&gt;             "\n"), env_inherits.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_inherits"), "\n", list("env_inherits"), 
#&gt;             "\n", list("Does environment inherit from another environment?"), 
#&gt;             "\n", list("\n", "env_inherits(env, ancestor)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("ancestor"), list("Another environment from which ", 
#&gt;                   list("x"), " might inherit.")), "\n"), "\n", 
#&gt;             list("\n", "This returns ", list("TRUE"), " if ", 
#&gt;                 list("x"), " has ", list("ancestor"), " among its parents.\n"), 
#&gt;             "\n"), env_lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_lock"), "\n", list("env_lock"), "\n", list(
#&gt;                 "env_is_locked"), "\n", list("Lock an environment"), 
#&gt;             "\n", list("\n", "env_lock(env)\n", "\n", "env_is_locked(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "The old value of ", 
#&gt;                 list("env_is_locked()"), " invisibly.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environments cannot be modified. An important example is\n", 
#&gt;                 "namespace environments which are locked by R when loaded in a\n", 
#&gt;                 "session. Once an environment is locked it normally cannot be\n", 
#&gt;                 "unlocked.\n", "\n", "Note that only the environment as a container is locked, not the\n", 
#&gt;                 "individual bindings. You can't remove or add a binding but you can\n", 
#&gt;                 "still modify the values of existing bindings. See\n", 
#&gt;                 list(list("env_binding_lock()")), " for locking individual bindings.\n"), 
#&gt;             "\n", list("\n", "# New environments are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = 1)\n", "env_is_locked(env)\n", 
#&gt;                 "\n", "# Use env_lock() to lock them:\n", "env_lock(env)\n", 
#&gt;                 "env_is_locked(env)\n", "\n", "# Now that `env` is locked, it is no longer possible to remove or\n", 
#&gt;                 "# add bindings. If run, the following would fail:\n", 
#&gt;                 "# env_unbind(env, \"a\")\n", "# env_bind(env, b = 2)\n", 
#&gt;                 "\n", "# Note that even though the environment as a container is locked,\n", 
#&gt;                 "# the individual bindings are still unlocked and can be modified:\n", 
#&gt;                 "env$a &lt;- 10\n"), "\n", list("\n", list(list(
#&gt;                 "env_binding_lock()")), "\n"), "\n", list("internal"), 
#&gt;             "\n"), env_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("env_name"), "\n", list("env_name"), "\n", 
#&gt;             list("env_label"), "\n", list("Label of an environment"), 
#&gt;             "\n", list("\n", "env_name(env)\n", "\n", "env_label(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Special environments like the global environment have their own\n", 
#&gt;                 "names. ", list("env_name()"), " returns:\n", 
#&gt;                 list("\n", list(), " \"global\" for the global environment.\n", 
#&gt;                   list(), " \"empty\" for the empty environment.\n", 
#&gt;                   list(), " \"base\" for the base package environment (the last environment on\n", 
#&gt;                   "the search path).\n", list(), " \"namespace:pkg\" if ", 
#&gt;                   list("env"), " is the namespace of the package \"pkg\".\n", 
#&gt;                   list(), " The ", list("name"), " attribute of ", 
#&gt;                   list("env"), " if it exists. This is how the\n", 
#&gt;                   list("package environments"), " and the ", 
#&gt;                   list("imports environments"), " store their names. The name of package\n", 
#&gt;                   "environments is typically \"package:pkg\".\n", 
#&gt;                   list(), " The empty string ", list("\"\""), 
#&gt;                   " otherwise.\n"), "\n", "\n", list("env_label()"), 
#&gt;                 " is exactly like ", list("env_name()"), " but returns the memory\n", 
#&gt;                 "address of anonymous environments as fallback.\n"), 
#&gt;             "\n", list("\n", "# Some environments have specific names:\n", 
#&gt;                 "env_name(global_env())\n", "env_name(ns_env(\"rlang\"))\n", 
#&gt;                 "\n", "# Anonymous environments don't have names but are labelled by their\n", 
#&gt;                 "# address in memory:\n", "env_name(env())\n", 
#&gt;                 "env_label(env())\n"), "\n"), env_names.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_names"), "\n", list("env_names"), 
#&gt;             "\n", list("env_length"), "\n", list("Names and numbers of symbols bound in an environment"), 
#&gt;             "\n", list("\n", "env_names(env)\n", "\n", "env_length(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of object names.\n"), 
#&gt;             "\n", list("\n", list("env_names()"), " returns object names from an enviroment ", 
#&gt;                 list("env"), " as a\n", "character vector. All names are returned, even those starting with\n", 
#&gt;                 "a dot. ", list("env_length()"), " returns the number of bindings.\n"), 
#&gt;             "\n", list(list("Names of symbols and objects"), 
#&gt;                 list("\n", "\n", "\n", "Technically, objects are bound to symbols rather than strings,\n", 
#&gt;                   "since the R interpreter evaluates symbols (see ", 
#&gt;                   list(list("is_expression()")), " for a\n", 
#&gt;                   "discussion of symbolic objects versus literal objects). However it\n", 
#&gt;                   "is often more convenient to work with strings. In rlang\n", 
#&gt;                   "terminology, the string corresponding to a symbol is called the\n", 
#&gt;                   list("name"), " of the symbol (or by extension the name of an object bound\n", 
#&gt;                   "to a symbol).\n")), "\n", "\n", list(list(
#&gt;                 "Encoding"), list("\n", "\n", "\n", "There are deep encoding issues when you convert a string to symbol\n", 
#&gt;                 "and vice versa. Symbols are ", list("always"), 
#&gt;                 " in the native encoding. If\n", "that encoding (let's say latin1) cannot support some characters,\n", 
#&gt;                 "these characters are serialised to ASCII. That's why you sometimes\n", 
#&gt;                 "see strings looking like ", list("&lt;U+1234&gt;"), 
#&gt;                 ", especially if you're running\n", "Windows (as R doesn't support UTF-8 as native encoding on that\n", 
#&gt;                 "platform).\n", "\n", "To alleviate some of the encoding pain, ", 
#&gt;                 list("env_names()"), " always\n", "returns a UTF-8 character vector (which is fine even on Windows)\n", 
#&gt;                 "with ASCII unicode points translated back to UTF-8.\n")), 
#&gt;             "\n", "\n", list("\n", "env &lt;- env(a = 1, b = 2)\n", 
#&gt;                 "env_names(env)\n"), "\n"), env_parent.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "env_parent"), "\n", list("env_parent"), "\n", 
#&gt;             list("env_tail"), "\n", list("env_parents"), "\n", 
#&gt;             list("Get parent environments"), "\n", list("\n", 
#&gt;                 "env_parent(env = caller_env(), n = 1)\n", "\n", 
#&gt;                 "env_tail(env = caller_env(), last = global_env(), sentinel = NULL)\n", 
#&gt;                 "\n", "env_parents(env = caller_env(), last = global_env())\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of generations to go up.")), 
#&gt;                 "\n", "\n", list(list("last"), list("The environment at which to stop. Defaults to the\n", 
#&gt;                   "global environment. The empty environment is always a stopping\n", 
#&gt;                   "condition so it is safe to leave the default even when taking the\n", 
#&gt;                   "tail or the parents of an environment on the search path.\n", 
#&gt;                   "\n", list("env_tail()"), " returns the environment which has ", 
#&gt;                   list("last"), " as parent\n", "and ", list(
#&gt;                     "env_parents()"), " returns the list of environments up to ", 
#&gt;                   list("last"), ".")), "\n", "\n", list(list(
#&gt;                   "sentinel"), list("This argument is defunct, please use ", 
#&gt;                   list("last"), " instead.")), "\n"), "\n", list(
#&gt;                 "\n", "An environment for ", list("env_parent()"), 
#&gt;                 " and ", list("env_tail()"), ", a list\n", "of environments for ", 
#&gt;                 list("env_parents()"), ".\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("env_parent()"), 
#&gt;                   " returns the parent environment of ", list(
#&gt;                     "env"), " if called\n", "with ", list("n = 1"), 
#&gt;                   ", the grandparent with ", list("n = 2"), ", etc.\n", 
#&gt;                   list(), " ", list("env_tail()"), " searches through the parents and returns the one\n", 
#&gt;                   "which has ", list(list("empty_env()")), " as parent.\n", 
#&gt;                   list(), " ", list("env_parents()"), " returns the list of all parents, including the\n", 
#&gt;                   "empty environment. This list is named using ", 
#&gt;                   list(list("env_name()")), ".\n"), "\n", "\n", 
#&gt;                 "See the section on ", list("inheritance"), " in ", 
#&gt;                 list(list("env()")), "'s documentation.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "The ", list("sentinel"), " argument of ", list(
#&gt;                   "env_tail()"), " has been deprecated in\n", 
#&gt;                 "rlang 0.2.0 and renamed to ", list("last"), 
#&gt;                 ". It is defunct as of rlang 0.4.0.\n")), "\n", 
#&gt;             "\n", list("\n", "# Get the parent environment with env_parent():\n", 
#&gt;                 "env_parent(global_env())\n", "\n", "# Or the tail environment with env_tail():\n", 
#&gt;                 "env_tail(global_env())\n", "\n", "# By default, env_parent() returns the parent environment of the\n", 
#&gt;                 "# current evaluation frame. If called at top-level (the global\n", 
#&gt;                 "# frame), the following two expressions are equivalent:\n", 
#&gt;                 "env_parent()\n", "env_parent(base_env())\n", 
#&gt;                 "\n", "# This default is more handy when called within a function. In this\n", 
#&gt;                 "# case, the enclosure environment of the function is returned\n", 
#&gt;                 "# (since it is the parent of the evaluation frame):\n", 
#&gt;                 "enclos_env &lt;- env()\n", "fn &lt;- set_env(function() env_parent(), enclos_env)\n", 
#&gt;                 "identical(enclos_env, fn())\n"), "\n"), env_poke.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_poke"), "\n", list("env_poke"), "\n", 
#&gt;             list("Poke an object in an environment"), "\n", list(
#&gt;                 "\n", "env_poke(env = caller_env(), nm, value, inherit = FALSE,\n", 
#&gt;                 "  create = !inherit)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n", 
#&gt;                 "\n", list(list("nm"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for a new binding.")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n", "\n", list(list("create"), 
#&gt;                   list("Whether to create a binding if it does not already\n", 
#&gt;                     "exist in the environment.")), "\n"), "\n", 
#&gt;             list("\n", "The old value of ", list("nm"), " or a ", 
#&gt;                 list("zap sentinel"), " if the\n", "binding did not exist yet.\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("env_poke()"), " will assign or reassign a binding in ", 
#&gt;                 list("env"), " if ", list("create"), "\n", "is ", 
#&gt;                 list("TRUE"), ". If ", list("create"), " is ", 
#&gt;                 list("FALSE"), " and a binding does not already\n", 
#&gt;                 "exists, an error is issued.\n"), "\n", list(
#&gt;                 "\n", "If ", list("inherit"), " is ", list("TRUE"), 
#&gt;                 ", the parents environments are checked for\n", 
#&gt;                 "an existing binding to reassign. If not found and ", 
#&gt;                 list("create"), " is\n", list("TRUE"), ", a new binding is created in ", 
#&gt;                 list("env"), ". The default value for\n", list(
#&gt;                   "create"), " is a function of ", list("inherit"), 
#&gt;                 ": ", list("FALSE"), " when inheriting,\n", list(
#&gt;                   "TRUE"), " otherwise.\n", "\n", "This default makes sense because the inheriting case is mostly\n", 
#&gt;                 "for overriding an existing binding. If not found, something\n", 
#&gt;                 "probably went wrong and it is safer to issue an error. Note that\n", 
#&gt;                 "this is different to the base R operator ", 
#&gt;                 list("&lt;&lt;-"), " which will create\n", "a binding in the global environment instead of the current\n", 
#&gt;                 "environment when no existing binding is found in the parents.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("env_poke()"), " is experimental. We are still experimenting with\n", 
#&gt;                 "reducing the number of redundant functions by using quasiquotation.\n", 
#&gt;                 "It is possible ", list("env_poke()"), " will be deprecated in favour of\n", 
#&gt;                 list("env_bind()"), " and name-unquoting with ", 
#&gt;                 list(":="), ".\n")), "\n", "\n", list("internal"), 
#&gt;             "\n"), env_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_print"), "\n", list("env_print"), "\n", 
#&gt;             list("Pretty-print an environment"), "\n", list("\n", 
#&gt;                 "env_print(env = caller_env())\n"), "\n", list(
#&gt;                 "\n", list(list("env"), list("An environment, or object that can be converted to an\n", 
#&gt;                   "environment by ", list(list("get_env()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This prints:\n", 
#&gt;                 list("\n", list(), " The ", list("label"), " and the parent label.\n", 
#&gt;                   list(), " Whether the environment is ", list(
#&gt;                     "locked"), ".\n", list(), " The bindings in the environment (up to 20 bindings). They are\n", 
#&gt;                   "printed succintly using ", list("pillar::type_sum()"), 
#&gt;                   " (if available,\n", "otherwise uses an internal version of that generic). In addition\n", 
#&gt;                   list("fancy bindings"), " (actives and promises) are\n", 
#&gt;                   "indicated as such.\n", list(), " Locked bindings get a ", 
#&gt;                   list("[L]"), " tag\n"), "\n"), "\n"), env_unbind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_unbind"), "\n", list("env_unbind"), 
#&gt;             "\n", list("Remove bindings from an environment"), 
#&gt;             "\n", list("\n", "env_unbind(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "The input object ", list("env"), " with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", list("env_unbind()"), " is the complement of ", 
#&gt;                 list(list("env_bind()")), ". Like ", list("env_has()"), 
#&gt;                 ",\n", "it ignores the parent environments of ", 
#&gt;                 list("env"), " by default. Set\n", list("inherit"), 
#&gt;                 " to ", list("TRUE"), " to track down bindings in parent environments.\n"), 
#&gt;             "\n", list("\n", "data &lt;- set_names(as.list(letters), letters)\n", 
#&gt;                 "env_bind(environment(), !!! data)\n", "env_has(environment(), letters)\n", 
#&gt;                 "\n", "# env_unbind() removes bindings:\n", "env_unbind(environment(), letters)\n", 
#&gt;                 "env_has(environment(), letters)\n", "\n", "# With inherit = TRUE, it removes bindings in parent environments\n", 
#&gt;                 "# as well:\n", "parent &lt;- child_env(NULL, foo = \"a\")\n", 
#&gt;                 "env &lt;- child_env(parent, foo = \"b\")\n", "env_unbind(env, \"foo\", inherit = TRUE)\n", 
#&gt;                 "env_has(env, \"foo\", inherit = TRUE)\n"), "\n"), 
#&gt;         env_unlock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_unlock"), "\n", list("env_unlock"), "\n", 
#&gt;             list("Unlock an environment"), "\n", list("\n", "env_unlock(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Whether the environment has been unlocked.\n"), 
#&gt;             "\n", list("\n", "This function should only be used in development tools or\n", 
#&gt;                 "interactively.\n"), "\n", list("internal"), 
#&gt;             "\n"), eval_bare.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("eval_bare"), "\n", list("eval_bare"), 
#&gt;             "\n", list("Evaluate an expression in an environment"), 
#&gt;             "\n", list("\n", "eval_bare(expr, env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate the expression.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_bare()"), " is a lower-level version of function ", 
#&gt;                 list(list("base::eval()")), ".\n", "Technically, it is a simple wrapper around the C function\n", 
#&gt;                 list("Rf_eval()"), ". You generally don't need to use ", 
#&gt;                 list("eval_bare()"), " instead\n", "of ", list(
#&gt;                   "eval()"), ". Its main advantage is that it handles stack-sensitive\n", 
#&gt;                 "(calls such as ", list("return()"), ", ", list(
#&gt;                   "on.exit()"), " or ", list("parent.frame()"), 
#&gt;                 ") more\n", "consistently when you pass an enviroment of a frame on the call\n", 
#&gt;                 "stack.\n"), "\n", list("\n", "These semantics are possible because ", 
#&gt;                 list("eval_bare()"), " creates only one\n", "frame on the call stack whereas ", 
#&gt;                 list("eval()"), " creates two frames, the\n", 
#&gt;                 "second of which has the user-supplied environment as frame\n", 
#&gt;                 "environment. When you supply an existing frame environment to\n", 
#&gt;                 list("base::eval()"), " there will be two frames on the stack with the same\n", 
#&gt;                 "frame environment. Stack-sensitive functions only detect the\n", 
#&gt;                 "topmost of these frames. We call these evaluation semantics\n", 
#&gt;                 "\"stack inconsistent\".\n", "\n", "Evaluating expressions in the actual frame environment has useful\n", 
#&gt;                 "practical implications for ", list("eval_bare()"), 
#&gt;                 ":\n", list("\n", list(), " ", list("return()"), 
#&gt;                   " calls are evaluated in frame environments that might\n", 
#&gt;                   "be burried deep in the call stack. This causes a long return that\n", 
#&gt;                   "unwinds multiple frames (triggering the ", 
#&gt;                   list("on.exit()"), " event for\n", "each frame). By contrast ", 
#&gt;                   list("eval()"), " only returns from the ", 
#&gt;                   list("eval()"), "\n", "call, one level up.\n", 
#&gt;                   list(), " ", list("on.exit()"), ", ", list(
#&gt;                     "parent.frame()"), ", ", list("sys.call()"), 
#&gt;                   ", and generally all\n", "the stack inspection functions ", 
#&gt;                   list("sys.xxx()"), " are evaluated in the\n", 
#&gt;                   "correct frame environment. This is similar to how this type of\n", 
#&gt;                   "calls can be evaluated deep in the call stack because of lazy\n", 
#&gt;                   "evaluation, when you force an argument that has been passed\n", 
#&gt;                   "around several times.\n"), "\n", "\n", "The flip side of the semantics of ", 
#&gt;                 list("eval_bare()"), " is that it can't\n", "evaluate ", 
#&gt;                 list("break"), " or ", list("next"), " expressions even if called within a\n", 
#&gt;                 "loop.\n"), "\n", list("\n", "# eval_bare() works just like base::eval() but you have to create\n", 
#&gt;                 "# the evaluation environment yourself:\n", "eval_bare(quote(foo), env(foo = \"bar\"))\n", 
#&gt;                 "\n", "# eval() has different evaluation semantics than eval_bare(). It\n", 
#&gt;                 "# can return from the supplied environment even if its an\n", 
#&gt;                 "# environment that is not on the call stack (i.e. because you've\n", 
#&gt;                 "# created it yourself). The following would trigger an error with\n", 
#&gt;                 "# eval_bare():\n", "ret &lt;- quote(return(\"foo\"))\n", 
#&gt;                 "eval(ret, env())\n", "# eval_bare(ret, env())  # \"no function to return from\" error\n", 
#&gt;                 "\n", "# Another feature of eval() is that you can control surround loops:\n", 
#&gt;                 "bail &lt;- quote(break)\n", "while (TRUE) {\n", 
#&gt;                 "  eval(bail)\n", "  # eval_bare(bail)  # \"no loop for break/next\" error\n", 
#&gt;                 "}\n", "\n", "# To explore the consequences of stack inconsistent semantics, let's\n", 
#&gt;                 "# create a function that evaluates `parent.frame()` deep in the call\n", 
#&gt;                 "# stack, in an environment corresponding to a frame in the middle of\n", 
#&gt;                 "# the stack. For consistency with R's lazy evaluation semantics, we'd\n", 
#&gt;                 "# expect to get the caller of that frame as result:\n", 
#&gt;                 "fn &lt;- function(eval_fn) {\n", "  list(\n", "    returned_env = middle(eval_fn),\n", 
#&gt;                 "    actual_env = current_env()\n", "  )\n", 
#&gt;                 "}\n", "middle &lt;- function(eval_fn) {\n", "  deep(eval_fn, current_env())\n", 
#&gt;                 "}\n", "deep &lt;- function(eval_fn, eval_env) {\n", 
#&gt;                 "  expr &lt;- quote(parent.frame())\n", "  eval_fn(expr, eval_env)\n", 
#&gt;                 "}\n", "\n", "# With eval_bare(), we do get the expected environment:\n", 
#&gt;                 "fn(rlang::eval_bare)\n", "\n", "# But that's not the case with base::eval():\n", 
#&gt;                 "fn(base::eval)\n"), "\n", list("\n", list(list(
#&gt;                 "eval_tidy()")), " for evaluation with data mask and quosure\n", 
#&gt;                 "support.\n"), "\n"), eval_tidy.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("eval_tidy"), "\n", list("eval_tidy"), 
#&gt;             "\n", list("Evaluate an expression with quosures and pronoun support"), 
#&gt;             "\n", list("\n", "eval_tidy(expr, data = NULL, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression or quosure to evaluate.")), 
#&gt;                 "\n", "\n", list(list("data"), list("A data frame, or named list or vector. Alternatively, a\n", 
#&gt;                   "data mask created with ", list(list("as_data_mask()")), 
#&gt;                   " or\n", list(list("new_data_mask()")), ". Objects in ", 
#&gt;                   list("data"), " have priority over those in\n", 
#&gt;                   list("env"), ". See the section about data masking.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate ", 
#&gt;                   list("expr"), ". This\n", "environment is not applicable for quosures because they have\n", 
#&gt;                   "their own environments.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_tidy()"), " is a variant of ", 
#&gt;                 list(list("base::eval()")), " that powers the tidy\n", 
#&gt;                 "evaluation framework. Like ", list("eval()"), 
#&gt;                 " it accepts user data as\n", "argument. Whereas ", 
#&gt;                 list("eval()"), " simply transforms the data to an\n", 
#&gt;                 "environment, ", list("eval_tidy()"), " transforms it to a ", 
#&gt;                 list("data mask"), " with\n", list(list("as_data_mask()")), 
#&gt;                 ". Evaluating in a data mask enables the following\n", 
#&gt;                 "features:\n", list("\n", list(), " ", list("Quosures"), 
#&gt;                   ". Quosures are expressions bundled with an\n", 
#&gt;                   "environment. If ", list("data"), " is supplied, objects in the data mask\n", 
#&gt;                   "always have precedence over the quosure environment, i.e. the\n", 
#&gt;                   "data masks the environment.\n", list(), " ", 
#&gt;                   list("Pronouns"), ". If ", list("data"), " is supplied, the ", 
#&gt;                   list(".env"), " and ", list(".data"), "\n", 
#&gt;                   "pronouns are installed in the data mask. ", 
#&gt;                   list(".env"), " is a reference to\n", "the calling environment and ", 
#&gt;                   list(".data"), " refers to the ", list("data"), 
#&gt;                   " argument.\n", "These pronouns lets you be explicit about where to find\n", 
#&gt;                   "values and throw errors if you try to access non-existent values.\n"), 
#&gt;                 "\n"), "\n", list(list("Data masking"), list(
#&gt;                 "\n", "\n", "\n", "Data masking refers to how columns or objects inside ", 
#&gt;                 list("data"), " have\n", "priority over objects defined in ", 
#&gt;                 list("env"), " (or in the quosure\n", "environment, if applicable). If there is a column ", 
#&gt;                 list("var"), " in ", list("data"), "\n", "and an object ", 
#&gt;                 list("var"), " in ", list("env"), ", and ", list(
#&gt;                   "expr"), " refers to ", list("var"), ", the\n", 
#&gt;                 "column has priority:", list("var &lt;- \"this one?\"\n", 
#&gt;                   "data &lt;- data.frame(var = rep(\"Or that one?\", 3))\n", 
#&gt;                   "\n", "within &lt;- function(data, expr) {\n", 
#&gt;                   "  eval_tidy(enquo(expr), data)\n", "}\n", 
#&gt;                   "\n", "within(data, toupper(var))\n", "#&gt; [1] \"OR THAT ONE?\" \"OR THAT ONE?\" \"OR THAT ONE?\"\n"), 
#&gt;                 "\n", "\n", "Because the columns or objects in ", 
#&gt;                 list("data"), " are always found first,\n", "before objects from ", 
#&gt;                 list("env"), ", we say that the data \"masks\" the\n", 
#&gt;                 "environment.\n")), "\n", "\n", list(list("When should eval_tidy() be used instead of eval()?"), 
#&gt;                 list("\n", "\n", "\n", list("base::eval()"), 
#&gt;                   " is sufficient for simple evaluation. Use\n", 
#&gt;                   list("eval_tidy()"), " when you'd like to support expressions referring to\n", 
#&gt;                   "the ", list(".data"), " pronoun, or when you need to support quosures.\n", 
#&gt;                   "\n", "If you're evaluating an expression captured with quasiquotation\n", 
#&gt;                   "support, it is recommended to use ", list(
#&gt;                     "eval_tidy()"), " because users will\n", 
#&gt;                   "likely unquote quosures.\n", "\n", "Note that unwrapping a quosure with ", 
#&gt;                   list(list("quo_get_expr()")), " does not\n", 
#&gt;                   "guarantee that there is no quosures inside the expression. Quosures\n", 
#&gt;                   "might be unquoted anywhere. For instance, the following does not\n", 
#&gt;                   "work reliably in the presence of nested quosures:", 
#&gt;                   list("my_quoting_fn &lt;- function(x) {\n", "  x &lt;- enquo(x)\n", 
#&gt;                     "  expr &lt;- quo_get_expr(x)\n", "  env &lt;- quo_get_env(x)\n", 
#&gt;                     "  eval(expr, env)\n", "}\n", "\n", "# Works:\n", 
#&gt;                     "my_quoting_fn(toupper(letters))\n", "\n", 
#&gt;                     "# Fails because of a nested quosure:\n", 
#&gt;                     "my_quoting_fn(toupper(!!quo(letters)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("rlang 0.3.0"), "\n", 
#&gt;                   "\n", "Passing an environment to ", list("data"), 
#&gt;                   " is deprecated. Please construct an\n", "rlang data mask with ", 
#&gt;                   list(list("new_data_mask()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "\n", "# With simple quoted expressions eval_tidy() works the same way as\n", 
#&gt;                 "# eval():\n", "apple &lt;- \"apple\"\n", "kiwi &lt;- \"kiwi\"\n", 
#&gt;                 "expr &lt;- quote(paste(apple, kiwi))\n", "expr\n", 
#&gt;                 "\n", "eval(expr)\n", "eval_tidy(expr)\n", "\n", 
#&gt;                 "# Both accept a data mask as argument:\n", "data &lt;- list(apple = \"CARROT\", kiwi = \"TOMATO\")\n", 
#&gt;                 "eval(expr, data)\n", "eval_tidy(expr, data)\n", 
#&gt;                 "\n", "\n", "# In addition eval_tidy() has support for quosures:\n", 
#&gt;                 "with_data &lt;- function(data, expr) {\n", "  quo &lt;- enquo(expr)\n", 
#&gt;                 "  eval_tidy(quo, data)\n", "}\n", "with_data(NULL, apple)\n", 
#&gt;                 "with_data(data, apple)\n", "with_data(data, list(apple, kiwi))\n", 
#&gt;                 "\n", "# Secondly eval_tidy() installs handy pronouns that allow users to\n", 
#&gt;                 "# be explicit about where to find symbols:\n", 
#&gt;                 "with_data(data, .data$apple)\n", "with_data(data, .env$apple)\n", 
#&gt;                 "\n", "\n", "# Note that instead of using `.env` it is often equivalent and may\n", 
#&gt;                 "# be preferred to unquote a value. There are two differences. First\n", 
#&gt;                 "# unquoting happens earlier, when the quosure is created. Secondly,\n", 
#&gt;                 "# subsetting `.env` with the `$` operator may be brittle because\n", 
#&gt;                 "# `$` does not look through the parents of the environment.\n", 
#&gt;                 "#\n", "# For instance using `.env$name` in a magrittr pipeline is an\n", 
#&gt;                 "# instance where this poses problem, because the magrittr pipe\n", 
#&gt;                 "# currently (as of v1.5.0) evaluates its operands in a *child* of\n", 
#&gt;                 "# the current environment (this child environment is where it\n", 
#&gt;                 "# defines the pronoun `.`).\n", list("\n", "  data %&gt;% with_data(!!kiwi)     # \"kiwi\"\n", 
#&gt;                   "  data %&gt;% with_data(.env$kiwi)  # NULL\n"), 
#&gt;                 "\n"), "\n", list("\n", list("quasiquotation"), 
#&gt;                 " for the second leg of the tidy evaluation\n", 
#&gt;                 "framework.\n"), "\n"), exec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("exec"), "\n", list("exec"), "\n", list(
#&gt;                 "Execute a function"), "\n", list("\n", "exec(.fn, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("A function, or function name as a string.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to function.\n", 
#&gt;                   "\n", "These dots support ", list("tidy-dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".env"), 
#&gt;                   list("Environment in which to evaluate the call. This will be\n", 
#&gt;                     "most useful if ", list("f"), " is a string, or the function has side-effects.")), 
#&gt;                 "\n"), "\n", list("\n", "This function constructs and evaluates a call to ", 
#&gt;                 list(".fn"), ".\n", "It has two primary uses:\n", 
#&gt;                 list("\n", list(), " To call a function with arguments stored in a list (if the function\n", 
#&gt;                   "doesn't support ", list("tidy-dots"), ")\n", 
#&gt;                   list(), " To call every function stored in a list (in conjunction with ", 
#&gt;                   list("map()"), "/\n", list(list("lapply()")), 
#&gt;                   ")\n"), "\n"), "\n", list("\n", "args &lt;- list(x = c(1:10, 100, NA), na.rm = TRUE)\n", 
#&gt;                 "exec(\"mean\", !!!args)\n", "exec(\"mean\", !!!args, trim = 0.2)\n", 
#&gt;                 "\n", "fs &lt;- list(a = function() \"a\", b = function() \"b\")\n", 
#&gt;                 "lapply(fs, exec)\n", "\n", "# Compare to do.call it will not automatically inline expressions\n", 
#&gt;                 "# into the evaluated call.\n", "x &lt;- 10\n", 
#&gt;                 "args &lt;- exprs(x1 = x + 1, x2 = x * 2)\n", "exec(list, !!!args)\n", 
#&gt;                 "do.call(list, args)\n", "\n", "# exec() is not designed to generate pretty function calls. This is\n", 
#&gt;                 "# most easily seen if you call a function that captures the call:\n", 
#&gt;                 "f &lt;- disp ~ cyl\n", "exec(\"lm\", f, data = mtcars)\n", 
#&gt;                 "\n", "# If you need finer control over the generated call, you'll need to\n", 
#&gt;                 "# construct it yourself. This may require creating a new environment\n", 
#&gt;                 "# with carefully constructed bindings\n", "data_env &lt;- env(data = mtcars)\n", 
#&gt;                 "eval(expr(lm(!!f, data)), data_env)\n"), "\n"), 
#&gt;         exiting.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("exiting"), "\n", list("exiting"), "\n", 
#&gt;             list("Exiting handler"), "\n", list("\n", "exiting(handler)\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", list("exiting()"), " is no longer necessary as handlers are exiting by default.\n"), 
#&gt;             "\n", list("internal"), "\n"), expr_interp.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("expr_interp"), "\n", list("expr_interp"), 
#&gt;             "\n", list("Process unquote operators in a captured expression"), 
#&gt;             "\n", list("\n", "expr_interp(x, env = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function, raw expression, or formula to interpolate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which unquoted expressions should be\n", 
#&gt;                   "evaluated. By default, the formula or closure environment if a\n", 
#&gt;                   "formula or a function, or the current environment otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "While all capturing functions in the tidy evaluation framework\n", 
#&gt;                 "perform unquote on capture (most notably ", 
#&gt;                 list(list("quo()")), "),\n", list("expr_interp()"), 
#&gt;                 " manually processes unquoting operators in\n", 
#&gt;                 "expressions that are already captured. ", list(
#&gt;                   "expr_interp()"), " should be\n", "called in all user-facing functions expecting a formula as argument\n", 
#&gt;                 "to provide the same quasiquotation functionality as NSE functions.\n"), 
#&gt;             "\n", list("\n", "# All tidy NSE functions like quo() unquote on capture:\n", 
#&gt;                 "quo(list(!!(1 + 2)))\n", "\n", "# expr_interp() is meant to provide the same functionality when you\n", 
#&gt;                 "# have a formula or expression that might contain unquoting\n", 
#&gt;                 "# operators:\n", "f &lt;- ~list(!!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "# Note that only the outer formula is unquoted (which is a reason\n", 
#&gt;                 "# to use expr_interp() as early as possible in all user-facing\n", 
#&gt;                 "# functions):\n", "f &lt;- ~list(~!!(1 + 2), !!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "\n", "# Another purpose for expr_interp() is to interpolate a closure's\n", 
#&gt;                 "# body. This is useful to inline a function within another. The\n", 
#&gt;                 "# important limitation is that all formal arguments of the inlined\n", 
#&gt;                 "# function should be defined in the receiving function:\n", 
#&gt;                 "other_fn &lt;- function(x) toupper(x)\n", "\n", 
#&gt;                 "fn &lt;- expr_interp(function(x) {\n", "  x &lt;- paste0(x, \"_suffix\")\n", 
#&gt;                 "  !!! body(other_fn)\n", "})\n", "fn\n", "fn(\"foo\")\n"), 
#&gt;             "\n"), expr_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_label"), "\n", list("expr_label"), 
#&gt;             "\n", list("expr_name"), "\n", list("expr_text"), 
#&gt;             "\n", list("Turn an expression to a label"), "\n", 
#&gt;             list("\n", "expr_label(expr)\n", "\n", "expr_name(expr)\n", 
#&gt;                 "\n", "expr_text(expr, width = 60L, nlines = Inf)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to labellise.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("expr_text()"), " turns the expression into a single string, which\n", 
#&gt;                 "might be multi-line. ", list("expr_name()"), 
#&gt;                 " is suitable for formatting\n", "names. It works best with symbols and scalar types, but also\n", 
#&gt;                 "accepts calls. ", list("expr_label()"), " formats the expression nicely for use\n", 
#&gt;                 "in messages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are in the questioning stage because they are\n", 
#&gt;                   "redundant with the ", list("quo_"), " variants and do not handle quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# To labellise a function argument, first capture it with\n", 
#&gt;                 "# substitute():\n", "fn &lt;- function(x) expr_label(substitute(x))\n", 
#&gt;                 "fn(x:y)\n", "\n", "# Strings are encoded\n", 
#&gt;                 "expr_label(\"a\\nb\")\n", "\n", "# Names and expressions are quoted with ``\n", 
#&gt;                 "expr_label(quote(x))\n", "expr_label(quote(a + b + c))\n", 
#&gt;                 "\n", "# Long expressions are collapsed\n", "expr_label(quote(foo({\n", 
#&gt;                 "  1 + 2\n", "  print(x)\n", "})))\n"), "\n"), 
#&gt;         expr_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_print"), "\n", list("expr_print"), 
#&gt;             "\n", list("expr_deparse"), "\n", list("Print an expression"), 
#&gt;             "\n", list("\n", "expr_print(x, width = peek_option(\"width\"))\n", 
#&gt;                 "\n", "expr_deparse(x, width = peek_option(\"width\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object or expression to print.")), 
#&gt;                 "\n", "\n", list(list("width"), list("The width of the deparsed or printed expression.\n", 
#&gt;                   "Defaults to the global option ", list("width"), 
#&gt;                   ".")), "\n"), "\n", list("\n", list("expr_print()"), 
#&gt;                 ", powered by ", list("expr_deparse()"), ", is an alternative\n", 
#&gt;                 "printer for R expressions with a few improvements over the base R\n", 
#&gt;                 "printer.\n", list("\n", list(), " It colourises ", 
#&gt;                   list("quosures"), " according to their environment.\n", 
#&gt;                   "Quosures from the global environment are printed normally while\n", 
#&gt;                   "quosures from local environments are printed in unique colour (or\n", 
#&gt;                   "in italic when all colours are taken).\n", 
#&gt;                   list(), " It wraps inlined objects in angular brackets. For instance, an\n", 
#&gt;                   "integer vector unquoted in a function call (e.g.\n", 
#&gt;                   list("expr(foo(!!(1:3)))"), ") is printed like this: ", 
#&gt;                   list("foo(&lt;int: 1L, 2L, 3L&gt;)"), " while by default R prints the code to create that vector:\n", 
#&gt;                   list("foo(1:3)"), " which is ambiguous.\n", 
#&gt;                   list(), " It respects the width boundary (from the global option ", 
#&gt;                   list("width"), ")\n", "in more cases.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# It supports any object. Non-symbolic objects are always printed\n", 
#&gt;                 "# within angular brackets:\n", "expr_print(1:3)\n", 
#&gt;                 "expr_print(function() NULL)\n", "\n", "# Contrast this to how the code to create these objects is printed:\n", 
#&gt;                 "expr_print(quote(1:3))\n", "expr_print(quote(function() NULL))\n", 
#&gt;                 "\n", "# The main cause of non-symbolic objects in expressions is\n", 
#&gt;                 "# quasiquotation:\n", "expr_print(expr(foo(!!(1:3))))\n", 
#&gt;                 "\n", "\n", "# Quosures from the global environment are printed normally:\n", 
#&gt;                 "expr_print(quo(foo))\n", "expr_print(quo(foo(!!quo(bar))))\n", 
#&gt;                 "\n", "# Quosures from local environments are colourised according to\n", 
#&gt;                 "# their environments (if you have crayon installed):\n", 
#&gt;                 "local_quo &lt;- local(quo(foo))\n", "expr_print(local_quo)\n", 
#&gt;                 "\n", "wrapper_quo &lt;- local(quo(bar(!!local_quo, baz)))\n", 
#&gt;                 "expr_print(wrapper_quo)\n"), "\n"), exprs_auto_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quotation.R", "\n", 
#&gt;             list("exprs_auto_name"), "\n", list("exprs_auto_name"), 
#&gt;             "\n", list("quos_auto_name"), "\n", list("Ensure that all elements of a list of expressions are named"), 
#&gt;             "\n", list("\n", "exprs_auto_name(exprs, width = NULL, printer = NULL)\n", 
#&gt;                 "\n", "quos_auto_name(quos, width = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("exprs"), list("A list of expressions.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Deprecated. Maximum width of names.")), 
#&gt;                 "\n", "\n", list(list("printer"), list("Deprecated. A function that takes an expression\n", 
#&gt;                   "and converts it to a string. This function must take an\n", 
#&gt;                   "expression as the first argument and ", list(
#&gt;                     "width"), " as the second\n", "argument.")), 
#&gt;                 "\n", "\n", list(list("quos"), list("A list of quosures.")), 
#&gt;                 "\n"), "\n", list("\n", "This gives default names to unnamed elements of a list of\n", 
#&gt;                 "expressions (or expression wrappers such as formulas or\n", 
#&gt;                 "quosures). ", list("exprs_auto_name()"), " deparses the expressions with\n", 
#&gt;                 list(list("expr_name()")), " by default. ", list(
#&gt;                   "quos_auto_name()"), " deparses with\n", list(
#&gt;                   list("quo_name()")), ".\n"), "\n"), f_rhs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("f_rhs"), "\n", list("f_rhs"), "\n", list("f_rhs&lt;-"), 
#&gt;             "\n", list("f_lhs"), "\n", list("f_lhs&lt;-"), "\n", 
#&gt;             list("f_env"), "\n", list("f_env&lt;-"), "\n", list(
#&gt;                 "Get or set formula components"), "\n", list(
#&gt;                 "\n", "f_rhs(f)\n", "\n", "f_rhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_lhs(f)\n", "\n", "f_lhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_env(f)\n", "\n", "f_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("f, x"), list("A formula")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value to replace with.")), 
#&gt;                 "\n"), "\n", list("\n", list("f_rhs"), " and ", 
#&gt;                 list("f_lhs"), " return language objects (i.e.  atomic\n", 
#&gt;                 "vectors of length 1, a name, or a call). ", 
#&gt;                 list("f_env"), " returns an\n", "environment.\n"), 
#&gt;             "\n", list("\n", list("f_rhs"), " extracts the righthand side, ", 
#&gt;                 list("f_lhs"), " extracts the lefthand\n", "side, and ", 
#&gt;                 list("f_env"), " extracts the environment. All functions throw an\n", 
#&gt;                 "error if ", list("f"), " is not a formula.\n"), 
#&gt;             "\n", list("\n", "f_rhs(~ 1 + 2 + 3)\n", "f_rhs(~ x)\n", 
#&gt;                 "f_rhs(~ \"A\")\n", "f_rhs(1 ~ 2)\n", "\n", "f_lhs(~ y)\n", 
#&gt;                 "f_lhs(x ~ y)\n", "\n", "f_env(~ x)\n"), "\n"), 
#&gt;         f_text.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("f_text"), "\n", list("f_text"), "\n", 
#&gt;             list("f_name"), "\n", list("f_label"), "\n", list(
#&gt;                 "Turn RHS of formula into a string or label"), 
#&gt;             "\n", list("\n", "f_text(x, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "f_name(x)\n", "\n", "f_label(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A formula.")), "\n", 
#&gt;                 "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", "Equivalent of ", list(
#&gt;                 list("expr_text()")), " and ", list(list("expr_label()")), 
#&gt;                 " for formulas.\n"), "\n", list("\n", "f &lt;- ~ a + b + bc\n", 
#&gt;                 "f_text(f)\n", "f_label(f)\n", "\n", "# Names a quoted with ``\n", 
#&gt;                 "f_label(~ x)\n", "# Strings are encoded\n", 
#&gt;                 "f_label(~ \"a\\nb\")\n", "# Long expressions are collapsed\n", 
#&gt;                 "f_label(~ foo({\n", "  1 + 2\n", "  print(x)\n", 
#&gt;                 "}))\n"), "\n"), flatten.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-squash.R", 
#&gt;             "\n", list("flatten"), "\n", list("flatten"), "\n", 
#&gt;             list("flatten_lgl"), "\n", list("flatten_int"), "\n", 
#&gt;             list("flatten_dbl"), "\n", list("flatten_cpl"), "\n", 
#&gt;             list("flatten_chr"), "\n", list("flatten_raw"), "\n", 
#&gt;             list("squash"), "\n", list("squash_lgl"), "\n", list(
#&gt;                 "squash_int"), "\n", list("squash_dbl"), "\n", 
#&gt;             list("squash_cpl"), "\n", list("squash_chr"), "\n", 
#&gt;             list("squash_raw"), "\n", list("flatten_if"), "\n", 
#&gt;             list("squash_if"), "\n", list("Flatten or squash a list of lists into a simpler vector"), 
#&gt;             "\n", list("\n", "flatten(x)\n", "\n", "flatten_lgl(x)\n", 
#&gt;                 "\n", "flatten_int(x)\n", "\n", "flatten_dbl(x)\n", 
#&gt;                 "\n", "flatten_cpl(x)\n", "\n", "flatten_chr(x)\n", 
#&gt;                 "\n", "flatten_raw(x)\n", "\n", "squash(x)\n", 
#&gt;                 "\n", "squash_lgl(x)\n", "\n", "squash_int(x)\n", 
#&gt;                 "\n", "squash_dbl(x)\n", "\n", "squash_cpl(x)\n", 
#&gt;                 "\n", "squash_chr(x)\n", "\n", "squash_raw(x)\n", 
#&gt;                 "\n", "flatten_if(x, predicate = is_spliced)\n", 
#&gt;                 "\n", "squash_if(x, predicate = is_spliced)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A list to flatten or squash. The contents of the list can\n", 
#&gt;                 "be anything for unsuffixed functions ", list(
#&gt;                   "flatten()"), " and ", list("squash()"), "\n", 
#&gt;                 "(as a list is returned), but the contents must match the type for\n", 
#&gt;                 "the other functions.")), "\n", "\n", list(list(
#&gt;                 "predicate"), list("A function of one argument returning whether it\n", 
#&gt;                 "should be spliced.")), "\n"), "\n", list("\n", 
#&gt;                 list("flatten()"), " returns a list, ", list(
#&gt;                   "flatten_lgl()"), " a logical\n", "vector, ", 
#&gt;                 list("flatten_int()"), " an integer vector, ", 
#&gt;                 list("flatten_dbl()"), " a\n", "double vector, and ", 
#&gt;                 list("flatten_chr()"), " a character vector. Similarly\n", 
#&gt;                 "for ", list("squash()"), " and the typed variants (", 
#&gt;                 list("squash_lgl()"), " etc).\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("flatten()"), " removes one level hierarchy from a list, while\n", 
#&gt;                 list("squash()"), " removes all levels. These functions are similar to\n", 
#&gt;                 list(list("unlist()")), " but they are type-stable so you always know what the\n", 
#&gt;                 "type of the output is.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "These functions are in the questioning stage. They have slightly\n", 
#&gt;                 "different semantics than the flattening functions in purrr and we\n", 
#&gt;                 "are currently rethinking our approach to flattening with the new\n", 
#&gt;                 "typing facilities of the vctrs package.\n")), 
#&gt;             "\n", "\n", list("\n", "x &lt;- replicate(2, sample(4), simplify = FALSE)\n", 
#&gt;                 "x\n", "\n", "flatten(x)\n", "flatten_int(x)\n", 
#&gt;                 "\n", "# With flatten(), only one level gets removed at a time:\n", 
#&gt;                 "deep &lt;- list(1, list(2, list(3)))\n", "flatten(deep)\n", 
#&gt;                 "flatten(flatten(deep))\n", "\n", "# But squash() removes all levels:\n", 
#&gt;                 "squash(deep)\n", "squash_dbl(deep)\n", "\n", 
#&gt;                 "# The typed flatten functions remove one level and coerce to an atomic\n", 
#&gt;                 "# vector at the same time:\n", "flatten_dbl(list(1, list(2)))\n", 
#&gt;                 "\n", "# Only bare lists are flattened, but you can splice S3 lists\n", 
#&gt;                 "# explicitly:\n", "foo &lt;- set_attrs(list(\"bar\"), class = \"foo\")\n", 
#&gt;                 "str(flatten(list(1, foo, list(100))))\n", "str(flatten(list(1, splice(foo), list(100))))\n", 
#&gt;                 "\n", "# Instead of splicing manually, flatten_if() and squash_if() let\n", 
#&gt;                 "# you specify a predicate function:\n", "is_foo &lt;- function(x) inherits(x, \"foo\") || is_bare_list(x)\n", 
#&gt;                 "str(flatten_if(list(1, foo, list(100)), is_foo))\n", 
#&gt;                 "\n", "# squash_if() does the same with deep lists:\n", 
#&gt;                 "deep_foo &lt;- list(1, list(foo, list(foo, 100)))\n", 
#&gt;                 "str(deep_foo)\n", "\n", "str(squash(deep_foo))\n", 
#&gt;                 "str(squash_if(deep_foo, is_foo))\n"), "\n", 
#&gt;             list("internal"), "\n"), fn_body.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_body"), "\n", list("fn_body"), "\n", list(
#&gt;                 "fn_body&lt;-"), "\n", list("Get or set function body"), 
#&gt;             "\n", list("\n", "fn_body(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_body(fn) &lt;- value\n"), "\n", list("\n", list(
#&gt;                 list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                   "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_body()"), " is a simple wrapper around ", 
#&gt;                 list(list("base::body()")), ". It always\n", 
#&gt;                 "returns a ", list("{"), " expression and throws an error when the input is a\n", 
#&gt;                 "primitive function (whereas ", list("body()"), 
#&gt;                 " returns ", list("NULL"), "). The setter\n", 
#&gt;                 "version preserves attributes, unlike ", list(
#&gt;                   "body&lt;-"), ".\n"), "\n", list("\n", "# fn_body() is like body() but always returns a block:\n", 
#&gt;                 "fn &lt;- function() do()\n", "body(fn)\n", "fn_body(fn)\n", 
#&gt;                 "\n", "# It also throws an error when used on a primitive function:\n", 
#&gt;                 "try(fn_body(base::list))\n"), "\n"), fn_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "fn_env"), "\n", list("fn_env"), "\n", list("fn_env&lt;-"), 
#&gt;             "\n", list("Return the closure environment of a function"), 
#&gt;             "\n", list("\n", "fn_env(fn)\n", "\n", "fn_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn, x"), list("A function.")), 
#&gt;                 "\n", "\n", list(list("value"), list("A new closure environment for the function.")), 
#&gt;                 "\n"), "\n", list("\n", "Closure environments define the scope of functions (see ", 
#&gt;                 list(list("env()")), ").\n", "When a function call is evaluated, R creates an evaluation frame\n", 
#&gt;                 "(see ", list(list("ctxt_stack()")), ") that inherits from the closure environment.\n", 
#&gt;                 "This makes all objects defined in the closure environment and all\n", 
#&gt;                 "its parents available to code executed within the function.\n"), 
#&gt;             "\n", list("\n", list("fn_env()"), " returns the closure environment of ", 
#&gt;                 list("fn"), ". There is also\n", "an assignment method to set a new closure environment.\n"), 
#&gt;             "\n", list("\n", "env &lt;- child_env(\"base\")\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(fn_env(fn), env)\n", 
#&gt;                 "\n", "other_env &lt;- child_env(\"base\")\n", "fn_env(fn) &lt;- other_env\n", 
#&gt;                 "identical(fn_env(fn), other_env)\n"), "\n"), 
#&gt;         fn_fmls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_fmls"), "\n", list("fn_fmls"), "\n", list(
#&gt;                 "fn_fmls_names"), "\n", list("fn_fmls_syms"), 
#&gt;             "\n", list("fn_fmls&lt;-"), "\n", list("fn_fmls_names&lt;-"), 
#&gt;             "\n", list("Extract arguments from a function"), 
#&gt;             "\n", list("\n", "fn_fmls(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_fmls_names(fn = caller_fn())\n", "\n", "fn_fmls_syms(fn = caller_fn())\n", 
#&gt;                 "\n", "fn_fmls(fn) &lt;- value\n", "\n", "fn_fmls_names(fn) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                 "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_fmls()"), " returns a named list of formal arguments.\n", 
#&gt;                 list("fn_fmls_names()"), " returns the names of the arguments.\n", 
#&gt;                 list("fn_fmls_syms()"), " returns formals as a named list of symbols. This\n", 
#&gt;                 "is especially useful for forwarding arguments in ", 
#&gt;                 list("constructed calls"), ".\n"), "\n", list(
#&gt;                 "\n", "Unlike ", list("formals()"), ", these helpers throw an error with primitive\n", 
#&gt;                 "functions instead of returning ", list("NULL"), 
#&gt;                 ".\n"), "\n", list("\n", "# Extract from current call:\n", 
#&gt;                 "fn &lt;- function(a = 1, b = 2) fn_fmls()\n", "fn()\n", 
#&gt;                 "\n", "# fn_fmls_syms() makes it easy to forward arguments:\n", 
#&gt;                 "call2(\"apply\", !!! fn_fmls_syms(lapply))\n", 
#&gt;                 "\n", "# You can also change the formals:\n", 
#&gt;                 "fn_fmls(fn) &lt;- list(A = 10, B = 20)\n", "fn()\n", 
#&gt;                 "\n", "fn_fmls_names(fn) &lt;- c(\"foo\", \"bar\")\n", 
#&gt;                 "fn()\n"), "\n", list("\n", list(list("call_args()")), 
#&gt;                 " and ", list(list("call_args_names()")), "\n"), 
#&gt;             "\n"), frame_position.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("frame_position"), "\n", list("frame_position"), 
#&gt;             "\n", list("Find the position or distance of a frame on the evaluation stack"), 
#&gt;             "\n", list("\n", "frame_position(frame, from = c(\"global\", \"current\"))\n"), 
#&gt;             "\n", list("\n", list(list("frame"), list("The environment of a frame. Can be any object with a\n", 
#&gt;                 list(list("get_env()")), " method. Note that for frame objects, the position from\n", 
#&gt;                 "the global frame is simply ", list("frame$pos"), 
#&gt;                 ". Alternatively, ", list("frame"), "\n", "can be an integer that represents the position on the stack (and\n", 
#&gt;                 "is thus returned as is if ", list("from"), " is \"global\".")), 
#&gt;                 "\n", "\n", list(list("from"), list("Whether to compute distance from the global frame (the\n", 
#&gt;                   "bottom of the evaluation stack), or from the current frame (the\n", 
#&gt;                   "top of the evaluation stack).")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "The frame position on the stack can be computed by counting frames\n", 
#&gt;                 "from the global frame (the bottom of the stack, the default) or\n", 
#&gt;                 "from the current frame (the top of the stack).\n"), 
#&gt;             "\n", list("\n", "While this function returns the position of the frame on the\n", 
#&gt;                 "evaluation stack, it can safely be called with intervening frames\n", 
#&gt;                 "as those will be discarded.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are deprecated and replaced by ", 
#&gt;                   list(list("trace_back()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) frame_position(env)\n", "\n", 
#&gt;                 "# frame_position() returns the position of the frame on the evaluation stack:\n", 
#&gt;                 "fn()\n", "identity(identity(fn()))\n", "\n", 
#&gt;                 "# Note that it trims off intervening calls before counting so you\n", 
#&gt;                 "# can safely nest it within other calls:\n", 
#&gt;                 "g &lt;- function(env) identity(identity(frame_position(env)))\n", 
#&gt;                 "fn()\n", "\n", "# You can also ask for the position from the current frame rather\n", 
#&gt;                 "# than the global frame:\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) frame_position(env, from = \"current\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), friendly_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("friendly_type"), "\n", list("friendly_type"), 
#&gt;             "\n", list("Format a type for error messages"), "\n", 
#&gt;             list("\n", "friendly_type(type)\n"), "\n", list("\n", 
#&gt;                 list(list("type"), list("A type as returned by ", 
#&gt;                   list(list("typeof()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "A string of the prettified type, qualified with an\n", 
#&gt;                 "indefinite article.\n"), "\n", list("\n", "Format a type for error messages\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("friendly_type()"), " is experimental.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "friendly_type(\"logical\")\n", 
#&gt;                 "friendly_type(\"integer\")\n", "friendly_type(\"string\")\n"), 
#&gt;             "\n", list("internal"), "\n"), get_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "get_env"), "\n", list("get_env"), "\n", list(
#&gt;                 "set_env"), "\n", list("env_poke_parent"), "\n", 
#&gt;             list("Get or set the environment of an object"), 
#&gt;             "\n", list("\n", "get_env(env, default = NULL)\n", 
#&gt;                 "\n", "set_env(env, new_env = caller_env())\n", 
#&gt;                 "\n", "env_poke_parent(env, new_env)\n"), "\n", 
#&gt;             list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The default environment in case ", 
#&gt;                   list("env"), " does not wrap\n", "an environment. If ", 
#&gt;                   list("NULL"), " and no environment could be extracted,\n", 
#&gt;                   "an error is issued.")), "\n", "\n", list(list(
#&gt;                   "new_env"), list("An environment to replace ", 
#&gt;                   list("env"), " with.")), "\n"), "\n", list(
#&gt;                 "\n", "These functions dispatch internally with methods for functions,\n", 
#&gt;                 "formulas and frames. If called with a missing argument, the\n", 
#&gt;                 "environment of the current evaluation frame (see ", 
#&gt;                 list(list("ctxt_stack()")), ") is\n", "returned. If you call ", 
#&gt;                 list("get_env()"), " with an environment, it acts as\n", 
#&gt;                 "the identity function and the environment is simply returned (this\n", 
#&gt;                 "helps simplifying code when writing generic functions for\n", 
#&gt;                 "environments).\n"), "\n", list("\n", "While ", 
#&gt;                 list("set_env()"), " returns a modified copy and does not have side\n", 
#&gt;                 "effects, ", list("env_poke_parent()"), " operates changes the environment by\n", 
#&gt;                 "side effect. This is because environments are\n", 
#&gt;                 list("uncopyable"), ". Be careful not to change environments\n", 
#&gt;                 "that you don't own, e.g. a parent environment of a function from a\n", 
#&gt;                 "package.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Using ", 
#&gt;                   list("get_env()"), " without supplying ", list(
#&gt;                     "env"), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                   list(list("current_env()")), " to retrieve the\n", 
#&gt;                   "current environment.\n", list(), " Passing environment wrappers like formulas or functions instead\n", 
#&gt;                   "of bare environments is deprecated as of rlang 0.3.0. This\n", 
#&gt;                   "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                   "should now extract the environment separately before calling\n", 
#&gt;                   "these functions.\n"), "\n")), "\n", "\n", 
#&gt;             list("\n", "# Environment of closure functions:\n", 
#&gt;                 "fn &lt;- function() \"foo\"\n", "get_env(fn)\n", 
#&gt;                 "\n", "# Or of quosures or formulas:\n", "get_env(~foo)\n", 
#&gt;                 "get_env(quo(foo))\n", "\n", "\n", "# Provide a default in case the object doesn't bundle an environment.\n", 
#&gt;                 "# Let's create an unevaluated formula:\n", "f &lt;- quote(~foo)\n", 
#&gt;                 "\n", "# The following line would fail if run because unevaluated formulas\n", 
#&gt;                 "# don't bundle an environment (they didn't have the chance to\n", 
#&gt;                 "# record one yet):\n", "# get_env(f)\n", "\n", 
#&gt;                 "# It is often useful to provide a default when you're writing\n", 
#&gt;                 "# functions accepting formulas as input:\n", 
#&gt;                 "default &lt;- env()\n", "identical(get_env(f, default), default)\n", 
#&gt;                 "\n", "# set_env() can be used to set the enclosure of functions and\n", 
#&gt;                 "# formulas. Let's create a function with a particular environment:\n", 
#&gt;                 "env &lt;- child_env(\"base\")\n", "fn &lt;- set_env(function() NULL, env)\n", 
#&gt;                 "\n", "# That function now has `env` as enclosure:\n", 
#&gt;                 "identical(get_env(fn), env)\n", "identical(get_env(fn), current_env())\n", 
#&gt;                 "\n", "# set_env() does not work by side effect. Setting a new environment\n", 
#&gt;                 "# for fn has no effect on the original function:\n", 
#&gt;                 "other_env &lt;- child_env(NULL)\n", "set_env(fn, other_env)\n", 
#&gt;                 "identical(get_env(fn), other_env)\n", "\n", 
#&gt;                 "# Since set_env() returns a new function with a different\n", 
#&gt;                 "# environment, you'll need to reassign the result:\n", 
#&gt;                 "fn &lt;- set_env(fn, other_env)\n", "identical(get_env(fn), other_env)\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_env()")), " and ", 
#&gt;                 list(list("quo_set_env()")), " for versions of\n", 
#&gt;                 list(list("get_env()")), " and ", list(list("set_env()")), 
#&gt;                 " that only work on quosures.\n"), "\n"), has_length.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/attr.R", "\n", 
#&gt;             list("has_length"), "\n", list("has_length"), "\n", 
#&gt;             list("How long is an object?"), "\n", list("\n", 
#&gt;                 "has_length(x, n = NULL)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("A R object.")), "\n", "\n", 
#&gt;                 list(list("n"), list("A specific length to test ", 
#&gt;                   list("x"), " with. If ", list("NULL"), ",\n", 
#&gt;                   list("has_length()"), " returns ", list("TRUE"), 
#&gt;                   " if ", list("x"), " has length greater than\n", 
#&gt;                   "zero, and ", list("FALSE"), " otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a function for the common task of testing the length of an\n", 
#&gt;                 "object. It checks the length of an object in a non-generic way:\n", 
#&gt;                 list(list("base::length()")), " methods are ignored.\n"), 
#&gt;             "\n", list("\n", "has_length(list())\n", "has_length(list(), 0)\n", 
#&gt;                 "\n", "has_length(letters)\n", "has_length(letters, 20)\n", 
#&gt;                 "has_length(letters, 26)\n"), "\n", list("internal"), 
#&gt;             "\n"), has_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("has_name"), "\n", list("has_name"), "\n", 
#&gt;             list("Does an object have an element with this name?"), 
#&gt;             "\n", list("\n", "has_name(x, name)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A data frame or another named object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Element name(s) to check")), 
#&gt;                 "\n"), "\n", list("\n", "A logical vector of the same length as ", 
#&gt;                 list("name"), "\n"), "\n", list("\n", "This function returns a logical value that indicates if a data\n", 
#&gt;                 "frame or another named object contains an element with a specific\n", 
#&gt;                 "name. Note that ", list("has_name()"), " only works with vectors. For instance,\n", 
#&gt;                 "environments need the specialised function ", 
#&gt;                 list(list("env_has()")), ".\n"), "\n", list("\n", 
#&gt;                 "Unnamed objects are treated as if all names are empty strings. ", 
#&gt;                 list("NA"), "\n", "input gives ", list("FALSE"), 
#&gt;                 " as output.\n"), "\n", list("\n", "has_name(iris, \"Species\")\n", 
#&gt;                 "has_name(mtcars, \"gears\")\n"), "\n"), inherits_any.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "inherits_any"), "\n", list("inherits_any"), 
#&gt;             "\n", list("inherits_all"), "\n", list("inherits_only"), 
#&gt;             "\n", list("Does an object inherit from a set of classes?"), 
#&gt;             "\n", list("\n", "inherits_any(x, class)\n", "\n", 
#&gt;                 "inherits_all(x, class)\n", "\n", "inherits_only(x, class)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test for inheritance.")), 
#&gt;                 "\n", "\n", list(list("class"), list("A character vector of classes.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " ", 
#&gt;                 list("inherits_any()"), " is like ", list(list(
#&gt;                   "base::inherits()")), " but is more explicit\n", 
#&gt;                 "about its behaviour with multiple classes. If ", 
#&gt;                 list("classes"), " contains\n", "several elements and the object inherits from at least one of\n", 
#&gt;                 "them, ", list("inherits_any()"), " returns ", 
#&gt;                 list("TRUE"), ".\n", list(), " ", list("inherits_all()"), 
#&gt;                 " tests that an object inherits from all of the\n", 
#&gt;                 "classes in the supplied order. This is usually the best way to\n", 
#&gt;                 "test for inheritance of multiple classes.\n", 
#&gt;                 list(), " ", list("inherits_only()"), " tests that the class vectors are identical. It\n", 
#&gt;                 "is a shortcut for ", list("identical(class(x), class)"), 
#&gt;                 ".\n"), "\n"), "\n", list("\n", "obj &lt;- structure(list(), class = c(\"foo\", \"bar\", \"baz\"))\n", 
#&gt;                 "\n", "# With the _any variant only one class must match:\n", 
#&gt;                 "inherits_any(obj, c(\"foobar\", \"bazbaz\"))\n", 
#&gt;                 "inherits_any(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "\n", "# With the _all variant all classes must match:\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"baz\"))\n", "\n", 
#&gt;                 "# The order of classes must match as well:\n", 
#&gt;                 "inherits_all(obj, c(\"baz\", \"foo\"))\n", "\n", 
#&gt;                 "# inherits_only() checks that the class vectors are identical:\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"baz\"))\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"bar\", \"baz\"))\n"), 
#&gt;             "\n"), invoke.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("invoke"), "\n", list("invoke"), "\n", 
#&gt;             list("Invoke a function with a list of arguments"), 
#&gt;             "\n", list("\n", "invoke(.fn, .args = list(), ..., .env = caller_env(),\n", 
#&gt;                 "  .bury = c(\".fn\", \"\"))\n"), "\n", list(
#&gt;                 "\n", list(list(".fn"), list("A function to invoke. Can be a function object or the\n", 
#&gt;                   "name of a function in scope of ", list(".env"), 
#&gt;                   ".")), "\n", "\n", list(list(".args, ..."), 
#&gt;                   list("List of arguments (possibly named) to be passed to\n", 
#&gt;                     list(".fn"), ".")), "\n", "\n", list(list(
#&gt;                   ".env"), list("The environment in which to call ", 
#&gt;                   list(".fn"), ".")), "\n", "\n", list(list(".bury"), 
#&gt;                   list("A character vector of length 2. The first string\n", 
#&gt;                     "specifies which name should the function have in the call\n", 
#&gt;                     "recorded in the evaluation stack. The second string specifies a\n", 
#&gt;                     "prefix for the argument names. Set ", list(
#&gt;                       ".bury"), " to ", list("NULL"), " if you\n", 
#&gt;                     "prefer to inline the function and its arguments in the call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "Normally, you invoke a R function by typing arguments manually. A\n", 
#&gt;                 "powerful alternative is to call a function with a list of arguments\n", 
#&gt;                 "assembled programmatically. This is the purpose of ", 
#&gt;                 list("invoke()"), ".\n"), "\n", list("\n", "Technically, ", 
#&gt;                 list("invoke()"), " is basically a version of ", 
#&gt;                 list(list("base::do.call()")), "\n", "that creates cleaner call traces because it does not inline the\n", 
#&gt;                 "function and the arguments in the call (see examples). To achieve\n", 
#&gt;                 "this, ", list("invoke()"), " creates a child environment of ", 
#&gt;                 list(".env"), " with ", list(".fn"), "\n", "and all arguments bound to new symbols (see ", 
#&gt;                 list(list("env_bury()")), "). It then\n", "uses the same strategy as ", 
#&gt;                 list(list("eval_bare()")), " to evaluate with minimal\n", 
#&gt;                 "noise.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", list("invoke()"), " is soft-deprecated in favour of ", 
#&gt;                 list(list("exec()")), ". Now that we\n", "understand better the interaction between unquoting and dots\n", 
#&gt;                 "capture, we can take a simpler approach in ", 
#&gt;                 list("exec()"), ".\n", "\n", "If you need finer control over the generated call, you should construct\n", 
#&gt;                 "an environment and call yourself, manually burying large objects\n", 
#&gt;                 "or complex expressions.\n")), "\n", "\n", list(
#&gt;                 "\n", "# invoke() has the same purpose as do.call():\n", 
#&gt;                 "invoke(paste, letters)\n", "\n", "# But it creates much cleaner calls:\n", 
#&gt;                 "invoke(call_inspect, mtcars)\n", "\n", "# and stacktraces:\n", 
#&gt;                 "fn &lt;- function(...) sys.calls()\n", "invoke(fn, list(mtcars))\n", 
#&gt;                 "\n", "# Compare to do.call():\n", "do.call(call_inspect, mtcars)\n", 
#&gt;                 "do.call(fn, list(mtcars))\n", "\n", "\n", "# Specify the function name either by supplying a string\n", 
#&gt;                 "# identifying the function (it should be visible in .env):\n", 
#&gt;                 "invoke(\"call_inspect\", letters)\n", "\n", 
#&gt;                 "# Or by changing the .bury argument, with which you can also change\n", 
#&gt;                 "# the argument prefix:\n", "invoke(call_inspect, mtcars, .bury = c(\"inspect!\", \"col\"))\n"), 
#&gt;             "\n", list("internal"), "\n"), is_call.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("is_call"), "\n", list("is_call"), "\n", list(
#&gt;                 "Is object a call?"), "\n", list("\n", "is_call(x, name = NULL, n = NULL, ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                 "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                 list("An optional name that the call should match. It is\n", 
#&gt;                   "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                   "and you can supply a vector of names to match. In this case,\n", 
#&gt;                   list("is_call()"), " returns ", list("TRUE"), 
#&gt;                   " if at least one name matches.")), "\n", "\n", 
#&gt;                 list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This function tests if ", 
#&gt;                 list("x"), " is a ", list("call"), ". This is a\n", 
#&gt;                 "pattern-matching predicate that returns ", list(
#&gt;                   "FALSE"), " if ", list("name"), " and ", list(
#&gt;                   "n"), "\n", "are supplied and the call does not match these properties.\n", 
#&gt;                 list("is_unary_call()"), " and ", list("is_binary_call()"), 
#&gt;                 " hardcode ", list("n"), " to 1 and 2.\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                 "is_lang()"), " has been soft-deprecated and renamed to ", 
#&gt;                 list("is_call()"), " in\n", "rlang 0.2.0 and similarly for ", 
#&gt;                 list("is_unary_lang()"), " and\n", list("is_binary_lang()"), 
#&gt;                 ". This renaming follows the general switch from\n", 
#&gt;                 "\"language\" to \"call\" in the rlang type nomenclature. See lifecycle\n", 
#&gt;                 "section in ", list(list("call2()")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "is_call(quote(foo(bar)))\n", 
#&gt;                 "\n", "# You can pattern-match the call with additional arguments:\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\")\n", "is_call(quote(foo(bar)), \"bar\")\n", 
#&gt;                 "is_call(quote(foo(bar)), quote(foo))\n", "\n", 
#&gt;                 "# Match the number of arguments with is_call():\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\", 1)\n", "is_call(quote(foo(bar)), \"foo\", 2)\n", 
#&gt;                 "\n", "\n", "# By default, namespaced calls are tested unqualified:\n", 
#&gt;                 "ns_expr &lt;- quote(base::list())\n", "is_call(ns_expr, \"list\")\n", 
#&gt;                 "\n", "# You can also specify whether the call shouldn't be namespaced by\n", 
#&gt;                 "# supplying an empty string:\n", "is_call(ns_expr, \"list\", ns = \"\")\n", 
#&gt;                 "\n", "# Or if it should have a namespace:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"utils\")\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"base\")\n", 
#&gt;                 "\n", "# You can supply multiple namespaces:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"base\"))\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"stats\"))\n", 
#&gt;                 "\n", "# If one of them is \"\", unnamespaced calls will match as well:\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = \"base\")\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "is_call(quote(base::list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "\n", "\n", "# The name argument is vectorised so you can supply a list of names\n", 
#&gt;                 "# to match with:\n", "is_call(quote(foo(bar)), c(\"bar\", \"baz\"))\n", 
#&gt;                 "is_call(quote(foo(bar)), c(\"bar\", \"foo\"))\n", 
#&gt;                 "is_call(quote(base::list), c(\"::\", \":::\", \"$\", \"@\"))\n"), 
#&gt;             "\n", list("\n", list(list("is_expression()")), "\n"), 
#&gt;             "\n"), is_callable.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("is_callable"), "\n", list("is_callable"), 
#&gt;             "\n", list("Is an object callable?"), "\n", list(
#&gt;                 "\n", "is_callable(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", "A callable object is an object that can appear in the function\n", 
#&gt;                 "position of a call (as opposed to argument position). This includes\n", 
#&gt;                 list("symbolic objects"), " that evaluate to a function or\n", 
#&gt;                 "literal functions embedded in the call.\n"), 
#&gt;             "\n", list("\n", "Note that strings may look like callable objects because\n", 
#&gt;                 "expressions of the form ", list("\"list\"()"), 
#&gt;                 " are valid R code. However,\n", "that's only because the R parser transforms strings to symbols. It\n", 
#&gt;                 "is not legal to manually set language heads to strings.\n"), 
#&gt;             "\n", list("\n", "# Symbolic objects and functions are callable:\n", 
#&gt;                 "is_callable(quote(foo))\n", "is_callable(base::identity)\n", 
#&gt;                 "\n", "# node_poke_car() lets you modify calls without any checking:\n", 
#&gt;                 "lang &lt;- quote(foo(10))\n", "node_poke_car(lang, current_env())\n", 
#&gt;                 "\n", "# Use is_callable() to check an input object is safe to put as CAR:\n", 
#&gt;                 "obj &lt;- base::identity\n", "\n", "if (is_callable(obj)) {\n", 
#&gt;                 "  lang &lt;- node_poke_car(lang, obj)\n", "} else {\n", 
#&gt;                 "  abort(\"`obj` must be callable\")\n", "}\n", 
#&gt;                 "\n", "eval_bare(lang)\n"), "\n", list("internal"), 
#&gt;             "\n"), is_condition.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("is_condition"), "\n", list("is_condition"), 
#&gt;             "\n", list("Is object a condition?"), "\n", list(
#&gt;                 "\n", "is_condition(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is object a condition?\n"), 
#&gt;             "\n", list("internal"), "\n"), is_copyable.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_copyable"), "\n", list("is_copyable"), "\n", 
#&gt;             list("Is an object copyable?"), "\n", list("\n", 
#&gt;                 "is_copyable(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "When an object is modified, R generally copies it (sometimes\n", 
#&gt;                 "lazily) to enforce ", list(list("https://en.wikipedia.org/wiki/Value_semantics"), 
#&gt;                   list("value semantics")), ".\n", "However, some internal types are uncopyable. If you try to copy\n", 
#&gt;                 "them, either with ", list("&lt;-"), " or by argument passing, you actually create\n", 
#&gt;                 "references to the original object rather than actual\n", 
#&gt;                 "copies. Modifying these references can thus have far reaching side\n", 
#&gt;                 "effects.\n"), "\n", list("\n", "# Let's add attributes with structure() to uncopyable types. Since\n", 
#&gt;                 "# they are not copied, the attributes are changed in place:\n", 
#&gt;                 "env &lt;- env()\n", "structure(env, foo = \"bar\")\n", 
#&gt;                 "env\n", "\n", "# These objects that can only be changed with side effect are not\n", 
#&gt;                 "# copyable:\n", "is_copyable(env)\n", "\n", 
#&gt;                 "structure(base::list, foo = \"bar\")\n", "str(base::list)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_empty.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_empty"), "\n", list("is_empty"), "\n", list(
#&gt;                 "Is object an empty vector or NULL?"), "\n", 
#&gt;             list("\n", "is_empty(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("object to test")), "\n"), "\n", 
#&gt;             list("\n", "Is object an empty vector or NULL?\n"), 
#&gt;             "\n", list("\n", "is_empty(NULL)\n", "is_empty(list())\n", 
#&gt;                 "is_empty(list(NULL))\n"), "\n"), is_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_env"), "\n", list("is_env"), "\n", 
#&gt;             list("is_bare_env"), "\n", list("Is an object an environment?"), 
#&gt;             "\n", list("\n", "is_env(x)\n", "\n", "is_bare_env(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("is_environment()")), "\n", "and ", 
#&gt;                 list(list("is_bare_environment()")), " in rlang 0.2.0. This is for consistency\n", 
#&gt;                 "with other type predicates which are not abbreviated.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_environment"), "\n", list("is_environment"), 
#&gt;             "\n", list("is_bare_environment"), "\n", list("Is object an environment?"), 
#&gt;             "\n", list("\n", "is_environment(x)\n", "\n", "is_bare_environment(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("is_bare_environment()"), 
#&gt;                 " tests whether ", list("x"), " is an environment without a s3 or\n", 
#&gt;                 "s4 class.\n"), "\n"), is_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_expr"), "\n", list("is_expr"), "\n", 
#&gt;             list("Is an object an expression?"), "\n", list("\n", 
#&gt;                 "is_expr(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to test.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "This function was deprecated and renamed to ", 
#&gt;                 list(list("is_expression()")), " in\n", "rlang 0.2.0. This is for consistency with other type predicates\n", 
#&gt;                 "which are not abbreviated.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_expression.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("is_expression"), "\n", list("is_expression"), 
#&gt;             "\n", list("is_syntactic_literal"), "\n", list("is_symbolic"), 
#&gt;             "\n", list("Is an object an expression?"), "\n", 
#&gt;             list("\n", "is_expression(x)\n", "\n", "is_syntactic_literal(x)\n", 
#&gt;                 "\n", "is_symbolic(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_expression()"), " tests for expressions, the set of objects that can be\n", 
#&gt;                 "obtained from parsing R code. An expression can be one of two\n", 
#&gt;                 "things: either a symbolic object (for which ", 
#&gt;                 list("is_symbolic()"), " returns\n", list("TRUE"), 
#&gt;                 "), or a syntactic literal (testable with\n", 
#&gt;                 list("is_syntactic_literal()"), "). Technically, calls can contain any R\n", 
#&gt;                 "object, not necessarily symbolic objects or syntactic\n", 
#&gt;                 "literals. However, this only happens in artificial\n", 
#&gt;                 "situations. Expressions as we define them only contain numbers,\n", 
#&gt;                 "strings, ", list("NULL"), ", symbols, and calls: this is the complete set of R\n", 
#&gt;                 "objects that can be created when R parses source code (e.g. from\n", 
#&gt;                 "using ", list(list("parse_expr()")), ").\n", 
#&gt;                 "\n", "Note that we are using the term expression in its colloquial sense\n", 
#&gt;                 "and not to refer to ", list(list("expression()")), 
#&gt;                 " vectors, a data type that wraps\n", "expressions in a vector and which isn't used much in modern R code.\n"), 
#&gt;             "\n", list("\n", list("is_symbolic()"), " returns ", 
#&gt;                 list("TRUE"), " for symbols and calls (objects with\n", 
#&gt;                 "type ", list("language"), "). Symbolic objects are replaced by their value\n", 
#&gt;                 "during evaluation. Literals are the complement of symbolic\n", 
#&gt;                 "objects. They are their own value and return themselves during\n", 
#&gt;                 "evaluation.\n", "\n", list("is_syntactic_literal()"), 
#&gt;                 " is a predicate that returns ", list("TRUE"), 
#&gt;                 " for the\n", "subset of literals that are created by R when parsing text (see\n", 
#&gt;                 list(list("parse_expr()")), "): numbers, strings and ", 
#&gt;                 list("NULL"), ". Along with symbols,\n", "these literals are the terminating nodes in an AST.\n", 
#&gt;                 "\n", "Note that in the most general sense, a literal is any R object that\n", 
#&gt;                 "evaluates to itself and that can be evaluated in the empty\n", 
#&gt;                 "environment. For instance, ", list("quote(c(1, 2))"), 
#&gt;                 " is not a literal, it is\n", "a call. However, the result of evaluating it in ", 
#&gt;                 list(list("base_env()")), " is a\n", "literal(in this case an atomic vector).\n", 
#&gt;                 "\n", "Pairlists are also a kind of language objects. However, since they\n", 
#&gt;                 "are mostly an internal data structure, ", list(
#&gt;                   "is_expression()"), " returns ", list("FALSE"), 
#&gt;                 "\n", "for pairlists. You can use ", list("is_pairlist()"), 
#&gt;                 " to explicitly check for\n", "them. Pairlists are the data structure for function arguments. They\n", 
#&gt;                 "usually do not arise from R code because subsetting a call is a\n", 
#&gt;                 "type-preserving operation. However, you can obtain the pairlist of\n", 
#&gt;                 "arguments by taking the CDR of the call object from C code. The\n", 
#&gt;                 "rlang function ", list(list("node_cdr()")), 
#&gt;                 " will do it from R. Another way in\n", "which pairlist of arguments arise is by extracting the argument\n", 
#&gt;                 "list of a closure with ", list(list("base::formals()")), 
#&gt;                 " or ", list(list("fn_fmls()")), ".\n"), "\n", 
#&gt;             list("\n", "q1 &lt;- quote(1)\n", "is_expression(q1)\n", 
#&gt;                 "is_syntactic_literal(q1)\n", "\n", "q2 &lt;- quote(x)\n", 
#&gt;                 "is_expression(q2)\n", "is_symbol(q2)\n", "\n", 
#&gt;                 "q3 &lt;- quote(x + 1)\n", "is_expression(q3)\n", 
#&gt;                 "is_call(q3)\n", "\n", "\n", "# Atomic expressions are the terminating nodes of a call tree:\n", 
#&gt;                 "# NULL or a scalar atomic vector:\n", "is_syntactic_literal(\"string\")\n", 
#&gt;                 "is_syntactic_literal(NULL)\n", "\n", "is_syntactic_literal(letters)\n", 
#&gt;                 "is_syntactic_literal(quote(call()))\n", "\n", 
#&gt;                 "# Parsable literals have the property of being self-quoting:\n", 
#&gt;                 "identical(\"foo\", quote(\"foo\"))\n", "identical(1L, quote(1L))\n", 
#&gt;                 "identical(NULL, quote(NULL))\n", "\n", "# Like any literals, they can be evaluated within the empty\n", 
#&gt;                 "# environment:\n", "eval_bare(quote(1L), empty_env())\n", 
#&gt;                 "\n", "# Whereas it would fail for symbolic expressions:\n", 
#&gt;                 "# eval_bare(quote(c(1L, 2L)), empty_env())\n", 
#&gt;                 "\n", "\n", "# Pairlists are also language objects representing argument lists.\n", 
#&gt;                 "# You will usually encounter them with extracted formals:\n", 
#&gt;                 "fmls &lt;- formals(is_expression)\n", "typeof(fmls)\n", 
#&gt;                 "\n", "# Since they are mostly an internal data structure, is_expression()\n", 
#&gt;                 "# returns FALSE for pairlists, so you will have to check explicitly\n", 
#&gt;                 "# for them:\n", "is_expression(fmls)\n", "is_pairlist(fmls)\n"), 
#&gt;             "\n", list("\n", list(list("is_call()")), " for a call predicate.\n"), 
#&gt;             "\n"), is_formula.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("is_formula"), "\n", list("is_formula"), 
#&gt;             "\n", list("is_bare_formula"), "\n", list("Is object a formula?"), 
#&gt;             "\n", list("\n", "is_formula(x, scoped = NULL, lhs = NULL)\n", 
#&gt;                 "\n", "is_bare_formula(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("scoped"), list("A boolean indicating whether the quosure is scoped,\n", 
#&gt;                   "that is, has a valid environment attribute. If ", 
#&gt;                   list("NULL"), ", the scope\n", "is not inspected.")), 
#&gt;                 "\n", "\n", list(list("lhs"), list("A boolean indicating whether the ", 
#&gt;                   list("formula"), "\n", "or ", list("definition"), 
#&gt;                   " has a left-hand side. If ", list("NULL"), 
#&gt;                   ",\n", "the LHS is not inspected.")), "\n"), 
#&gt;             "\n", list("\n", list("is_formula()"), " tests if ", 
#&gt;                 list("x"), " is a call to ", list("~"), ". ", 
#&gt;                 list("is_bare_formula()"), "\n", "tests in addition that ", 
#&gt;                 list("x"), " does not inherit from anything else than\n", 
#&gt;                 list("\"formula\""), ".\n"), "\n", list("\n", 
#&gt;                 "The ", list("scoped"), " argument patterns-match on whether the scoped bundled\n", 
#&gt;                 "with the quosure is valid or not. Invalid scopes may happen in\n", 
#&gt;                 "nested quotations like ", list("~~expr"), ", where the outer quosure is validly\n", 
#&gt;                 "scoped but not the inner one. This is because ", 
#&gt;                 list("~"), " saves the\n", "environment when it is evaluated, and quoted formulas are by\n", 
#&gt;                 "definition not evaluated.\n"), "\n", list("\n", 
#&gt;                 "x &lt;- disp ~ am\n", "is_formula(x)\n", "\n", 
#&gt;                 "is_formula(~10)\n", "is_formula(10)\n", "\n", 
#&gt;                 "is_formula(quo(foo))\n", "is_bare_formula(quo(foo))\n", 
#&gt;                 "\n", "# Note that unevaluated formulas are treated as bare formulas even\n", 
#&gt;                 "# though they don't inherit from \"formula\":\n", 
#&gt;                 "f &lt;- quote(~foo)\n", "is_bare_formula(f)\n", 
#&gt;                 "\n", "# However you can specify `scoped` if you need the predicate to\n", 
#&gt;                 "# return FALSE for these unevaluated formulas:\n", 
#&gt;                 "is_bare_formula(f, scoped = TRUE)\n", "is_bare_formula(eval(f), scoped = TRUE)\n"), 
#&gt;             "\n"), is_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_frame"), "\n", list("is_frame"), "\n", 
#&gt;             list("Is object a frame?"), "\n", list("\n", "is_frame(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "is_function"), "\n", list("is_function"), "\n", 
#&gt;             list("is_closure"), "\n", list("is_primitive"), "\n", 
#&gt;             list("is_primitive_eager"), "\n", list("is_primitive_lazy"), 
#&gt;             "\n", list("Is object a function?"), "\n", list("\n", 
#&gt;                 "is_function(x)\n", "\n", "is_closure(x)\n", 
#&gt;                 "\n", "is_primitive(x)\n", "\n", "is_primitive_eager(x)\n", 
#&gt;                 "\n", "is_primitive_lazy(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n"), "\n", list("\n", "The R language defines two different types of functions: primitive\n", 
#&gt;                 "functions, which are low-level, and closures, which are the regular\n", 
#&gt;                 "kind of functions.\n"), "\n", list("\n", "Closures are functions written in R, named after the way their\n", 
#&gt;                 "arguments are scoped within nested environments (see\n", 
#&gt;                 "https://en.wikipedia.org/wiki/Closure_(computer_programming)). The\n", 
#&gt;                 "root environment of the closure is called the closure\n", 
#&gt;                 "environment. When closures are evaluated, a new environment called\n", 
#&gt;                 "the evaluation frame is created with the closure environment as\n", 
#&gt;                 "parent. This is where the body of the closure is evaluated. These\n", 
#&gt;                 "closure frames appear on the evaluation stack (see ", 
#&gt;                 list(list("ctxt_stack()")), "),\n", "as opposed to primitive functions which do not necessarily have\n", 
#&gt;                 "their own evaluation frame and never appear on the stack.\n", 
#&gt;                 "\n", "Primitive functions are more efficient than closures for two\n", 
#&gt;                 "reasons. First, they are written entirely in fast low-level\n", 
#&gt;                 "code. Second, the mechanism by which they are passed arguments is\n", 
#&gt;                 "more efficient because they often do not need the full procedure of\n", 
#&gt;                 "argument matching (dealing with positional versus named arguments,\n", 
#&gt;                 "partial matching, etc). One practical consequence of the special\n", 
#&gt;                 "way in which primitives are passed arguments is that they\n", 
#&gt;                 "technically do not have formal arguments, and ", 
#&gt;                 list(list("formals()")), " will\n", "return ", 
#&gt;                 list("NULL"), " if called on a primitive function. Finally, primitive\n", 
#&gt;                 "functions can either take arguments lazily, like R closures do,\n", 
#&gt;                 "or evaluate them eagerly before being passed on to the C code.\n", 
#&gt;                 "The former kind of primitives are called \"special\" in R terminology,\n", 
#&gt;                 "while the latter is referred to as \"builtin\". ", 
#&gt;                 list("is_primitive_eager()"), "\n", "and ", list(
#&gt;                   "is_primitive_lazy()"), " allow you to check whether a primitive\n", 
#&gt;                 "function evaluates arguments eagerly or lazily.\n", 
#&gt;                 "\n", "You will also encounter the distinction between primitive and\n", 
#&gt;                 "internal functions in technical documentation. Like primitive\n", 
#&gt;                 "functions, internal functions are defined at a low level and\n", 
#&gt;                 "written in C. However, internal functions have no representation in\n", 
#&gt;                 "the R language. Instead, they are called via a call to\n", 
#&gt;                 list(list("base::.Internal()")), " within a regular closure. This ensures that\n", 
#&gt;                 "they appear as normal R function objects: they obey all the usual\n", 
#&gt;                 "rules of argument passing, and they appear on the evaluation stack\n", 
#&gt;                 "as any other closures. As a result, ", list(
#&gt;                   list("fn_fmls()")), " does not need to\n", 
#&gt;                 "look in the ", list(".ArgsEnv"), " environment to obtain a representation of\n", 
#&gt;                 "their arguments, and there is no way of querying from R whether\n", 
#&gt;                 "they are lazy ('special' in R terminology) or eager ('builtin').\n", 
#&gt;                 "\n", "You can call primitive functions with ", 
#&gt;                 list(list(".Primitive()")), " and internal\n", 
#&gt;                 "functions with ", list(list(".Internal()")), 
#&gt;                 ". However, calling internal functions\n", "in a package is forbidden by CRAN's policy because they are\n", 
#&gt;                 "considered part of the private API. They often assume that they\n", 
#&gt;                 "have been called with correctly formed arguments, and may cause R\n", 
#&gt;                 "to crash if you call them with unexpected objects.\n"), 
#&gt;             "\n", list("\n", "# Primitive functions are not closures:\n", 
#&gt;                 "is_closure(base::c)\n", "is_primitive(base::c)\n", 
#&gt;                 "\n", "# On the other hand, internal functions are wrapped in a closure\n", 
#&gt;                 "# and appear as such from the R side:\n", "is_closure(base::eval)\n", 
#&gt;                 "\n", "# Both closures and primitives are functions:\n", 
#&gt;                 "is_function(base::c)\n", "is_function(base::eval)\n", 
#&gt;                 "\n", "# Primitive functions never appear in evaluation stacks:\n", 
#&gt;                 "is_primitive(base::`[[`)\n", "is_primitive(base::list)\n", 
#&gt;                 "list(ctxt_stack())[[1]]\n", "\n", "# While closures do:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# Many primitive functions evaluate arguments eagerly:\n", 
#&gt;                 "is_primitive_eager(base::c)\n", "is_primitive_eager(base::list)\n", 
#&gt;                 "is_primitive_eager(base::`+`)\n", "\n", "# However, primitives that operate on expressions, like quote() or\n", 
#&gt;                 "# substitute(), are lazy:\n", "is_primitive_lazy(base::quote)\n", 
#&gt;                 "is_primitive_lazy(base::substitute)\n"), "\n"), 
#&gt;         is_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_installed"), "\n", list("is_installed"), 
#&gt;             "\n", list("Is a package installed in the library?"), 
#&gt;             "\n", list("\n", "is_installed(pkg)\n"), "\n", list(
#&gt;                 "\n", list(list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", list("TRUE"), " if the package is installed, ", 
#&gt;                 list("FALSE"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This checks that a package is installed with minimal side effects.\n", 
#&gt;                 "If installed, the package will be loaded but not attached.\n"), 
#&gt;             "\n", list("\n", "is_installed(\"utils\")\n", "is_installed(\"ggplot5\")\n"), 
#&gt;             "\n"), is_integerish.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/types.R", 
#&gt;             "\n", list("is_integerish"), "\n", list("is_integerish"), 
#&gt;             "\n", list("is_bare_integerish"), "\n", list("is_scalar_integerish"), 
#&gt;             "\n", list("Is a vector integer-like?"), "\n", list(
#&gt;                 "\n", "is_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_bare_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_scalar_integerish(x, finite = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check whether R considers a number vector to be\n", 
#&gt;                 "integer-like, according to its own tolerance check (which is in\n", 
#&gt;                 "fact delegated to the C library). This function is not adapted to\n", 
#&gt;                 "data analysis, see the help for ", list(list(
#&gt;                   "base::is.integer()")), " for examples\n", 
#&gt;                 "of how to check for whole numbers.\n", "\n", 
#&gt;                 "Things to consider when checking for integer-like doubles:\n", 
#&gt;                 list("\n", list(), " This check can be expensive because the whole double vector has\n", 
#&gt;                   "to be traversed and checked.\n", list(), " Large double values may be integerish but may still not be\n", 
#&gt;                   "coercible to integer. This is because integers in R only support\n", 
#&gt;                   "values up to ", list("2^31 - 1"), " while numbers stored as double can be\n", 
#&gt;                   "much larger.\n"), "\n"), "\n", list("\n", 
#&gt;                 "is_integerish(10L)\n", "is_integerish(10.0)\n", 
#&gt;                 "is_integerish(10.0, n = 2)\n", "is_integerish(10.000001)\n", 
#&gt;                 "is_integerish(TRUE)\n"), "\n", list("\n", list(
#&gt;                 list("is_bare_numeric()")), " for testing whether an object is a\n", 
#&gt;                 "base numeric type (a bare double or integer vector).\n"), 
#&gt;             "\n"), is_interactive.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/state.R", 
#&gt;             "\n", list("is_interactive"), "\n", list("is_interactive"), 
#&gt;             "\n", list("scoped_interactive"), "\n", list("with_interactive"), 
#&gt;             "\n", list("Is R running interactively?"), "\n", 
#&gt;             list("\n", "is_interactive()\n", "\n", "scoped_interactive(value = TRUE, frame = caller_env())\n", 
#&gt;                 "\n", "with_interactive(expr, value = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("value"), list("A single ", 
#&gt;                 list("TRUE"), " or ", list("FALSE"), ". This overrides the return\n", 
#&gt;                 "value of ", list("is_interactive()"), ".")), 
#&gt;                 "\n", "\n", list(list("frame"), list("The environment of a running function which defines\n", 
#&gt;                   "the scope of the temporary options. When the function returns,\n", 
#&gt;                   "the options are reset to their original values.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("An expression to evaluate with interactivity set to\n", 
#&gt;                   list("value"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "Like ", list(list("base::interactive()")), ", ", 
#&gt;                 list("is_interactive()"), " returns ", list("TRUE"), 
#&gt;                 " when\n", "the function runs interactively and ", 
#&gt;                 list("FALSE"), " when it runs in batch\n", "mode. It also checks, in this order:\n", 
#&gt;                 list("\n", list(), " The ", list("rlang_interactive"), 
#&gt;                   " global option. If set to a single ", list(
#&gt;                     "TRUE"), "\n", "or ", list("FALSE"), ", ", 
#&gt;                   list("is_interactive()"), " returns that value immediately. This\n", 
#&gt;                   "escape hatch is useful in unit tests or to manually turn on\n", 
#&gt;                   "interactive features in RMarkdown outputs.\n", 
#&gt;                   list(), " Whether knitr, an RStudio notebook, or testthat is in progress.\n"), 
#&gt;                 "\n", "\n", list("with_interactive()"), " and ", 
#&gt;                 list("scoped_interactive()"), " set the global\n", 
#&gt;                 "option conveniently.\n"), "\n"), is_lang.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_lang"), "\n", list("is_lang"), "\n", 
#&gt;             list("is_unary_lang"), "\n", list("is_binary_lang"), 
#&gt;             "\n", list("quo_is_lang"), "\n", list("Is object a call?"), 
#&gt;             "\n", list("\n", "is_lang(x, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_unary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_binary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_lang(quo)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                   "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                   list("An optional name that the call should match. It is\n", 
#&gt;                     "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                     "and you can supply a vector of names to match. In this case,\n", 
#&gt;                     list("is_call()"), " returns ", list("TRUE"), 
#&gt;                     " if at least one name matches.")), "\n", 
#&gt;                 "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("is_call()")), " and its ", list("n"), 
#&gt;                 "\n", "argument instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_named.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("is_named"), "\n", list("is_named"), "\n", 
#&gt;             list("is_dictionaryish"), "\n", list("have_name"), 
#&gt;             "\n", list("Is object named?"), "\n", list("\n", 
#&gt;                 "is_named(x)\n", "\n", "is_dictionaryish(x)\n", 
#&gt;                 "\n", "have_name(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " and ", list(
#&gt;                 "is_dictionaryish()"), " are scalar predicates\n", 
#&gt;                 "and return ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ". ", list("have_name()"), " is vectorised and\n", 
#&gt;                 "returns a logical vector as long as the input.\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " checks that ", 
#&gt;                 list("x"), " has names attributes, and that none of\n", 
#&gt;                 "the names are missing or empty (", list("NA"), 
#&gt;                 " or ", list("\"\""), "). ", list("is_dictionaryish()"), 
#&gt;                 "\n", "checks that an object is a dictionary: that it has actual names and\n", 
#&gt;                 "in addition that there are no duplicated names. ", 
#&gt;                 list("have_name()"), "\n", "is a vectorised version of ", 
#&gt;                 list("is_named()"), ".\n"), "\n", list("\n", 
#&gt;                 "# A data frame usually has valid, unique names\n", 
#&gt;                 "is_named(mtcars)\n", "have_name(mtcars)\n", 
#&gt;                 "is_dictionaryish(mtcars)\n", "\n", "# But data frames can also have duplicated columns:\n", 
#&gt;                 "dups &lt;- cbind(mtcars, cyl = seq_len(nrow(mtcars)))\n", 
#&gt;                 "is_dictionaryish(dups)\n", "\n", "# The names are still valid:\n", 
#&gt;                 "is_named(dups)\n", "have_name(dups)\n", "\n", 
#&gt;                 "\n", "# For empty objects the semantics are slightly different.\n", 
#&gt;                 "# is_dictionaryish() returns TRUE for empty objects:\n", 
#&gt;                 "is_dictionaryish(list())\n", "\n", "# But is_named() will only return TRUE if there is a names\n", 
#&gt;                 "# attribute (a zero-length character vector in this case):\n", 
#&gt;                 "x &lt;- set_names(list(), character(0))\n", "is_named(x)\n", 
#&gt;                 "\n", "\n", "# Empty and missing names are invalid:\n", 
#&gt;                 "invalid &lt;- dups\n", "names(invalid)[2] &lt;- \"\"\n", 
#&gt;                 "names(invalid)[5] &lt;- NA\n", "\n", "# is_named() performs a global check while have_name() can show you\n", 
#&gt;                 "# where the problem is:\n", "is_named(invalid)\n", 
#&gt;                 "have_name(invalid)\n", "\n", "# have_name() will work even with vectors that don't have a names\n", 
#&gt;                 "# attribute:\n", "have_name(letters)\n"), "\n"), 
#&gt;         is_namespace.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_namespace"), "\n", list("is_namespace"), 
#&gt;             "\n", list("Is an object a namespace environment?"), 
#&gt;             "\n", list("\n", "is_namespace(x)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is an object a namespace environment?\n"), 
#&gt;             "\n"), is_pairlist.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("is_pairlist"), "\n", list("is_pairlist"), 
#&gt;             "\n", list("is_node"), "\n", list("is_node_list"), 
#&gt;             "\n", list("Is object a node or pairlist?"), "\n", 
#&gt;             list("\n", "is_pairlist(x)\n", "\n", "is_node(x)\n", 
#&gt;                 "\n", "is_node_list(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("is_pairlist()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), ".\n", list(), " ", list("is_node()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), " or ", list("language"), ".\n", 
#&gt;                 "It tests whether ", list("x"), " is a node that has a CAR and a CDR,\n", 
#&gt;                 "including callable nodes (language objects).\n", 
#&gt;                 list(), " ", list("is_node_list()"), " checks that ", 
#&gt;                 list("x"), " has type ", list("pairlist"), " or ", 
#&gt;                 list("NULL"), ".\n", list("NULL"), " is the empty node list.\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are experimental. We are still figuring out a good\n", 
#&gt;                 "naming convention to refer to the different lisp-like lists in R.\n")), 
#&gt;             "\n", "\n", list("\n", list(list("is_call()")), " tests for language nodes.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_reference.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_reference"), "\n", list("is_reference"), 
#&gt;             "\n", list("Is an object referencing another?"), 
#&gt;             "\n", list("\n", "is_reference(x, y)\n"), "\n", list(
#&gt;                 "\n", list(list("x, y"), list("R objects.")), 
#&gt;                 "\n"), "\n", list("\n", "There are typically two situations where two symbols may refer to\n", 
#&gt;                 "the same object.\n", list("\n", list(), " R objects usually have copy-on-write semantics. This is an\n", 
#&gt;                   "optimisation that ensures that objects are only copied if\n", 
#&gt;                   "needed. When you copy a vector, no memory is actually copied\n", 
#&gt;                   "until you modify either the original object or the copy is\n", 
#&gt;                   "modified.\n", "\n", "Note that the copy-on-write optimisation is an implementation\n", 
#&gt;                   "detail that is not guaranteed by the specification of the R\n", 
#&gt;                   "language.\n", list(), " Assigning an ", list(
#&gt;                     "uncopyable"), " object (like an\n", "environment) creates a reference. These objects are never copied\n", 
#&gt;                   "even if you modify one of the references.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Reassigning an uncopyable object such as an environment creates a\n", 
#&gt;                 "# reference:\n", "env &lt;- env()\n", "ref &lt;- env\n", 
#&gt;                 "is_reference(ref, env)\n", "\n", "# Due to copy-on-write optimisation, a copied vector can\n", 
#&gt;                 "# temporarily reference the original vector:\n", 
#&gt;                 "vec &lt;- 1:10\n", "copy &lt;- vec\n", "is_reference(copy, vec)\n", 
#&gt;                 "\n", "# Once you modify on of them, the copy is triggered in the\n", 
#&gt;                 "# background and the objects cease to reference each other:\n", 
#&gt;                 "vec[[1]] &lt;- 100\n", "is_reference(copy, vec)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_stack.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_stack"), "\n", list("is_stack"), "\n", 
#&gt;             list("is_eval_stack"), "\n", list("is_call_stack"), 
#&gt;             "\n", list("Is object a stack?"), "\n", list("\n", 
#&gt;                 "is_stack(x)\n", "\n", "is_eval_stack(x)\n", 
#&gt;                 "\n", "is_call_stack(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_symbol.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/sym.R", "\n", list(
#&gt;                 "is_symbol"), "\n", list("is_symbol"), "\n", 
#&gt;             list("Is object a symbol?"), "\n", list("\n", "is_symbol(x, name = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An optional name or vector of names that the symbol\n", 
#&gt;                   "should match.")), "\n"), "\n", list("\n", 
#&gt;                 "Is object a symbol?\n"), "\n"), is_true.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_true"), "\n", list("is_true"), "\n", list(
#&gt;                 "is_false"), "\n", list("Is object identical to TRUE or FALSE?"), 
#&gt;             "\n", list("\n", "is_true(x)\n", "\n", "is_false(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", "These functions bypass R's automatic conversion rules and check\n", 
#&gt;                 "that ", list("x"), " is literally ", list("TRUE"), 
#&gt;                 " or ", list("FALSE"), ".\n"), "\n", list("\n", 
#&gt;                 "is_true(TRUE)\n", "is_true(1)\n", "\n", "is_false(FALSE)\n", 
#&gt;                 "is_false(0)\n"), "\n"), is_weakref.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("is_weakref"), "\n", list("is_weakref"), "\n", 
#&gt;             list("Is object a weak reference?"), "\n", list("\n", 
#&gt;                 "is_weakref(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "Is object a weak reference?\n"), "\n"), 
#&gt;         lang.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang"), "\n", list("lang"), "\n", list(
#&gt;                 "new_language"), "\n", list("Create a call"), 
#&gt;             "\n", list("\n", "lang(.fn, ..., .ns = NULL)\n", 
#&gt;                 "\n", "new_language(head, tail = NULL)\n"), "\n", 
#&gt;             list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call2()")), " and\n", list(list("new_call()")), 
#&gt;                 " instead.\n"), "\n", list("internal"), "\n"), 
#&gt;         lang_head.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_head"), "\n", list("lang_head"), 
#&gt;             "\n", list("lang_tail"), "\n", list("Return the head or tail of a call"), 
#&gt;             "\n", list("\n", "lang_head(lang)\n", "\n", "lang_tail(lang)\n"), 
#&gt;             "\n", list("\n", list(list("lang"), list("A call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.2.0 these functions are retired (deprecated for now)\n", 
#&gt;                 "because they are low level accessors that are rarely needed for end\n", 
#&gt;                 "users.\n"), "\n", list("internal"), "\n"), lang_modify.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_modify"), "\n", list("lang_modify"), 
#&gt;             "\n", list("lang_standardise"), "\n", list("lang_fn"), 
#&gt;             "\n", list("lang_name"), "\n", list("lang_args"), 
#&gt;             "\n", list("lang_args_names"), "\n", list("Manipulate or access a call"), 
#&gt;             "\n", list("\n", "lang_modify(.lang, ..., .standardise = FALSE)\n", 
#&gt;                 "\n", "lang_standardise(lang)\n", "\n", "lang_fn(lang)\n", 
#&gt;                 "\n", "lang_name(lang)\n", "\n", "lang_args(lang)\n", 
#&gt;                 "\n", "lang_args_names(lang)\n"), "\n", list(
#&gt;                 "\n", list(list("..."), list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                   list(".standardise"), list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n", "\n", list(list("lang, .lang"), 
#&gt;                   list("The ", list("call"), " or ", list(".call"), 
#&gt;                     " argument of the renamed\n", "functions.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call_modify()")), ",\n", list(list(
#&gt;                   "call_standardise()")), ", or ", list(list(
#&gt;                   "call_fn()")), " instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), last_error.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-abort.R", 
#&gt;             "\n", list("last_error"), "\n", list("last_error"), 
#&gt;             "\n", list("last_trace"), "\n", list("Last ", list(
#&gt;                 "abort()"), " error"), "\n", list("\n", "last_error()\n", 
#&gt;                 "\n", "last_trace()\n"), "\n", list("\n", list(
#&gt;                 "\n", list(), " ", list("last_error()"), " returns the last error thrown with ", 
#&gt;                 list(list("abort()")), ". The\n", "error is printed with a backtrace in simplified form.\n", 
#&gt;                 list(), " ", list("last_trace()"), " is a shortcut to return the backtrace stored in\n", 
#&gt;                 "the last error. This backtrace is printed in full form.\n"), 
#&gt;                 "\n"), "\n"), lifecycle.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle.R", 
#&gt;             "\n", list("lifecycle"), "\n", list("lifecycle"), 
#&gt;             "\n", list("Life cycle of the rlang package"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"maturing\")"), 
#&gt;                 "\n", "\n", "The rlang package is currently maturing. Unless otherwise stated,\n", 
#&gt;                 "this applies to all its exported functions. Maturing functions are\n", 
#&gt;                 "susceptible to API changes. Only use these in packages if you're\n", 
#&gt;                 "prepared to make changes as the package evolves. See sections below\n", 
#&gt;                 "for a list of functions marked as stable.\n", 
#&gt;                 "\n", "The documentation pages of retired functions contain life cycle\n", 
#&gt;                 "sections that explain the reasons for their retirements.\n"), 
#&gt;             "\n", list(list("Stable functions"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("eval_tidy()")), 
#&gt;                   "\n", list(), " ", list("!!"), ", ", list("!!!"), 
#&gt;                   "\n", list(), " ", list(list("enquo()")), ", ", 
#&gt;                   list(list("quo()")), ", ", list(list("quos()")), 
#&gt;                   "\n", list(), " ", list(list("enexpr()")), 
#&gt;                   ", ", list(list("expr()")), ", ", list(list(
#&gt;                     "exprs()")), "\n", list(), " ", list(list(
#&gt;                     "sym()")), ", ", list(list("syms()")), "\n", 
#&gt;                   list(), " ", list(list("new_quosure()")), ", ", 
#&gt;                   list(list("is_quosure()")), "\n", list(), " ", 
#&gt;                   list(list("missing_arg()")), ", ", list(list(
#&gt;                     "is_missing()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_expr()")), ", ", list(list(
#&gt;                     "quo_set_expr()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_env()")), ", ", list(list("quo_set_env()")), 
#&gt;                   "\n", list(), " ", list(list("eval_bare()")), 
#&gt;                   "\n", list(), " ", list(list("set_names()")), 
#&gt;                   ", ", list(list("names2()")), "\n", list(), 
#&gt;                   " ", list(list("as_function()")), ", ", list(
#&gt;                     list("new_function()")), "\n"), "\n")), "\n", 
#&gt;             "\n", list(list("Experimental functions"), list("\n", 
#&gt;                 "\n", "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These functions are not yet part of the rlang API. Expect breaking\n", 
#&gt;                 "changes.\n", list("\n", list(), " ", list(list(
#&gt;                   "with_env()")), ", ", list(list("locally()")), 
#&gt;                   ", ", list(list("env_poke()")), "\n", list(), 
#&gt;                   " ", list(list("pkg_env()")), ", ", list(list(
#&gt;                     "pkg_env_name()")), ", ", list(list("ns_env()")), 
#&gt;                   ", ", list(list("ns_imports_env()")), ", ", 
#&gt;                   list(list("ns_env_name()")), "\n", list(), 
#&gt;                   " ", list(list("is_pairlist()")), ", ", list(
#&gt;                     list("as_pairlist()")), ", ", list(list("is_node()")), 
#&gt;                   ", ", list(list("is_node_list()")), "\n", list(), 
#&gt;                   " ", list(list("is_definition()")), ", ", list(
#&gt;                     list("new_definition()")), ", ", list(list(
#&gt;                     "is_formulaish()")), ",\n", list(list("dots_definitions()")), 
#&gt;                   "\n", list(), " ", list(list("scoped_options()")), 
#&gt;                   ", ", list(list("with_options()")), ", ", list(
#&gt;                     list("push_options()")), ",\n", list(list(
#&gt;                     "peek_options()")), ", ", list(list("peek_option()")), 
#&gt;                   "\n", list(), " ", list(list("as_bytes()")), 
#&gt;                   ", ", list(list("chr_unserialise_unicode()")), 
#&gt;                   "\n", list(), " ", list(list("caller_fn()")), 
#&gt;                   ", ", list(list("current_fn()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Questioning stage"), list(
#&gt;                 "\n", "\n", "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("In the questioning stage as of rlang 0.4.0"), 
#&gt;                 "\n", "\n", "These functions are likely to be moved to the vctrs package:\n", 
#&gt;                 list("\n", list(), " ", list(list("lgl()")), 
#&gt;                   ", ", list(list("int()")), ", etc.\n", list(), 
#&gt;                   " ", list(list("new_logical()")), ", ", list(
#&gt;                     list("new_integer()")), ", etc.\n", list(), 
#&gt;                   " ", list("na_lgl"), ", ", list("na_int"), 
#&gt;                   ", ", list(list("is_lgl_na()")), ", ", list(
#&gt;                     list("is_int_na()")), ", etc.\n"), "\n", 
#&gt;                 "\n", list("In the questioning stage as of rlang 0.3.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("child_env()")), 
#&gt;                   "\n", list(), " ", list(list("flatten()")), 
#&gt;                   ", ", list(list("squash()")), ", and their atomic vector variants\n", 
#&gt;                   list(), " ", list(list("modify()")), " and ", 
#&gt;                   list(list("prepend()")), "\n", list(), " ", 
#&gt;                   list(list("with_restarts()")), ", ", list(list(
#&gt;                     "rst_list()")), ", ", list(list("rst_exists()")), 
#&gt;                   ", ", list(list("rst_jump()")), ",\n", list(
#&gt;                     list("rst_maybe_jump()")), ", ", list(list(
#&gt;                     "rst_abort()")), ". It is not clear yet whether we\n", 
#&gt;                   "want to recommend restarts as a style of programming in R.\n", 
#&gt;                   list(), " ", list(list("return_from()")), " and ", 
#&gt;                   list(list("return_to()")), ".\n", list(), " ", 
#&gt;                   list(list("expr_label()")), ", ", list(list(
#&gt;                     "expr_name()")), ", and ", list(list("expr_text()")), 
#&gt;                   ".\n"), "\n", "\n", list("In the questioning stage as of rlang 0.2.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("UQ()")), 
#&gt;                   ", ", list(list("UQS()")), "\n", list(), " ", 
#&gt;                   list(list("dots_splice()")), ", ", list(list(
#&gt;                     "splice()")), "\n"), "\n")), "\n", "\n", 
#&gt;             list(list("Soft-deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                   "\n", "\n", list("Soft-deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("exiting()")), 
#&gt;                     ": Handlers are now treated as exiting by default.\n", 
#&gt;                     list(), " ", list(list("invoke()")), ": Use the simpler ", 
#&gt;                     list(list("exec()")), " instead.\n", list(), 
#&gt;                     " ", list(list("as_logical()")), ", ", list(
#&gt;                       list("as_integer()")), ", etc. =&gt; ", list(
#&gt;                       "vctrs::vec_cast()"), ".\n", list(), " ", 
#&gt;                     list(list("type_of()")), ", ", list(list(
#&gt;                       "switch_type()")), ", ", list(list("coerce_type()")), 
#&gt;                     ", ", list(list("switch_class()")), ",\n", 
#&gt;                     list(list("coerce_class()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                   "\n", "\n", list("Bumped to deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("modify()")), 
#&gt;                     " and ", list(list("prepend()")), ".\n", 
#&gt;                     list(), " ", list("new_logical_along()"), 
#&gt;                     ", ", list("new_integer_along()"), ",\n", 
#&gt;                     list("new_double_along()"), ", ", list("new_complex_along()"), 
#&gt;                     ",\n", list("new_character_along()"), ", ", 
#&gt;                     list("new_raw_along()"), ", ", list("new_list_along()"), 
#&gt;                     ".\n", list(), " ", list(list("lang_modify()")), 
#&gt;                     " =&gt; ", list(list("call_modify()")), "\n", 
#&gt;                     list(), " ", list(list("lang_standardise()")), 
#&gt;                     " =&gt; ", list(list("call_standardise()")), 
#&gt;                     "\n", list(), " ", list(list("lang_fn()")), 
#&gt;                     " =&gt; ", list(list("call_fn()")), "\n", list(), 
#&gt;                     " ", list(list("lang_name()")), " =&gt; ", list(
#&gt;                       list("call_name()")), "\n", list(), " ", 
#&gt;                     list(list("lang_args()")), " =&gt; ", list(list(
#&gt;                       "call_args()")), "\n", list(), " ", list(
#&gt;                       list("lang_args_names()")), " =&gt; ", list(
#&gt;                       list("call_args_names()")), "\n", list(), 
#&gt;                     " ", list(list("lang_head()")), ", ", list(
#&gt;                       list("lang_tail()")), "\n", list(), " ", 
#&gt;                     list(list("lang()")), " =&gt; ", list(list("call2()")), 
#&gt;                     "\n", list(), " ", list(list("new_language()")), 
#&gt;                     " =&gt; ", list(list("new_call()")), "\n", list(), 
#&gt;                     " ", list(list("is_lang()")), " =&gt; ", list(
#&gt;                       list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("is_unary_lang()")), " =&gt; Use the ", 
#&gt;                     list("n"), " argument of ", list(list("is_call()")), 
#&gt;                     "\n", list(), " ", list(list("is_binary_lang()")), 
#&gt;                     " =&gt; Use the ", list("n"), " argument of ", 
#&gt;                     list(list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("quo_is_lang()")), " =&gt; ", list(
#&gt;                       list("quo_is_call()")), "\n", list(), " ", 
#&gt;                     list(list("call_modify()")), ": ", list(".standardise"), 
#&gt;                     " and ", list(".env"), " arguments.\n", list(), 
#&gt;                     " ", list(list("is_expr()")), " =&gt; ", list(
#&gt;                       list("is_expression()")), "\n", list(), 
#&gt;                     " ", list("quo_expr()"), " =&gt; ", list(list(
#&gt;                       "quo_squash()")), "\n", list(), " ", list(
#&gt;                       list("parse_quosure()")), " =&gt; ", list(
#&gt;                       list("parse_quo()")), "\n", list(), " ", 
#&gt;                     list(list("parse_quosures()")), " =&gt; ", list(
#&gt;                       list("parse_quos()")), "\n", list(), " Assigning non-quosure objects to quosure lists.\n", 
#&gt;                     list(), " ", list("as.character()"), " on quosures.\n", 
#&gt;                     list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": ", list(".cnd"), " =&gt; ", list("cnd"), 
#&gt;                     "\n", list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": The ", list(".mufflable"), " argument no longer has any effect\n", 
#&gt;                     list(), " ", list("scoped_names()"), " =&gt; ", 
#&gt;                     list(list("base::search()")), "\n", list(), 
#&gt;                     " ", list("is_scoped()"), " =&gt; ", list(list(
#&gt;                       "is_attached()")), "\n", list(), " ", list(
#&gt;                       "scoped_env()"), " =&gt; ", list(list("search_env()")), 
#&gt;                     "\n", list(), " ", list("scoped_envs()"), 
#&gt;                     " =&gt; ", list(list("search_envs()")), "\n", 
#&gt;                     list(), " ", list("env_bind_exprs()"), " =&gt; ", 
#&gt;                     list(list("env_bind_lazy()")), "\n", list(), 
#&gt;                     " ", list("env_bind_fns()"), " =&gt; ", list(
#&gt;                       list("env_bind_active()")), "\n", list(), 
#&gt;                     " Passing a function or formula to ", list(
#&gt;                       "env_depth()"), ",\n", list("env_poke_parent()"), 
#&gt;                     ", ", list("env_parent&lt;-"), ", ", list("env_tail()"), 
#&gt;                     ", ", list("set_env()"), ",\n", list("env_clone()"), 
#&gt;                     ", ", list("env_inherits()"), ", ", list(
#&gt;                       "env_bind()"), ",\n", list("scoped_bindings()"), 
#&gt;                     ", ", list("with_bindings()"), ", ", list(
#&gt;                       "env_poke()"), ",\n", list("env_has()"), 
#&gt;                     ", ", list("env_get()"), ", ", list("env_names()"), 
#&gt;                     ", ", list("env_bind_exprs()"), " and\n", 
#&gt;                     list("env_bind_fns()"), ". This internal genericity was causing confusion\n", 
#&gt;                     "(see issue #427). You should now extract the environment\n", 
#&gt;                     "separately before calling these functions.\n", 
#&gt;                     list(), " ", list(list("get_env()")), ": The ", 
#&gt;                     list("env"), " argument no longer has a default and must be supplied\n", 
#&gt;                     list(), " ", list(list("is_frame()")), ", ", 
#&gt;                     list(list("global_frame()")), ", ", list(
#&gt;                       list("current_frame()")), ",\n", list(list(
#&gt;                       "ctxt_frame()")), ", ", list(list("call_frame()")), 
#&gt;                     ", ", list(list("frame_position()")), ",\n", 
#&gt;                     list(list("caller_frame()")), "\n", list(), 
#&gt;                     " ", list(list("ctxt_depth()")), ", ", list(
#&gt;                       list("call_depth()")), ", ", list(list(
#&gt;                       "ctxt_stack()")), ", ", list(list("call_stack()")), 
#&gt;                     ",\n", list(list("stack_trim()")), "\n", 
#&gt;                     list(), " ", list(list("set_attrs()")), ", ", 
#&gt;                     list(list("mut_attrs()")), "\n", list(), 
#&gt;                     " The ", list("width"), " and ", list("printer"), 
#&gt;                     " arguments of ", list(list("exprs_auto_name()")), 
#&gt;                     " and\n", list(list("quos_auto_name()")), 
#&gt;                     " no longer have any effect. For the same\n", 
#&gt;                     "reason, passing a width as ", list(".named"), 
#&gt;                     " argument of dots collectors\n", "like ", 
#&gt;                     list("quos()"), " is deprecated.\n", list(), 
#&gt;                     " ", list("as_overscope()"), " =&gt; ", list(
#&gt;                       list("as_data_mask()")), "\n", list(), 
#&gt;                     " ", list("new_overscope()"), " =&gt; ", list(
#&gt;                       list("new_data_mask()")), "\n", list(), 
#&gt;                     " ", list("overscope_eval_next()"), " =&gt; ", 
#&gt;                     list(list("eval_tidy()")), "\n", list(), 
#&gt;                     " ", list("overscope_clean()"), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Defunct functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"defunct\")"), 
#&gt;                   "\n", "\n", list("Defunct as of rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list("length()"), 
#&gt;                     " and ", list("names()"), " on tidy eval ", 
#&gt;                     list(".data"), " pronouns.\n", list(), " Supplying a named ", 
#&gt;                     list("!!!"), " call.\n", list(), " ", list(
#&gt;                       list("as_data_mask()")), ": ", list("parent"), 
#&gt;                     " argument\n", list(), " ", list(list("new_data_mask()")), 
#&gt;                     ": ", list("parent"), " argument\n", list(), 
#&gt;                     " ", list(list("env_tail()")), ": ", list(
#&gt;                       "sentinel"), " =&gt; ", list("last"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ": ", list("msg"), ", ", list("type"), " =&gt; ", 
#&gt;                     list(".msg"), ", ", list(".type"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ", ", list(list("cnd()")), ", ", list(list(
#&gt;                       "error_cnd()")), ",\n", list(list("warning_cnd()")), 
#&gt;                     ", ", list(list("message_cnd()")), ": ", 
#&gt;                     list("call"), " argument.\n", list(), " ", 
#&gt;                     list(list("is_character()")), ", ", list(
#&gt;                       list("is_string()")), ", and variants: The ", 
#&gt;                     list("encoding"), "\n", "argument.\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Archived"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"archived\")"), 
#&gt;                 "\n", "\n", "These functions were entirely removed from the package. You will\n", 
#&gt;                 "find them in the commit history and previous releases.\n", 
#&gt;                 "\n", list("Archived as of rlang 0.4.0"), "\n", 
#&gt;                 list("\n", list(), " ", list("UQE()"), "\n", 
#&gt;                   list(), " ", list("as_dictionary()"), ", ", 
#&gt;                   list("is_dictionary()"), "\n", list(), " ", 
#&gt;                   list("as_quosureish()"), ", ", list("is_quosureish()"), 
#&gt;                   "\n", list(), " ", list("eval_tidy_()"), "\n", 
#&gt;                   list(), " ", list("mut_utf8_locale()"), ", ", 
#&gt;                   list("mut_latin1_locale()"), ", ", list("mut_mbcs_locale()"), 
#&gt;                   "\n", list(), " ", list("set_chr_encoding()"), 
#&gt;                   ", ", list("chr_encoding()"), ", ", list("set_str_encoding()"), 
#&gt;                   ", ", list("str_encoding()"), "\n", list(), 
#&gt;                   " ", list("as_native_character()"), ", ", list(
#&gt;                     "as_utf8_string()"), ", ", list("as_native_string()"), 
#&gt;                   "\n", list(), " ", list("lang_type_of()"), 
#&gt;                   ", ", list("switch_lang()"), ", ", list("coerce_lang()"), 
#&gt;                   "\n"), "\n", "\n", list("Archived as of rlang 0.3.0:"), 
#&gt;                 "\n", list("\n", list(), " ", list("cnd_inform()"), 
#&gt;                   ", ", list("cnd_warn()"), " and ", list("cnd_abort()"), 
#&gt;                   "\n", list(), " ", list("new_cnd()"), " =&gt; ", 
#&gt;                   list(list("cnd()")), "\n", list(), " ", list(
#&gt;                     "cnd_message()"), " =&gt; ", list(list("message_cnd()")), 
#&gt;                   "\n", list(), " ", list("cnd_warning()"), " =&gt; ", 
#&gt;                   list(list("warning_cnd()")), "\n", list(), 
#&gt;                   " ", list("cnd_error()"), " =&gt; ", list(list(
#&gt;                     "error_cnd()")), "\n", list(), " ", list(
#&gt;                     "rst_muffle()"), " =&gt; ", list(list("cnd_muffle()")), 
#&gt;                   "\n", list(), " ", list("inplace()"), " =&gt; ", 
#&gt;                   list(list("calling()")), ". The ", list("muffle"), 
#&gt;                   " argument of ", list("inplace()"), "\n", "has not been implemented in ", 
#&gt;                   list("calling()"), " and is now defunct.\n", 
#&gt;                   list(), " ", list(list("cnd_signal()")), ": ", 
#&gt;                   list(".msg"), " and ", list(".call"), ".\n", 
#&gt;                   list(), " ", list(list("cnd()")), ", ", list(
#&gt;                     list("error_cnd()")), ", ", list(list("warning_cnd()")), 
#&gt;                   " and ", list(list("message_cnd()")), ":\n", 
#&gt;                   list(".msg"), " =&gt; ", list("message"), ".\n"), 
#&gt;                 "\n")), "\n", "\n", list("internal"), "\n"), 
#&gt;         missing.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-na.R", 
#&gt;             "\n", list("data"), "\n", list("missing"), "\n", 
#&gt;             list("missing"), "\n", list("na_lgl"), "\n", list(
#&gt;                 "na_int"), "\n", list("na_dbl"), "\n", list("na_chr"), 
#&gt;             "\n", list("na_cpl"), "\n", list("Missing values"), 
#&gt;             "\n", list("An object of class ", list("logical"), 
#&gt;                 " of length 1."), "\n", list("\n", "na_lgl\n", 
#&gt;                 "\n", "na_int\n", "\n", "na_dbl\n", "\n", "na_chr\n", 
#&gt;                 "\n", "na_cpl\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Missing values are represented in R with the general symbol\n", 
#&gt;                 list("NA"), ". They can be inserted in almost all data containers: all\n", 
#&gt;                 "atomic vectors except raw vectors can contain missing values. To\n", 
#&gt;                 "achieve this, R automatically converts the general ", 
#&gt;                 list("NA"), " symbol to a\n", "typed missing value appropriate for the target vector. The objects\n", 
#&gt;                 "provided here are aliases for those typed ", 
#&gt;                 list("NA"), " objects.\n"), "\n", list("\n", 
#&gt;                 "Typed missing values are necessary because R needs sentinel values\n", 
#&gt;                 "of the same type (i.e. the same machine representation of the data)\n", 
#&gt;                 "as the containers into which they are inserted. The official typed\n", 
#&gt;                 "missing values are ", list("NA_integer_"), ", ", 
#&gt;                 list("NA_real_"), ", ", list("NA_character_"), 
#&gt;                 " and\n", list("NA_complex_"), ". The missing value for logical vectors is simply the\n", 
#&gt;                 "default ", list("NA"), ". The aliases provided in rlang are consistently named\n", 
#&gt;                 "and thus simpler to remember. Also, ", list(
#&gt;                   "na_lgl"), " is provided as an\n", "alias to ", 
#&gt;                 list("NA"), " that makes intent clearer.\n", 
#&gt;                 "\n", "Since ", list("na_lgl"), " is the default ", 
#&gt;                 list("NA"), ", expressions such as ", list("c(NA, NA)"), 
#&gt;                 "\n", "yield logical vectors as no data is available to give a clue of the\n", 
#&gt;                 "target type. In the same way, since lists and environments can\n", 
#&gt;                 "contain any types, expressions like ", list(
#&gt;                   "list(NA)"), " store a logical\n", list("NA"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These shortcuts might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;             "\n", "\n", list("\n", "typeof(NA)\n", "typeof(na_lgl)\n", 
#&gt;                 "typeof(na_int)\n", "\n", "# Note that while the base R missing symbols cannot be overwritten,\n", 
#&gt;                 "# that's not the case for rlang's aliases:\n", 
#&gt;                 "na_dbl &lt;- NA\n", "typeof(na_dbl)\n"), "\n", 
#&gt;             list("datasets"), "\n", list("internal"), "\n"), 
#&gt;         missing_arg.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("missing_arg"), "\n", list("missing_arg"), "\n", 
#&gt;             list("is_missing"), "\n", list("maybe_missing"), 
#&gt;             "\n", list("Generate or handle a missing argument"), 
#&gt;             "\n", list("\n", "missing_arg()\n", "\n", "is_missing(x)\n", 
#&gt;                 "\n", "maybe_missing(x, default = missing_arg())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object that might be the missing argument.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The object to return if the input is missing,\n", 
#&gt;                   "defaults to ", list("missing_arg()"), ".")), 
#&gt;                 "\n"), "\n", list("\n", "These functions help using the missing argument as a regular R\n", 
#&gt;                 "object.\n", list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " generates a missing argument.\n", list(), 
#&gt;                   " ", list("is_missing()"), " is like ", list(
#&gt;                     list("base::missing()")), " but also supports\n", 
#&gt;                   "testing for missing arguments contained in other objects like\n", 
#&gt;                   "lists.\n", list(), " ", list("maybe_missing()"), 
#&gt;                   " is useful to pass down an input that might be\n", 
#&gt;                   "missing to another function, potentially substituting by a\n", 
#&gt;                   "default value. It avoids triggering an \"argument is missing\" error.\n"), 
#&gt;                 "\n"), "\n", list(list("Other ways to reify the missing argument"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "base::quote(expr = )"), " is the canonical way to create a missing\n", 
#&gt;                   "argument object.\n", list(), " ", list("expr()"), 
#&gt;                   " called without argument creates a missing argument.\n", 
#&gt;                   list(), " ", list("quo()"), " called without argument creates an empty quosure, i.e. a\n", 
#&gt;                   "quosure containing the missing argument object.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Fragility of the missing argument object"), 
#&gt;                 list("\n", "\n", "\n", "The missing argument is an object that triggers an error if and\n", 
#&gt;                   "only if it is the result of evaluating a symbol. No error is\n", 
#&gt;                   "produced when a function call evaluates to the missing argument\n", 
#&gt;                   "object. This means that expressions like ", 
#&gt;                   list("x[[1]] &lt;- missing_arg()"), "\n", "are perfectly safe. Likewise, ", 
#&gt;                   list("x[[1]]"), " is safe even if the result\n", 
#&gt;                   "is the missing object.\n", "\n", "However, as soon as the missing argument is passed down between\n", 
#&gt;                   "functions through an argument, you're at risk of triggering a\n", 
#&gt;                   "missing error. This is because arguments are passed through\n", 
#&gt;                   "symbols. To work around this, ", list("is_missing()"), 
#&gt;                   " and ", list("maybe_missing(x)"), "\n", "use a bit of magic to determine if the input is the missing\n", 
#&gt;                   "argument without triggering a missing error.\n", 
#&gt;                   "\n", list("maybe_missing()"), " is particularly useful for prototyping\n", 
#&gt;                   "meta-programming algorithms in R. The missing argument is a likely\n", 
#&gt;                   "input when computing on the language because it is a standard\n", 
#&gt;                   "object in formals lists. While C functions are always allowed to\n", 
#&gt;                   "return the missing argument and pass it to other C functions, this\n", 
#&gt;                   "is not the case on the R side. If you're implementing your\n", 
#&gt;                   "meta-programming algorithm in R, use ", list(
#&gt;                     "maybe_missing()"), " when an\n", "input might be the missing argument object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " and ", list("is_missing()"), " are stable.\n", 
#&gt;                   list(), " Like the rest of rlang, ", list("maybe_missing()"), 
#&gt;                   " is maturing.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# The missing argument usually arises inside a function when the\n", 
#&gt;                 "# user omits an argument that does not have a default:\n", 
#&gt;                 "fn &lt;- function(x) is_missing(x)\n", "fn()\n", 
#&gt;                 "\n", "# Creating a missing argument can also be useful to generate calls\n", 
#&gt;                 "args &lt;- list(1, missing_arg(), 3, missing_arg())\n", 
#&gt;                 "quo(fn(!!! args))\n", "\n", "# Other ways to create that object include:\n", 
#&gt;                 "quote(expr = )\n", "expr()\n", "\n", "# It is perfectly valid to generate and assign the missing\n", 
#&gt;                 "# argument in a list.\n", "x &lt;- missing_arg()\n", 
#&gt;                 "l &lt;- list(missing_arg())\n", "\n", "# Just don't evaluate a symbol that contains the empty argument.\n", 
#&gt;                 "# Evaluating the object `x` that we created above would trigger an\n", 
#&gt;                 "# error.\n", "# x  # Not run\n", "\n", "# On the other hand accessing a missing argument contained in a\n", 
#&gt;                 "# list does not trigger an error because subsetting is a function\n", 
#&gt;                 "# call:\n", "l[[1]]\n", "is.null(l[[1]])\n", 
#&gt;                 "\n", "# In case you really need to access a symbol that might contain the\n", 
#&gt;                 "# empty argument object, use maybe_missing():\n", 
#&gt;                 "maybe_missing(x)\n", "is.null(maybe_missing(x))\n", 
#&gt;                 "is_missing(maybe_missing(x))\n", "\n", "\n", 
#&gt;                 "# Note that base::missing() only works on symbols and does not\n", 
#&gt;                 "# support complex expressions. For this reason the following lines\n", 
#&gt;                 "# would throw an error:\n", "\n", "#&gt; missing(missing_arg())\n", 
#&gt;                 "#&gt; missing(l[[1]])\n", "\n", "# while is_missing() will work as expected:\n", 
#&gt;                 "is_missing(missing_arg())\n", "is_missing(l[[1]])\n"), 
#&gt;             "\n"), mut_node_car.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("mut_node_car"), "\n", list("mut_node_car"), 
#&gt;             "\n", list("mut_node_cdr"), "\n", list("mut_node_caar"), 
#&gt;             "\n", list("mut_node_cadr"), "\n", list("mut_node_cdar"), 
#&gt;             "\n", list("mut_node_cddr"), "\n", list("mut_node_tag"), 
#&gt;             "\n", list("Mutate node components"), "\n", list(
#&gt;                 "\n", "mut_node_car(x, newcar)\n", "\n", "mut_node_cdr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_caar(x, newcar)\n", "\n", "mut_node_cadr(x, newcar)\n", 
#&gt;                 "\n", "mut_node_cdar(x, newcdr)\n", "\n", "mut_node_cddr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_tag(x, newtag)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newcar"), list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newcdr"), list("The new CAR or CDR for the node. These\n", 
#&gt;                     "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("node_poke_"), "\n", "prefix in rlang 0.2.0. This change follows a new naming convention\n", 
#&gt;                 "where mutation is referred to as \"poking\".\n"), 
#&gt;             "\n", list("internal"), "\n"), names2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("names2"), "\n", list("names2"), "\n", 
#&gt;             list("Get names of a vector"), "\n", list("\n", "names2(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This names getter always returns a character vector, even when an\n", 
#&gt;                 "object does not have a ", list("names"), " attribute. In this case, it returns\n", 
#&gt;                 "a vector of empty names ", list("\"\""), ". It also standardises missing names to\n", 
#&gt;                 list("\"\""), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("names2()"), " is stable.\n")), 
#&gt;             "\n", "\n", list("\n", "names2(letters)\n", "\n", 
#&gt;                 "# It also takes care of standardising missing names:\n", 
#&gt;                 "x &lt;- set_names(1:3, c(\"a\", NA, \"b\"))\n", 
#&gt;                 "names2(x)\n"), "\n"), `new-vector-along-retired.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("new-vector-along-retired"), "\n", list(
#&gt;                 "new-vector-along-retired"), "\n", list("new_logical_along"), 
#&gt;             "\n", list("new_integer_along"), "\n", list("new_double_along"), 
#&gt;             "\n", list("new_character_along"), "\n", list("new_complex_along"), 
#&gt;             "\n", list("new_raw_along"), "\n", list("new_list_along"), 
#&gt;             "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "new_logical_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_integer_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_double_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_character_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_complex_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_raw_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_list_along(x, names = base::names(x))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions are deprecated as of rlang 0.3.0 because they\n", 
#&gt;                 "are longer to type than the equivalent ", list(
#&gt;                   list("rep_along()")), " or\n", list(list("rep_named()")), 
#&gt;                 " calls without added clarity.\n"), "\n", list(
#&gt;                 "internal"), "\n"), `new-vector.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("new-vector"), "\n", list("new-vector"), 
#&gt;             "\n", list("new_logical"), "\n", list("new_integer"), 
#&gt;             "\n", list("new_double"), "\n", list("new_character"), 
#&gt;             "\n", list("new_complex"), "\n", list("new_raw"), 
#&gt;             "\n", list("new_list"), "\n", list("Create vectors matching a given length"), 
#&gt;             "\n", list("\n", "new_logical(n, names = NULL)\n", 
#&gt;                 "\n", "new_integer(n, names = NULL)\n", "\n", 
#&gt;                 "new_double(n, names = NULL)\n", "\n", "new_character(n, names = NULL)\n", 
#&gt;                 "\n", "new_complex(n, names = NULL)\n", "\n", 
#&gt;                 "new_raw(n, names = NULL)\n", "\n", "new_list(n, names = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The vector length.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "These functions construct vectors of a given length, with attributes\n", 
#&gt;                 "specified via dots. Except for ", list("new_list()"), 
#&gt;                 " and ", list("new_raw()"), ", the\n", "empty vectors are filled with typed ", 
#&gt;                 list("missing"), " values. This is in\n", "contrast to the base function ", 
#&gt;                 list(list("base::vector()")), " which creates\n", 
#&gt;                 "zero-filled vectors.\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are likely to be replaced by a vctrs equivalent in\n", 
#&gt;                   "the future. They are in the questioning lifecycle stage.\n")), 
#&gt;             "\n", "\n", list("\n", "new_list(10)\n", "new_logical(10)\n"), 
#&gt;             "\n", list("\n", "rep_along\n"), "\n", list("internal"), 
#&gt;             "\n"), new_call.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_call"), "\n", list("new_call"), "\n", 
#&gt;             list("Create a new call from components"), "\n", 
#&gt;             list("\n", "new_call(car, cdr = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("car"), list("The head of the call. It should be a\n", 
#&gt;                 list("callable"), " object: a symbol, call, or literal\n", 
#&gt;                 "function.")), "\n", "\n", list(list("cdr"), 
#&gt;                 list("The tail of the call, i.e. a ", list("node list"), 
#&gt;                   " of\n", "arguments.")), "\n"), "\n", list(
#&gt;                 "\n", "Create a new call from components\n"), 
#&gt;             "\n", list("internal"), "\n"), new_formula.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("new_formula"), "\n", list("new_formula"), "\n", 
#&gt;             list("Create a formula"), "\n", list("\n", "new_formula(lhs, rhs, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("lhs, rhs"), list("A call, name, or atomic vector.")), 
#&gt;                 "\n", "\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A formula object.\n"), 
#&gt;             "\n", list("\n", "Create a formula\n"), "\n", list(
#&gt;                 "\n", "new_formula(quote(a), quote(b))\n", "new_formula(NULL, quote(b))\n"), 
#&gt;             "\n", list("\n", list(list("new_quosure()")), "\n"), 
#&gt;             "\n"), new_function.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("new_function"), "\n", list("new_function"), 
#&gt;             "\n", list("Create a function"), "\n", list("\n", 
#&gt;                 "new_function(args, body, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("args"), list("A named list or pairlist of default arguments. Note\n", 
#&gt;                 "that if you want arguments that don't have defaults, you'll need\n", 
#&gt;                 "to use the special function ", list(list("pairlist2()")), 
#&gt;                 ". If you need quoted\n", "defaults, use ", list(
#&gt;                   list("exprs()")), ".")), "\n", "\n", list(list(
#&gt;                 "body"), list("A language object representing the code inside the\n", 
#&gt;                 "function. Usually this will be most easily generated with\n", 
#&gt;                 list(list("base::quote()")))), "\n", "\n", list(
#&gt;                 list("env"), list("The parent environment of the function, defaults to the\n", 
#&gt;                   "calling environment of ", list("new_function()"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This constructs a new function given its three components:\n", 
#&gt;                 "list of arguments, body code and parent environment.\n"), 
#&gt;             "\n", list("\n", "f &lt;- function() letters\n", "g &lt;- new_function(NULL, quote(letters))\n", 
#&gt;                 "identical(f, g)\n", "\n", "# Pass a list or pairlist of named arguments to create a function\n", 
#&gt;                 "# with parameters. The name becomes the parameter name and the\n", 
#&gt;                 "# argument the default value for this parameter:\n", 
#&gt;                 "new_function(list(x = 10), quote(x))\n", "new_function(pairlist2(x = 10), quote(x))\n", 
#&gt;                 "\n", "# Use `exprs()` to create quoted defaults. Compare:\n", 
#&gt;                 "new_function(pairlist2(x = 5 + 5), quote(x))\n", 
#&gt;                 "new_function(exprs(x = 5 + 5), quote(x))\n", 
#&gt;                 "\n", "# Pass empty arguments to omit defaults. `list()` doesn't allow\n", 
#&gt;                 "# empty arguments but `pairlist2()` does:\n", 
#&gt;                 "new_function(pairlist2(x = , y = 5 + 5), quote(x + y))\n", 
#&gt;                 "new_function(exprs(x = , y = 5 + 5), quote(x + y))\n"), 
#&gt;             "\n"), new_node.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_node"), "\n", list("new_node"), "\n", 
#&gt;             list("node_car"), "\n", list("node_cdr"), "\n", list(
#&gt;                 "node_caar"), "\n", list("node_cadr"), "\n", 
#&gt;             list("node_cdar"), "\n", list("node_cddr"), "\n", 
#&gt;             list("node_poke_car"), "\n", list("node_poke_cdr"), 
#&gt;             "\n", list("node_poke_caar"), "\n", list("node_poke_cadr"), 
#&gt;             "\n", list("node_poke_cdar"), "\n", list("node_poke_cddr"), 
#&gt;             "\n", list("node_tag"), "\n", list("node_poke_tag"), 
#&gt;             "\n", list("Helpers for pairlist and language nodes"), 
#&gt;             "\n", list("\n", "new_node(car, cdr = NULL)\n", "\n", 
#&gt;                 "node_car(x)\n", "\n", "node_cdr(x)\n", "\n", 
#&gt;                 "node_caar(x)\n", "\n", "node_cadr(x)\n", "\n", 
#&gt;                 "node_cdar(x)\n", "\n", "node_cddr(x)\n", "\n", 
#&gt;                 "node_poke_car(x, newcar)\n", "\n", "node_poke_cdr(x, newcdr)\n", 
#&gt;                 "\n", "node_poke_caar(x, newcar)\n", "\n", "node_poke_cadr(x, newcar)\n", 
#&gt;                 "\n", "node_poke_cdar(x, newcdr)\n", "\n", "node_poke_cddr(x, newcdr)\n", 
#&gt;                 "\n", "node_tag(x)\n", "\n", "node_poke_tag(x, newtag)\n"), 
#&gt;             "\n", list("\n", list(list("car, newcar, cdr, newcdr"), 
#&gt;                 list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                 list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Setters like ", list(
#&gt;                 "node_poke_car()"), " invisibly return ", list(
#&gt;                 "x"), " modified\n", "in place. Getters return the requested node component.\n"), 
#&gt;             "\n", list("\n", list("Important"), ": These functions are for expert R programmers only.\n", 
#&gt;                 "You should only use them if you feel comfortable manipulating low\n", 
#&gt;                 "level R data structures at the C level. We export them at the R level\n", 
#&gt;                 "in order to make it easy to prototype C code. They don't perform\n", 
#&gt;                 "any type checking and can crash R very easily (try to take the CAR\n", 
#&gt;                 "of an integer vector --- save any important objects beforehand!).\n"), 
#&gt;             "\n", list("\n", list(list("duplicate()")), " for creating copy-safe objects and\n", 
#&gt;                 list(list("base::pairlist()")), " for an easier way of creating a linked list of\n", 
#&gt;                 "nodes.\n"), "\n", list("internal"), "\n"), new_quosures.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "new_quosures"), "\n", list("new_quosures"), 
#&gt;             "\n", list("as_quosures"), "\n", list("is_quosures"), 
#&gt;             "\n", list("Create a list of quosures"), "\n", list(
#&gt;                 "\n", "new_quosures(x)\n", "\n", "as_quosures(x, env, named = FALSE)\n", 
#&gt;                 "\n", "is_quosures(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("A list of quosures or objects to coerce to quosures.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The default environment for the new quosures.")), 
#&gt;                 "\n", "\n", list(list("named"), list("Whether to name the list with ", 
#&gt;                   list(list("quos_auto_name()")), ".")), "\n"), 
#&gt;             "\n", list("\n", "This small S3 class provides methods for ", 
#&gt;                 list("["), " and ", list("c()"), " and ensures\n", 
#&gt;                 "the following invariants:\n", list("\n", list(), 
#&gt;                   " The list only contains quosures.\n", list(), 
#&gt;                   " It is always named, possibly with a vector of empty strings.\n"), 
#&gt;                 "\n", "\n", list("new_quosures()"), " takes a list of quosures and adds the ", 
#&gt;                 list("quosures"), "\n", "class and a vector of empty names if needed. ", 
#&gt;                 list("as_quosures()"), " calls\n", list(list(
#&gt;                   "as_quosure()")), " on all elements before creating the ", 
#&gt;                 list("quosures"), "\n", "object.\n"), "\n"), 
#&gt;         new_weakref.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/weakref.R", 
#&gt;             "\n", list("new_weakref"), "\n", list("new_weakref"), 
#&gt;             "\n", list("Create a weak reference"), "\n", list(
#&gt;                 "\n", "new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("key"), list("The key for the weak reference. Must be a reference object -- that\n", 
#&gt;                 "is, an environment or external pointer.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for the weak reference. This can be ", 
#&gt;                   list("NULL"), ", if you\n", "want to use the weak reference like a weak pointer.")), 
#&gt;                 "\n", "\n", list(list("finalizer"), list("A function that is run after the key becomes unreachable.")), 
#&gt;                 "\n", "\n", list(list("on_quit"), list("Should the finalizer be run when R exits?")), 
#&gt;                 "\n"), "\n", list("\n", "A weak reference is a special R object which makes it possible to keep a\n", 
#&gt;                 "reference to an object without preventing garbage collection of that object.\n", 
#&gt;                 "It can also be used to keep data about an object without preventing GC of the\n", 
#&gt;                 "object, similar to WeakMaps in JavaScript.\n", 
#&gt;                 "\n", "Objects in R are considered ", list("reachable"), 
#&gt;                 " if they can be accessed by following\n", "a chain of references, starting from a ", 
#&gt;                 list("root node"), "; root nodes are\n", "specially-designated R objects, and include the global environment and base\n", 
#&gt;                 "environment. As long as the key is reachable, the value will not be garbage\n", 
#&gt;                 "collected. This is true even if the weak reference object becomes\n", 
#&gt;                 "unreachable. The key effectively prevents the weak reference and its value\n", 
#&gt;                 "from being collected, according to the following chain of ownership:\n", 
#&gt;                 list("weakref &lt;- key -&gt; value"), ".\n", "\n", 
#&gt;                 "When the key becomes unreachable, the key and value in the weak reference\n", 
#&gt;                 "object are replaced by ", list("NULL"), ", and the finalizer is scheduled to execute.\n"), 
#&gt;             "\n", list("\n", "e &lt;- env()\n", "\n", "# Create a weak reference to e\n", 
#&gt;                 "w &lt;- new_weakref(e, finalizer = function(e) message(\"finalized\"))\n", 
#&gt;                 "\n", "# Get the key object from the weak reference\n", 
#&gt;                 "identical(wref_key(w), e)\n", "\n", "# When the regular reference (the `e` binding) is removed and a GC occurs,\n", 
#&gt;                 "# the weak reference will not keep the object alive.\n", 
#&gt;                 "rm(e)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "\n", "\n", "# A weak reference with a key and value. The value contains data about the\n", 
#&gt;                 "# key.\n", "k &lt;- env()\n", "v &lt;- list(1, 2, 3)\n", 
#&gt;                 "w &lt;- new_weakref(k, v)\n", "\n", "identical(wref_key(w), k)\n", 
#&gt;                 "identical(wref_value(w), v)\n", "\n", "# When v is removed, the weak ref keeps it alive because k is still reachable.\n", 
#&gt;                 "rm(v)\n", "gc()\n", "identical(wref_value(w), list(1, 2, 3))\n", 
#&gt;                 "\n", "# When k is removed, the weak ref does not keep k or v alive.\n", 
#&gt;                 "rm(k)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "identical(wref_value(w), NULL)\n"), "\n", list(
#&gt;                 "\n", list(list("is_weakref()")), ", ", list(
#&gt;                   list("wref_key()")), " and ", list(list("wref_value()")), 
#&gt;                 ".\n"), "\n", list("experimental"), "\n"), ns_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("ns_env"), "\n", list("ns_env"), "\n", 
#&gt;             list("ns_imports_env"), "\n", list("ns_env_name"), 
#&gt;             "\n", list("Get the namespace of a package"), "\n", 
#&gt;             list("\n", "ns_env(x = caller_env())\n", "\n", "ns_imports_env(x = caller_env())\n", 
#&gt;                 "\n", "ns_env_name(x = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list(list("\n", list(), 
#&gt;                 " For ", list("ns_env()"), ", the name of a package or an environment as a\n", 
#&gt;                 "string.\n", list("\n", list(), " An environment (the current environment by default).\n", 
#&gt;                   list(), " A function.\n"), "\n", "\n", "In the latter two cases, the environment ancestry is searched for\n", 
#&gt;                 "a namespace with ", list(list("base::topenv()")), 
#&gt;                 ". If the environment doesn't\n", "inherit from a namespace, this is an error.\n"))), 
#&gt;                 "\n", "\n", list(list("env"), list("A namespace environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Namespaces are the environment where all the functions of a package\n", 
#&gt;                 "live. The parent environments of namespaces are the ", 
#&gt;                 list("imports"), "\n", "environments, which contain all the functions imported from other\n", 
#&gt;                 "packages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental and may not belong to the rlang\n", 
#&gt;                   "package. Expect API changes.\n")), "\n", "\n", 
#&gt;             list("\n", list(list("pkg_env()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), `op-definition.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-definition"), "\n", list("op-definition"), 
#&gt;             "\n", list("is_definition"), "\n", list("new_definition"), 
#&gt;             "\n", list("is_formulaish"), "\n", list("Definition operator"), 
#&gt;             "\n", list("\n", "is_definition(x)\n", "\n", "new_definition(lhs, rhs, env = caller_env())\n", 
#&gt;                 "\n", "is_formulaish(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("lhs, rhs"), list("Expressions for the LHS and RHS of the definition.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The evaluation environment bundled with the definition.")), 
#&gt;                 "\n"), "\n", list("\n", "The definition operator is typically used in DSL packages like\n", 
#&gt;                 list("ggvis"), " and ", list("data.table"), ". It is also used in the tidyverse as a way\n", 
#&gt;                 "of unquoting names (see ", list("quasiquotation"), 
#&gt;                 ").\n", list("\n", list(), " ", list("is_definition()"), 
#&gt;                   " returns ", list("TRUE"), " for calls to ", 
#&gt;                   list(":="), ".\n", list(), " ", list("is_formulaish()"), 
#&gt;                   " returns ", list("TRUE"), " for both formulas and\n", 
#&gt;                   "colon-equals operators.\n"), "\n"), "\n", 
#&gt;             list("\n", "The recommended way to use it is to capture arguments as\n", 
#&gt;                 "expressions or quosures. You can then give a special function\n", 
#&gt;                 "definition for the ", list(":="), " symbol in an overscope. Note that if you\n", 
#&gt;                 "capture dots with ", list(list("exprs()")), 
#&gt;                 " or ", list(list("quos()")), ", you need to disable\n", 
#&gt;                 "interpretation of ", list(":="), " by setting ", 
#&gt;                 list(".unquote_names"), " to ", list("FALSE"), 
#&gt;                 ".\n", "\n", "From rlang and data.table perspectives, this operator is not meant\n", 
#&gt;                 "to be evaluated directly at top-level which is why the exported\n", 
#&gt;                 "definitions issue an error.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "\n", "# A predicate is provided to distinguish formulas from the\n", 
#&gt;                 "# colon-equals operator:\n", "is_definition(quote(a := b))\n", 
#&gt;                 "is_definition(a ~ b)\n", "\n", "\n", "# is_formulaish() tests for both definitions and formulas:\n", 
#&gt;                 "is_formulaish(a ~ b)\n", "is_formulaish(quote(a := b))\n"), 
#&gt;             "\n", list("internal"), "\n"), `op-get-attr.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-get-attr"), "\n", list("op-get-attr"), "\n", 
#&gt;             list("%@%"), "\n", list("%@%&lt;-"), "\n", list("Infix attribute accessor and setter"), 
#&gt;             "\n", list("\n", "x %@% name\n", "\n", "x %@% name &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Attribute name")), 
#&gt;                 "\n", "\n", list(list("value"), list("New value for attribute ", 
#&gt;                   list("name"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "This operator extracts or sets attributes for regular objects and\n", 
#&gt;                 "S4 fields for S4 objects.\n"), "\n", list("\n", 
#&gt;                 "# Unlike `@`, this operator extracts attributes for any kind of\n", 
#&gt;                 "# objects:\n", "factor(1:3) %@% \"levels\"\n", 
#&gt;                 "mtcars %@% class\n", "\n", "mtcars %@% class &lt;- NULL\n", 
#&gt;                 "mtcars\n", "\n", "# It also works on S4 objects:\n", 
#&gt;                 ".Person &lt;- setClass(\"Person\", slots = c(name = \"character\", species = \"character\"))\n", 
#&gt;                 "fievel &lt;- .Person(name = \"Fievel\", species = \"mouse\")\n", 
#&gt;                 "fievel %@% name\n"), "\n"), `op-na-default.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-na-default"), "\n", list("op-na-default"), 
#&gt;             "\n", list("%|%"), "\n", list("Replace missing values"), 
#&gt;             "\n", list("\n", "x %|% y\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("The original values.")), "\n", 
#&gt;                 "\n", list(list("y"), list("The replacement values. Must be of length 1 or the same length as ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "This infix function is similar to ", 
#&gt;                 list("%||%"), " but is vectorised\n", "and provides a default value for missing elements. It is faster\n", 
#&gt;                 "than using ", list(list("base::ifelse()")), 
#&gt;                 " and does not perform type conversions.\n"), 
#&gt;             "\n", list("\n", "c(\"a\", \"b\", NA, \"c\") %|% \"default\"\n", 
#&gt;                 "c(1L, NA, 3L, NA, NA) %|% (6L:10L)\n"), "\n", 
#&gt;             list("\n", list("op-null-default"), "\n"), "\n"), 
#&gt;         `op-null-default.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/operators.R", 
#&gt;             "\n", list("op-null-default"), "\n", list("op-null-default"), 
#&gt;             "\n", list("%||%"), "\n", list("Default value for ", 
#&gt;                 list("NULL")), "\n", list("\n", "x %||% y\n"), 
#&gt;             "\n", list("\n", list(list("x, y"), list("If ", list(
#&gt;                 "x"), " is NULL, will return ", list("y"), "; otherwise returns ", 
#&gt;                 list("x"), ".")), "\n"), "\n", list("\n", "This infix function makes it easy to replace ", 
#&gt;                 list("NULL"), "s with a default\n", "value. It's inspired by the way that Ruby's or operation (", 
#&gt;                 list("||"), ")\n", "works.\n"), "\n", list("\n", 
#&gt;                 "1 %||% 2\n", "NULL %||% 2\n"), "\n"), overscope_eval_next.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("overscope_eval_next"), "\n", list("overscope_eval_next"), 
#&gt;             "\n", list("Evaluate next quosure in a data mask"), 
#&gt;             "\n", list("\n", "overscope_eval_next(overscope, quo, env = base_env())\n"), 
#&gt;             "\n", list("\n", list(list("overscope"), list("A valid overscope containing bindings for ", 
#&gt;                 list("~"), ",\n", list(".top_env"), " and ", 
#&gt;                 list("_F"), " and whose parents contain overscoped bindings\n", 
#&gt;                 "for tidy evaluation.")), "\n", "\n", list(list(
#&gt;                 "quo"), list("A quosure.")), "\n", "\n", list(
#&gt;                 list("env"), list("The lexical enclosure in case ", 
#&gt;                   list("quo"), " is not a validly\n", "scoped quosure. This is the ", 
#&gt;                   list("base environment"), " by\n", "default.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("overscope_eval_next()"), " is deprecated as of rlang 0.2.0. Please use\n", 
#&gt;                 list("eval_tidy()"), " to which you can now supply an overscope.\n"), 
#&gt;             "\n", list("internal"), "\n"), pairlist2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("pairlist2"), "\n", list("pairlist2"), "\n", 
#&gt;             list("Create pairlists with splicing support"), "\n", 
#&gt;             list("\n", "pairlist2(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Arguments stored in the pairlist. Empty arguments are\n", 
#&gt;                   "preserved.")), "\n"), "\n", list("\n", "This pairlist constructor supports ", 
#&gt;                 list("tidy dots"), " features\n", "like ", list(
#&gt;                   "!!!"), ". Use it to manually create argument lists for calls or\n", 
#&gt;                 "parameter lists for functions.\n"), "\n", list(
#&gt;                 "\n", "# Unlike `exprs()`, `pairlist2()` evaluates its arguments.\n", 
#&gt;                 "new_function(pairlist2(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "new_function(exprs(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "\n", "# It preserves missing arguments, which is useful for creating\n", 
#&gt;                 "# parameters without defaults:\n", "new_function(pairlist2(x = , y = 3 * 6), quote(x * y))\n"), 
#&gt;             "\n"), parse_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parse.R", 
#&gt;             "\n", list("parse_expr"), "\n", list("parse_expr"), 
#&gt;             "\n", list("parse_exprs"), "\n", list("parse_quo"), 
#&gt;             "\n", list("parse_quos"), "\n", list("Parse R code"), 
#&gt;             "\n", list("\n", "parse_expr(x)\n", "\n", "parse_exprs(x)\n", 
#&gt;                 "\n", "parse_quo(x, env)\n", "\n", "parse_quos(x, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("parse_expr()"), 
#&gt;                 " returns an ", list("expression"), ",\n", list(
#&gt;                   "parse_exprs()"), " returns a list of expressions. Note that for the\n", 
#&gt;                 "plural variants the length of the output may be greater than the\n", 
#&gt;                 "length of the input. This would happen is one of the strings\n", 
#&gt;                 "contain several expressions (such as ", list(
#&gt;                   "\"foo; bar\""), ").\n"), "\n", list("\n", 
#&gt;                 "These functions parse and transform text into R expressions. This\n", 
#&gt;                 "is the first step to interpret or evaluate a piece of R code\n", 
#&gt;                 "written by a programmer.\n"), "\n", list("\n", 
#&gt;                 list("parse_expr()"), " returns one expression. If the text contains more\n", 
#&gt;                 "than one expression (separated by semicolons or new lines), an error is\n", 
#&gt;                 "issued. On the other hand ", list("parse_exprs()"), 
#&gt;                 " can handle multiple\n", "expressions. It always returns a list of expressions (compare to\n", 
#&gt;                 list(list("base::parse()")), " which returns a base::expression vector). All\n", 
#&gt;                 "functions also support R connections.\n", "\n", 
#&gt;                 "The versions suffixed with ", list("_quo"), 
#&gt;                 " and ", list("_quos"), " return\n", list("quosures"), 
#&gt;                 " rather than raw expressions.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " ", list("parse_quosure()"), " and ", 
#&gt;                   list("parse_quosures()"), " were soft-deprecated in\n", 
#&gt;                   "rlang 0.2.0 and renamed to ", list("parse_quo()"), 
#&gt;                   " and ", list("parse_quos()"), ". This\n", 
#&gt;                   "is consistent with the rule that abbreviated suffixes indicate\n", 
#&gt;                   "the return type of a function.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# parse_expr() can parse any R expression:\n", 
#&gt;                 "parse_expr(\"mtcars %&gt;% dplyr::mutate(cyl_prime = cyl / sd(cyl))\")\n", 
#&gt;                 "\n", "# A string can contain several expressions separated by ; or \\n\n", 
#&gt;                 "parse_exprs(\"NULL; list()\\n foo(bar)\")\n", 
#&gt;                 "\n", "# You can also parse source files by passing a R connection. Let's\n", 
#&gt;                 "# create a file containing R code:\n", "path &lt;- tempfile(\"my-file.R\")\n", 
#&gt;                 "cat(\"1; 2; mtcars\", file = path)\n", "\n", 
#&gt;                 "# We can now parse it by supplying a connection:\n", 
#&gt;                 "parse_exprs(file(path))\n"), "\n", list("\n", 
#&gt;                 list(list("base::parse()")), "\n"), "\n"), parse_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("parse_quosure"), "\n", list("parse_quosure"), 
#&gt;             "\n", list("parse_quosures"), "\n", list("Parse text into a quosure"), 
#&gt;             "\n", list("\n", "parse_quosure(x, env = caller_env())\n", 
#&gt;                 "\n", "parse_quosures(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("parse_quo()")), "\n", "and ", list(
#&gt;                   list("parse_quos()")), " in rlang 0.2.0. This is for consistency with the\n", 
#&gt;                 "convention that suffixes indicating return types are not\n", 
#&gt;                 "abbreviated.\n"), "\n", list("internal"), "\n"), 
#&gt;         prepend.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("prepend"), "\n", list("prepend"), "\n", 
#&gt;             list("modify"), "\n", list("Prepend a vector"), "\n", 
#&gt;             list("\n", "prepend(x, values, before = 1)\n", "\n", 
#&gt;                 "modify(.x, ...)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("the vector to be modified.")), "\n", 
#&gt;                 "\n", list(list("values"), list("to be included in the modified vector.")), 
#&gt;                 "\n", "\n", list(list("before"), list("a subscript, before which the values are to be appended.")), 
#&gt;                 "\n", "\n", list(list(".x"), list("A vector to modify.")), 
#&gt;                 "\n", "\n", list(list("..."), list("List of elements to merge into ", 
#&gt;                   list(".x"), ". Named elements\n", "already existing in ", 
#&gt;                   list(".x"), " are used as replacements. Elements that\n", 
#&gt;                   "have new or no names are inserted at the end. These dots support\n", 
#&gt;                   list("tidy dots"), " features.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "Vector functions are now out of scope for rlang. They might be\n", 
#&gt;                 "revived in the vctrs or funs packages.\n"), 
#&gt;             "\n", list("internal"), "\n"), prim_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "prim_name"), "\n", list("prim_name"), "\n", 
#&gt;             list("Name of a primitive function"), "\n", list(
#&gt;                 "\n", "prim_name(prim)\n"), "\n", list("\n", 
#&gt;                 list(list("prim"), list("A primitive function such as ", 
#&gt;                   list(list("base::c()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "Name of a primitive function\n"), "\n", 
#&gt;             list("internal"), "\n"), quasiquotation.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("quasiquotation"), "\n", list("quasiquotation"), 
#&gt;             "\n", list("UQ"), "\n", list("UQS"), "\n", list("{{}}"), 
#&gt;             "\n", list("{{"), "\n", list("!!"), "\n", list("!!!"), 
#&gt;             "\n", list(":="), "\n", list("qq_show"), "\n", list(
#&gt;                 "Quasiquotation of an expression"), "\n", list(
#&gt;                 "\n", "qq_show(expr)\n"), "\n", list("\n", list(
#&gt;                 list("expr"), list("An expression to be quasiquoted.")), 
#&gt;                 "\n"), "\n", list("\n", "Quasiquotation is the mechanism that makes it possible to program\n", 
#&gt;                 "flexibly with tidy evaluation grammars like dplyr. It is enabled in\n", 
#&gt;                 "all functions quoting their arguments with ", 
#&gt;                 list("enquo()"), ", ", list("enexpr()"), ",\n", 
#&gt;                 "or the plural variants.\n", "\n", "Quasiquotation is the combination of quoting an expression while\n", 
#&gt;                 "allowing immediate evaluation (unquoting) of part of that\n", 
#&gt;                 "expression. We provide both syntactic operators and functional\n", 
#&gt;                 "forms for unquoting.\n", list("\n", list(), 
#&gt;                   " The ", list("!!"), " operator unquotes its argument. It gets evaluated\n", 
#&gt;                   "immediately in the surrounding context.\n", 
#&gt;                   list(), " The ", list("!!!"), " operator unquotes and splices its argument. The\n", 
#&gt;                   "argument should represent a list or a vector. Each element will\n", 
#&gt;                   "be embedded in the surrounding call, i.e. each element is\n", 
#&gt;                   "inserted as an argument. If the vector is named, the names are\n", 
#&gt;                   "used as argument names.\n", "\n", "If the vector is a classed object (like a factor), it is\n", 
#&gt;                   "converted to a list with ", list(list("base::as.list()")), 
#&gt;                   " to ensure proper\n", "dispatch. If it is an S4 objects, it is converted to a list with\n", 
#&gt;                   list(list("methods::as()")), ".\n", list(), 
#&gt;                   " The ", list("{{ }}"), " operator quotes and unquotes its argument in one\n", 
#&gt;                   "go, a pattern that we call ", list("interpolation"), 
#&gt;                   ". It is an alias for\n", list("!!enquo(arg)"), 
#&gt;                   ".\n", "\n", "Like ", list("enquo()"), ", ", 
#&gt;                   list("{{ }}"), " is used in functions to capture an\n", 
#&gt;                   "argument as a quoted expression. This expression is immediately\n", 
#&gt;                   "unquoted in place.\n"), "\n", "\n", "Use ", 
#&gt;                 list("qq_show()"), " to experiment with quasiquotation or debug the\n", 
#&gt;                 "effect of unquoting operators. ", list("qq_show()"), 
#&gt;                 " quotes its input,\n", "processes unquoted parts, and prints the result with\n", 
#&gt;                 list(list("expr_print()")), ". This expression printer has a clearer output than\n", 
#&gt;                 "the base R printer (see the ", list("documentation topic"), 
#&gt;                 ").\n"), "\n", list(list("Unquoting names"), 
#&gt;                 list("\n", "\n", "\n", "When a function takes multiple named arguments\n", 
#&gt;                   "(e.g. ", list("dplyr::mutate()"), "), it is difficult to supply a variable as\n", 
#&gt;                   "name. Since the LHS of ", list("="), " is quoted, giving the name of a variable\n", 
#&gt;                   "results in the argument having the name of the variable rather than\n", 
#&gt;                   "the name stored in that variable. This problem is right up the\n", 
#&gt;                   "alley for the unquoting operator ", list("!!"), 
#&gt;                   ". If you were able to unquote\n", "the variable when supplying the name, the argument would be named\n", 
#&gt;                   "after the content of that variable.\n", "\n", 
#&gt;                   "Unfortunately R is very strict about the kind of expressions\n", 
#&gt;                   "supported on the LHS of ", list("="), ". This is why we have made the more\n", 
#&gt;                   "flexible ", list(":="), " operator an alias of ", 
#&gt;                   list("="), ". You can use it to supply\n", 
#&gt;                   "names, e.g. ", list("a := b"), " is equivalent to ", 
#&gt;                   list("a = b"), ". Since its syntax is\n", "more flexible you can unquote on the LHS:", 
#&gt;                   list("name &lt;- \"Jane\"\n", "\n", "list2(!!name := 1 + 2)\n", 
#&gt;                     "exprs(!!name := 1 + 2)\n", "quos(!!name := 1 + 2)\n"), 
#&gt;                   "\n", "\n", "Like ", list("="), ", the ", list(
#&gt;                     ":="), " operator expects strings or symbols on its LHS.\n", 
#&gt;                   "\n", "Note that unquoting on the LHS of ", 
#&gt;                   list(":="), " only works in top level\n", "expressions. These are all valid:", 
#&gt;                   list("exprs(!!nm := x)\n", "tibble(!!nm := x)\n", 
#&gt;                     "list2(!!nm := x)\n"), "\n", "\n", "But deep-unquoting names isn't supported:", 
#&gt;                   list("expr(foo(!!nm := x))\n", "exprs(foo(!!nm := x))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Theory"), list(
#&gt;                 "\n", "\n", "\n", "Formally, ", list("quo()"), 
#&gt;                 " and ", list("expr()"), " are quasiquote functions, ", 
#&gt;                 list("!!"), " is\n", "the unquote operator, and ", 
#&gt;                 list("!!!"), " is the unquote-splice operator.\n", 
#&gt;                 "These terms have a rich history in Lisp languages, and live on in\n", 
#&gt;                 "modern languages like\n", list(list("https://docs.julialang.org/en/v1/manual/metaprogramming/"), 
#&gt;                   list("Julia")), "\n", "and\n", list(list("https://docs.racket-lang.org/reference/quasiquote.html"), 
#&gt;                   list("Racket")), ".\n")), "\n", "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " Calling ", list("UQ()"), " and ", 
#&gt;                   list("UQS()"), " with the rlang namespace qualifier is\n", 
#&gt;                   "deprecated as of rlang 0.3.0. Just use the unqualified forms\n", 
#&gt;                   "instead:", list("# Bad\n", "rlang::expr(mean(rlang::UQ(var) * 100))\n", 
#&gt;                     "\n", "# Ok\n", "rlang::expr(mean(UQ(var) * 100))\n", 
#&gt;                     "\n", "# Good\n", "rlang::expr(mean(!!var * 100))\n"), 
#&gt;                   "\n", "\n", "Supporting namespace qualifiers complicates the implementation of\n", 
#&gt;                   "unquotation and is misleading as to the nature of unquoting\n", 
#&gt;                   "operators (which are syntactic operators that operates at\n", 
#&gt;                   "quotation-time rather than function calls at evaluation-time).\n", 
#&gt;                   list(), " ", list("UQ()"), " and ", list("UQS()"), 
#&gt;                   " were soft-deprecated in rlang 0.2.0 in order\n", 
#&gt;                   "to make the syntax of quasiquotation more consistent. The prefix\n", 
#&gt;                   "forms are now ", list("`!!`()"), " and ", 
#&gt;                   list("`!!!`()"), " which is\n", "consistent with other R operators (e.g. ", 
#&gt;                   list("`+`(a, b)"), " is the\n", "prefix form of ", 
#&gt;                   list("a + b"), ").\n", "\n", "Note that the prefix forms are not as relevant as before because\n", 
#&gt;                   list("!!"), " now has the right operator precedence, i.e. the same as\n", 
#&gt;                   "unary ", list("-"), " or ", list("+"), ". It is thus safe to mingle it with other\n", 
#&gt;                   "operators, e.g. ", list("!!a + !!b"), " does the right thing. In addition the\n", 
#&gt;                   "parser now strips one level of parentheses around unquoted\n", 
#&gt;                   "expressions. This way ", list("(!!\"foo\")(...)"), 
#&gt;                   " expands to ", list("foo(...)"), ".\n", "These changes make the prefix forms less useful.\n", 
#&gt;                   "\n", "Finally, the named functional forms ", 
#&gt;                   list("UQ()"), " and ", list("UQS()"), " were\n", 
#&gt;                   "misleading because they suggested that existing knowledge about\n", 
#&gt;                   "functions is applicable to quasiquotation. This was reinforced by\n", 
#&gt;                   "the visible definitions of these functions exported by rlang and\n", 
#&gt;                   "by the tidy eval parser interpreting ", list(
#&gt;                     "rlang::UQ()"), " as ", list("!!"), ". In\n", 
#&gt;                   "reality unquoting is ", list("not"), " a function call, it is a syntactic\n", 
#&gt;                   "operation. The operator form makes it clearer that unquoting is\n", 
#&gt;                   "special.\n"), "\n")), "\n", "\n", list("\n", 
#&gt;                 "# Interpolation with {{  }} is the easiest way to forward\n", 
#&gt;                 "# arguments to tidy eval functions:\n", "if (is_attached(\"package:dplyr\")) {\n", 
#&gt;                 "\n", "# Forward all arguments involving data frame columns by\n", 
#&gt;                 "# interpolating them within other data masked arguments.\n", 
#&gt;                 "# Here we interpolate `arg` in a `summarise()` call:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean({{ arg }}, na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "my_function(mtcars, cyl * 10)\n", 
#&gt;                 "\n", "# The  operator is just a shortcut for `!!enquo()`:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean(!!enquo(arg), na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "\n", 
#&gt;                 "}\n", "\n", "# Quasiquotation functions quote expressions like base::quote()\n", 
#&gt;                 "quote(how_many(this))\n", "expr(how_many(this))\n", 
#&gt;                 "quo(how_many(this))\n", "\n", "# In addition, they support unquoting. Let's store symbols\n", 
#&gt;                 "# (i.e. object names) in variables:\n", "this &lt;- sym(\"apples\")\n", 
#&gt;                 "that &lt;- sym(\"oranges\")\n", "\n", "# With unquotation you can insert the contents of these variables\n", 
#&gt;                 "# inside the quoted expression:\n", "expr(how_many(!!this))\n", 
#&gt;                 "expr(how_many(!!that))\n", "\n", "# You can also insert values:\n", 
#&gt;                 "expr(how_many(!!(1 + 2)))\n", "quo(how_many(!!(1 + 2)))\n", 
#&gt;                 "\n", "\n", "# Note that when you unquote complex objects into an expression,\n", 
#&gt;                 "# the base R printer may be a bit misleading. For instance compare\n", 
#&gt;                 "# the output of `expr()` and `quo()` (which uses a custom printer)\n", 
#&gt;                 "# when we unquote an integer vector:\n", "expr(how_many(!!(1:10)))\n", 
#&gt;                 "quo(how_many(!!(1:10)))\n", "\n", "# This is why it's often useful to use qq_show() to examine the\n", 
#&gt;                 "# result of unquotation operators. It uses the same printer as\n", 
#&gt;                 "# quosures but does not return anything:\n", 
#&gt;                 "qq_show(how_many(!!(1:10)))\n", "\n", "\n", 
#&gt;                 "# Use `!!!` to add multiple arguments to a function. Its argument\n", 
#&gt;                 "# should evaluate to a list or vector:\n", "args &lt;- list(1:3, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!!args))\n", "\n", "# You can combine the two\n", 
#&gt;                 "var &lt;- quote(xyz)\n", "extra_args &lt;- list(trim = 0.9, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!var , !!!extra_args))\n", "\n", "\n", 
#&gt;                 "# The plural versions have support for the `:=` operator.\n", 
#&gt;                 "# Like `=`, `:=` creates named arguments:\n", 
#&gt;                 "quos(mouse1 := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "# The `:=` is mainly useful to unquote names. Unlike `=` it\n", 
#&gt;                 "# supports `!!` on its LHS:\n", "var &lt;- \"unquote me!\"\n", 
#&gt;                 "quos(!!var := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "\n", "# All these features apply to dots captured by enquos():\n", 
#&gt;                 "fn &lt;- function(...) enquos(...)\n", "fn(!!!args, !!var := penny)\n", 
#&gt;                 "\n", "\n", "# Unquoting is especially useful for building an expression by\n", 
#&gt;                 "# expanding around a variable part (the unquoted part):\n", 
#&gt;                 "quo1 &lt;- quo(toupper(foo))\n", "quo1\n", "\n", 
#&gt;                 "quo2 &lt;- quo(paste(!!quo1, bar))\n", "quo2\n", 
#&gt;                 "\n", "quo3 &lt;- quo(list(!!quo2, !!!syms(letters[1:5])))\n", 
#&gt;                 "quo3\n"), "\n"), quo_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("quo_expr"), "\n", list("quo_expr"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_expr(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated, please use ", 
#&gt;                 list(list("quo_squash()")), " instead.\n"), "\n", 
#&gt;             list("internal"), "\n"), quo_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quo.R", "\n", 
#&gt;             list("quo_label"), "\n", list("quo_label"), "\n", 
#&gt;             list("quo_text"), "\n", list("quo_name"), "\n", list(
#&gt;                 "Format quosures for printing or labelling"), 
#&gt;             "\n", list("\n", "quo_label(quo)\n", "\n", "quo_text(quo, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "quo_name(quo)\n"), "\n", list("\n", list(
#&gt;                 list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("Note:"), " You should now use ", 
#&gt;                 list(list("as_label()")), " or ", list(list("as_name()")), 
#&gt;                 " instead\n", "of ", list("quo_name()"), ". See life cycle section below.\n", 
#&gt;                 "\n", "These functions take an arbitrary R object, typically an\n", 
#&gt;                 list("expression"), ", and represent it as a string.\n", 
#&gt;                 list("\n", list(), " ", list("quo_name()"), " returns an abbreviated representation of the object\n", 
#&gt;                   "as a single line string. It is suitable for default names.\n", 
#&gt;                   list(), " ", list("quo_text()"), " returns a multiline string. For instance block\n", 
#&gt;                   "expressions like ", list("{ foo; bar }"), 
#&gt;                   " are represented on 4 lines (one\n", "for each symbol, and the curly braces on their own lines).\n"), 
#&gt;                 "\n", "\n", "These deparsers are only suitable for creating default names or\n", 
#&gt;                 "printing output at the console. The behaviour of your functions\n", 
#&gt;                 "should not depend on deparsed objects. If you are looking for a way\n", 
#&gt;                 "of transforming symbols to strings, use ", list(
#&gt;                   list("as_string()")), " instead of\n", list(
#&gt;                   "quo_name()"), ". Unlike deparsing, the transformation between symbols\n", 
#&gt;                 "and strings is non-lossy and well defined.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are in the questioning life cycle stage.\n", 
#&gt;                 list("\n", list(), " ", list(list("as_label()")), 
#&gt;                   " and ", list(list("as_name()")), " should be used instead of\n", 
#&gt;                   list("quo_name()"), ". ", list("as_label()"), 
#&gt;                   " transforms any R object to a string\n", "but should only be used to create a default name. Labelisation is\n", 
#&gt;                   "not a well defined operation and no assumption should be made\n", 
#&gt;                   "about the label. On the other hand, ", list(
#&gt;                     "as_name()"), " only works with\n", "(possibly quosured) symbols, but is a well defined and\n", 
#&gt;                   "deterministic operation.\n", list(), " We don't have a good replacement for ", 
#&gt;                   list("quo_text()"), " yet. See\n", list("https://github.com/r-lib/rlang/issues/636"), 
#&gt;                   " to follow discussions\n", "about a new deparsing API.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(foo(!! quo(bar)))\n", "quo\n", "\n", 
#&gt;                 "# quo_squash() unwraps all quosures and returns a raw expression:\n", 
#&gt;                 "quo_squash(quo)\n", "\n", "# This is used by quo_text() and quo_label():\n", 
#&gt;                 "quo_text(quo)\n", "\n", "# Compare to the unwrapped expression:\n", 
#&gt;                 "expr_text(quo)\n", "\n", "# quo_name() is helpful when you need really short labels:\n", 
#&gt;                 "quo_name(quo(sym))\n", "quo_name(quo(!! sym))\n"), 
#&gt;             "\n", list("\n", list(list("expr_label()")), ", ", 
#&gt;                 list(list("f_label()")), "\n"), "\n"), quo_squash.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quo_squash"), "\n", list("quo_squash"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_squash(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("quo_squash()"), " flattens all nested quosures within an expression.\n", 
#&gt;                 "For example it transforms ", list("^foo(^bar(), ^baz)"), 
#&gt;                 " to the bare\n", "expression ", list("foo(bar(), baz)"), 
#&gt;                 ".\n", "\n", "This operation is safe if the squashed quosure is used for\n", 
#&gt;                 "labelling or printing (see ", list(list("quo_label()")), 
#&gt;                 " or ", list(list("quo_name()")), "). However\n", 
#&gt;                 "if the squashed quosure is evaluated, all expressions of the\n", 
#&gt;                 "flattened quosures are resolved in a single environment. This is a\n", 
#&gt;                 "source of bugs so it is good practice to set ", 
#&gt;                 list("warn"), " to ", list("TRUE"), " to\n", 
#&gt;                 "let the user know about the lossy squashing.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "This function replaces ", list("quo_expr()"), 
#&gt;                 " which was deprecated in\n", "rlang 0.2.0. ", 
#&gt;                 list("quo_expr()"), " was a misnomer because it implied that it\n", 
#&gt;                 "was a mere expression acccessor for quosures whereas it was really\n", 
#&gt;                 "a lossy operation that squashed all nested quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(wrapper(!!quo(wrappee)))\n", "quo\n", 
#&gt;                 "\n", "# quo_squash() flattens all the quosures and returns a simple expression:\n", 
#&gt;                 "quo_squash(quo)\n"), "\n"), quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quosure"), "\n", list("quosure"), "\n", list(
#&gt;                 "is_quosure"), "\n", list("quo_is_missing"), 
#&gt;             "\n", list("quo_is_symbol"), "\n", list("quo_is_call"), 
#&gt;             "\n", list("quo_is_symbolic"), "\n", list("quo_is_null"), 
#&gt;             "\n", list("quo_get_expr"), "\n", list("quo_get_env"), 
#&gt;             "\n", list("quo_set_expr"), "\n", list("quo_set_env"), 
#&gt;             "\n", list("Quosure getters, setters and testers"), 
#&gt;             "\n", list("\n", "is_quosure(x)\n", "\n", "quo_is_missing(quo)\n", 
#&gt;                 "\n", "quo_is_symbol(quo, name = NULL)\n", "\n", 
#&gt;                 "quo_is_call(quo, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_symbolic(quo)\n", "\n", "quo_is_null(quo)\n", 
#&gt;                 "\n", "quo_get_expr(quo)\n", "\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo_set_expr(quo, expr)\n", "\n", "quo_set_env(quo, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("The name of the symbol or function call. If ", 
#&gt;                   list("NULL"), " the\n", "name is not tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("expr"), list(
#&gt;                   "A new expression for the quosure.")), "\n", 
#&gt;                 "\n", list(list("env"), list("A new environment for the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure is a type of ", 
#&gt;                 list("quoted expression"), " that includes\n", 
#&gt;                 "a reference to the context where it was created. A quosure is thus\n", 
#&gt;                 "guaranteed to evaluate in its original environment and can refer to\n", 
#&gt;                 "local objects.\n", "\n", "You can access the quosure components (its expression and its\n", 
#&gt;                 "environment) with:\n", list("\n", list(), " ", 
#&gt;                   list(list("get_expr()")), " and ", list(list(
#&gt;                     "get_env()")), ". These getters also support other\n", 
#&gt;                   "kinds of objects such as formulas.\n", list(), 
#&gt;                   " ", list("quo_get_expr()"), " and ", list(
#&gt;                     "quo_get_env()"), ". These getters only work\n", 
#&gt;                   "with quosures and throw an error with other types of input.\n"), 
#&gt;                 "\n", "\n", "Test if an object is a quosure with ", 
#&gt;                 list("is_quosure()"), ". If you know an\n", "object is a quosure, use the ", 
#&gt;                 list("quo_"), " prefixed predicates to check\n", 
#&gt;                 "its contents, ", list("quo_is_missing()"), ", ", 
#&gt;                 list("quo_is_symbol()"), ", etc.\n"), "\n", list(
#&gt;                 list("Quosured constants"), list("\n", "\n", 
#&gt;                   "\n", "A quosure usually does not carry environments for ", 
#&gt;                   list("constant objects"), " like strings or numbers. ", 
#&gt;                   list(list("quo()")), " and\n", list(list("enquo()")), 
#&gt;                   " only capture an environment for ", list("symbolic expressions"), 
#&gt;                   ". For instance, all of these return the\n", 
#&gt;                   list("empty environment"), ":", list("quo_get_env(quo(\"constant\"))\n", 
#&gt;                     "quo_get_env(quo(100))\n", "quo_get_env(quo(NA))\n"), 
#&gt;                   "\n", "\n", "On the other hand, quosures capture the environment of symbolic\n", 
#&gt;                   "expressions, i.e. expressions whose meaning depends on the\n", 
#&gt;                   "environment in which they are evaluated and what objects are\n", 
#&gt;                   "defined there:", list("quo_get_env(quo(some_object))\n", 
#&gt;                     "quo_get_env(quo(some_function()))\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Empty quosures"), list("\n", 
#&gt;                 "\n", "\n", "When missing arguments are captured as quosures, either through\n", 
#&gt;                 list(list("enquo()")), " or ", list(list("quos()")), 
#&gt;                 ", they are returned as an empty quosure. These\n", 
#&gt;                 "quosures contain the ", list("missing argument"), 
#&gt;                 " and typically\n", "have the ", list("empty environment"), 
#&gt;                 " as enclosure.\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "is_quosure()"), " is stable.\n", list(), " ", 
#&gt;                   list("quo_get_expr()"), " and ", list("quo_get_env()"), 
#&gt;                   " are stable.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "quo &lt;- quo(my_quosure)\n", "quo\n", "\n", 
#&gt;                 "\n", "# Access and set the components of a quosure:\n", 
#&gt;                 "quo_get_expr(quo)\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo &lt;- quo_set_expr(quo, quote(baz))\n", 
#&gt;                 "quo &lt;- quo_set_env(quo, empty_env())\n", "quo\n", 
#&gt;                 "\n", "# Test wether an object is a quosure:\n", 
#&gt;                 "is_quosure(quo)\n", "\n", "# If it is a quosure, you can use the specialised type predicates\n", 
#&gt;                 "# to check what is inside it:\n", "quo_is_symbol(quo)\n", 
#&gt;                 "quo_is_call(quo)\n", "quo_is_null(quo)\n", "\n", 
#&gt;                 "# quo_is_missing() checks for a special kind of quosure, the one\n", 
#&gt;                 "# that contains the missing argument:\n", "quo()\n", 
#&gt;                 "quo_is_missing(quo())\n", "\n", "fn &lt;- function(arg) enquo(arg)\n", 
#&gt;                 "fn()\n", "quo_is_missing(fn())\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), " for creating quosures by quotation; ", 
#&gt;                 list(list("as_quosure()")), "\n", "and ", list(
#&gt;                   list("new_quosure()")), " for constructing quosures manually.\n"), 
#&gt;             "\n"), quotation.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quotation.R", 
#&gt;             "\n", list("quotation"), "\n", list("quotation"), 
#&gt;             "\n", list("expr"), "\n", list("enexpr"), "\n", list(
#&gt;                 "exprs"), "\n", list("enexprs"), "\n", list("ensym"), 
#&gt;             "\n", list("ensyms"), "\n", list("quo"), "\n", list(
#&gt;                 "enquo"), "\n", list("quos"), "\n", list("enquos"), 
#&gt;             "\n", list("Quotation"), "\n", list("\n", "expr(expr)\n", 
#&gt;                 "\n", "enexpr(arg)\n", "\n", "exprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE)\n", "\n", 
#&gt;                 "enexprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "ensym(arg)\n", "\n", "ensyms(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "quo(expr)\n", "\n", "enquo(arg)\n", "\n", "quos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .unquote_names = TRUE)\n", "\n", "enquos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An expression.")), 
#&gt;                 "\n", "\n", list(list("arg"), list("A symbol representing an argument. The expression\n", 
#&gt;                   "supplied to that argument will be captured instead of being\n", 
#&gt;                   "evaluated.")), "\n", "\n", list(list("..."), 
#&gt;                   list("For ", list("enexprs()"), ", ", list(
#&gt;                     "ensyms()"), " and ", list("enquos()"), ", names of\n", 
#&gt;                     "arguments to capture without evaluation (including ", 
#&gt;                     list("..."), "). For\n", list("exprs()"), 
#&gt;                     " and ", list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                     "(including expressions contained in ", list(
#&gt;                       "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n", "\n", list(list(".unquote_names"), 
#&gt;                   list("Whether to treat ", list(":="), " as ", 
#&gt;                     list("="), ". Unlike ", list("="), ", the\n", 
#&gt;                     list(":="), " syntax supports ", list("!!"), 
#&gt;                     " unquoting on the LHS.")), "\n", "\n", list(
#&gt;                   list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                     "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                     list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                     " to only keep the first occurrences, to ", 
#&gt;                     list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                     list("\"error\""), " to raise an informative\n", 
#&gt;                     "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "Quotation is a mechanism by which an expression supplied as\n", 
#&gt;                 "argument is captured by a function. Instead of seeing the value of\n", 
#&gt;                 "the argument, the function sees the recipe (the R code) to make\n", 
#&gt;                 "that value. This is possible because R ", list(
#&gt;                   "expressions"), " are\n", "representable as regular objects in R:\n", 
#&gt;                 list("\n", list(), " Calls represent the action of calling a function to\n", 
#&gt;                   "compute a new value. Evaluating a call causes that value to be\n", 
#&gt;                   "computed. Calls typically involve symbols to reference R objects.\n", 
#&gt;                   list(), " Symbols represent the name that is given to an object in a\n", 
#&gt;                   "particular context (an ", list("environment"), 
#&gt;                   ").\n"), "\n", "\n", "We call objects containing calls and symbols ", 
#&gt;                 list("expressions"), ".\n", "There are two ways to create R expressions. First you can ", 
#&gt;                 list("build"), "\n", "calls and symbols from parts and pieces (see ", 
#&gt;                 list(list("sym()")), ", ", list(list("syms()")), 
#&gt;                 " and\n", list(list("call2()")), "). The other way is by ", 
#&gt;                 list("quotation"), " or ", list("quasiquotation"), 
#&gt;                 ",\n", "i.e. by intercepting an expression instead of evaluating it.\n"), 
#&gt;             "\n", list(list("User expressions versus your expressions"), 
#&gt;                 list("\n", "\n", "\n", "There are two points of view when it comes to capturing an\n", 
#&gt;                   "expression:\n", list("\n", list(), " You can capture the expressions supplied by ", 
#&gt;                     list("the user"), " of your\n", "function. This is the purpose of ", 
#&gt;                     list("ensym()"), ", ", list("enexpr()"), 
#&gt;                     " and\n", list("enquo()"), " and their plural variants. These functions take an\n", 
#&gt;                     "argument name and capture the expression that was supplied to\n", 
#&gt;                     "that argument.\n", list(), " You can capture the expressions that ", 
#&gt;                     list("you"), " supply. To this end\n", "use ", 
#&gt;                     list("expr()"), " and ", list("quo()"), " and their plural variants ", 
#&gt;                     list("exprs()"), " and\n", list("quos()"), 
#&gt;                     ".\n"), "\n")), "\n", "\n", list(list("Capture raw expressions"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "enexpr()"), " and ", list("expr()"), " capture a single raw expression.\n", 
#&gt;                   list(), " ", list("enexprs()"), " and ", list(
#&gt;                     "exprs()"), " capture a list of raw expressions\n", 
#&gt;                   "including expressions contained in ", list(
#&gt;                     "..."), ".\n", list(), " ", list("ensym()"), 
#&gt;                   " and ", list("ensyms()"), " are variants of ", 
#&gt;                   list("enexpr()"), " and\n", list("enexprs()"), 
#&gt;                   " that check the captured expression is either a string\n", 
#&gt;                   "(which they convert to symbol) or a symbol. If anything else\n", 
#&gt;                   "is supplied they throw an error.\n"), "\n", 
#&gt;                   "\n", "In terms of base functions, ", list(
#&gt;                     "enexpr(arg)"), " corresponds to\n", list(
#&gt;                     "base::substitute(arg)"), " (though that function also features complex\n", 
#&gt;                   "substitution semantics) and ", list("expr()"), 
#&gt;                   " is like ", list(list("quote()")), " (and\n", 
#&gt;                   list(list("bquote()")), " if we consider unquotation syntax). The plural variant\n", 
#&gt;                   list("exprs()"), " is equivalent to ", list(
#&gt;                     list("base::alist()")), ". Finally there is no\n", 
#&gt;                   "function in base R that is equivalent to ", 
#&gt;                   list("enexprs()"), " but you can\n", "reproduce its behaviour with ", 
#&gt;                   list("eval(substitute(alist(...)))"), ".\n")), 
#&gt;             "\n", "\n", list(list("Capture expressions in quosures"), 
#&gt;                 list("\n", "\n", "\n", list("quo()"), " and ", 
#&gt;                   list("enquo()"), " are similar to their ", 
#&gt;                   list("expr"), " counterparts but\n", "capture both the expression and its environment in an object called\n", 
#&gt;                   "a quosure. This wrapper contains a reference to the original\n", 
#&gt;                   "environment in which that expression was captured. Keeping track of\n", 
#&gt;                   "the environments of expressions is important because this is where\n", 
#&gt;                   "functions and objects mentioned in the expression are defined.\n", 
#&gt;                   "\n", "Quosures are objects that can be evaluated with ", 
#&gt;                   list(list("eval_tidy()")), " just\n", "like symbols or function calls. Since they always evaluate in their\n", 
#&gt;                   "original environment, quosures can be seen as vehicles that allow\n", 
#&gt;                   "expressions to travel from function to function but that beam back\n", 
#&gt;                   "instantly to their original environment upon evaluation.\n", 
#&gt;                   "\n", "See the ", list("quosure"), " help topic about tools to work with quosures.\n")), 
#&gt;             "\n", "\n", list(list("Quasiquotation"), list("\n", 
#&gt;                 "\n", "\n", "All quotation functions in rlang have support for ", 
#&gt;                 list("unquoting operators"), ". The combination of quotation and\n", 
#&gt;                 "unquotation is called ", list("quasiquotation"), 
#&gt;                 ".\n", "\n", "Unquotation provides a way to refer to variables during quotation.\n", 
#&gt;                 "Variables are problematic when quoting because a captured\n", 
#&gt;                 "expression is essentially a constant, just like a string is a\n", 
#&gt;                 "constant. For instance in all the following cases ", 
#&gt;                 list("apple"), " is a\n", "constant: ", list(
#&gt;                   "~apple"), ", ", list("\"apple\""), " and ", 
#&gt;                 list("expr(apple)"), ". Unquoting allows\n", 
#&gt;                 "you to introduce a part of variability within a captured\n", 
#&gt;                 "expression.\n", list("\n", list(), " In the case of ", 
#&gt;                   list("enexpr()"), " and ", list("enquo()"), 
#&gt;                   ", unquoting provides an\n", "escape hatch to the users of your function that allows them to\n", 
#&gt;                   "manipulate the expression that you capture.\n", 
#&gt;                   list(), " In the case of ", list("expr()"), 
#&gt;                   " and ", list("quo()"), ", quasiquotation lets you\n", 
#&gt;                   "build a complex expressions where some parts are constant (the\n", 
#&gt;                   "parts that are captured) and some parts are variable (the parts\n", 
#&gt;                   "that are unquoted).\n"), "\n", "\n", "See the ", 
#&gt;                 list("quasiquotation"), " help topic for more about this as well as\n", 
#&gt;                 list(list("https://adv-r.hadley.nz/quasiquotation.html"), 
#&gt;                   list("the chapter in Advanced R")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# expr() and exprs() capture expressions that you supply:\n", 
#&gt;                 "expr(symbol)\n", "exprs(several, such, symbols)\n", 
#&gt;                 "\n", "# enexpr() and enexprs() capture expressions that your user supplied:\n", 
#&gt;                 "expr_inputs &lt;- function(arg, ...) {\n", "  user_exprs &lt;- enexprs(arg, ...)\n", 
#&gt;                 "  user_exprs\n", "}\n", "expr_inputs(hello)\n", 
#&gt;                 "expr_inputs(hello, bonjour, ciao)\n", "\n", 
#&gt;                 "# ensym() and ensyms() provide additional type checking to ensure\n", 
#&gt;                 "# the user calling your function has supplied bare object names:\n", 
#&gt;                 "sym_inputs &lt;- function(...) {\n", "  user_symbols &lt;- ensyms(...)\n", 
#&gt;                 "  user_symbols\n", "}\n", "sym_inputs(hello, \"bonjour\")\n", 
#&gt;                 "## sym_inputs(say(hello))  # Error: Must supply symbols or strings\n", 
#&gt;                 "expr_inputs(say(hello))\n", "\n", "\n", "# All these quoting functions have quasiquotation support. This\n", 
#&gt;                 "# means that you can unquote (evaluate and inline) part of the\n", 
#&gt;                 "# captured expression:\n", "what &lt;- sym(\"bonjour\")\n", 
#&gt;                 "expr(say(what))\n", "expr(say(!!what))\n", "\n", 
#&gt;                 "# This also applies to expressions supplied by the user. This is\n", 
#&gt;                 "# like an escape hatch that allows control over the captured\n", 
#&gt;                 "# expression:\n", "expr_inputs(say(!!what), !!what)\n", 
#&gt;                 "\n", "\n", "# Finally, you can capture expressions as quosures. A quosure is an\n", 
#&gt;                 "# object that contains both the expression and its environment:\n", 
#&gt;                 "quo &lt;- quo(letters)\n", "quo\n", "\n", "get_expr(quo)\n", 
#&gt;                 "get_env(quo)\n", "\n", "# Quosures can be evaluated with eval_tidy():\n", 
#&gt;                 "eval_tidy(quo)\n", "\n", "# They have the nice property that you can pass them around from\n", 
#&gt;                 "# context to context (that is, from function to function) and they\n", 
#&gt;                 "# still evaluate in their original environment:\n", 
#&gt;                 "multiply_expr_by_10 &lt;- function(expr) {\n", 
#&gt;                 "  # We capture the user expression and its environment:\n", 
#&gt;                 "  expr &lt;- enquo(expr)\n", "\n", "  # Then create an object that only exists in this function:\n", 
#&gt;                 "  local_ten &lt;- 10\n", "\n", "  # Now let's create a multiplication expression that (a) inlines\n", 
#&gt;                 "  # the user expression as LHS (still wrapped in its quosure) and\n", 
#&gt;                 "  # (b) refers to the local object in the RHS:\n", 
#&gt;                 "  quo(!!expr * local_ten)\n", "}\n", "quo &lt;- multiply_expr_by_10(2 + 3)\n", 
#&gt;                 "\n", "# The local parts of the quosure are printed in colour if your\n", 
#&gt;                 "# terminal is capable of displaying colours:\n", 
#&gt;                 "quo\n", "\n", "# All the quosures in the expression evaluate in their original\n", 
#&gt;                 "# context. The local objects are looked up properly and we get the\n", 
#&gt;                 "# expected result:\n", "eval_tidy(quo)\n"), 
#&gt;             "\n"), rep_along.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("rep_along"), "\n", list("rep_along"), 
#&gt;             "\n", list("rep_named"), "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "rep_along(along, x)\n", "\n", "rep_named(names, x)\n"), 
#&gt;             "\n", list("\n", list(list("along"), list("Vector whose length determine how many times ", 
#&gt;                 list("x"), "\n", "is repeated.")), "\n", "\n", 
#&gt;                 list(list("x"), list("Values to repeat.")), "\n", 
#&gt;                 "\n", list(list("names"), list("Names for the new vector. The length of ", 
#&gt;                   list("names"), "\n", "determines how many times ", 
#&gt;                   list("x"), " is repeated.")), "\n"), "\n", 
#&gt;             list("\n", "These functions take the idea of ", list(
#&gt;                 list("seq_along()")), " and apply it to\n", "repeating values.\n"), 
#&gt;             "\n", list("\n", "x &lt;- 0:5\n", "rep_along(x, 1:2)\n", 
#&gt;                 "rep_along(x, 1)\n", "\n", "# Create fresh vectors by repeating missing values:\n", 
#&gt;                 "rep_along(x, na_int)\n", "rep_along(x, na_chr)\n", 
#&gt;                 "\n", "# rep_named() repeats a value along a names vectors\n", 
#&gt;                 "rep_named(c(\"foo\", \"bar\"), list(letters))\n"), 
#&gt;             "\n", list("\n", "new-vector\n"), "\n"), restarting.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("restarting"), "\n", list("restarting"), 
#&gt;             "\n", list("Create a restarting handler"), "\n", 
#&gt;             list("\n", "restarting(.restart, ..., .fields = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Additional arguments passed on the restart\n", 
#&gt;                   "function. These arguments are evaluated only once and\n", 
#&gt;                   "immediately, when creating the restarting handler. Furthermore,\n", 
#&gt;                   "they support ", list("tidy dots"), " features.")), 
#&gt;                 "\n", "\n", list(list(".fields"), list("A character vector specifying the fields of the\n", 
#&gt;                   "condition that should be passed as arguments to the restart. If\n", 
#&gt;                   "named, the names (except empty names ", list(
#&gt;                     "\"\""), ") are used as\n", "argument names for calling the restart function. Otherwise the\n", 
#&gt;                   "the fields themselves are used as argument names.")), 
#&gt;                 "\n"), "\n", list("\n", "This constructor automates the common task of creating an\n", 
#&gt;                 list(list("calling()")), " handler that invokes a restart.\n"), 
#&gt;             "\n", list("\n", "Jumping to a restart point from a calling handler has two\n", 
#&gt;                 "effects. First, the control flow jumps to wherever the restart was\n", 
#&gt;                 "established, and the restart function is called (with ", 
#&gt;                 list("..."), ", or\n", list(".fields"), " as arguments). Execution resumes from the\n", 
#&gt;                 list(list("with_restarts()")), " call. Secondly, the transfer of the control flow\n", 
#&gt;                 "out of the function that signalled the condition means that the\n", 
#&gt;                 "handler has dealt with the condition. Thus the condition will not\n", 
#&gt;                 "be passed on to other potential handlers established on the stack.\n"), 
#&gt;             "\n", list("\n", "# This is a restart that takes a data frame and names as arguments\n", 
#&gt;                 "rst_bar &lt;- function(df, nms) {\n", "  stats::setNames(df, nms)\n", 
#&gt;                 "}\n", "\n", "# This restart is simpler and does not take arguments\n", 
#&gt;                 "rst_baz &lt;- function() \"baz\"\n", "\n", "# Signalling a condition parameterised with a data frame\n", 
#&gt;                 "fn &lt;- function() {\n", "  with_restarts(signal(\"A foobar condition occurred\", \"foo\", foo_field = mtcars),\n", 
#&gt;                 "    rst_bar = rst_bar,\n", "    rst_baz = rst_baz\n", 
#&gt;                 "  )\n", "}\n", "\n", "# Creating a restarting handler that passes arguments `nms` and\n", 
#&gt;                 "# `df`, the latter taken from a data field of the condition object\n", 
#&gt;                 "restart_bar &lt;- restarting(\"rst_bar\",\n", "  nms = LETTERS[1:11], .fields = c(df = \"foo_field\")\n", 
#&gt;                 ")\n", "\n", "# The restarting handlers jumps to `rst_bar` when `foo` is signalled:\n", 
#&gt;                 "with_handlers(fn(), foo = restart_bar)\n", "\n", 
#&gt;                 "# The restarting() constructor is especially nice to use with\n", 
#&gt;                 "# restarts that do not need arguments:\n", "with_handlers(fn(), foo = restarting(\"rst_baz\"))\n"), 
#&gt;             "\n", list("\n", list(list("calling()")), " and ", 
#&gt;                 list(list("exiting()")), ".\n"), "\n", list("internal"), 
#&gt;             "\n"), return_from.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("return_from"), "\n", list("return_from"), 
#&gt;             "\n", list("return_to"), "\n", list("Jump to or from a frame"), 
#&gt;             "\n", list("\n", "return_from(frame, value = NULL)\n", 
#&gt;                 "\n", "return_to(frame, value = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("frame"), list("An environment, a frame object, or any object with an\n", 
#&gt;                 list(list("get_env()")), " method. The environment should be an evaluation\n", 
#&gt;                 "environment currently on the stack.")), "\n", 
#&gt;                 "\n", list(list("value"), list("The return value.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "While ", list(list("base::return()")), 
#&gt;                 " can only return from the current local\n", 
#&gt;                 "frame, these two functions will return from any frame on the\n", 
#&gt;                 "current evaluation stack, between the global and the currently\n", 
#&gt;                 "active context. They provide a way of performing arbitrary\n", 
#&gt;                 "non-local jumps out of the function currently under evaluation.\n"), 
#&gt;             "\n", list("\n", list("return_from()"), " will jump out of ", 
#&gt;                 list("frame"), ". ", list("return_to()"), " is a bit\n", 
#&gt;                 "trickier. It will jump out of the frame located just before ", 
#&gt;                 list("frame"), "\n", "in the evaluation stack, so that control flow ends up in ", 
#&gt;                 list("frame"), ",\n", "at the location where the previous frame was called from.\n", 
#&gt;                 "\n", "These functions should only be used rarely. These sort of non-local\n", 
#&gt;                 "gotos can be hard to reason about in casual code, though they can\n", 
#&gt;                 "sometimes be useful. Also, consider to use the condition system to\n", 
#&gt;                 "perform non-local jumps.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "The support for ", 
#&gt;                 list("frame"), " object is soft-deprecated.  Please pass\n", 
#&gt;                 "simple environments to ", list("return_from()"), 
#&gt;                 " and ", list("return_to()"), ".\n", "\n", "These functions are in the questioning lifecycle because we are\n", 
#&gt;                 "considering simpler alternatives.\n")), "\n", 
#&gt;             "\n", list("\n", "# Passing fn() evaluation frame to g():\n", 
#&gt;                 "fn &lt;- function() {\n", "  val &lt;- g(current_env())\n", 
#&gt;                 "  cat(\"g returned:\", val, \"\\n\")\n", "  \"normal return\"\n", 
#&gt;                 "}\n", "g &lt;- function(env) h(env)\n", "\n", "# Here we return from fn() with a new return value:\n", 
#&gt;                 "h &lt;- function(env) return_from(env, \"early return\")\n", 
#&gt;                 "fn()\n", "\n", "# Here we return to fn(). The call stack unwinds until the last frame\n", 
#&gt;                 "# called by fn(), which is g() in that case.\n", 
#&gt;                 "h &lt;- function(env) return_to(env, \"early return\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), rlang_backtrace_on_error.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-abort.R", "\n", 
#&gt;             list("rlang_backtrace_on_error"), "\n", list("rlang_backtrace_on_error"), 
#&gt;             "\n", list("add_backtrace"), "\n", list("Display backtrace on error"), 
#&gt;             "\n", list("\n", "Errors thrown with ", list(list(
#&gt;                 "abort()")), " automatically save a backtrace that\n", 
#&gt;                 "can be inspected by calling ", list(list("last_error()")), 
#&gt;                 ". Optionally, you can\n", "also display the backtrace alongside the error message by setting\n", 
#&gt;                 "the option ", list("rlang_backtrace_on_error"), 
#&gt;                 " to one of the following\n", "values:\n", list(
#&gt;                   "\n", list(), " ", list("\"reminder\""), ": Display a reminder that the backtrace can be\n", 
#&gt;                   "inspected by calling ", list(list("rlang::last_error()")), 
#&gt;                   ".\n", list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                   list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                   list(), " ", list("\"full\""), ": Display the full backtrace tree.\n"), 
#&gt;                 "\n"), "\n", list(list("Promote base errors to rlang errors"), 
#&gt;                 list("\n", "\n", "\n", "Call ", list("options(error = rlang::enframe)"), 
#&gt;                   " to instrument base\n", "errors with rlang features. This handler does two things:\n", 
#&gt;                   list("\n", list(), " It saves the base error as an rlang object. This allows you to\n", 
#&gt;                     "call ", list(list("last_error()")), " to print the backtrace or inspect its data.\n", 
#&gt;                     list(), " It prints the backtrace for the current error according to the\n", 
#&gt;                     list(list("rlang_backtrace_on_error")), " option.\n"), 
#&gt;                   "\n")), "\n", "\n", list("\n", "# Display a simplified backtrace on error for both base and rlang\n", 
#&gt;                 "# errors:\n", "\n", "# options(\n", "#   rlang_backtrace_on_error = \"branch\",\n", 
#&gt;                 "#   error = rlang::enframe\n", "# )\n", "# stop(\"foo\")\n"), 
#&gt;             "\n"), rst_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_abort"), "\n", list("rst_abort"), 
#&gt;             "\n", list("Jump to the abort restart"), "\n", list(
#&gt;                 "\n", "rst_abort()\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"questioning\")"), "\n", 
#&gt;                 "\n", "The abort restart is the only restart that is established at top\n", 
#&gt;                 "level. It is used by R as a top-level target, most notably when an\n", 
#&gt;                 "error is issued (see ", list(list("abort()")), 
#&gt;                 ") that no handler is able\n", "to deal with (see ", 
#&gt;                 list(list("with_handlers()")), ").\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# The `abort` restart is a bit special in that it is always\n", 
#&gt;                 "# registered in a R session. You will always find it on the restart\n", 
#&gt;                 "# stack because it is established at top level:\n", 
#&gt;                 "rst_list()\n", "\n", "# You can use the `above` restart to jump to top level without\n", 
#&gt;                 "# signalling an error:\n", list("\n", "fn &lt;- function() {\n", 
#&gt;                   "  cat(\"aborting...\\n\")\n", "  rst_abort()\n", 
#&gt;                   "  cat(\"This is never called\\n\")\n", "}\n", 
#&gt;                   "{\n", "  fn()\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# The `above` restart is the target that R uses to jump to top\n", 
#&gt;                 "# level when critical errors are signalled:\n", 
#&gt;                 list("\n", "{\n", "  abort(\"error\")\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# If another `abort` restart is specified, errors are signalled as\n", 
#&gt;                 "# usual but then control flow resumes with from the new restart:\n", 
#&gt;                 list("\n", "out &lt;- NULL\n", "{\n", "  out &lt;- with_restarts(abort(\"error\"), abort = function() \"restart!\")\n", 
#&gt;                   "  cat(\"This is called\\n\")\n", "}\n", "cat(\"`out` has now become:\", out, \"\\n\")\n"), 
#&gt;                 "\n"), "\n", list("\n", list(list("rst_jump()")), 
#&gt;                 ", ", list(list("abort()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), rst_list.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_list"), "\n", list("rst_list"), "\n", 
#&gt;             list("rst_exists"), "\n", list("rst_jump"), "\n", 
#&gt;             list("rst_maybe_jump"), "\n", list("Restarts utilities"), 
#&gt;             "\n", list("\n", "rst_list()\n", "\n", "rst_exists(.restart)\n", 
#&gt;                 "\n", "rst_jump(.restart, ...)\n", "\n", "rst_maybe_jump(.restart, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed on to the restart function. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restarts are named jumping points established by ", 
#&gt;                 list(list("with_restarts()")), ".\n", list("rst_list()"), 
#&gt;                 " returns the names of all restarts currently\n", 
#&gt;                 "established. ", list("rst_exists()"), " checks if a given restart is\n", 
#&gt;                 "established. ", list("rst_jump()"), " stops execution of the current function\n", 
#&gt;                 "and jumps to a restart point. If the restart does not exist, an\n", 
#&gt;                 "error is thrown.  ", list("rst_maybe_jump()"), 
#&gt;                 " first checks that a restart\n", "exists before jumping.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 list(list("with_restarts()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), `scalar-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("scalar-type-predicates"), "\n", list("scalar-type-predicates"), 
#&gt;             "\n", list("is_scalar_list"), "\n", list("is_scalar_atomic"), 
#&gt;             "\n", list("is_scalar_vector"), "\n", list("is_scalar_integer"), 
#&gt;             "\n", list("is_scalar_double"), "\n", list("is_scalar_character"), 
#&gt;             "\n", list("is_scalar_logical"), "\n", list("is_scalar_raw"), 
#&gt;             "\n", list("is_string"), "\n", list("is_scalar_bytes"), 
#&gt;             "\n", list("is_bool"), "\n", list("Scalar type predicates"), 
#&gt;             "\n", list("\n", "is_scalar_list(x)\n", "\n", "is_scalar_atomic(x)\n", 
#&gt;                 "\n", "is_scalar_vector(x)\n", "\n", "is_scalar_integer(x)\n", 
#&gt;                 "\n", "is_scalar_double(x)\n", "\n", "is_scalar_character(x, encoding = NULL)\n", 
#&gt;                 "\n", "is_scalar_logical(x)\n", "\n", "is_scalar_raw(x)\n", 
#&gt;                 "\n", "is_string(x, string = NULL)\n", "\n", 
#&gt;                 "is_scalar_bytes(x)\n", "\n", "is_bool(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to be tested.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n", "\n", list(list("string"), list("A string to compare to ", 
#&gt;                   list("x"), ". If a character vector,\n", "returns ", 
#&gt;                   list("TRUE"), " if at least one element is equal to ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "These predicates check for a given type and whether the vector is\n", 
#&gt;                 "\"scalar\", that is, of length 1.\n", "\n", 
#&gt;                 "In addition to the length check, ", list("is_string()"), 
#&gt;                 " and ", list("is_bool()"), "\n", "return ", 
#&gt;                 list("FALSE"), " if their input is missing. This is useful for\n", 
#&gt;                 "type-checking arguments, when your function expects a single string\n", 
#&gt;                 "or a single ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ".\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("bare-type-predicates"), "\n"), "\n"), 
#&gt;         scoped_bindings.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("scoped_bindings"), "\n", list("scoped_bindings"), 
#&gt;             "\n", list("with_bindings"), "\n", list("Temporarily change bindings of an environment"), 
#&gt;             "\n", list("\n", "scoped_bindings(..., .env = .frame, .frame = caller_env())\n", 
#&gt;                 "\n", "with_bindings(.expr, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Pairs of names and values. These dots support splicing\n", 
#&gt;                 "(with value semantics) and name unquoting.")), 
#&gt;                 "\n", "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The frame environment that determines the scope of\n", 
#&gt;                   "the temporary bindings. When that frame is popped from the call\n", 
#&gt;                   "stack, bindings are switched back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary bindings.")), 
#&gt;                 "\n"), "\n", list("\n", list("scoped_bindings()"), 
#&gt;                 " returns the values of old bindings\n", "invisibly; ", 
#&gt;                 list("with_bindings()"), " returns the value of ", 
#&gt;                 list("expr"), ".\n"), "\n", list("\n", list("\n", 
#&gt;                 list(), " ", list("scoped_bindings()"), " temporarily changes bindings in ", 
#&gt;                 list(".env"), " (which\n", "is by default the caller environment). The bindings are reset to\n", 
#&gt;                 "their original values when the current frame (or an arbitrary one\n", 
#&gt;                 "if you specify ", list(".frame"), ") goes out of scope.\n", 
#&gt;                 list(), " ", list("with_bindings()"), " evaluates ", 
#&gt;                 list("expr"), " with temporary bindings. When\n", 
#&gt;                 list("with_bindings()"), " returns, bindings are reset to their original\n", 
#&gt;                 "values. It is a simple wrapper around ", list(
#&gt;                   "scoped_bindings()"), ".\n"), "\n"), "\n", 
#&gt;             list("\n", "foo &lt;- \"foo\"\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "\n", "# `foo` will be temporarily rebinded while executing `expr`\n", 
#&gt;                 "with_bindings(paste(foo, bar), foo = \"rebinded\")\n", 
#&gt;                 "paste(foo, bar)\n"), "\n"), scoped_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("scoped_env"), "\n", list("scoped_env"), 
#&gt;             "\n", list("is_scoped"), "\n", list("scoped_envs"), 
#&gt;             "\n", list("scoped_names"), "\n", list("Retired ", 
#&gt;                 list("scoped"), " functions"), "\n", list("\n", 
#&gt;                 "scoped_env(nm)\n", "\n", "is_scoped(nm)\n", 
#&gt;                 "\n", "scoped_envs()\n", "\n", "scoped_names()\n"), 
#&gt;             "\n", list("\n", list(list("nm"), list("The name of an environment attached to the search\n", 
#&gt;                 "path. Call ", list(list("base::search()")), 
#&gt;                 " to see what is currently on the path.")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated as of rlang 0.3.0. They are replaced\n", 
#&gt;                 "by ", list(list("is_attached()")), ", ...\n"), 
#&gt;             "\n", list("internal"), "\n"), scoped_options.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/state.R", "\n", 
#&gt;             list("scoped_options"), "\n", list("scoped_options"), 
#&gt;             "\n", list("with_options"), "\n", list("push_options"), 
#&gt;             "\n", list("peek_options"), "\n", list("peek_option"), 
#&gt;             "\n", list("Change global options"), "\n", list("\n", 
#&gt;                 "scoped_options(..., .frame = caller_env())\n", 
#&gt;                 "\n", "with_options(.expr, ...)\n", "\n", "push_options(...)\n", 
#&gt;                 "\n", "peek_options(...)\n", "\n", "peek_option(name)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("For ", list(
#&gt;                 "scoped_options()"), " and ", list("push_options()"), 
#&gt;                 ", named\n", "values defining new option values. For ", 
#&gt;                 list("peek_options()"), ", strings\n", "or character vectors of option names.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The environment of a stack frame which defines the\n", 
#&gt;                   "scope of the temporary options. When the frame returns, the\n", 
#&gt;                   "options are set back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary options.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An option name as string.")), 
#&gt;                 "\n"), "\n", list("\n", "For ", list("scoped_options()"), 
#&gt;                 " and ", list("push_options()"), ", the old option\n", 
#&gt;                 "values. ", list("peek_option()"), " returns the current value of an option\n", 
#&gt;                 "while the plural ", list("peek_options()"), 
#&gt;                 " returns a list of current\n", "option values.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("scoped_options()"), 
#&gt;                 " changes options for the duration of a stack\n", 
#&gt;                 "frame (by default the current one). Options are set back to their\n", 
#&gt;                 "old values when the frame returns.\n", list(), 
#&gt;                 " ", list("with_options()"), " changes options while an expression is\n", 
#&gt;                 "evaluated. Options are restored when the expression returns.\n", 
#&gt;                 list(), " ", list("push_options()"), " adds or changes options permanently.\n", 
#&gt;                 list(), " ", list("peek_option()"), " and ", 
#&gt;                 list("peek_options()"), " return option values. The\n", 
#&gt;                 "former returns the option directly while the latter returns a\n", 
#&gt;                 "list.\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "# Store and retrieve a global option:\n", 
#&gt;                 "push_options(my_option = 10)\n", "peek_option(\"my_option\")\n", 
#&gt;                 "\n", "# Change the option temporarily:\n", "with_options(my_option = 100, peek_option(\"my_option\"))\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The scoped variant is useful within functions:\n", 
#&gt;                 "fn &lt;- function() {\n", "  scoped_options(my_option = 100)\n", 
#&gt;                 "  peek_option(\"my_option\")\n", "}\n", "fn()\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The plural peek returns a named list:\n", 
#&gt;                 "peek_options(\"my_option\")\n", "peek_options(\"my_option\", \"digits\")\n"), 
#&gt;             "\n", list("experimental"), "\n"), search_envs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("search_envs"), "\n", list("search_envs"), 
#&gt;             "\n", list("search_env"), "\n", list("pkg_env"), 
#&gt;             "\n", list("pkg_env_name"), "\n", list("is_attached"), 
#&gt;             "\n", list("base_env"), "\n", list("global_env"), 
#&gt;             "\n", list("Search path environments"), "\n", list(
#&gt;                 "\n", "search_envs()\n", "\n", "search_env(name)\n", 
#&gt;                 "\n", "pkg_env(pkg)\n", "\n", "pkg_env_name(pkg)\n", 
#&gt;                 "\n", "is_attached(x)\n", "\n", "base_env()\n", 
#&gt;                 "\n", "global_env()\n"), "\n", list("\n", list(
#&gt;                 list("name"), list("The name of an environment attached to the search\n", 
#&gt;                   "path. Call ", list(list("base::search()")), 
#&gt;                   " to get the names of environments\n", "currently attached to the search path. Note that the search name\n", 
#&gt;                   "of a package environment is prefixed with ", 
#&gt;                   list("\"package:\""), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", "The search path is a chain of environments containing exported\n", 
#&gt;                 "functions of attached packages.\n", "\n", "The API includes:\n", 
#&gt;                 list("\n", list(), " ", list(list("base::search()")), 
#&gt;                   " to get the names of environments attached to the\n", 
#&gt;                   "search path.\n", list(), " ", list("search_envs()"), 
#&gt;                   " returns the environments on the search path as a\n", 
#&gt;                   "list.\n", list(), " ", list("pkg_env_name()"), 
#&gt;                   " takes a bare package name and prefixes it with\n", 
#&gt;                   list("\"package:\""), ". Attached package environments have search names of\n", 
#&gt;                   "the form ", list("package:name"), ".\n", list(), 
#&gt;                   " ", list("pkg_env()"), " takes a bare package name and returns the scoped\n", 
#&gt;                   "environment of packages if they are attached to the search path,\n", 
#&gt;                   "and throws an error otherwise. It is a shortcut for\n", 
#&gt;                   list("search_env(pkg_env_name(\"pkgname\"))"), 
#&gt;                   ".\n", list(), " ", list("is_attached()"), 
#&gt;                   " returns ", list("TRUE"), " when its argument (a search name\n", 
#&gt;                   "or a package environment) is attached to the search path.\n"), 
#&gt;                 "\n"), "\n", list(list("The search path"), list(
#&gt;                 "\n", "\n", "\n", "This chain of environments determines what objects are visible from\n", 
#&gt;                 "the global workspace. It contains the following elements:\n", 
#&gt;                 list("\n", list(), " The chain always starts with ", 
#&gt;                   list("global_env()"), " and finishes with\n", 
#&gt;                   list("base_env()"), " (technically, it finishes with the ", 
#&gt;                   list("empty_env()"), "\n", "which the base package environment inherits from).\n", 
#&gt;                   list(), " Each ", list(list("base::library()")), 
#&gt;                   " call attaches a new package environment to\n", 
#&gt;                   "the search path. Attached packages are associated with a ", 
#&gt;                   list("search name"), ".\n", list(), " In addition, any list, data frame, or environment can be attached\n", 
#&gt;                   "to the search path with ", list(list("base::attach()")), 
#&gt;                   ".\n"), "\n")), "\n", "\n", list("\n", "# List the search names of environments attached to the search path:\n", 
#&gt;                 "search()\n", "\n", "# Get the corresponding environments:\n", 
#&gt;                 "search_envs()\n", "\n", "# The global environment and the base package are always first and\n", 
#&gt;                 "# last in the chain, respectively:\n", "envs &lt;- search_envs()\n", 
#&gt;                 "envs[[1]]\n", "envs[[length(envs)]]\n", "\n", 
#&gt;                 "# These two environments have their own shortcuts:\n", 
#&gt;                 "global_env()\n", "base_env()\n", "\n", "# Packages appear in the search path with a special name. Use\n", 
#&gt;                 "# pkg_env_name() to create that name:\n", "pkg_env_name(\"rlang\")\n", 
#&gt;                 "search_env(pkg_env_name(\"rlang\"))\n", "\n", 
#&gt;                 "# Alternatively, get the scoped environment of a package with\n", 
#&gt;                 "# pkg_env():\n", "pkg_env(\"utils\")\n"), "\n", 
#&gt;             list("internal"), "\n"), seq2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("seq2"), "\n", list("seq2"), "\n", list("seq2_along"), 
#&gt;             "\n", list("Increasing sequence of integers in an interval"), 
#&gt;             "\n", list("\n", "seq2(from, to)\n", "\n", "seq2_along(from, x)\n"), 
#&gt;             "\n", list("\n", list(list("from"), list("The starting point of the sequence.")), 
#&gt;                 "\n", "\n", list(list("to"), list("The end point.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A vector whose length is the end point.")), 
#&gt;                 "\n"), "\n", list("\n", "An integer vector containing a strictly increasing\n", 
#&gt;                 "sequence.\n"), "\n", list("\n", "These helpers take two endpoints and return the sequence of all\n", 
#&gt;                 "integers within that interval. For ", list("seq2_along()"), 
#&gt;                 ", the upper\n", "endpoint is taken from the length of a vector. Unlike\n", 
#&gt;                 list("base::seq()"), ", they return an empty vector if the starting point is\n", 
#&gt;                 "a larger integer than the end point.\n"), "\n", 
#&gt;             list("\n", "seq2(2, 10)\n", "seq2(10, 2)\n", "seq(10, 2)\n", 
#&gt;                 "\n", "seq2_along(10, letters)\n"), "\n"), set_attrs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("set_attrs"), "\n", list("set_attrs"), 
#&gt;             "\n", list("mut_attrs"), "\n", list("Add attributes to an object"), 
#&gt;             "\n", list("\n", "set_attrs(.x, ...)\n", "\n", "mut_attrs(.x, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("An object to decorate with attributes.")), 
#&gt;                 "\n", "\n", list(list("..."), list("A list of named attributes. These have ", 
#&gt;                   list("explicit splicing semantics"), ". Pass a single unnamed ", 
#&gt;                   list("NULL"), " argument to\n", "zap all attributes from ", 
#&gt;                   list(".x"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("set_attrs()"), " returns a modified ", 
#&gt;                 list("shallow copy"), "\n", "of ", list(".x"), 
#&gt;                 ". ", list("mut_attrs()"), " invisibly returns the original ", 
#&gt;                 list(".x"), "\n", "modified in place.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("set_attrs()"), " adds, changes, or zaps attributes of objects. Pass a\n", 
#&gt;                 "single unnamed ", list("NULL"), " argument to zap all attributes. For\n", 
#&gt;                 list("uncopyable"), " types, use ", list("mut_attrs()"), 
#&gt;                 ".\n"), "\n", list("\n", "Unlike ", list(list(
#&gt;                 "structure()")), ", these setters have no special handling of\n", 
#&gt;                 "internal attributes names like ", list(".Dim"), 
#&gt;                 ", ", list(".Dimnames"), " or ", list(".Names"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are deprecated since rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "set_attrs(letters, names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "\n", "# Splice a list of attributes:\n", "attrs &lt;- list(attr = \"attr\", names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "obj &lt;- set_attrs(letters, splice(attrs))\n", 
#&gt;                 "obj\n", "\n", "# Zap attributes by passing a single unnamed NULL argument:\n", 
#&gt;                 "set_attrs(obj, NULL)\n", "set_attrs(obj, !!! list(NULL))\n", 
#&gt;                 "\n", "# Note that set_attrs() never modifies objects in place:\n", 
#&gt;                 "obj\n", "\n", "# For uncopyable types, mut_attrs() lets you modify in place:\n", 
#&gt;                 "env &lt;- env()\n", "mut_attrs(env, foo = \"bar\")\n", 
#&gt;                 "env\n"), "\n", list("internal"), "\n"), set_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/expr.R", "\n", 
#&gt;             list("set_expr"), "\n", list("set_expr"), "\n", list(
#&gt;                 "get_expr"), "\n", list("Set and get an expression"), 
#&gt;             "\n", list("\n", "set_expr(x, value)\n", "\n", "get_expr(x, default = x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An expression, closure, or one-sided formula. In addition,\n", 
#&gt;                 list("set_expr()"), " accept frames.")), "\n", 
#&gt;                 "\n", list(list("value"), list("An updated expression.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default expression to return when ", 
#&gt;                   list("x"), " is not an\n", "expression wrapper. Defaults to ", 
#&gt;                   list("x"), " itself.")), "\n"), "\n", list(
#&gt;                 "\n", "The updated original input for ", list(
#&gt;                   "set_expr()"), ". A raw\n", "expression for ", 
#&gt;                 list("get_expr()"), ".\n"), "\n", list("\n", 
#&gt;                 "These helpers are useful to make your function work generically\n", 
#&gt;                 "with quosures and raw expressions. First call ", 
#&gt;                 list("get_expr()"), " to\n", "extract an expression. Once you're done processing the expression,\n", 
#&gt;                 "call ", list("set_expr()"), " on the original object to update the expression.\n", 
#&gt;                 "You can return the result of ", list("set_expr()"), 
#&gt;                 ", either a formula or an\n", "expression depending on the input type. Note that ", 
#&gt;                 list("set_expr()"), " does\n", "not change its input, it creates a new object.\n"), 
#&gt;             "\n", list("\n", "f &lt;- ~foo(bar)\n", "e &lt;- quote(foo(bar))\n", 
#&gt;                 "frame &lt;- identity(identity(ctxt_frame()))\n", 
#&gt;                 "\n", "get_expr(f)\n", "get_expr(e)\n", "get_expr(frame)\n", 
#&gt;                 "\n", "set_expr(f, quote(baz))\n", "set_expr(e, quote(baz))\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_expr()")), " and ", 
#&gt;                 list(list("quo_set_expr()")), " for versions of\n", 
#&gt;                 list(list("get_expr()")), " and ", list(list(
#&gt;                   "set_expr()")), " that only work on quosures.\n"), 
#&gt;             "\n"), set_names.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("set_names"), "\n", list("set_names"), 
#&gt;             "\n", list("Set names of a vector"), "\n", list("\n", 
#&gt;                 "set_names(x, nm = x, ...)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Vector to name.")), "\n", 
#&gt;                 "\n", list(list("nm, ..."), list("Vector of names, the same length as ", 
#&gt;                   list("x"), ".\n", "\n", "You can specify names in the following ways:\n", 
#&gt;                   list("\n", list(), " If you do nothing, ", 
#&gt;                     list("x"), " will be named with itself.\n", 
#&gt;                     list(), " If ", list("x"), " already has names, you can provide a function or formula\n", 
#&gt;                     "to transform the existing names. In that case, ", 
#&gt;                     list("..."), " is passed\n", "to the function.\n", 
#&gt;                     list(), " If ", list("nm"), " is ", list(
#&gt;                       "NULL"), ", the names are removed (if present).\n", 
#&gt;                     list(), " In all other cases, ", list("nm"), 
#&gt;                     " and ", list("..."), " are coerced to character.\n"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "stats::setNames()")), ", with more features and\n", 
#&gt;                 "stricter argument checking.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                   "set_names()"), " is stable and exported in purrr.\n")), 
#&gt;             "\n", "\n", list("\n", "set_names(1:4, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "set_names(1:4, letters[1:4])\n", "set_names(1:4, \"a\", \"b\", \"c\", \"d\")\n", 
#&gt;                 "\n", "# If the second argument is ommitted a vector is named with itself\n", 
#&gt;                 "set_names(letters[1:5])\n", "\n", "# Alternatively you can supply a function\n", 
#&gt;                 "set_names(1:10, ~ letters[seq_along(.)])\n", 
#&gt;                 "set_names(head(mtcars), toupper)\n", "\n", "# If the input vector is unnamed, it is first named after itself\n", 
#&gt;                 "# before the function is applied:\n", "set_names(letters, toupper)\n", 
#&gt;                 "\n", "# `...` is passed to the function:\n", 
#&gt;                 "set_names(head(mtcars), paste0, \"_foo\")\n"), 
#&gt;             "\n"), splice.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("splice"), "\n", list("splice"), "\n", 
#&gt;             list("is_spliced"), "\n", list("is_spliced_bare"), 
#&gt;             "\n", list("dots_splice"), "\n", list("Splice lists"), 
#&gt;             "\n", list("\n", "splice(x)\n", "\n", "is_spliced(x)\n", 
#&gt;                 "\n", "is_spliced_bare(x)\n", "\n", "dots_splice(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A list to splice.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to collect with ", 
#&gt;                   list("!!!"), " support.")), "\n", "\n", list(
#&gt;                   list(".ignore_empty"), list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("splice"), 
#&gt;                   " marks an object to be spliced. It is equivalent to using\n", 
#&gt;                   list("!!!"), " in a function with ", list("tidy dots semantics"), 
#&gt;                   ".\n", list(), " ", list("dots_splice()"), 
#&gt;                   " is like ", list(list("dots_list()")), " but automatically splices\n", 
#&gt;                   "list inputs.\n"), "\n"), "\n", list(list("Standard splicing versus quoting splicing"), 
#&gt;                 list("\n", "\n", "\n", "The ", list("!!!"), " operator works differently in ", 
#&gt;                   list("standard"), " functions taking\n", "dots with ", 
#&gt;                   list("dots_list()"), " than in ", list("quoting"), 
#&gt;                   " functions taking dots\n", "with ", list(list(
#&gt;                     "enexprs()")), " or ", list(list("enquos()")), 
#&gt;                   ".\n", list("\n", list(), " In quoting functions ", 
#&gt;                     list("!!!"), " disaggregates its argument (let's call\n", 
#&gt;                     "it ", list("x"), ") into as many objects as there are elements in\n", 
#&gt;                     list("x"), ". E.g. ", list("quo(foo(!!! c(1, 2)))"), 
#&gt;                     " is completely equivalent to\n", list("quo(foo(1, 2))"), 
#&gt;                     ". The creation of those separate objects has an\n", 
#&gt;                     "overhead but is typically not important when manipulating calls\n", 
#&gt;                     "because function calls typically take a small number of\n", 
#&gt;                     "arguments.\n", list(), " In standard functions, disaggregating the spliced collection\n", 
#&gt;                     "would have a negative performance impact in cases where\n", 
#&gt;                     list("dots_list()"), " is used to build up data structures from user\n", 
#&gt;                     "inputs. To avoid this spliced inputs are marked with ", 
#&gt;                     list(list("splice()")), "\n", "and the final list is built with (the equivalent of)\n", 
#&gt;                     list("flatten_if(dots, is_spliced)"), ".\n"), 
#&gt;                   "\n", "\n", "Most of the time you should not care about the difference. However\n", 
#&gt;                   "if you use a standard function taking tidy dots within a quoting\n", 
#&gt;                   "function, the ", list("!!!"), " operator will disaggregate its argument because\n", 
#&gt;                   "the behaviour of the quasiquoting function has priority. You might\n", 
#&gt;                   "then observe some performance cost in edge cases. Here is one\n", 
#&gt;                   "example where this would happen:", list("purrr::rerun(10, dplyr::bind_rows(!!! x))\n"), 
#&gt;                   "\n", "\n", list("purrr::rerun()"), " is a quoting function and ", 
#&gt;                   list("dplyr::bind_rows()"), " is\n", "a standard function. Because ", 
#&gt;                   list("bind_rows()"), " is called ", list("inside"), 
#&gt;                   "\n", list("rerun()"), ", the list ", list(
#&gt;                     "x"), " will be disaggregated into a pairlist of\n", 
#&gt;                   "arguments. To avoid this you can use ", list(
#&gt;                     "splice()"), " instead:", list("purrr::rerun(10, dplyr::bind_rows(splice(x)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "dots_splice()"), " is in the questioning stage. It is part of our\n", 
#&gt;                   "experiments with dots semantics. Compared to ", 
#&gt;                   list("dots_list()"), ",\n", list("dots_splice()"), 
#&gt;                   " automatically splices lists. We now lean towards\n", 
#&gt;                   "adopting a single type of dots semantics (those of ", 
#&gt;                   list("dots_list()"), ")\n", "where splicing is explicit.\n", 
#&gt;                   list(), " ", list("splice()"), " is in the questioning stage. It is not clear whether it is\n", 
#&gt;                   "really needed as there are other ways to avoid the performance\n", 
#&gt;                   "issue discussed above.\n"), "\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), stack.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack"), "\n", list("stack"), "\n", list(
#&gt;                 "global_frame"), "\n", list("current_frame"), 
#&gt;             "\n", list("ctxt_frame"), "\n", list("call_frame"), 
#&gt;             "\n", list("ctxt_depth"), "\n", list("call_depth"), 
#&gt;             "\n", list("ctxt_stack"), "\n", list("call_stack"), 
#&gt;             "\n", list("Call stack information"), "\n", list(
#&gt;                 "\n", "global_frame()\n", "\n", "current_frame()\n", 
#&gt;                 "\n", "ctxt_frame(n = 1)\n", "\n", "call_frame(n = 1, clean = TRUE)\n", 
#&gt;                 "\n", "ctxt_depth()\n", "\n", "call_depth()\n", 
#&gt;                 "\n", "ctxt_stack(n = NULL, trim = 0)\n", "\n", 
#&gt;                 "call_stack(n = NULL, clean = TRUE)\n"), "\n", 
#&gt;             list("\n", list(list("n"), list("The number of frames to go back in the stack.")), 
#&gt;                 "\n", "\n", list(list("clean"), list("Whether to post-process the call stack to clean\n", 
#&gt;                   "non-standard frames. If ", list("TRUE"), ", suboptimal call-stack entries by\n", 
#&gt;                   list(list("base::eval()")), " will be cleaned up: the duplicate frame created by\n", 
#&gt;                   list("eval()"), " is eliminated.")), "\n", 
#&gt;                 "\n", list(list("trim"), list("The number of layers of intervening frames to trim off\n", 
#&gt;                   "the stack. See ", list(list("stack_trim()")), 
#&gt;                   " and examples.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "The ", list("eval_"), " and ", list("call_"), 
#&gt;                 " families of functions provide a replacement\n", 
#&gt;                 "for the base R functions prefixed with ", list(
#&gt;                   "sys."), " (which are all about\n", "the context stack), as well as for ", 
#&gt;                 list(list("parent.frame()")), " (which is the\n", 
#&gt;                 "only base R function for querying the call stack). The context\n", 
#&gt;                 "stack includes all R-level evaluation contexts. It is linear in\n", 
#&gt;                 "terms of execution history but due to lazy evaluation it is\n", 
#&gt;                 "potentially nonlinear in terms of call history. The call stack\n", 
#&gt;                 "history, on the other hand, is homogenous.\n"), 
#&gt;             "\n", list("\n", list("ctxt_frame()"), " and ", list(
#&gt;                 "call_frame()"), " return a ", list("frame"), 
#&gt;                 " object\n", "containing the following fields: ", 
#&gt;                 list("expr"), " and ", list("env"), " (call expression\n", 
#&gt;                 "and evaluation environment), ", list("pos"), 
#&gt;                 " and ", list("caller_pos"), " (position of\n", 
#&gt;                 "current frame in the context stack and position of the caller), and\n", 
#&gt;                 list("fun"), " (function of the current frame). ", 
#&gt;                 list("ctxt_stack()"), " and\n", list("call_stack()"), 
#&gt;                 " return a list of all context or call frames on the\n", 
#&gt;                 "stack. Finally, ", list("ctxt_depth()"), " and ", 
#&gt;                 list("call_depth()"), " report the\n", "current context position or the number of calling frames on the\n", 
#&gt;                 "stack.\n", "\n", "The base R functions take two sorts of arguments to indicate which\n", 
#&gt;                 "frame to query: ", list("which"), " and ", list(
#&gt;                   "n"), ". The ", list("n"), " argument is\n", 
#&gt;                 "straightforward: it's the number of frames to go down the stack,\n", 
#&gt;                 "with ", list("n = 1"), " referring to the current context. The ", 
#&gt;                 list("which"), " argument\n", "is more complicated and changes meaning for values lower than 1.\n", 
#&gt;                 "For the sake of consistency, the rlang functions all take the\n", 
#&gt;                 "same kind of argument ", list("n"), ". This argument has a single meaning (the\n", 
#&gt;                 "number of frames to go down the stack) and cannot be lower than 1.\n", 
#&gt;                 "\n", "Note finally that ", list("parent.frame(1)"), 
#&gt;                 " corresponds to\n", list("call_frame(2)$env"), 
#&gt;                 ", as ", list("n = 1"), " always refers to the current\n", 
#&gt;                 "frame. This makes the ", list("_frame()"), " and ", 
#&gt;                 list("_stack()"), " functions\n", "consistent: ", 
#&gt;                 list("ctxt_frame(2)"), " is the same as ", list(
#&gt;                   "ctxt_stack()[[2]]"), ".\n", "Also, ", list(
#&gt;                   "ctxt_depth()"), " returns one more frame than\n", 
#&gt;                 list(list("base::sys.nframe()")), " because it counts the global frame. That is\n", 
#&gt;                 "consistent with the ", list("_stack()"), " functions which return the global\n", 
#&gt;                 "frame as well. This way, ", list("call_stack(call_depth())"), 
#&gt;                 " is the same as\n", list("global_frame()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are soft-deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Expressions within arguments count as contexts\n", 
#&gt;                 "identity(identity(ctxt_depth())) # returns 2\n", 
#&gt;                 "\n", "# But they are not part of the call stack because arguments are\n", 
#&gt;                 "# evaluated within the calling function (or the global environment\n", 
#&gt;                 "# if called at top level)\n", "identity(identity(call_depth())) # returns 0\n", 
#&gt;                 "\n", "# The context stacks includes all intervening execution frames. The\n", 
#&gt;                 "# call stack doesn't:\n", "f &lt;- function(x) identity(x)\n", 
#&gt;                 "f(f(ctxt_stack()))\n", "f(f(call_stack()))\n", 
#&gt;                 "\n", "g &lt;- function(cmd) cmd()\n", "f(g(ctxt_stack))\n", 
#&gt;                 "f(g(call_stack))\n", "\n", "# The rlang _stack() functions return a list of frame\n", 
#&gt;                 "# objects. Use purrr::transpose() or index a field with\n", 
#&gt;                 "# purrr::map()'s to extract a particular field from a stack:\n", 
#&gt;                 "\n", "# stack &lt;- f(f(call_stack()))\n", "# purrr::map(stack, \"env\")\n", 
#&gt;                 "# purrr::transpose(stack)$expr\n", "\n", "# current_frame() is an alias for ctxt_frame(1)\n", 
#&gt;                 "fn &lt;- function() list(current = current_frame(), first = ctxt_frame(1))\n", 
#&gt;                 "fn()\n", "\n", "# While current_frame() is the top of the stack, global_frame() is\n", 
#&gt;                 "# the bottom:\n", "fn &lt;- function() {\n", "  n &lt;- ctxt_depth()\n", 
#&gt;                 "  ctxt_frame(n)\n", "}\n", "identical(fn(), global_frame())\n", 
#&gt;                 "\n", "\n", "# ctxt_stack() returns a stack with all intervening frames. You can\n", 
#&gt;                 "# trim layers of intervening frames with the trim argument:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "identity(identity(ctxt_stack(trim = 1)))\n", 
#&gt;                 "\n", "# ctxt_stack() is called within fn() with intervening frames:\n", 
#&gt;                 "fn &lt;- function(trim) identity(identity(ctxt_stack(trim = trim)))\n", 
#&gt;                 "fn(0)\n", "\n", "# We can trim the first layer of those:\n", 
#&gt;                 "fn(1)\n", "\n", "# The outside intervening frames (at the fn() call site) are still\n", 
#&gt;                 "# returned, but can be trimmed as well:\n", 
#&gt;                 "identity(identity(fn(1)))\n", "identity(identity(fn(2)))\n", 
#&gt;                 "\n", "g &lt;- function(trim) identity(identity(fn(trim)))\n", 
#&gt;                 "g(2)\n", "g(3)\n"), "\n", list("internal"), 
#&gt;             "\n"), stack_trim.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack_trim"), "\n", list("stack_trim"), 
#&gt;             "\n", list("Trim top call layers from the evaluation stack"), 
#&gt;             "\n", list("\n", "stack_trim(stack, n = 1)\n"), "\n", 
#&gt;             list("\n", list(list("stack"), list("An evaluation stack.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of call frames (not eval frames) to trim off\n", 
#&gt;                   "the top of the stack. In other words, the number of layers of\n", 
#&gt;                   "intervening frames to trim.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list(list("ctxt_stack()")), " can be tricky to use in real code because all\n", 
#&gt;                 "intervening frames are returned with the stack, including those at\n", 
#&gt;                 list("ctxt_stack()"), " own call site. ", list(
#&gt;                   "stack_trim()"), " makes it easy to\n", "remove layers of intervening calls.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Intervening frames appear on the evaluation stack:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# stack_trim() will trim the first n layers of calls:\n", 
#&gt;                 "stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "\n", "# Note that it also takes care of calls intervening at its own call\n", 
#&gt;                 "# site:\n", "identity(identity(\n", "  stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "))\n", "\n", "# It is especially useful when used within a function that needs to\n", 
#&gt;                 "# inspect the evaluation stack but should nonetheless be callable\n", 
#&gt;                 "# within nested calls without side effects:\n", 
#&gt;                 "stack_util &lt;- function() {\n", "  # n = 2 means that two layers of intervening calls should be\n", 
#&gt;                 "  # removed: The layer at ctxt_stack()'s call site (including the\n", 
#&gt;                 "  # stack_trim() call), and the layer at stack_util()'s call.\n", 
#&gt;                 "  stack &lt;- stack_trim(ctxt_stack(), n = 2)\n", 
#&gt;                 "  stack\n", "}\n", "user_fn &lt;- function() {\n", 
#&gt;                 "  # A user calls your stack utility with intervening frames:\n", 
#&gt;                 "  identity(identity(stack_util()))\n", "}\n", 
#&gt;                 "# These intervening frames won't appear in the evaluation stack\n", 
#&gt;                 "identity(user_fn())\n"), "\n", list("internal"), 
#&gt;             "\n"), string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("string"), "\n", list("string"), "\n", 
#&gt;             list("Create a string"), "\n", list("\n", "string(x, encoding = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A character vector or a vector or list of string-like\n", 
#&gt;                 "objects.")), "\n", "\n", list(list("encoding"), 
#&gt;                 list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These base-type constructors allow more control over the creation\n", 
#&gt;                 "of strings in R. They take character vectors or string-like objects\n", 
#&gt;                 "(integerish or raw vectors), and optionally set the encoding. The\n", 
#&gt;                 "string version checks that the input contains a scalar string.\n"), 
#&gt;             "\n", list("\n", "# As everywhere in R, you can specify a string with Unicode\n", 
#&gt;                 "# escapes. The characters corresponding to Unicode codepoints will\n", 
#&gt;                 "# be encoded in UTF-8, and the string will be marked as UTF-8\n", 
#&gt;                 "# automatically:\n", "cafe &lt;- string(\"caf\\uE9\")\n", 
#&gt;                 "Encoding(cafe)\n", "as_bytes(cafe)\n", "\n", 
#&gt;                 "# In addition, string() provides useful conversions to let\n", 
#&gt;                 "# programmers control how the string is represented in memory. For\n", 
#&gt;                 "# encodings other than UTF-8, you'll need to supply the bytes in\n", 
#&gt;                 "# hexadecimal form. If it is a latin1 encoding, you can mark the\n", 
#&gt;                 "# string explicitly:\n", "cafe_latin1 &lt;- string(c(0x63, 0x61, 0x66, 0xE9), \"latin1\")\n", 
#&gt;                 "Encoding(cafe_latin1)\n", "as_bytes(cafe_latin1)\n"), 
#&gt;             "\n", list("internal"), "\n"), switch_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("switch_type"), "\n", list("switch_type"), 
#&gt;             "\n", list("coerce_type"), "\n", list("switch_class"), 
#&gt;             "\n", list("coerce_class"), "\n", list("Dispatch on base types"), 
#&gt;             "\n", list("\n", "switch_type(.x, ...)\n", "\n", 
#&gt;                 "coerce_type(.x, .to, ...)\n", "\n", "switch_class(.x, ...)\n", 
#&gt;                 "\n", "coerce_class(.x, .to, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".x"), list("An object from which to dispatch.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named clauses. The names should be types as returned by\n", 
#&gt;                   list(list("type_of()")), ".")), "\n", "\n", 
#&gt;                 list(list(".to"), list("This is useful when you switchpatch within a coercing\n", 
#&gt;                   "function. If supplied, this should be a string indicating the\n", 
#&gt;                   "target type. A catch-all clause is then added to signal an error\n", 
#&gt;                   "stating the conversion failure. This type is prettified unless\n", 
#&gt;                   list(".to"), " inherits from the S3 class ", 
#&gt;                   list("\"AsIs\""), " (see ", list(list("base::I()")), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("switch_type()"), " is equivalent to\n", 
#&gt;                 list(list("switch"), "(", list("type_of"), "(x, ...))"), 
#&gt;                 ", while\n", list("switch_class()"), " switchpatches based on ", 
#&gt;                 list("class(x)"), ". The ", list("coerce_"), 
#&gt;                 "\n", "versions are intended for type conversion and provide a standard\n", 
#&gt;                 "error message when conversion fails.\n"), "\n", 
#&gt;             list("\n", "switch_type(3L,\n", "  double = \"foo\",\n", 
#&gt;                 "  integer = \"bar\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# Use the coerce_ version to get standardised error handling when no\n", 
#&gt;                 "# type matches:\n", "to_chr &lt;- function(x) {\n", 
#&gt;                 "  coerce_type(x, \"a chr\",\n", "    integer = as.character(x),\n", 
#&gt;                 "    double = as.character(x)\n", "  )\n", "}\n", 
#&gt;                 "to_chr(3L)\n", "\n", "# Strings have their own type:\n", 
#&gt;                 "switch_type(\"str\",\n", "  character = \"foo\",\n", 
#&gt;                 "  string = \"bar\",\n", "  \"default\"\n", ")\n", 
#&gt;                 "\n", "# Use a fallthrough clause if you need to dispatch on all character\n", 
#&gt;                 "# vectors, including strings:\n", "switch_type(\"str\",\n", 
#&gt;                 "  string = ,\n", "  character = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "\n", "# special and builtin functions are treated as primitive, since\n", 
#&gt;                 "# there is usually no reason to treat them differently:\n", 
#&gt;                 "switch_type(base::list,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "switch_type(base::`$`,\n", 
#&gt;                 "  primitive = \"foo\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# closures are not primitives:\n", 
#&gt;                 "switch_type(rlang::switch_type,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n"), "\n", list("internal"), 
#&gt;             "\n"), sym.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("sym"), "\n", list("sym"), "\n", list("syms"), 
#&gt;             "\n", list("Create a symbol or list of symbols"), 
#&gt;             "\n", list("\n", "sym(x)\n", "\n", "syms(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or list of strings.")), 
#&gt;                 "\n"), "\n", list("\n", "A symbol for ", list(
#&gt;                 "sym()"), " and a list of symbols for ", list(
#&gt;                 "syms()"), ".\n"), "\n", list("\n", "These functions take strings as input and turn them into symbols.\n"), 
#&gt;             "\n", list("\n", "# The empty string returns the missing argument:\n", 
#&gt;                 "sym(\"\")\n", "\n", "# This way sym() and as_string() are inverse of each other:\n", 
#&gt;                 "as_string(missing_arg())\n", "sym(as_string(missing_arg()))\n"), 
#&gt;             "\n"), `tidy-dots.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R, R/vec-new.R", 
#&gt;             "\n", list("tidy-dots"), "\n", list("tidy-dots"), 
#&gt;             "\n", list("dots_list"), "\n", list("list2"), "\n", 
#&gt;             list("Collect dots as lists"), "\n", list("\n", "dots_list(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "list2(...)\n"), "\n", list("\n", list(list("..."), 
#&gt;                 list("Arguments to collect with ", list("!!!"), 
#&gt;                   " support.")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                 list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "A list of arguments. This list is always named: unnamed\n", 
#&gt;                 "arguments are named with the empty string ", 
#&gt;                 list("\"\""), ".\n"), "\n", list("\n", list("list2()"), 
#&gt;                 " is equivalent to ", list("list(...)"), " with a few additional\n", 
#&gt;                 "features:\n", list("\n", list(), " You can splice other lists with the\n", 
#&gt;                   list("unquote-splice"), " ", list("!!!"), " operator.\n", 
#&gt;                   list(), " You can unquote names by using the ", 
#&gt;                   list("unquote"), "\n", "operator ", list("!!"), 
#&gt;                   " on the left-hand side of ", list(":="), ".\n", 
#&gt;                   list(), " Trailing commas are ignored, making it easier to copy and paste\n", 
#&gt;                   "arguments.\n"), "\n", "\n", "For lack of a better name, these features are collectively called\n", 
#&gt;                 "\"tidy dots\".\n", "\n", list("dots_list()"), 
#&gt;                 " is a lower-level version of ", list("list2()"), 
#&gt;                 " that offers\n", "additional parameters for dots capture.\n"), 
#&gt;             "\n", list("\n", "# Let's create a function that takes a variable number of arguments:\n", 
#&gt;                 "numeric &lt;- function(...) {\n", "  dots &lt;- list2(...)\n", 
#&gt;                 "  num &lt;- as.numeric(dots)\n", "  set_names(num, names(dots))\n", 
#&gt;                 "}\n", "numeric(1, 2, 3)\n", "\n", "# The main difference with list(...) is that list2(...) enables\n", 
#&gt;                 "# the `!!!` syntax to splice lists:\n", "x &lt;- list(2, 3)\n", 
#&gt;                 "numeric(1, !!! x, 4)\n", "\n", "# As well as unquoting of names:\n", 
#&gt;                 "nm &lt;- \"yup!\"\n", "numeric(!!nm := 1)\n", "\n", 
#&gt;                 "\n", "# One useful application of splicing is to work around exact and\n", 
#&gt;                 "# partial matching of arguments. Let's create a function taking\n", 
#&gt;                 "# named arguments and dots:\n", "fn &lt;- function(data, ...) {\n", 
#&gt;                 "  list2(...)\n", "}\n", "\n", "# You normally cannot pass an argument named `data` through the dots\n", 
#&gt;                 "# as it will match `fn`'s `data` argument. The splicing syntax\n", 
#&gt;                 "# provides a workaround:\n", "fn(\"wrong!\", data = letters)  # exact matching of `data`\n", 
#&gt;                 "fn(\"wrong!\", dat = letters)   # partial matching of `data`\n", 
#&gt;                 "fn(some_data, !!!list(data = letters))  # no matching\n", 
#&gt;                 "\n", "\n", "# Empty arguments trigger an error by default:\n", 
#&gt;                 "try(fn(, ))\n", "\n", "# You can choose to preserve empty arguments instead:\n", 
#&gt;                 "list3 &lt;- function(...) dots_list(..., .preserve_empty = TRUE)\n", 
#&gt;                 "\n", "# Note how the last empty argument is still ignored because\n", 
#&gt;                 "# `.ignore_empty` defaults to \"trailing\":\n", 
#&gt;                 "list3(, )\n", "\n", "# The list with preserved empty arguments is equivalent to:\n", 
#&gt;                 "list(missing_arg())\n", "\n", "\n", "# Arguments with duplicated names are kept by default:\n", 
#&gt;                 "list2(a = 1, a = 2, b = 3, b = 4, 5, 6)\n", 
#&gt;                 "\n", "# Use the `.homonyms` argument to keep only the first of these:\n", 
#&gt;                 "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"first\")\n", 
#&gt;                 "\n", "# Or the last:\n", "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"last\")\n", 
#&gt;                 "\n", "# Or raise an informative error:\n", "try(dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"error\"))\n", 
#&gt;                 "\n", "\n", "# dots_list() can be configured to warn when a `&lt;-` call is\n", 
#&gt;                 "# detected:\n", "my_list &lt;- function(...) dots_list(..., .check_assign = TRUE)\n", 
#&gt;                 "my_list(a &lt;- 1)\n", "\n", "# There is no warning if the assignment is wrapped in braces.\n", 
#&gt;                 "# This requires users to be explicit about their intent:\n", 
#&gt;                 "my_list({ a &lt;- 1 })\n"), "\n", list("\n", list(
#&gt;                 list("exprs()")), " for extracting dots without evaluation.\n"), 
#&gt;             "\n"), `tidyeval-data.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("data"), "\n", list("tidyeval-data"), 
#&gt;             "\n", list("tidyeval-data"), "\n", list(".data"), 
#&gt;             "\n", list("Data pronoun for tidy evaluation"), "\n", 
#&gt;             list("\n", ".data\n"), "\n", list("\n", "This pronoun allows you to be explicit when you refer to an object\n", 
#&gt;                 "inside the data. Referring to the ", list(".data"), 
#&gt;                 " pronoun rather than to\n", "the original data frame has several advantages:\n", 
#&gt;                 list("\n", list(), " It makes it easy to refer to column names stored as strings. If\n", 
#&gt;                   list("var"), " contains the column ", list(
#&gt;                     "\"height\""), ", the pronoun will subset that\n", 
#&gt;                   "column:", list("var &lt;- \"height\"\n", "dplyr::summarise(df, mean(.data[[var]]))\n"), 
#&gt;                   "\n", "\n", "The index variable ", list("var"), 
#&gt;                   " is ", list("unquoted"), ", which\n", "ensures a column named ", 
#&gt;                   list("var"), " in the data frame cannot mask it.\n", 
#&gt;                   "This makes the pronoun safe to use in functions and packages.\n", 
#&gt;                   list(), " Sometimes a computation is not about the whole data but about a\n", 
#&gt;                   "subset. For example if you supply a grouped data frame to a dplyr\n", 
#&gt;                   "verb, the ", list(".data"), " pronoun contains the group subset.\n", 
#&gt;                   list(), " It lets dplyr know that you're referring to a column from the\n", 
#&gt;                   "data which is helpful to generate correct queries when the source\n", 
#&gt;                   "is a database.\n"), "\n", "\n", "The ", list(
#&gt;                   ".data"), " object exported here is useful to import in your\n", 
#&gt;                 "package namespace to avoid a ", list("R CMD check"), 
#&gt;                 " note when referring to\n", "objects from the data mask.\n"), 
#&gt;             "\n", list("datasets"), "\n"), trace_back.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/trace.R", "\n", 
#&gt;             list("trace_back"), "\n", list("trace_back"), "\n", 
#&gt;             list("trace_length"), "\n", list("Capture a backtrace"), 
#&gt;             "\n", list("\n", "trace_back(top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "trace_length(trace)\n"), "\n", list("\n", 
#&gt;                 list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n", "\n", 
#&gt;                 list(list("trace"), list("A backtrace created by ", 
#&gt;                   list("trace_back()"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "A backtrace captures the sequence of calls that lead to the current\n", 
#&gt;                 "function, sometimes called the call stack. Because of lazy\n", 
#&gt;                 "evaluation, the call stack in R is actually a tree, which the\n", 
#&gt;                 list("summary()"), " method of this object will reveal.\n"), 
#&gt;             "\n", list("\n", list("trace_length()"), " returns the number of frames in a backtrace.\n"), 
#&gt;             "\n", list("\n", "# Trim backtraces automatically (this improves the generated\n", 
#&gt;                 "# documentation for the rlang website and the same trick can be\n", 
#&gt;                 "# useful within knitr documents):\n", "options(rlang_trace_top_env = current_env())\n", 
#&gt;                 "\n", "f &lt;- function() g()\n", "g &lt;- function() h()\n", 
#&gt;                 "h &lt;- function() trace_back()\n", "\n", "# When no lazy evaluation is involved the backtrace is linear\n", 
#&gt;                 "# (i.e. every call has only one child)\n", "f()\n", 
#&gt;                 "\n", "# Lazy evaluation introduces a tree like structure\n", 
#&gt;                 "identity(identity(f()))\n", "identity(try(f()))\n", 
#&gt;                 "try(identity(f()))\n", "\n", "# When printing, you can request to simplify this tree to only show\n", 
#&gt;                 "# the direct sequence of calls that lead to `trace_back()`\n", 
#&gt;                 "x &lt;- try(identity(f()))\n", "x\n", "print(x, simplify = \"branch\")\n", 
#&gt;                 "\n", "# With a little cunning you can also use it to capture the\n", 
#&gt;                 "# tree from within a base NSE function\n", "x &lt;- NULL\n", 
#&gt;                 "with(mtcars, {x &lt;&lt;- f(); 10})\n", "x\n", "\n", 
#&gt;                 "\n", "# Restore default top env for next example\n", 
#&gt;                 "options(rlang_trace_top_env = NULL)\n", "\n", 
#&gt;                 "# When code is executed indirectly, i.e. via source or within an\n", 
#&gt;                 "# RMarkdown document, you'll tend to get a lot of guff at the beginning\n", 
#&gt;                 "# related to the execution environment:\n", 
#&gt;                 "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n", "\n", "# To automatically strip this off, specify which frame should be\n", 
#&gt;                 "# the top of the backtrace. This will automatically trim off calls\n", 
#&gt;                 "# prior to that frame:\n", "top &lt;- current_env()\n", 
#&gt;                 "h &lt;- function() trace_back(top)\n", "\n", "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n"), "\n"), `type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("type-predicates"), "\n", list("type-predicates"), 
#&gt;             "\n", list("is_list"), "\n", list("is_atomic"), "\n", 
#&gt;             list("is_vector"), "\n", list("is_integer"), "\n", 
#&gt;             list("is_double"), "\n", list("is_character"), "\n", 
#&gt;             list("is_logical"), "\n", list("is_raw"), "\n", list(
#&gt;                 "is_bytes"), "\n", list("is_null"), "\n", list(
#&gt;                 "Type predicates"), "\n", list("\n", "is_list(x, n = NULL)\n", 
#&gt;                 "\n", "is_atomic(x, n = NULL)\n", "\n", "is_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_integer(x, n = NULL)\n", "\n", "is_double(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_logical(x, n = NULL)\n", "\n", "is_raw(x, n = NULL)\n", 
#&gt;                 "\n", "is_bytes(x, n = NULL)\n", "\n", "is_null(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These type predicates aim to make type testing in R more\n", 
#&gt;                 "consistent. They are wrappers around ", list(
#&gt;                   list("base::typeof()")), ", so operate\n", 
#&gt;                 "at a level beneath S3/S4 etc.\n"), "\n", list(
#&gt;                 "\n", "Compared to base R functions:\n", list(
#&gt;                   "\n", list(), " The predicates for vectors include the ", 
#&gt;                   list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                   list(), " Unlike ", list("is.atomic()"), ", ", 
#&gt;                   list("is_atomic()"), " does not return ", list(
#&gt;                     "TRUE"), " for\n", list("NULL"), ".\n", list(), 
#&gt;                   " Unlike ", list("is.vector()"), ", ", list(
#&gt;                     "is_vector()"), " tests if an object is an\n", 
#&gt;                   "atomic vector or a list. ", list("is.vector"), 
#&gt;                   " checks for the presence of\n", "attributes (other than name).\n"), 
#&gt;                 "\n"), "\n", list("\n", list("bare-type-predicates"), 
#&gt;                 " ", list("scalar-type-predicates"), "\n"), "\n"), 
#&gt;         type_of.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("type_of"), "\n", list("type_of"), "\n", 
#&gt;             list("Base type of an object"), "\n", list("\n", 
#&gt;                 "type_of(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An R object.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "base::typeof()")), " with a few differences that\n", 
#&gt;                 "make dispatching easier:\n", list("\n", list(), 
#&gt;                   " The type of one-sided formulas is \"quote\".\n", 
#&gt;                   list(), " The type of character vectors of length 1 is \"string\".\n", 
#&gt;                   list(), " The type of special and builtin functions is \"primitive\".\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", list("type_of()"), " is an experimental function. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "type_of(10L)\n", "\n", "# Quosures are treated as a new base type but not formulas:\n", 
#&gt;                 "type_of(quo(10L))\n", "type_of(~10L)\n", "\n", 
#&gt;                 "# Compare to base::typeof():\n", "typeof(quo(10L))\n", 
#&gt;                 "\n", "# Strings are treated as a new base type:\n", 
#&gt;                 "type_of(letters)\n", "type_of(letters[[1]])\n", 
#&gt;                 "\n", "# This is a bit inconsistent with the core language tenet that data\n", 
#&gt;                 "# types are vectors. However, treating strings as a different\n", 
#&gt;                 "# scalar type is quite helpful for switching on function inputs\n", 
#&gt;                 "# since so many arguments expect strings:\n", 
#&gt;                 "switch_type(\"foo\", character = abort(\"vector!\"), string = \"result\")\n", 
#&gt;                 "\n", "# Special and builtin primitives are both treated as primitives.\n", 
#&gt;                 "# That's because it is often irrelevant which type of primitive an\n", 
#&gt;                 "# input is:\n", "typeof(list)\n", "typeof(`$`)\n", 
#&gt;                 "type_of(list)\n", "type_of(`$`)\n"), "\n", list(
#&gt;                 "internal"), "\n"), vec_poke_n.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("vec_poke_n"), "\n", list("vec_poke_n"), "\n", 
#&gt;             list("vec_poke_range"), "\n", list("Poke values into a vector"), 
#&gt;             "\n", list("\n", "vec_poke_n(x, start, y, from = 1L, n = length(y))\n", 
#&gt;                 "\n", "vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("The destination vector.")), 
#&gt;                 "\n", "\n", list(list("start"), list("The index indicating where to start modifying ", 
#&gt;                   list("x"), ".")), "\n", "\n", list(list("y"), 
#&gt;                   list("The source vector.")), "\n", "\n", list(
#&gt;                   list("from"), list("The index indicating where to start copying from ", 
#&gt;                     list("y"), ".")), "\n", "\n", list(list("n"), 
#&gt;                   list("How many elements should be copied from ", 
#&gt;                     list("y"), " to ", list("x"), ".")), "\n", 
#&gt;                 "\n", list(list("to"), list("The index indicating the end of the range to copy from ", 
#&gt;                   list("y"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n", 
#&gt;                 "\n", "These tools are for R experts only. They copy elements from ", 
#&gt;                 list("y"), "\n", "into ", list("x"), " by mutation. You should only do this if you own ", 
#&gt;                 list("x"), ",\n", "i.e. if you have created it or if you are certain that it doesn't\n", 
#&gt;                 "exist in any other context. Otherwise you might create unintended\n", 
#&gt;                 "side effects that have undefined consequences.\n"), 
#&gt;             "\n", list("internal"), "\n"), `vector-coercion.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("vector-coercion"), "\n", list("vector-coercion"), 
#&gt;             "\n", list("as_logical"), "\n", list("as_integer"), 
#&gt;             "\n", list("as_double"), "\n", list("as_complex"), 
#&gt;             "\n", list("as_character"), "\n", list("as_list"), 
#&gt;             "\n", list("Coerce an object to a base type"), "\n", 
#&gt;             list("\n", "as_logical(x)\n", "\n", "as_integer(x)\n", 
#&gt;                 "\n", "as_double(x)\n", "\n", "as_complex(x)\n", 
#&gt;                 "\n", "as_character(x, encoding = NULL)\n", "\n", 
#&gt;                 "as_list(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to coerce to a base type.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "These are equivalent to the base functions (e.g. ", 
#&gt;                 list(list("as.logical()")), ",\n", list(list(
#&gt;                   "as.list()")), ", etc), but perform coercion rather than conversion.\n", 
#&gt;                 "This means they are not generic and will not call S3 conversion\n", 
#&gt;                 "methods. They only attempt to coerce the base type of their\n", 
#&gt;                 "input. In addition, they have stricter implicit coercion rules and\n", 
#&gt;                 "will never attempt any kind of parsing. E.g. they will not try to\n", 
#&gt;                 "figure out if a character vector represents integers or booleans.\n", 
#&gt;                 "Finally, they treat attributes consistently, unlike the base R\n", 
#&gt;                 "functions: all attributes except names are removed.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated in favour of ", 
#&gt;                 list("vctrs::vec_cast()"), ".\n")), "\n", "\n", 
#&gt;             list(list("Coercion to logical and numeric atomic vectors"), 
#&gt;                 list("\n", "\n", list("\n", list(), " To logical vectors: Integer and integerish double vectors. See\n", 
#&gt;                   list(list("is_integerish()")), ".\n", list(), 
#&gt;                   " To integer vectors: Logical and integerish double vectors.\n", 
#&gt;                   list(), " To double vectors: Logical and integer vectors.\n", 
#&gt;                   list(), " To complex vectors: Logical, integer and double vectors.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Coercion to character vectors"), 
#&gt;                 list("\n", "\n", "\n", list("as_character()"), 
#&gt;                   " and ", list("as_string()"), " have an optional ", 
#&gt;                   list("encoding"), "\n", "argument to specify the encoding. R uses this information for\n", 
#&gt;                   "internal handling of strings and character vectors. Note that this\n", 
#&gt;                   "is only declarative, no encoding conversion is attempted.\n", 
#&gt;                   "\n", "Note that only ", list("as_string()"), 
#&gt;                   " can coerce symbols to a scalar\n", "character vector. This makes the code more explicit and adds an\n", 
#&gt;                   "extra type check.\n")), "\n", "\n", list(list(
#&gt;                 "Coercion to lists"), list("\n", "\n", "\n", 
#&gt;                 list("as_list()"), " only coerces vector and dictionary types (environments\n", 
#&gt;                 "are an example of dictionary type). Unlike ", 
#&gt;                 list(list("base::as.list()")), ",\n", list("as_list()"), 
#&gt;                 " removes all attributes except names.\n")), 
#&gt;             "\n", "\n", list(list("Effects of removing attributes"), 
#&gt;                 list("\n", "\n", "\n", "A technical side-effect of removing the attributes of the input is\n", 
#&gt;                   "that the underlying objects has to be copied. This has no\n", 
#&gt;                   "performance implications in the case of lists because this is a\n", 
#&gt;                   "shallow copy: only the list structure is copied, not the contents\n", 
#&gt;                   "(see ", list(list("duplicate()")), "). However, be aware that atomic vectors\n", 
#&gt;                   "containing large amounts of data will have to be copied.\n", 
#&gt;                   "\n", "In general, any attribute modification creates a copy, which is why\n", 
#&gt;                   "it is better to avoid using attributes with heavy atomic vectors.\n", 
#&gt;                   "Uncopyable objects like environments and symbols are an exception\n", 
#&gt;                   "to this rule: in this case, attributes modification happens in\n", 
#&gt;                   "place and has side-effects.\n")), "\n", "\n", 
#&gt;             list("\n", "# Coercing atomic vectors removes attributes with both base R and rlang:\n", 
#&gt;                 "x &lt;- structure(TRUE, class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.logical(x)\n", "\n", "# But coercing lists preserves attributes in base R but not rlang:\n", 
#&gt;                 "l &lt;- structure(list(TRUE), class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# Implicit conversions are performed in base R but not rlang:\n", 
#&gt;                 "as.logical(l)\n", list("\n", "as_logical(l)\n"), 
#&gt;                 "\n", "\n", "# Conversion methods are bypassed, making the result of the\n", 
#&gt;                 "# coercion more predictable:\n", "as.list.foo &lt;- function(x) \"wrong\"\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# The input is never parsed. E.g. character vectors of numbers are\n", 
#&gt;                 "# not converted to numeric types:\n", "as.integer(\"33\")\n", 
#&gt;                 list("\n", "as_integer(\"33\")\n"), "\n", "\n", 
#&gt;                 "\n", "# With base R tools there is no way to convert an environment to a\n", 
#&gt;                 "# list without either triggering method dispatch, or changing the\n", 
#&gt;                 "# original environment. as_list() makes it easy:\n", 
#&gt;                 "x &lt;- structure(as_environment(mtcars[1:2]), class = \"foobar\")\n", 
#&gt;                 "as.list.foobar &lt;- function(x) abort(\"dont call me\")\n", 
#&gt;                 "as_list(x)\n"), "\n", list("internal"), "\n"), 
#&gt;         `vector-construction.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("vector-construction"), "\n", list("vector-construction"), 
#&gt;             "\n", list("lgl"), "\n", list("int"), "\n", list(
#&gt;                 "dbl"), "\n", list("cpl"), "\n", list("chr"), 
#&gt;             "\n", list("bytes"), "\n", list("ll"), "\n", list(
#&gt;                 "Create vectors"), "\n", list("\n", "lgl(...)\n", 
#&gt;                 "\n", "int(...)\n", "\n", "dbl(...)\n", "\n", 
#&gt;                 "cpl(...)\n", "\n", "chr(...)\n", "\n", "bytes(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Components of the new vector. Bare lists and explicitly\n", 
#&gt;                 "spliced lists are spliced.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "The atomic vector constructors are equivalent to ", 
#&gt;                 list(list("c()")), " but:\n", list("\n", list(), 
#&gt;                   " They allow you to be more explicit about the output\n", 
#&gt;                   "type. Implicit coercions (e.g. from integer to logical) follow\n", 
#&gt;                   "the rules described in ", list("vector-coercion"), 
#&gt;                   ".\n", list(), " They use ", list("tidy dots"), 
#&gt;                   " and thus support splicing with ", list("!!!"), 
#&gt;                   ".\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " All the abbreviated constructors such as ", 
#&gt;                   list("lgl()"), " will probably be\n", "moved to the vctrs package at some point. This is why they are\n", 
#&gt;                   "marked as questioning.\n", list(), " Automatic splicing is soft-deprecated and will trigger a warning\n", 
#&gt;                   "in a future version. Please splice explicitly with ", 
#&gt;                   list("!!!"), ".\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# These constructors are like a typed version of c():\n", 
#&gt;                 "c(TRUE, FALSE)\n", "lgl(TRUE, FALSE)\n", "\n", 
#&gt;                 "# They follow a restricted set of coercion rules:\n", 
#&gt;                 "int(TRUE, FALSE, 20)\n", "\n", "# Lists can be spliced:\n", 
#&gt;                 "dbl(10, !!! list(1, 2L), TRUE)\n", "\n", "\n", 
#&gt;                 "# They splice names a bit differently than c(). The latter\n", 
#&gt;                 "# automatically composes inner and outer names:\n", 
#&gt;                 "c(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "\n", "# On the other hand, rlang's ctors use the inner names and issue a\n", 
#&gt;                 "# warning to inform the user that the outer names are ignored:\n", 
#&gt;                 "dbl(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "dbl(a = c(1, 2))\n", "\n", "# As an exception, it is allowed to provide an outer name when the\n", 
#&gt;                 "# inner vector is an unnamed scalar atomic:\n", 
#&gt;                 "dbl(a = 1)\n", "\n", "# Spliced lists behave the same way:\n", 
#&gt;                 "dbl(!!! list(a = 1))\n", "dbl(!!! list(a = c(A = 1)))\n", 
#&gt;                 "\n", "# bytes() accepts integerish inputs\n", 
#&gt;                 "bytes(1:10)\n", "bytes(0x01, 0xff, c(0x03, 0x05), list(10, 20, 30L))\n"), 
#&gt;             "\n"), `vector-old-ctors.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("node"), "\n", list("node"), "\n", list(
#&gt;                 "vector-old-ctors"), "\n", list("lgl_len"), "\n", 
#&gt;             list("int_len"), "\n", list("dbl_len"), "\n", list(
#&gt;                 "chr_len"), "\n", list("cpl_len"), "\n", list(
#&gt;                 "raw_len"), "\n", list("bytes_len"), "\n", list(
#&gt;                 "list_len"), "\n", list("lgl_along"), "\n", list(
#&gt;                 "int_along"), "\n", list("dbl_along"), "\n", 
#&gt;             list("chr_along"), "\n", list("cpl_along"), "\n", 
#&gt;             list("raw_along"), "\n", list("bytes_along"), "\n", 
#&gt;             list("list_along"), "\n", list("Retired vector construction by length"), 
#&gt;             "\n", list("\n", "node(car, cdr = NULL)\n", "\n", 
#&gt;                 "lgl_len(.n)\n", "\n", "int_len(.n)\n", "\n", 
#&gt;                 "dbl_len(.n)\n", "\n", "chr_len(.n)\n", "\n", 
#&gt;                 "cpl_len(.n)\n", "\n", "raw_len(.n)\n", "\n", 
#&gt;                 "bytes_len(.n)\n", "\n", "list_len(.n)\n", "\n", 
#&gt;                 "lgl_along(.x)\n", "\n", "int_along(.x)\n", "\n", 
#&gt;                 "dbl_along(.x)\n", "\n", "chr_along(.x)\n", "\n", 
#&gt;                 "cpl_along(.x)\n", "\n", "raw_along(.x)\n", "\n", 
#&gt;                 "bytes_along(.x)\n", "\n", "list_along(.x)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("new_"), " prefix in\n", "rlang 0.2.0. This is for consistency with other non-variadic object\n", 
#&gt;                 "constructors.\n"), "\n", list("internal"), "\n"), 
#&gt;         with_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("with_abort"), "\n", list("with_abort"), 
#&gt;             "\n", list("Promote all errors to rlang errors"), 
#&gt;             "\n", list("\n", "with_abort(expr, classes = \"error\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression run in a context where errors are\n", 
#&gt;                 "promoted to rlang errors.")), "\n", "\n", list(
#&gt;                 list("classes"), list("Character vector of condition classes that should be\n", 
#&gt;                   "promoted to rlang errors.")), "\n"), "\n", 
#&gt;             list("\n", list("with_abort()"), " promotes conditions as if they were thrown with\n", 
#&gt;                 list(list("abort()")), ". These errors embed a ", 
#&gt;                 list("backtrace"), ". They are\n", "particularly suitable to be set as ", 
#&gt;                 list("parent errors"), " (see ", list("parent"), 
#&gt;                 "\n", "argument of ", list(list("abort()")), 
#&gt;                 ").\n"), "\n", list("\n", list("with_abort()"), 
#&gt;                 " installs a ", list("calling handler"), " for errors and\n", 
#&gt;                 "rethrows non-rlang errors with ", list(list(
#&gt;                   "abort()")), ". However, error handlers\n", 
#&gt;                 "installed ", list("within"), " ", list("with_abort()"), 
#&gt;                 " have priority. For this reason,\n", "you should use ", 
#&gt;                 list(list("tryCatch()")), " and ", list("exiting"), 
#&gt;                 " handlers outside\n", list("with_abort()"), 
#&gt;                 " rather than inside.\n"), "\n", list("\n", "# with_abort() automatically casts simple errors thrown by stop()\n", 
#&gt;                 "# to rlang errors. It is is handy for rethrowing low level\n", 
#&gt;                 "# errors. The backtraces are then segmented between the low level\n", 
#&gt;                 "# and high level contexts.\n", "f &lt;- function() g()\n", 
#&gt;                 "g &lt;- function() stop(\"Low level error\")\n", 
#&gt;                 "\n", "high_level &lt;- function() {\n", "  with_handlers(\n", 
#&gt;                 "    with_abort(f()),\n", "    error = ~ abort(\"High level error\", parent = .)\n", 
#&gt;                 "  )\n", "}\n"), "\n"), with_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("with_env"), "\n", list("with_env"), "\n", 
#&gt;             list("locally"), "\n", list("Evaluate an expression within a given environment"), 
#&gt;             "\n", list("\n", "with_env(env, expr)\n", "\n", "locally(expr)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment within which to evaluate ", 
#&gt;                 list("expr"), ". Can be\n", "an object with a ", 
#&gt;                 list(list("get_env()")), " method.")), "\n", 
#&gt;                 "\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions evaluate ", 
#&gt;                 list("expr"), " within a given environment (", 
#&gt;                 list("env"), "\n", "for ", list("with_env()"), 
#&gt;                 ", or the child of the current environment for\n", 
#&gt;                 list("locally"), "). They rely on ", list(list(
#&gt;                   "eval_bare()")), " which features a lighter\n", 
#&gt;                 "evaluation mechanism than base R ", list(list(
#&gt;                   "base::eval()")), ", and which also has\n", 
#&gt;                 "some subtle implications when evaluting stack sensitive functions\n", 
#&gt;                 "(see help for ", list(list("eval_bare()")), 
#&gt;                 ").\n"), "\n", list("\n", list("locally()"), 
#&gt;                 " is equivalent to the base function\n", list(
#&gt;                   list("base::local()")), " but it produces a much cleaner\n", 
#&gt;                 "evaluation stack, and has stack-consistent semantics. It is thus\n", 
#&gt;                 "more suited for experimenting with the R language.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "# with_env() is handy to create formulas with a given environment:\n", 
#&gt;                 "env &lt;- child_env(\"rlang\")\n", "f &lt;- with_env(env, ~new_formula())\n", 
#&gt;                 "identical(f_env(f), env)\n", "\n", "# Or functions with a given enclosure:\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(get_env(fn), env)\n", 
#&gt;                 "\n", "\n", "# Unlike eval() it doesn't create duplicates on the evaluation\n", 
#&gt;                 "# stack. You can thus use it e.g. to create non-local returns:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g(current_env())\n", 
#&gt;                 "  \"normal return\"\n", "}\n", "g &lt;- function(env) {\n", 
#&gt;                 "  with_env(env, return(\"early return\"))\n", 
#&gt;                 "}\n", "fn()\n", "\n", "\n", "# Since env is passed to as_environment(), it can be any object with an\n", 
#&gt;                 "# as_environment() method. For strings, the pkg_env() is returned:\n", 
#&gt;                 "with_env(\"base\", ~mtcars)\n", "\n", "# This can be handy to put dictionaries in scope:\n", 
#&gt;                 "with_env(mtcars, cyl)\n"), "\n", list("internal"), 
#&gt;             "\n"), with_handlers.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("with_handlers"), "\n", list("with_handlers"), 
#&gt;             "\n", list("calling"), "\n", list("Establish handlers on the stack"), 
#&gt;             "\n", list("\n", "with_handlers(.expr, ...)\n", "\n", 
#&gt;                 "calling(handler)\n"), "\n", list("\n", list(
#&gt;                 list(".expr"), list("An expression to execute in a context where new\n", 
#&gt;                   "handlers are established. The underscored version takes a quoted\n", 
#&gt;                   "expression or a quoted formula.")), "\n", 
#&gt;                 "\n", list(list("..."), list("Named handlers. These should be functions of one\n", 
#&gt;                   "argument. These handlers are treated as exiting by default. Use\n", 
#&gt;                   list(list("calling()")), " to specify a calling handler. These dots support\n", 
#&gt;                   list("tidy dots"), " features and are passed to ", 
#&gt;                   list(list("as_function()")), "\n", "to enable the formula shortcut for lambda functions.")), 
#&gt;                 "\n", "\n", list(list("handler"), list("A handler function that takes a condition as\n", 
#&gt;                   "argument. This is passed to ", list(list("as_function()")), 
#&gt;                   " and can thus be a\n", "formula describing a lambda function.")), 
#&gt;                 "\n"), "\n", list("\n", "Condition handlers are functions established on the evaluation\n", 
#&gt;                 "stack (see ", list(list("ctxt_stack()")), ") that are called by R when a condition is\n", 
#&gt;                 "signalled (see ", list(list("cnd_signal()")), 
#&gt;                 " and ", list(list("abort()")), " for two common signal\n", 
#&gt;                 "functions). They come in two types:\n", list(
#&gt;                   "\n", list(), " Exiting handlers aborts all code currently run between\n", 
#&gt;                   list("with_handlers()"), " and the point where the condition has been\n", 
#&gt;                   "raised. ", list("with_handlers()"), " passes the return value of the handler\n", 
#&gt;                   "to its caller.\n", list(), " Calling handlers, which are executed from inside the signalling\n", 
#&gt;                   "functions. Their return values are ignored, only their side\n", 
#&gt;                   "effects matters. Valid side effects are writing a log message, or\n", 
#&gt;                   "jumping out of the signalling context by ", 
#&gt;                   list("invoking a restart"), " or using ", list(
#&gt;                     list("return_from()")), ". If the raised\n", 
#&gt;                   "condition was an error, this interrupts the aborting process.\n", 
#&gt;                   "\n", "If a calling handler returns normally, it effectively declines to\n", 
#&gt;                   "handle the condition and other handlers on the stack (calling or\n", 
#&gt;                   "exiting) are given a chance to handle the condition.\n"), 
#&gt;                 "\n", "\n", "Handlers are exiting by default, use ", 
#&gt;                 list(list("calling()")), " to create a\n", "calling handler.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", " ", list(
#&gt;                 "exiting()"), " is soft-deprecated as of rlang\n", 
#&gt;                 "0.4.0 because ", list(list("with_handlers()")), 
#&gt;                 " now treats handlers as exiting by\n", "default.\n")), 
#&gt;             "\n", "\n", list("\n", "# Signal a condition with signal():\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"called?\\n\")\n", 
#&gt;                 "  \"fn() return value\"\n", "}\n", "g &lt;- function() {\n", 
#&gt;                 "  h()\n", "  cat(\"called?\\n\")\n", "}\n", 
#&gt;                 "h &lt;- function() {\n", "  signal(\"A foobar condition occurred\", \"foo\")\n", 
#&gt;                 "  cat(\"called?\\n\")\n", "}\n", "\n", "# Exiting handlers jump to with_handlers() before being\n", 
#&gt;                 "# executed. Their return value is handed over:\n", 
#&gt;                 "handler &lt;- function(c) \"handler return value\"\n", 
#&gt;                 "with_handlers(fn(), foo = handler)\n", "\n", 
#&gt;                 "# Calling handlers are called in turn and their return value is\n", 
#&gt;                 "# ignored. Returning just means they are declining to take charge of\n", 
#&gt;                 "# the condition. However, they can produce side-effects such as\n", 
#&gt;                 "# displaying a message:\n", "some_handler &lt;- function(c) cat(\"some handler!\\n\")\n", 
#&gt;                 "other_handler &lt;- function(c) cat(\"other handler!\\n\")\n", 
#&gt;                 "with_handlers(fn(), foo = calling(some_handler), foo = calling(other_handler))\n", 
#&gt;                 "\n", "# If a calling handler jumps to an earlier context, it takes\n", 
#&gt;                 "# charge of the condition and no other handler gets a chance to\n", 
#&gt;                 "# deal with it. The canonical way of transferring control is by\n", 
#&gt;                 "# jumping to a restart. See with_restarts() and restarting()\n", 
#&gt;                 "# documentation for more on this:\n", "exiting_handler &lt;- function(c) rst_jump(\"rst_foo\")\n", 
#&gt;                 "fn2 &lt;- function() {\n", "  with_restarts(g(), rst_foo = function() \"restart value\")\n", 
#&gt;                 "}\n", "with_handlers(fn2(), foo = calling(exiting_handler), foo = calling(other_handler))\n"), 
#&gt;             "\n"), with_restarts.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("with_restarts"), "\n", list("with_restarts"), 
#&gt;             "\n", list("Establish a restart point on the stack"), 
#&gt;             "\n", list("\n", "with_restarts(.expr, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".expr"), list("An expression to execute with new restarts established\n", 
#&gt;                 "on the stack. This argument is passed by expression and supports\n", 
#&gt;                 list("unquoting"), ". It is evaluated in a context where\n", 
#&gt;                 "restarts are established.")), "\n", "\n", list(
#&gt;                 list("..."), list("Named restart functions. The name is taken as the\n", 
#&gt;                   "restart name and the function is executed after the jump. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restart points are named functions that are established with\n", 
#&gt;                 list("with_restarts()"), ". Once established, you can interrupt the normal\n", 
#&gt;                 "execution of R code, jump to the restart, and resume execution from\n", 
#&gt;                 "there. Each restart is established along with a restart function\n", 
#&gt;                 "that is executed after the jump and that provides a return value\n", 
#&gt;                 "from the establishing point (i.e., a return value for\n", 
#&gt;                 list("with_restarts()"), ").\n"), "\n", list(
#&gt;                 "\n", "Restarts are not the only way of jumping to a previous call frame\n", 
#&gt;                 "(see ", list(list("return_from()")), " or ", 
#&gt;                 list(list("return_to()")), "). However, they have the\n", 
#&gt;                 "advantage of being callable by name once established.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Restarts are not the only way to jump to a previous frame, but\n", 
#&gt;                 "# they have the advantage of being callable by name:\n", 
#&gt;                 "fn &lt;- function() with_restarts(g(), my_restart = function() \"returned\")\n", 
#&gt;                 "g &lt;- function() h()\n", "h &lt;- function() { rst_jump(\"my_restart\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "# Whereas a non-local return requires to manually pass the calling\n", 
#&gt;                 "# frame to the return function:\n", "fn &lt;- function() g(current_env())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) { return_from(env, \"returned\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "\n", "# rst_maybe_jump() checks that a restart exists before trying to jump:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"will this be called?\\n\")\n", 
#&gt;                 "}\n", "g &lt;- function() {\n", "  rst_maybe_jump(\"my_restart\")\n", 
#&gt;                 "  cat(\"will this be called?\\n\")\n", "}\n", 
#&gt;                 "\n", "# Here no restart are on the stack:\n", 
#&gt;                 "fn()\n", "\n", "# If a restart point called `my_restart` was established on the\n", 
#&gt;                 "# stack before calling fn(), the control flow will jump there:\n", 
#&gt;                 "rst &lt;- function() {\n", "  cat(\"restarting...\\n\")\n", 
#&gt;                 "  \"return value\"\n", "}\n", "with_restarts(fn(), my_restart = rst)\n", 
#&gt;                 "\n", "\n", "# Restarts are particularly useful to provide alternative default\n", 
#&gt;                 "# values when the normal output cannot be computed:\n", 
#&gt;                 "\n", "fn &lt;- function(valid_input) {\n", "  if (valid_input) {\n", 
#&gt;                 "    return(\"normal value\")\n", "  }\n", "\n", 
#&gt;                 "  # We decide to return the empty string \"\" as default value. An\n", 
#&gt;                 "  # altenative strategy would be to signal an error. In any case,\n", 
#&gt;                 "  # we want to provide a way for the caller to get a different\n", 
#&gt;                 "  # output. For this purpose, we provide two restart functions that\n", 
#&gt;                 "  # returns alternative defaults:\n", "  restarts &lt;- list(\n", 
#&gt;                 "    rst_empty_chr = function() character(0),\n", 
#&gt;                 "    rst_null = function() NULL\n", "  )\n", 
#&gt;                 "\n", "  with_restarts(splice(restarts), .expr = {\n", 
#&gt;                 "\n", "    # Signal a typed condition to let the caller know that we are\n", 
#&gt;                 "    # about to return an empty string as default value:\n", 
#&gt;                 "    cnd_signal(\"default_empty_string\")\n", 
#&gt;                 "\n", "    # If no jump to with_restarts, return default value:\n", 
#&gt;                 "    \"\"\n", "  })\n", "}\n", "\n", "# Normal value for valid input:\n", 
#&gt;                 "fn(TRUE)\n", "\n", "# Default value for bad input:\n", 
#&gt;                 "fn(FALSE)\n", "\n", "# Change the default value if you need an empty character vector by\n", 
#&gt;                 "# defining a calling handler that jumps to the restart. It has to\n", 
#&gt;                 "# be calling because exiting handlers jump to the place where they\n", 
#&gt;                 "# are established before being executed, and the restart is not\n", 
#&gt;                 "# defined anymore at that point:\n", "rst_handler &lt;- calling(function(c) rst_jump(\"rst_empty_chr\"))\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = rst_handler)\n", 
#&gt;                 "\n", "# You can use restarting() to create restarting handlers easily:\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = restarting(\"rst_null\"))\n"), 
#&gt;             "\n", list("\n", list(list("return_from()")), " and ", 
#&gt;                 list(list("return_to()")), " for a more flexible way\n", 
#&gt;                 "of performing a non-local jump to an arbitrary call frame.\n"), 
#&gt;             "\n", list("internal"), "\n"), wref_key.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("wref_key"), "\n", list("wref_key"), "\n", list(
#&gt;                 "wref_value"), "\n", list("Get key/value from a weak reference object"), 
#&gt;             "\n", list("\n", "wref_key(x)\n", "\n", "wref_value(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A weak reference object.")), 
#&gt;                 "\n"), "\n", list("\n", "Get key/value from a weak reference object\n"), 
#&gt;             "\n", list("\n", list(list("is_weakref()")), " and ", 
#&gt;                 list(list("new_weakref()")), ".\n"), "\n"), zap.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "zap"), "\n", list("zap"), "\n", list("is_zap"), 
#&gt;             "\n", list("Create zap objects"), "\n", list("\n", 
#&gt;                 "zap()\n", "\n", "is_zap(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("zap()"), " creates a sentinel object that indicates that an object\n", 
#&gt;                 "should be removed. For instance, named zaps instruct ", 
#&gt;                 list(list("env_bind()")), "\n", "and ", list(
#&gt;                   list("call_modify()")), " to remove those objects from the environment or\n", 
#&gt;                 "the call.\n", "\n", "The advantage of zap objects is that they unambiguously signal the\n", 
#&gt;                 "intent of removing an object. Sentinels like ", 
#&gt;                 list("NULL"), " or\n", list(list("missing_arg()")), 
#&gt;                 " are ambiguous because they represent valid R\n", 
#&gt;                 "objects.\n"), "\n", list("\n", "# Create one zap object:\n", 
#&gt;                 "zap()\n", "\n", "# Create a list of zaps:\n", 
#&gt;                 "rep(list(zap()), 3)\n", "rep_named(c(\"foo\", \"bar\"), list(zap()))\n"), 
#&gt;             "\n")), source = list(abort.Rd = c("R/cnd-abort.R", 
#&gt;     "R/cnd-signal.R"), are_na.Rd = "R/vec-na.R", arg_match.Rd = "R/arg.R", 
#&gt;         as_box.Rd = "R/s3.R", as_bytes.Rd = "R/utils-encoding.R", 
#&gt;         as_data_mask.Rd = "R/eval-tidy.R", as_env.Rd = "R/lifecycle-retired.R", 
#&gt;         as_environment.Rd = "R/env.R", as_function.Rd = "R/fn.R", 
#&gt;         as_label.Rd = "R/deparse.R", as_name.Rd = "R/deparse.R", 
#&gt;         as_overscope.Rd = "R/lifecycle-retired.R", as_pairlist.Rd = "R/node.R", 
#&gt;         as_quosure.Rd = "R/quo.R", as_string.Rd = "R/sym.R", 
#&gt;         as_utf8_character.Rd = "R/utils-encoding.R", `bare-type-predicates.Rd` = "R/types.R", 
#&gt;         box.Rd = "R/s3.R", call2.Rd = "R/call.R", call_args.Rd = "R/call.R", 
#&gt;         call_fn.Rd = "R/call.R", call_inspect.Rd = "R/stack.R", 
#&gt;         call_modify.Rd = "R/call.R", call_name.Rd = "R/call.R", 
#&gt;         call_standardise.Rd = "R/call.R", caller_env.Rd = "R/env-special.R", 
#&gt;         caller_fn.Rd = "R/stack.R", caller_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         catch_cnd.Rd = "R/cnd-handlers.R", chr_unserialise_unicode.Rd = "R/utils-encoding.R", 
#&gt;         cnd.Rd = c("R/cnd-error.R", "R/cnd.R"), cnd_message.Rd = "R/cnd-message.R", 
#&gt;         cnd_muffle.Rd = "R/cnd-handlers.R", cnd_signal.Rd = "R/cnd-signal.R", 
#&gt;         cnd_type.Rd = "R/cnd.R", done.Rd = "R/s3.R", dots_definitions.Rd = "R/dots.R", 
#&gt;         dots_n.Rd = "R/dots.R", dots_values.Rd = "R/dots.R", 
#&gt;         duplicate.Rd = "R/sexp.R", empty_env.Rd = "R/env-special.R", 
#&gt;         entrace.Rd = "R/cnd-entrace.R", env.Rd = "R/env.R", env_bind.Rd = "R/env-binding.R", 
#&gt;         env_bind_exprs.Rd = "R/lifecycle-retired.R", env_binding_are_active.Rd = "R/env-binding.R", 
#&gt;         env_binding_lock.Rd = "R/env-binding.R", env_bury.Rd = "R/env-binding.R", 
#&gt;         env_clone.Rd = "R/env.R", env_depth.Rd = "R/env.R", env_get.Rd = "R/env-binding.R", 
#&gt;         env_has.Rd = "R/env-binding.R", env_inherits.Rd = "R/env.R", 
#&gt;         env_lock.Rd = "R/env.R", env_name.Rd = "R/env-special.R", 
#&gt;         env_names.Rd = "R/env-binding.R", env_parent.Rd = "R/env.R", 
#&gt;         env_poke.Rd = "R/env-binding.R", env_print.Rd = "R/env.R", 
#&gt;         env_unbind.Rd = "R/env-binding.R", env_unlock.Rd = "R/env.R", 
#&gt;         eval_bare.Rd = "R/eval.R", eval_tidy.Rd = "R/eval-tidy.R", 
#&gt;         exec.Rd = "R/eval.R", exiting.Rd = "R/lifecycle-retired.R", 
#&gt;         expr_interp.Rd = "R/quasiquotation.R", expr_label.Rd = "R/expr.R", 
#&gt;         expr_print.Rd = "R/expr.R", exprs_auto_name.Rd = "R/quotation.R", 
#&gt;         f_rhs.Rd = "R/formula.R", f_text.Rd = "R/formula.R", 
#&gt;         flatten.Rd = "R/vec-squash.R", fn_body.Rd = "R/fn.R", 
#&gt;         fn_env.Rd = "R/fn.R", fn_fmls.Rd = "R/fn.R", frame_position.Rd = "R/lifecycle-retired.R", 
#&gt;         friendly_type.Rd = "R/types.R", get_env.Rd = "R/env.R", 
#&gt;         has_length.Rd = "R/attr.R", has_name.Rd = "R/attr.R", 
#&gt;         inherits_any.Rd = "R/s3.R", invoke.Rd = "R/eval.R", is_call.Rd = "R/call.R", 
#&gt;         is_callable.Rd = "R/call.R", is_condition.Rd = "R/cnd.R", 
#&gt;         is_copyable.Rd = "R/types.R", is_empty.Rd = "R/types.R", 
#&gt;         is_env.Rd = "R/lifecycle-retired.R", is_environment.Rd = "R/types.R", 
#&gt;         is_expr.Rd = "R/lifecycle-retired.R", is_expression.Rd = "R/expr.R", 
#&gt;         is_formula.Rd = "R/formula.R", is_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         is_function.Rd = "R/fn.R", is_installed.Rd = "R/env-special.R", 
#&gt;         is_integerish.Rd = "R/types.R", is_interactive.Rd = "R/state.R", 
#&gt;         is_lang.Rd = "R/lifecycle-retired.R", is_named.Rd = "R/attr.R", 
#&gt;         is_namespace.Rd = "R/env-special.R", is_pairlist.Rd = "R/node.R", 
#&gt;         is_reference.Rd = "R/types.R", is_stack.Rd = "R/lifecycle-retired.R", 
#&gt;         is_symbol.Rd = "R/sym.R", is_true.Rd = "R/types.R", is_weakref.Rd = "R/weakref.R", 
#&gt;         lang.Rd = "R/lifecycle-retired.R", lang_head.Rd = "R/lifecycle-retired.R", 
#&gt;         lang_modify.Rd = "R/lifecycle-retired.R", last_error.Rd = "R/cnd-abort.R", 
#&gt;         lifecycle.Rd = "R/lifecycle.R", missing.Rd = "R/vec-na.R", 
#&gt;         missing_arg.Rd = "R/arg.R", mut_node_car.Rd = "R/lifecycle-retired.R", 
#&gt;         names2.Rd = "R/attr.R", `new-vector-along-retired.Rd` = "R/lifecycle-retired.R", 
#&gt;         `new-vector.Rd` = "R/vec-new.R", new_call.Rd = "R/node.R", 
#&gt;         new_formula.Rd = "R/formula.R", new_function.Rd = "R/fn.R", 
#&gt;         new_node.Rd = "R/node.R", new_quosures.Rd = "R/quo.R", 
#&gt;         new_weakref.Rd = "R/weakref.R", ns_env.Rd = "R/env-special.R", 
#&gt;         `op-definition.Rd` = "R/operators.R", `op-get-attr.Rd` = "R/operators.R", 
#&gt;         `op-na-default.Rd` = "R/operators.R", `op-null-default.Rd` = "R/operators.R", 
#&gt;         overscope_eval_next.Rd = "R/lifecycle-retired.R", pairlist2.Rd = "R/call.R", 
#&gt;         parse_expr.Rd = "R/parse.R", parse_quosure.Rd = "R/lifecycle-retired.R", 
#&gt;         prepend.Rd = "R/lifecycle-retired.R", prim_name.Rd = "R/fn.R", 
#&gt;         quasiquotation.Rd = "R/quasiquotation.R", quo_expr.Rd = "R/lifecycle-retired.R", 
#&gt;         quo_label.Rd = "R/quo.R", quo_squash.Rd = "R/quo.R", 
#&gt;         quosure.Rd = "R/quo.R", quotation.Rd = "R/quotation.R", 
#&gt;         rep_along.Rd = "R/vec-new.R", restarting.Rd = "R/cnd-handlers.R", 
#&gt;         return_from.Rd = "R/stack.R", rlang_backtrace_on_error.Rd = "R/cnd-abort.R", 
#&gt;         rst_abort.Rd = "R/cnd-restarts.R", rst_list.Rd = "R/cnd-restarts.R", 
#&gt;         `scalar-type-predicates.Rd` = "R/types.R", scoped_bindings.Rd = "R/env-binding.R", 
#&gt;         scoped_env.Rd = "R/lifecycle-retired.R", scoped_options.Rd = "R/state.R", 
#&gt;         search_envs.Rd = "R/env-special.R", seq2.Rd = "R/vec.R", 
#&gt;         set_attrs.Rd = "R/lifecycle-retired.R", set_expr.Rd = "R/expr.R", 
#&gt;         set_names.Rd = "R/attr.R", splice.Rd = "R/dots.R", stack.Rd = "R/lifecycle-retired.R", 
#&gt;         stack_trim.Rd = "R/lifecycle-retired.R", string.Rd = "R/utils-encoding.R", 
#&gt;         switch_type.Rd = "R/lifecycle-retired.R", sym.Rd = "R/sym.R", 
#&gt;         `tidy-dots.Rd` = c("R/dots.R", "R/vec-new.R"), `tidyeval-data.Rd` = "R/eval-tidy.R", 
#&gt;         trace_back.Rd = "R/trace.R", `type-predicates.Rd` = "R/types.R", 
#&gt;         type_of.Rd = "R/lifecycle-retired.R", vec_poke_n.Rd = "R/vec.R", 
#&gt;         `vector-coercion.Rd` = "R/lifecycle-retired.R", `vector-construction.Rd` = "R/vec-new.R", 
#&gt;         `vector-old-ctors.Rd` = "R/lifecycle-retired.R", with_abort.Rd = "R/cnd-entrace.R", 
#&gt;         with_env.Rd = "R/eval.R", with_handlers.Rd = "R/cnd-handlers.R", 
#&gt;         with_restarts.Rd = "R/cnd-restarts.R", wref_key.Rd = "R/weakref.R", 
#&gt;         zap.Rd = "R/s3.R"), concepts = list(abort.Rd = character(0), 
#&gt;         are_na.Rd = character(0), arg_match.Rd = character(0), 
#&gt;         as_box.Rd = character(0), as_bytes.Rd = character(0), 
#&gt;         as_data_mask.Rd = character(0), as_env.Rd = character(0), 
#&gt;         as_environment.Rd = character(0), as_function.Rd = character(0), 
#&gt;         as_label.Rd = character(0), as_name.Rd = character(0), 
#&gt;         as_overscope.Rd = character(0), as_pairlist.Rd = character(0), 
#&gt;         as_quosure.Rd = character(0), as_string.Rd = character(0), 
#&gt;         as_utf8_character.Rd = character(0), `bare-type-predicates.Rd` = character(0), 
#&gt;         box.Rd = character(0), call2.Rd = character(0), call_args.Rd = character(0), 
#&gt;         call_fn.Rd = character(0), call_inspect.Rd = character(0), 
#&gt;         call_modify.Rd = character(0), call_name.Rd = character(0), 
#&gt;         call_standardise.Rd = character(0), caller_env.Rd = character(0), 
#&gt;         caller_fn.Rd = character(0), caller_frame.Rd = character(0), 
#&gt;         catch_cnd.Rd = character(0), chr_unserialise_unicode.Rd = character(0), 
#&gt;         cnd.Rd = character(0), cnd_message.Rd = character(0), 
#&gt;         cnd_muffle.Rd = character(0), cnd_signal.Rd = character(0), 
#&gt;         cnd_type.Rd = character(0), done.Rd = character(0), dots_definitions.Rd = character(0), 
#&gt;         dots_n.Rd = character(0), dots_values.Rd = character(0), 
#&gt;         duplicate.Rd = character(0), empty_env.Rd = character(0), 
#&gt;         entrace.Rd = character(0), env.Rd = character(0), env_bind.Rd = character(0), 
#&gt;         env_bind_exprs.Rd = character(0), env_binding_are_active.Rd = character(0), 
#&gt;         env_binding_lock.Rd = character(0), env_bury.Rd = character(0), 
#&gt;         env_clone.Rd = character(0), env_depth.Rd = character(0), 
#&gt;         env_get.Rd = character(0), env_has.Rd = character(0), 
#&gt;         env_inherits.Rd = character(0), env_lock.Rd = character(0), 
#&gt;         env_name.Rd = character(0), env_names.Rd = character(0), 
#&gt;         env_parent.Rd = character(0), env_poke.Rd = character(0), 
#&gt;         env_print.Rd = character(0), env_unbind.Rd = character(0), 
#&gt;         env_unlock.Rd = character(0), eval_bare.Rd = character(0), 
#&gt;         eval_tidy.Rd = character(0), exec.Rd = character(0), 
#&gt;         exiting.Rd = character(0), expr_interp.Rd = character(0), 
#&gt;         expr_label.Rd = character(0), expr_print.Rd = character(0), 
#&gt;         exprs_auto_name.Rd = character(0), f_rhs.Rd = character(0), 
#&gt;         f_text.Rd = character(0), flatten.Rd = character(0), 
#&gt;         fn_body.Rd = character(0), fn_env.Rd = character(0), 
#&gt;         fn_fmls.Rd = character(0), frame_position.Rd = character(0), 
#&gt;         friendly_type.Rd = character(0), get_env.Rd = character(0), 
#&gt;         has_length.Rd = character(0), has_name.Rd = character(0), 
#&gt;         inherits_any.Rd = character(0), invoke.Rd = character(0), 
#&gt;         is_call.Rd = character(0), is_callable.Rd = character(0), 
#&gt;         is_condition.Rd = character(0), is_copyable.Rd = character(0), 
#&gt;         is_empty.Rd = character(0), is_env.Rd = character(0), 
#&gt;         is_environment.Rd = character(0), is_expr.Rd = character(0), 
#&gt;         is_expression.Rd = character(0), is_formula.Rd = character(0), 
#&gt;         is_frame.Rd = character(0), is_function.Rd = character(0), 
#&gt;         is_installed.Rd = character(0), is_integerish.Rd = character(0), 
#&gt;         is_interactive.Rd = character(0), is_lang.Rd = character(0), 
#&gt;         is_named.Rd = character(0), is_namespace.Rd = character(0), 
#&gt;         is_pairlist.Rd = character(0), is_reference.Rd = character(0), 
#&gt;         is_stack.Rd = character(0), is_symbol.Rd = character(0), 
#&gt;         is_true.Rd = character(0), is_weakref.Rd = character(0), 
#&gt;         lang.Rd = character(0), lang_head.Rd = character(0), 
#&gt;         lang_modify.Rd = character(0), last_error.Rd = character(0), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = character(0), 
#&gt;         missing_arg.Rd = character(0), mut_node_car.Rd = character(0), 
#&gt;         names2.Rd = character(0), `new-vector-along-retired.Rd` = character(0), 
#&gt;         `new-vector.Rd` = character(0), new_call.Rd = character(0), 
#&gt;         new_formula.Rd = character(0), new_function.Rd = character(0), 
#&gt;         new_node.Rd = character(0), new_quosures.Rd = character(0), 
#&gt;         new_weakref.Rd = character(0), ns_env.Rd = character(0), 
#&gt;         `op-definition.Rd` = character(0), `op-get-attr.Rd` = character(0), 
#&gt;         `op-na-default.Rd` = character(0), `op-null-default.Rd` = character(0), 
#&gt;         overscope_eval_next.Rd = character(0), pairlist2.Rd = character(0), 
#&gt;         parse_expr.Rd = character(0), parse_quosure.Rd = character(0), 
#&gt;         prepend.Rd = character(0), prim_name.Rd = character(0), 
#&gt;         quasiquotation.Rd = character(0), quo_expr.Rd = character(0), 
#&gt;         quo_label.Rd = character(0), quo_squash.Rd = character(0), 
#&gt;         quosure.Rd = character(0), quotation.Rd = character(0), 
#&gt;         rep_along.Rd = character(0), restarting.Rd = character(0), 
#&gt;         return_from.Rd = character(0), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = character(0), rst_list.Rd = character(0), 
#&gt;         `scalar-type-predicates.Rd` = character(0), scoped_bindings.Rd = character(0), 
#&gt;         scoped_env.Rd = character(0), scoped_options.Rd = character(0), 
#&gt;         search_envs.Rd = character(0), seq2.Rd = character(0), 
#&gt;         set_attrs.Rd = character(0), set_expr.Rd = character(0), 
#&gt;         set_names.Rd = character(0), splice.Rd = character(0), 
#&gt;         stack.Rd = character(0), stack_trim.Rd = character(0), 
#&gt;         string.Rd = character(0), switch_type.Rd = character(0), 
#&gt;         sym.Rd = character(0), `tidy-dots.Rd` = character(0), 
#&gt;         `tidyeval-data.Rd` = character(0), trace_back.Rd = character(0), 
#&gt;         `type-predicates.Rd` = character(0), type_of.Rd = character(0), 
#&gt;         vec_poke_n.Rd = character(0), `vector-coercion.Rd` = character(0), 
#&gt;         `vector-construction.Rd` = character(0), `vector-old-ctors.Rd` = character(0), 
#&gt;         with_abort.Rd = character(0), with_env.Rd = character(0), 
#&gt;         with_handlers.Rd = character(0), with_restarts.Rd = character(0), 
#&gt;         wref_key.Rd = character(0), zap.Rd = character(0)), internal = c(FALSE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, FALSE, FALSE)), tutorials = list(name = character(0), 
#&gt;         file_out = character(0), title = character(0), pagetitle = character(0), 
#&gt;         url = character(0)), vignettes = list(name = character(0), 
#&gt;         file_in = character(0), file_out = character(0), title = character(0)), 
#&gt;     topic_index = c(`:=` = "quasiquotation", `!!` = "quasiquotation", 
#&gt;     `!!!` = "quasiquotation", .data = "tidyeval-data", `{{` = "quasiquotation", 
#&gt;     `{{}}` = "quasiquotation", `%@%` = "op-get-attr", `%@%&lt;-` = "op-get-attr", 
#&gt;     `%|%` = "op-na-default", `%||%` = "op-null-default", abort = "abort", 
#&gt;     add_backtrace = "rlang_backtrace_on_error", are_na = "are_na", 
#&gt;     arg_match = "arg_match", as_box = "as_box", as_box_if = "as_box", 
#&gt;     as_bytes = "as_bytes", as_character = "vector-coercion", 
#&gt;     as_closure = "as_function", as_complex = "vector-coercion", 
#&gt;     as_data_mask = "as_data_mask", as_data_pronoun = "as_data_mask", 
#&gt;     as_double = "vector-coercion", as_env = "as_env", as_environment = "as_environment", 
#&gt;     as_function = "as_function", as_integer = "vector-coercion", 
#&gt;     as_label = "as_label", as_list = "vector-coercion", as_logical = "vector-coercion", 
#&gt;     as_name = "as_name", as_overscope = "as_overscope", as_pairlist = "as_pairlist", 
#&gt;     as_quosure = "as_quosure", as_quosures = "new_quosures", 
#&gt;     as_string = "as_string", as_utf8_character = "as_utf8_character", 
#&gt;     `bare-type-predicates` = "bare-type-predicates", base_env = "search_envs", 
#&gt;     box = "box", bytes = "vector-construction", bytes_along = "vector-old-ctors", 
#&gt;     bytes_len = "vector-old-ctors", call_args = "call_args", 
#&gt;     call_args_names = "call_args", call_depth = "stack", call_fn = "call_fn", 
#&gt;     call_frame = "stack", call_inspect = "call_inspect", call_modify = "call_modify", 
#&gt;     call_name = "call_name", call_ns = "call_name", call_stack = "stack", 
#&gt;     call_standardise = "call_standardise", call2 = "call2", caller_env = "caller_env", 
#&gt;     caller_fn = "caller_fn", caller_frame = "caller_frame", calling = "with_handlers", 
#&gt;     catch_cnd = "catch_cnd", child_env = "env", chr = "vector-construction", 
#&gt;     chr_along = "vector-old-ctors", chr_len = "vector-old-ctors", 
#&gt;     chr_unserialise_unicode = "chr_unserialise_unicode", cnd = "cnd", 
#&gt;     cnd_bullets = "cnd_message", cnd_entrace = "entrace", cnd_issue = "cnd_message", 
#&gt;     cnd_message = "cnd_message", cnd_muffle = "cnd_muffle", cnd_signal = "cnd_signal", 
#&gt;     cnd_type = "cnd_type", coerce_class = "switch_type", coerce_type = "switch_type", 
#&gt;     cpl = "vector-construction", cpl_along = "vector-old-ctors", 
#&gt;     cpl_len = "vector-old-ctors", ctxt_depth = "stack", ctxt_frame = "stack", 
#&gt;     ctxt_stack = "stack", current_env = "caller_env", current_fn = "caller_fn", 
#&gt;     current_frame = "stack", dbl = "vector-construction", dbl_along = "vector-old-ctors", 
#&gt;     dbl_len = "vector-old-ctors", done = "done", dots_definitions = "dots_definitions", 
#&gt;     dots_list = "tidy-dots", dots_n = "dots_n", dots_splice = "splice", 
#&gt;     dots_values = "dots_values", duplicate = "duplicate", empty_env = "empty_env", 
#&gt;     enexpr = "quotation", enexprs = "quotation", enquo = "quotation", 
#&gt;     enquos = "quotation", ensym = "quotation", ensyms = "quotation", 
#&gt;     entrace = "entrace", env = "env", env_bind = "env_bind", 
#&gt;     env_bind_active = "env_bind", env_bind_exprs = "env_bind_exprs", 
#&gt;     env_bind_fns = "env_bind_exprs", env_bind_lazy = "env_bind", 
#&gt;     env_binding_are_active = "env_binding_are_active", env_binding_are_lazy = "env_binding_are_active", 
#&gt;     env_binding_are_locked = "env_binding_lock", env_binding_lock = "env_binding_lock", 
#&gt;     env_binding_unlock = "env_binding_lock", env_bury = "env_bury", 
#&gt;     env_clone = "env_clone", env_depth = "env_depth", env_get = "env_get", 
#&gt;     env_get_list = "env_get", env_has = "env_has", env_inherits = "env_inherits", 
#&gt;     env_is_locked = "env_lock", env_label = "env_name", env_length = "env_names", 
#&gt;     env_lock = "env_lock", env_name = "env_name", env_names = "env_names", 
#&gt;     env_parent = "env_parent", env_parents = "env_parent", env_poke = "env_poke", 
#&gt;     env_poke_parent = "get_env", env_print = "env_print", env_tail = "env_parent", 
#&gt;     env_unbind = "env_unbind", env_unlock = "env_unlock", error_cnd = "cnd", 
#&gt;     eval_bare = "eval_bare", eval_tidy = "eval_tidy", exec = "exec", 
#&gt;     exiting = "exiting", expr = "quotation", expr_deparse = "expr_print", 
#&gt;     expr_interp = "expr_interp", expr_label = "expr_label", expr_name = "expr_label", 
#&gt;     expr_print = "expr_print", expr_text = "expr_label", exprs = "quotation", 
#&gt;     exprs_auto_name = "exprs_auto_name", f_env = "f_rhs", `f_env&lt;-` = "f_rhs", 
#&gt;     f_label = "f_text", f_lhs = "f_rhs", `f_lhs&lt;-` = "f_rhs", 
#&gt;     f_name = "f_text", f_rhs = "f_rhs", `f_rhs&lt;-` = "f_rhs", 
#&gt;     f_text = "f_text", flatten = "flatten", flatten_chr = "flatten", 
#&gt;     flatten_cpl = "flatten", flatten_dbl = "flatten", flatten_if = "flatten", 
#&gt;     flatten_int = "flatten", flatten_lgl = "flatten", flatten_raw = "flatten", 
#&gt;     fn_body = "fn_body", `fn_body&lt;-` = "fn_body", fn_env = "fn_env", 
#&gt;     `fn_env&lt;-` = "fn_env", fn_fmls = "fn_fmls", fn_fmls_names = "fn_fmls", 
#&gt;     `fn_fmls_names&lt;-` = "fn_fmls", fn_fmls_syms = "fn_fmls", 
#&gt;     `fn_fmls&lt;-` = "fn_fmls", format_bullets = "cnd_message", 
#&gt;     frame_position = "frame_position", friendly_type = "friendly_type", 
#&gt;     get_env = "get_env", get_expr = "set_expr", global_env = "search_envs", 
#&gt;     global_frame = "stack", has_length = "has_length", has_name = "has_name", 
#&gt;     have_name = "is_named", inform = "abort", inherits_all = "inherits_any", 
#&gt;     inherits_any = "inherits_any", inherits_only = "inherits_any", 
#&gt;     int = "vector-construction", int_along = "vector-old-ctors", 
#&gt;     int_len = "vector-old-ctors", interrupt = "abort", invoke = "invoke", 
#&gt;     is_atomic = "type-predicates", is_attached = "search_envs", 
#&gt;     is_bare_atomic = "bare-type-predicates", is_bare_bytes = "bare-type-predicates", 
#&gt;     is_bare_character = "bare-type-predicates", is_bare_double = "bare-type-predicates", 
#&gt;     is_bare_env = "is_env", is_bare_environment = "is_environment", 
#&gt;     is_bare_formula = "is_formula", is_bare_integer = "bare-type-predicates", 
#&gt;     is_bare_integerish = "is_integerish", is_bare_list = "bare-type-predicates", 
#&gt;     is_bare_logical = "bare-type-predicates", is_bare_numeric = "bare-type-predicates", 
#&gt;     is_bare_raw = "bare-type-predicates", is_bare_string = "bare-type-predicates", 
#&gt;     is_bare_vector = "bare-type-predicates", is_binary_lang = "is_lang", 
#&gt;     is_bool = "scalar-type-predicates", is_box = "box", is_bytes = "type-predicates", 
#&gt;     is_call = "is_call", is_call_stack = "is_stack", is_callable = "is_callable", 
#&gt;     is_character = "type-predicates", is_chr_na = "are_na", is_closure = "is_function", 
#&gt;     is_condition = "is_condition", is_copyable = "is_copyable", 
#&gt;     is_cpl_na = "are_na", is_dbl_na = "are_na", is_definition = "op-definition", 
#&gt;     is_dictionaryish = "is_named", is_done_box = "done", is_double = "type-predicates", 
#&gt;     is_empty = "is_empty", is_env = "is_env", is_environment = "is_environment", 
#&gt;     is_eval_stack = "is_stack", is_expr = "is_expr", is_expression = "is_expression", 
#&gt;     is_false = "is_true", is_formula = "is_formula", is_formulaish = "op-definition", 
#&gt;     is_frame = "is_frame", is_function = "is_function", is_installed = "is_installed", 
#&gt;     is_int_na = "are_na", is_integer = "type-predicates", is_integerish = "is_integerish", 
#&gt;     is_interactive = "is_interactive", is_lambda = "as_function", 
#&gt;     is_lang = "is_lang", is_lgl_na = "are_na", is_list = "type-predicates", 
#&gt;     is_logical = "type-predicates", is_missing = "missing_arg", 
#&gt;     is_na = "are_na", is_named = "is_named", is_namespace = "is_namespace", 
#&gt;     is_node = "is_pairlist", is_node_list = "is_pairlist", is_null = "type-predicates", 
#&gt;     is_pairlist = "is_pairlist", is_primitive = "is_function", 
#&gt;     is_primitive_eager = "is_function", is_primitive_lazy = "is_function", 
#&gt;     is_quosure = "quosure", is_quosures = "new_quosures", is_raw = "type-predicates", 
#&gt;     is_reference = "is_reference", is_scalar_atomic = "scalar-type-predicates", 
#&gt;     is_scalar_bytes = "scalar-type-predicates", is_scalar_character = "scalar-type-predicates", 
#&gt;     is_scalar_double = "scalar-type-predicates", is_scalar_integer = "scalar-type-predicates", 
#&gt;     is_scalar_integerish = "is_integerish", is_scalar_list = "scalar-type-predicates", 
#&gt;     is_scalar_logical = "scalar-type-predicates", is_scalar_raw = "scalar-type-predicates", 
#&gt;     is_scalar_vector = "scalar-type-predicates", is_scoped = "scoped_env", 
#&gt;     is_spliced = "splice", is_spliced_bare = "splice", is_stack = "is_stack", 
#&gt;     is_string = "scalar-type-predicates", is_symbol = "is_symbol", 
#&gt;     is_symbolic = "is_expression", is_syntactic_literal = "is_expression", 
#&gt;     is_true = "is_true", is_unary_lang = "is_lang", is_vector = "type-predicates", 
#&gt;     is_weakref = "is_weakref", is_zap = "zap", lang = "lang", 
#&gt;     lang_args = "lang_modify", lang_args_names = "lang_modify", 
#&gt;     lang_fn = "lang_modify", lang_head = "lang_head", lang_modify = "lang_modify", 
#&gt;     lang_name = "lang_modify", lang_standardise = "lang_modify", 
#&gt;     lang_tail = "lang_head", last_error = "last_error", last_trace = "last_error", 
#&gt;     lgl = "vector-construction", lgl_along = "vector-old-ctors", 
#&gt;     lgl_len = "vector-old-ctors", lifecycle = "lifecycle", list_along = "vector-old-ctors", 
#&gt;     list_len = "vector-old-ctors", list2 = "tidy-dots", ll = "vector-construction", 
#&gt;     locally = "with_env", maybe_missing = "missing_arg", message_cnd = "cnd", 
#&gt;     missing = "missing", missing_arg = "missing_arg", modify = "prepend", 
#&gt;     mut_attrs = "set_attrs", mut_node_caar = "mut_node_car", 
#&gt;     mut_node_cadr = "mut_node_car", mut_node_car = "mut_node_car", 
#&gt;     mut_node_cdar = "mut_node_car", mut_node_cddr = "mut_node_car", 
#&gt;     mut_node_cdr = "mut_node_car", mut_node_tag = "mut_node_car", 
#&gt;     na_chr = "missing", na_cpl = "missing", na_dbl = "missing", 
#&gt;     na_int = "missing", na_lgl = "missing", names2 = "names2", 
#&gt;     new_box = "box", new_call = "new_call", new_character = "new-vector", 
#&gt;     new_character_along = "new-vector-along-retired", new_complex = "new-vector", 
#&gt;     new_complex_along = "new-vector-along-retired", new_data_mask = "as_data_mask", 
#&gt;     new_definition = "op-definition", new_double = "new-vector", 
#&gt;     new_double_along = "new-vector-along-retired", new_environment = "env", 
#&gt;     new_formula = "new_formula", new_function = "new_function", 
#&gt;     new_integer = "new-vector", new_integer_along = "new-vector-along-retired", 
#&gt;     new_language = "lang", new_list = "new-vector", new_list_along = "new-vector-along-retired", 
#&gt;     new_logical = "new-vector", new_logical_along = "new-vector-along-retired", 
#&gt;     new_node = "new_node", new_overscope = "as_overscope", new_quosure = "as_quosure", 
#&gt;     new_quosures = "new_quosures", new_raw = "new-vector", new_raw_along = "new-vector-along-retired", 
#&gt;     new_weakref = "new_weakref", `new-vector` = "new-vector", 
#&gt;     `new-vector-along-retired` = "new-vector-along-retired", 
#&gt;     node = "vector-old-ctors", node_caar = "new_node", node_cadr = "new_node", 
#&gt;     node_car = "new_node", node_cdar = "new_node", node_cddr = "new_node", 
#&gt;     node_cdr = "new_node", node_poke_caar = "new_node", node_poke_cadr = "new_node", 
#&gt;     node_poke_car = "new_node", node_poke_cdar = "new_node", 
#&gt;     node_poke_cddr = "new_node", node_poke_cdr = "new_node", 
#&gt;     node_poke_tag = "new_node", node_tag = "new_node", ns_env = "ns_env", 
#&gt;     ns_env_name = "ns_env", ns_imports_env = "ns_env", `op-definition` = "op-definition", 
#&gt;     `op-get-attr` = "op-get-attr", `op-na-default` = "op-na-default", 
#&gt;     `op-null-default` = "op-null-default", overscope_clean = "as_overscope", 
#&gt;     overscope_eval_next = "overscope_eval_next", pairlist2 = "pairlist2", 
#&gt;     parse_expr = "parse_expr", parse_exprs = "parse_expr", parse_quo = "parse_expr", 
#&gt;     parse_quos = "parse_expr", parse_quosure = "parse_quosure", 
#&gt;     parse_quosures = "parse_quosure", peek_option = "scoped_options", 
#&gt;     peek_options = "scoped_options", pkg_env = "search_envs", 
#&gt;     pkg_env_name = "search_envs", prepend = "prepend", prim_name = "prim_name", 
#&gt;     push_options = "scoped_options", qq_show = "quasiquotation", 
#&gt;     quasiquotation = "quasiquotation", quo = "quotation", quo_expr = "quo_expr", 
#&gt;     quo_get_env = "quosure", quo_get_expr = "quosure", quo_is_call = "quosure", 
#&gt;     quo_is_lang = "is_lang", quo_is_missing = "quosure", quo_is_null = "quosure", 
#&gt;     quo_is_symbol = "quosure", quo_is_symbolic = "quosure", quo_label = "quo_label", 
#&gt;     quo_name = "quo_label", quo_set_env = "quosure", quo_set_expr = "quosure", 
#&gt;     quo_squash = "quo_squash", quo_text = "quo_label", quos = "quotation", 
#&gt;     quos_auto_name = "exprs_auto_name", quosure = "quosure", 
#&gt;     quotation = "quotation", raw_along = "vector-old-ctors", 
#&gt;     raw_len = "vector-old-ctors", rep_along = "rep_along", rep_named = "rep_along", 
#&gt;     restarting = "restarting", return_from = "return_from", return_to = "return_from", 
#&gt;     rlang_backtrace_on_error = "rlang_backtrace_on_error", rst_abort = "rst_abort", 
#&gt;     rst_exists = "rst_list", rst_jump = "rst_list", rst_list = "rst_list", 
#&gt;     rst_maybe_jump = "rst_list", `scalar-type-predicates` = "scalar-type-predicates", 
#&gt;     scoped_bindings = "scoped_bindings", scoped_env = "scoped_env", 
#&gt;     scoped_envs = "scoped_env", scoped_interactive = "is_interactive", 
#&gt;     scoped_names = "scoped_env", scoped_options = "scoped_options", 
#&gt;     search_env = "search_envs", search_envs = "search_envs", 
#&gt;     seq2 = "seq2", seq2_along = "seq2", set_attrs = "set_attrs", 
#&gt;     set_env = "get_env", set_expr = "set_expr", set_names = "set_names", 
#&gt;     signal = "abort", splice = "splice", squash = "flatten", 
#&gt;     squash_chr = "flatten", squash_cpl = "flatten", squash_dbl = "flatten", 
#&gt;     squash_if = "flatten", squash_int = "flatten", squash_lgl = "flatten", 
#&gt;     squash_raw = "flatten", stack = "stack", stack_trim = "stack_trim", 
#&gt;     string = "string", switch_class = "switch_type", switch_type = "switch_type", 
#&gt;     sym = "sym", syms = "sym", `tidy-dots` = "tidy-dots", `tidyeval-data` = "tidyeval-data", 
#&gt;     trace_back = "trace_back", trace_length = "trace_back", type_of = "type_of", 
#&gt;     `type-predicates` = "type-predicates", unbox = "box", UQ = "quasiquotation", 
#&gt;     UQS = "quasiquotation", vec_poke_n = "vec_poke_n", vec_poke_range = "vec_poke_n", 
#&gt;     `vector-coercion` = "vector-coercion", `vector-construction` = "vector-construction", 
#&gt;     `vector-old-ctors` = "vector-old-ctors", warn = "abort", 
#&gt;     warning_cnd = "cnd", with_abort = "with_abort", with_bindings = "scoped_bindings", 
#&gt;     with_env = "with_env", with_handlers = "with_handlers", with_interactive = "is_interactive", 
#&gt;     with_options = "scoped_options", with_restarts = "with_restarts", 
#&gt;     wref_key = "wref_key", wref_value = "wref_key", zap = "zap"
#&gt;     ), article_index = character(0)), examples = TRUE, run_dont_run = FALSE, 
#&gt;     seed = 1014, lazy = FALSE, override = list(destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE), 
#&gt;     envir = &lt;environment&gt;)
#&gt; 
#&gt; [[12]]
#&gt; (function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; })(pkg = list(package = "rlang", version = list(c(0L, 4L, 1L)), 
#&gt;     src_path = "/home/travis/build/r-lib/rlang", dst_path = "/tmp/RtmpGSP0ZP/file4f58692244b4", 
#&gt;     github_url = "https://github.com/r-lib/rlang", desc = &lt;environment&gt;, 
#&gt;     meta = list(url = "https://rlang.r-lib.org", template = list(
#&gt;         params = list(ganalytics = "UA-115082821-1")), home = list(
#&gt;         links = list(list(text = "The tidy eval bookdown", href = "https://tidyeval.tidyverse.org"))), 
#&gt;         navbar = list(structure = list(left = c("home", "reference", 
#&gt;         "lifecycle", "news"), right = "github"), components = list(
#&gt;             lifecycle = list(text = "Life cycle", href = "reference/lifecycle.html"), 
#&gt;             news = list(text = "News", menu = list(list(text = "Release notes"), 
#&gt;                 list(text = "Version 0.4.0", href = "https://www.tidyverse.org/articles/2019/06/rlang-0-4-0/"), 
#&gt;                 list(text = "Version 0.3.1", href = "https://www.tidyverse.org/articles/2019/01/rlang-0-3-1/"), 
#&gt;                 list(text = "Version 0.3.0", href = "https://www.tidyverse.org/articles/2018/10/rlang-0-3-0/"), 
#&gt;                 list(text = "Version 0.2.0", href = "https://www.tidyverse.org/articles/2018/03/rlang-0.2.0/"), 
#&gt;                 list(text = "------------------"), list(text = "Change log", 
#&gt;                   href = "news/index.html"))))), reference = list(
#&gt;             list(title = "Tidy evaluation", desc = "Quote arguments and expressions with unquoting support. The quosure variants wrap an environment with the expression.\n", 
#&gt;                 contents = c("quo", "quos", "enquo", "enquos", 
#&gt;                 "expr", "exprs", "enexpr", "enexprs", "quasiquotation", 
#&gt;                 "as_label", "as_name")), list(title = "Tidy dots", 
#&gt;                 desc = "Collect arguments contained in `...` with `!!!` and name-unquoting support.\n", 
#&gt;                 contents = c("list2", "dots_list", "pairlist2"
#&gt;                 )), list(title = "Errors, conditions, and backtraces", 
#&gt;                 contents = c("abort", "warn", "inform", "signal", 
#&gt;                 "trace_back", "with_abort", "entrace", "cnd_signal", 
#&gt;                 "last_error", "rlang_backtrace_on_error", "catch_cnd"
#&gt;                 )), list(title = "Evaluate expressions", contents = c("eval_tidy", 
#&gt;             "eval_bare", "exec")), list(title = "Symbols", contents = c("sym", 
#&gt;             "syms", "is_symbol", "as_string")), list(title = "Calls", 
#&gt;                 contents = c("starts_with(\"call_\")", "call2", 
#&gt;                 "is_call")), list(title = "Expressions", contents = c("starts_with(\"expr_\")", 
#&gt;             "starts_with(\"exprs_\")", "starts_with(\"parse_\")", 
#&gt;             "is_expression", "is_symbolic", "expr_text", "expr_label", 
#&gt;             "expr_name", "set_expr", "get_expr")), list(title = "Quosures", 
#&gt;                 contents = c("starts_with(\"quo_\")", "new_quosure", 
#&gt;                 "is_quosure", "as_quosure", "is_quosures", "quos_auto_name"
#&gt;                 )), list(title = "Formulas", contents = c("starts_with(\"f_\")", 
#&gt;             "new_formula", "is_formula", "is_bare_formula")), 
#&gt;             list(title = "Functions", contents = c("starts_with(\"fn_\")", 
#&gt;             "new_function", "is_function", "is_closure", "is_primitive", 
#&gt;             "as_function", "as_closure")), list(title = "Environments", 
#&gt;                 contents = c("env", "new_environment", "env_print", 
#&gt;                 "env_parent", "env_tail", "env_parents", "env_depth", 
#&gt;                 "get_env", "set_env", "env_clone", "env_inherits", 
#&gt;                 "is_environment", "is_bare_environment", "as_environment", 
#&gt;                 "caller_env")), list(title = "Environment bindings", 
#&gt;                 contents = c("env_bind", "env_bind_lazy", "env_bind_active", 
#&gt;                 "env_unbind", "with_bindings", "scoped_bindings", 
#&gt;                 "env_has", "env_get", "env_get_list", "env_names", 
#&gt;                 "env_length", "env_poke")), list(title = "Search path and namespaces", 
#&gt;                 contents = c("search_envs", "search_env", "base_env", 
#&gt;                 "global_env", "empty_env", "is_installed", "is_namespace", 
#&gt;                 "ns_env", "pkg_env", "env_name", "env_label")), 
#&gt;             list(title = "S3", contents = c("inherits_any", "inherits_all", 
#&gt;             "inherits_only", "new_box", "is_box", "as_box", "as_box_if", 
#&gt;             "unbox", "zap", "is_zap", "done")), list(title = "Create vectors", 
#&gt;                 desc = "Atomic vector constructors have implicit splicing (i.e. splice lists automatically), while the list constructor has explicit splicing.\n", 
#&gt;                 contents = c("lgl", "int", "dbl", "cpl", "chr", 
#&gt;                 "list2", "rep_along", "rep_named", "seq2", "seq2_along"
#&gt;                 )), list(title = "Attributes", contents = c("set_names", 
#&gt;             "names2", "has_name", "is_named")), list(title = "Type predicates", 
#&gt;                 contents = c("is_list", "is_atomic", "is_vector", 
#&gt;                 "is_integer", "is_double", "is_character", "is_logical", 
#&gt;                 "is_raw", "is_bytes", "is_scalar_list", "is_scalar_atomic", 
#&gt;                 "is_scalar_vector", "is_scalar_integer", "is_scalar_double", 
#&gt;                 "is_scalar_character", "is_scalar_logical", "is_scalar_raw", 
#&gt;                 "is_scalar_bytes", "is_bare_list", "is_bare_atomic", 
#&gt;                 "is_bare_vector", "is_bare_double", "is_bare_integer", 
#&gt;                 "is_bare_numeric", "is_bare_character", "is_bare_logical", 
#&gt;                 "is_bare_raw", "is_bare_bytes", "is_empty", "is_integerish", 
#&gt;                 "is_bare_integerish", "is_scalar_integerish", 
#&gt;                 "is_null", "is_true", "is_false", "is_string", 
#&gt;                 "is_bool", "is_bare_string")), list(title = "Operators", 
#&gt;                 contents = c("`%||%`", "`%|%`", "`%@%`")), list(
#&gt;                 title = "Function arguments", contents = c("arg_match", 
#&gt;                 "missing_arg", "is_missing", "maybe_missing")), 
#&gt;             list(title = "Create tidy evaluation APIs", desc = "Create data masking APIs à-la dplyr or tidyr. These functions are meant for developers rather than users.\n", 
#&gt;                 contents = c("`tidyeval-data`", "eval_tidy", 
#&gt;                 "as_data_mask", "new_data_mask", "as_data_pronoun"
#&gt;                 )), list(title = "Condition handlers", contents = c("with_handlers", 
#&gt;             "calling")), list(title = "Session state", contents = c("matches(\"interactive\")", 
#&gt;             "matches(\"option\")")), list(title = "Weak references", 
#&gt;                 contents = c("matches(\"weakref\")", "matches(\"wref\")"
#&gt;                 ))), destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     figures = list(dev = "grDevices::png", dpi = 96L, dev.args = list(), 
#&gt;         fig.ext = "png", fig.width = 7.29166666666667, fig.height = NULL, 
#&gt;         fig.retina = 2L, fig.asp = 0.618046971569839), development = list(
#&gt;         destination = "dev", mode = "release", version_label = "default", 
#&gt;         version_tooltip = "Released version", in_dev = FALSE), 
#&gt;     topics = list(name = c("abort", "are_na", "arg_match", "as_box", 
#&gt;     "as_bytes", "as_data_mask", "as_env", "as_environment", "as_function", 
#&gt;     "as_label", "as_name", "as_overscope", "as_pairlist", "as_quosure", 
#&gt;     "as_string", "as_utf8_character", "bare-type-predicates", 
#&gt;     "box", "call2", "call_args", "call_fn", "call_inspect", "call_modify", 
#&gt;     "call_name", "call_standardise", "caller_env", "caller_fn", 
#&gt;     "caller_frame", "catch_cnd", "chr_unserialise_unicode", "error_cnd", 
#&gt;     "cnd_message", "cnd_muffle", "cnd_signal", "cnd_type", "done", 
#&gt;     "dots_definitions", "dots_n", "dots_values", "duplicate", 
#&gt;     "empty_env", "entrace", "env", "env_bind", "env_bind_exprs", 
#&gt;     "env_binding_are_active", "env_binding_lock", "env_bury", 
#&gt;     "env_clone", "env_depth", "env_get", "env_has", "env_inherits", 
#&gt;     "env_lock", "env_name", "env_names", "env_parent", "env_poke", 
#&gt;     "env_print", "env_unbind", "env_unlock", "eval_bare", "eval_tidy", 
#&gt;     "exec", "exiting", "expr_interp", "expr_label", "expr_print", 
#&gt;     "exprs_auto_name", "f_rhs", "f_text", "flatten", "fn_body", 
#&gt;     "fn_env", "fn_fmls", "frame_position", "friendly_type", "get_env", 
#&gt;     "has_length", "has_name", "inherits_any", "invoke", "is_call", 
#&gt;     "is_callable", "is_condition", "is_copyable", "is_empty", 
#&gt;     "is_env", "is_environment", "is_expr", "is_expression", "is_formula", 
#&gt;     "is_frame", "is_function", "is_installed", "is_integerish", 
#&gt;     "is_interactive", "is_lang", "is_named", "is_namespace", 
#&gt;     "is_pairlist", "is_reference", "is_stack", "is_symbol", "is_true", 
#&gt;     "is_weakref", "lang", "lang_head", "lang_modify", "last_error", 
#&gt;     "lifecycle", "missing", "missing_arg", "mut_node_car", "names2", 
#&gt;     "new-vector-along-retired", "new-vector", "new_call", "new_formula", 
#&gt;     "new_function", "new_node", "new_quosures", "new_weakref", 
#&gt;     "ns_env", "op-definition", "op-get-attr", "op-na-default", 
#&gt;     "op-null-default", "overscope_eval_next", "pairlist2", "parse_expr", 
#&gt;     "parse_quosure", "prepend", "prim_name", "quasiquotation", 
#&gt;     "quo_expr", "quo_label", "quo_squash", "quosure", "quotation", 
#&gt;     "rep_along", "restarting", "return_from", "rlang_backtrace_on_error", 
#&gt;     "rst_abort", "rst_list", "scalar-type-predicates", "scoped_bindings", 
#&gt;     "scoped_env", "scoped_options", "search_envs", "seq2", "set_attrs", 
#&gt;     "set_expr", "set_names", "splice", "stack", "stack_trim", 
#&gt;     "string", "switch_type", "sym", "tidy-dots", "tidyeval-data", 
#&gt;     "trace_back", "type-predicates", "type_of", "vec_poke_n", 
#&gt;     "vector-coercion", "vector-construction", "node", "with_abort", 
#&gt;     "with_env", "with_handlers", "with_restarts", "wref_key", 
#&gt;     "zap"), file_in = c("abort.Rd", "are_na.Rd", "arg_match.Rd", 
#&gt;     "as_box.Rd", "as_bytes.Rd", "as_data_mask.Rd", "as_env.Rd", 
#&gt;     "as_environment.Rd", "as_function.Rd", "as_label.Rd", "as_name.Rd", 
#&gt;     "as_overscope.Rd", "as_pairlist.Rd", "as_quosure.Rd", "as_string.Rd", 
#&gt;     "as_utf8_character.Rd", "bare-type-predicates.Rd", "box.Rd", 
#&gt;     "call2.Rd", "call_args.Rd", "call_fn.Rd", "call_inspect.Rd", 
#&gt;     "call_modify.Rd", "call_name.Rd", "call_standardise.Rd", 
#&gt;     "caller_env.Rd", "caller_fn.Rd", "caller_frame.Rd", "catch_cnd.Rd", 
#&gt;     "chr_unserialise_unicode.Rd", "cnd.Rd", "cnd_message.Rd", 
#&gt;     "cnd_muffle.Rd", "cnd_signal.Rd", "cnd_type.Rd", "done.Rd", 
#&gt;     "dots_definitions.Rd", "dots_n.Rd", "dots_values.Rd", "duplicate.Rd", 
#&gt;     "empty_env.Rd", "entrace.Rd", "env.Rd", "env_bind.Rd", "env_bind_exprs.Rd", 
#&gt;     "env_binding_are_active.Rd", "env_binding_lock.Rd", "env_bury.Rd", 
#&gt;     "env_clone.Rd", "env_depth.Rd", "env_get.Rd", "env_has.Rd", 
#&gt;     "env_inherits.Rd", "env_lock.Rd", "env_name.Rd", "env_names.Rd", 
#&gt;     "env_parent.Rd", "env_poke.Rd", "env_print.Rd", "env_unbind.Rd", 
#&gt;     "env_unlock.Rd", "eval_bare.Rd", "eval_tidy.Rd", "exec.Rd", 
#&gt;     "exiting.Rd", "expr_interp.Rd", "expr_label.Rd", "expr_print.Rd", 
#&gt;     "exprs_auto_name.Rd", "f_rhs.Rd", "f_text.Rd", "flatten.Rd", 
#&gt;     "fn_body.Rd", "fn_env.Rd", "fn_fmls.Rd", "frame_position.Rd", 
#&gt;     "friendly_type.Rd", "get_env.Rd", "has_length.Rd", "has_name.Rd", 
#&gt;     "inherits_any.Rd", "invoke.Rd", "is_call.Rd", "is_callable.Rd", 
#&gt;     "is_condition.Rd", "is_copyable.Rd", "is_empty.Rd", "is_env.Rd", 
#&gt;     "is_environment.Rd", "is_expr.Rd", "is_expression.Rd", "is_formula.Rd", 
#&gt;     "is_frame.Rd", "is_function.Rd", "is_installed.Rd", "is_integerish.Rd", 
#&gt;     "is_interactive.Rd", "is_lang.Rd", "is_named.Rd", "is_namespace.Rd", 
#&gt;     "is_pairlist.Rd", "is_reference.Rd", "is_stack.Rd", "is_symbol.Rd", 
#&gt;     "is_true.Rd", "is_weakref.Rd", "lang.Rd", "lang_head.Rd", 
#&gt;     "lang_modify.Rd", "last_error.Rd", "lifecycle.Rd", "missing.Rd", 
#&gt;     "missing_arg.Rd", "mut_node_car.Rd", "names2.Rd", "new-vector-along-retired.Rd", 
#&gt;     "new-vector.Rd", "new_call.Rd", "new_formula.Rd", "new_function.Rd", 
#&gt;     "new_node.Rd", "new_quosures.Rd", "new_weakref.Rd", "ns_env.Rd", 
#&gt;     "op-definition.Rd", "op-get-attr.Rd", "op-na-default.Rd", 
#&gt;     "op-null-default.Rd", "overscope_eval_next.Rd", "pairlist2.Rd", 
#&gt;     "parse_expr.Rd", "parse_quosure.Rd", "prepend.Rd", "prim_name.Rd", 
#&gt;     "quasiquotation.Rd", "quo_expr.Rd", "quo_label.Rd", "quo_squash.Rd", 
#&gt;     "quosure.Rd", "quotation.Rd", "rep_along.Rd", "restarting.Rd", 
#&gt;     "return_from.Rd", "rlang_backtrace_on_error.Rd", "rst_abort.Rd", 
#&gt;     "rst_list.Rd", "scalar-type-predicates.Rd", "scoped_bindings.Rd", 
#&gt;     "scoped_env.Rd", "scoped_options.Rd", "search_envs.Rd", "seq2.Rd", 
#&gt;     "set_attrs.Rd", "set_expr.Rd", "set_names.Rd", "splice.Rd", 
#&gt;     "stack.Rd", "stack_trim.Rd", "string.Rd", "switch_type.Rd", 
#&gt;     "sym.Rd", "tidy-dots.Rd", "tidyeval-data.Rd", "trace_back.Rd", 
#&gt;     "type-predicates.Rd", "type_of.Rd", "vec_poke_n.Rd", "vector-coercion.Rd", 
#&gt;     "vector-construction.Rd", "vector-old-ctors.Rd", "with_abort.Rd", 
#&gt;     "with_env.Rd", "with_handlers.Rd", "with_restarts.Rd", "wref_key.Rd", 
#&gt;     "zap.Rd"), file_out = c("abort.html", "are_na.html", "arg_match.html", 
#&gt;     "as_box.html", "as_bytes.html", "as_data_mask.html", "as_env.html", 
#&gt;     "as_environment.html", "as_function.html", "as_label.html", 
#&gt;     "as_name.html", "as_overscope.html", "as_pairlist.html", 
#&gt;     "as_quosure.html", "as_string.html", "as_utf8_character.html", 
#&gt;     "bare-type-predicates.html", "box.html", "call2.html", "call_args.html", 
#&gt;     "call_fn.html", "call_inspect.html", "call_modify.html", 
#&gt;     "call_name.html", "call_standardise.html", "caller_env.html", 
#&gt;     "caller_fn.html", "caller_frame.html", "catch_cnd.html", 
#&gt;     "chr_unserialise_unicode.html", "cnd.html", "cnd_message.html", 
#&gt;     "cnd_muffle.html", "cnd_signal.html", "cnd_type.html", "done.html", 
#&gt;     "dots_definitions.html", "dots_n.html", "dots_values.html", 
#&gt;     "duplicate.html", "empty_env.html", "entrace.html", "env.html", 
#&gt;     "env_bind.html", "env_bind_exprs.html", "env_binding_are_active.html", 
#&gt;     "env_binding_lock.html", "env_bury.html", "env_clone.html", 
#&gt;     "env_depth.html", "env_get.html", "env_has.html", "env_inherits.html", 
#&gt;     "env_lock.html", "env_name.html", "env_names.html", "env_parent.html", 
#&gt;     "env_poke.html", "env_print.html", "env_unbind.html", "env_unlock.html", 
#&gt;     "eval_bare.html", "eval_tidy.html", "exec.html", "exiting.html", 
#&gt;     "expr_interp.html", "expr_label.html", "expr_print.html", 
#&gt;     "exprs_auto_name.html", "f_rhs.html", "f_text.html", "flatten.html", 
#&gt;     "fn_body.html", "fn_env.html", "fn_fmls.html", "frame_position.html", 
#&gt;     "friendly_type.html", "get_env.html", "has_length.html", 
#&gt;     "has_name.html", "inherits_any.html", "invoke.html", "is_call.html", 
#&gt;     "is_callable.html", "is_condition.html", "is_copyable.html", 
#&gt;     "is_empty.html", "is_env.html", "is_environment.html", "is_expr.html", 
#&gt;     "is_expression.html", "is_formula.html", "is_frame.html", 
#&gt;     "is_function.html", "is_installed.html", "is_integerish.html", 
#&gt;     "is_interactive.html", "is_lang.html", "is_named.html", "is_namespace.html", 
#&gt;     "is_pairlist.html", "is_reference.html", "is_stack.html", 
#&gt;     "is_symbol.html", "is_true.html", "is_weakref.html", "lang.html", 
#&gt;     "lang_head.html", "lang_modify.html", "last_error.html", 
#&gt;     "lifecycle.html", "missing.html", "missing_arg.html", "mut_node_car.html", 
#&gt;     "names2.html", "new-vector-along-retired.html", "new-vector.html", 
#&gt;     "new_call.html", "new_formula.html", "new_function.html", 
#&gt;     "new_node.html", "new_quosures.html", "new_weakref.html", 
#&gt;     "ns_env.html", "op-definition.html", "op-get-attr.html", 
#&gt;     "op-na-default.html", "op-null-default.html", "overscope_eval_next.html", 
#&gt;     "pairlist2.html", "parse_expr.html", "parse_quosure.html", 
#&gt;     "prepend.html", "prim_name.html", "quasiquotation.html", 
#&gt;     "quo_expr.html", "quo_label.html", "quo_squash.html", "quosure.html", 
#&gt;     "quotation.html", "rep_along.html", "restarting.html", "return_from.html", 
#&gt;     "rlang_backtrace_on_error.html", "rst_abort.html", "rst_list.html", 
#&gt;     "scalar-type-predicates.html", "scoped_bindings.html", "scoped_env.html", 
#&gt;     "scoped_options.html", "search_envs.html", "seq2.html", "set_attrs.html", 
#&gt;     "set_expr.html", "set_names.html", "splice.html", "stack.html", 
#&gt;     "stack_trim.html", "string.html", "switch_type.html", "sym.html", 
#&gt;     "tidy-dots.html", "tidyeval-data.html", "trace_back.html", 
#&gt;     "type-predicates.html", "type_of.html", "vec_poke_n.html", 
#&gt;     "vector-coercion.html", "vector-construction.html", "vector-old-ctors.html", 
#&gt;     "with_abort.html", "with_env.html", "with_handlers.html", 
#&gt;     "with_restarts.html", "wref_key.html", "zap.html"), alias = list(
#&gt;         abort.Rd = c("abort", "warn", "inform", "signal", "interrupt"
#&gt;         ), are_na.Rd = c("are_na", "is_na", "is_lgl_na", "is_int_na", 
#&gt;         "is_dbl_na", "is_chr_na", "is_cpl_na"), arg_match.Rd = "arg_match", 
#&gt;         as_box.Rd = c("as_box", "as_box_if"), as_bytes.Rd = "as_bytes", 
#&gt;         as_data_mask.Rd = c("as_data_mask", "as_data_pronoun", 
#&gt;         "new_data_mask"), as_env.Rd = "as_env", as_environment.Rd = "as_environment", 
#&gt;         as_function.Rd = c("as_function", "is_lambda", "as_closure"
#&gt;         ), as_label.Rd = "as_label", as_name.Rd = "as_name", 
#&gt;         as_overscope.Rd = c("as_overscope", "new_overscope", 
#&gt;         "overscope_clean"), as_pairlist.Rd = "as_pairlist", as_quosure.Rd = c("as_quosure", 
#&gt;         "new_quosure"), as_string.Rd = "as_string", as_utf8_character.Rd = "as_utf8_character", 
#&gt;         `bare-type-predicates.Rd` = c("bare-type-predicates", 
#&gt;         "is_bare_list", "is_bare_atomic", "is_bare_vector", "is_bare_double", 
#&gt;         "is_bare_integer", "is_bare_numeric", "is_bare_character", 
#&gt;         "is_bare_logical", "is_bare_raw", "is_bare_string", "is_bare_bytes"
#&gt;         ), box.Rd = c("box", "new_box", "is_box", "unbox"), call2.Rd = "call2", 
#&gt;         call_args.Rd = c("call_args", "call_args_names"), call_fn.Rd = "call_fn", 
#&gt;         call_inspect.Rd = "call_inspect", call_modify.Rd = "call_modify", 
#&gt;         call_name.Rd = c("call_name", "call_ns"), call_standardise.Rd = "call_standardise", 
#&gt;         caller_env.Rd = c("caller_env", "current_env"), caller_fn.Rd = c("caller_fn", 
#&gt;         "current_fn"), caller_frame.Rd = "caller_frame", catch_cnd.Rd = "catch_cnd", 
#&gt;         chr_unserialise_unicode.Rd = "chr_unserialise_unicode", 
#&gt;         cnd.Rd = c("error_cnd", "cnd", "warning_cnd", "message_cnd"
#&gt;         ), cnd_message.Rd = c("cnd_message", "cnd_issue", "cnd_bullets", 
#&gt;         "format_bullets"), cnd_muffle.Rd = "cnd_muffle", cnd_signal.Rd = "cnd_signal", 
#&gt;         cnd_type.Rd = "cnd_type", done.Rd = c("done", "is_done_box"
#&gt;         ), dots_definitions.Rd = "dots_definitions", dots_n.Rd = "dots_n", 
#&gt;         dots_values.Rd = "dots_values", duplicate.Rd = "duplicate", 
#&gt;         empty_env.Rd = "empty_env", entrace.Rd = c("entrace", 
#&gt;         "cnd_entrace"), env.Rd = c("env", "child_env", "new_environment"
#&gt;         ), env_bind.Rd = c("env_bind", "env_bind_lazy", "env_bind_active"
#&gt;         ), env_bind_exprs.Rd = c("env_bind_exprs", "env_bind_fns"
#&gt;         ), env_binding_are_active.Rd = c("env_binding_are_active", 
#&gt;         "env_binding_are_lazy"), env_binding_lock.Rd = c("env_binding_lock", 
#&gt;         "env_binding_unlock", "env_binding_are_locked"), env_bury.Rd = "env_bury", 
#&gt;         env_clone.Rd = "env_clone", env_depth.Rd = "env_depth", 
#&gt;         env_get.Rd = c("env_get", "env_get_list"), env_has.Rd = "env_has", 
#&gt;         env_inherits.Rd = "env_inherits", env_lock.Rd = c("env_lock", 
#&gt;         "env_is_locked"), env_name.Rd = c("env_name", "env_label"
#&gt;         ), env_names.Rd = c("env_names", "env_length"), env_parent.Rd = c("env_parent", 
#&gt;         "env_tail", "env_parents"), env_poke.Rd = "env_poke", 
#&gt;         env_print.Rd = "env_print", env_unbind.Rd = "env_unbind", 
#&gt;         env_unlock.Rd = "env_unlock", eval_bare.Rd = "eval_bare", 
#&gt;         eval_tidy.Rd = "eval_tidy", exec.Rd = "exec", exiting.Rd = "exiting", 
#&gt;         expr_interp.Rd = "expr_interp", expr_label.Rd = c("expr_label", 
#&gt;         "expr_name", "expr_text"), expr_print.Rd = c("expr_print", 
#&gt;         "expr_deparse"), exprs_auto_name.Rd = c("exprs_auto_name", 
#&gt;         "quos_auto_name"), f_rhs.Rd = c("f_rhs", "f_rhs&lt;-", "f_lhs", 
#&gt;         "f_lhs&lt;-", "f_env", "f_env&lt;-"), f_text.Rd = c("f_text", 
#&gt;         "f_name", "f_label"), flatten.Rd = c("flatten", "flatten_lgl", 
#&gt;         "flatten_int", "flatten_dbl", "flatten_cpl", "flatten_chr", 
#&gt;         "flatten_raw", "squash", "squash_lgl", "squash_int", 
#&gt;         "squash_dbl", "squash_cpl", "squash_chr", "squash_raw", 
#&gt;         "flatten_if", "squash_if"), fn_body.Rd = c("fn_body", 
#&gt;         "fn_body&lt;-"), fn_env.Rd = c("fn_env", "fn_env&lt;-"), fn_fmls.Rd = c("fn_fmls", 
#&gt;         "fn_fmls_names", "fn_fmls_syms", "fn_fmls&lt;-", "fn_fmls_names&lt;-"
#&gt;         ), frame_position.Rd = "frame_position", friendly_type.Rd = "friendly_type", 
#&gt;         get_env.Rd = c("get_env", "set_env", "env_poke_parent"
#&gt;         ), has_length.Rd = "has_length", has_name.Rd = "has_name", 
#&gt;         inherits_any.Rd = c("inherits_any", "inherits_all", "inherits_only"
#&gt;         ), invoke.Rd = "invoke", is_call.Rd = "is_call", is_callable.Rd = "is_callable", 
#&gt;         is_condition.Rd = "is_condition", is_copyable.Rd = "is_copyable", 
#&gt;         is_empty.Rd = "is_empty", is_env.Rd = c("is_env", "is_bare_env"
#&gt;         ), is_environment.Rd = c("is_environment", "is_bare_environment"
#&gt;         ), is_expr.Rd = "is_expr", is_expression.Rd = c("is_expression", 
#&gt;         "is_syntactic_literal", "is_symbolic"), is_formula.Rd = c("is_formula", 
#&gt;         "is_bare_formula"), is_frame.Rd = "is_frame", is_function.Rd = c("is_function", 
#&gt;         "is_closure", "is_primitive", "is_primitive_eager", "is_primitive_lazy"
#&gt;         ), is_installed.Rd = "is_installed", is_integerish.Rd = c("is_integerish", 
#&gt;         "is_bare_integerish", "is_scalar_integerish"), is_interactive.Rd = c("is_interactive", 
#&gt;         "scoped_interactive", "with_interactive"), is_lang.Rd = c("is_lang", 
#&gt;         "is_unary_lang", "is_binary_lang", "quo_is_lang"), is_named.Rd = c("is_named", 
#&gt;         "is_dictionaryish", "have_name"), is_namespace.Rd = "is_namespace", 
#&gt;         is_pairlist.Rd = c("is_pairlist", "is_node", "is_node_list"
#&gt;         ), is_reference.Rd = "is_reference", is_stack.Rd = c("is_stack", 
#&gt;         "is_eval_stack", "is_call_stack"), is_symbol.Rd = "is_symbol", 
#&gt;         is_true.Rd = c("is_true", "is_false"), is_weakref.Rd = "is_weakref", 
#&gt;         lang.Rd = c("lang", "new_language"), lang_head.Rd = c("lang_head", 
#&gt;         "lang_tail"), lang_modify.Rd = c("lang_modify", "lang_standardise", 
#&gt;         "lang_fn", "lang_name", "lang_args", "lang_args_names"
#&gt;         ), last_error.Rd = c("last_error", "last_trace"), lifecycle.Rd = "lifecycle", 
#&gt;         missing.Rd = c("missing", "na_lgl", "na_int", "na_dbl", 
#&gt;         "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg", 
#&gt;         "is_missing", "maybe_missing"), mut_node_car.Rd = c("mut_node_car", 
#&gt;         "mut_node_cdr", "mut_node_caar", "mut_node_cadr", "mut_node_cdar", 
#&gt;         "mut_node_cddr", "mut_node_tag"), names2.Rd = "names2", 
#&gt;         `new-vector-along-retired.Rd` = c("new-vector-along-retired", 
#&gt;         "new_logical_along", "new_integer_along", "new_double_along", 
#&gt;         "new_character_along", "new_complex_along", "new_raw_along", 
#&gt;         "new_list_along"), `new-vector.Rd` = c("new-vector", 
#&gt;         "new_logical", "new_integer", "new_double", "new_character", 
#&gt;         "new_complex", "new_raw", "new_list"), new_call.Rd = "new_call", 
#&gt;         new_formula.Rd = "new_formula", new_function.Rd = "new_function", 
#&gt;         new_node.Rd = c("new_node", "node_car", "node_cdr", "node_caar", 
#&gt;         "node_cadr", "node_cdar", "node_cddr", "node_poke_car", 
#&gt;         "node_poke_cdr", "node_poke_caar", "node_poke_cadr", 
#&gt;         "node_poke_cdar", "node_poke_cddr", "node_tag", "node_poke_tag"
#&gt;         ), new_quosures.Rd = c("new_quosures", "as_quosures", 
#&gt;         "is_quosures"), new_weakref.Rd = "new_weakref", ns_env.Rd = c("ns_env", 
#&gt;         "ns_imports_env", "ns_env_name"), `op-definition.Rd` = c("op-definition", 
#&gt;         "is_definition", "new_definition", "is_formulaish"), 
#&gt;         `op-get-attr.Rd` = c("op-get-attr", "%@%", "%@%&lt;-"), 
#&gt;         `op-na-default.Rd` = c("op-na-default", "%|%"), `op-null-default.Rd` = c("op-null-default", 
#&gt;         "%||%"), overscope_eval_next.Rd = "overscope_eval_next", 
#&gt;         pairlist2.Rd = "pairlist2", parse_expr.Rd = c("parse_expr", 
#&gt;         "parse_exprs", "parse_quo", "parse_quos"), parse_quosure.Rd = c("parse_quosure", 
#&gt;         "parse_quosures"), prepend.Rd = c("prepend", "modify"
#&gt;         ), prim_name.Rd = "prim_name", quasiquotation.Rd = c("quasiquotation", 
#&gt;         "UQ", "UQS", "{{}}", "{{", "!!", "!!!", ":=", "qq_show"
#&gt;         ), quo_expr.Rd = "quo_expr", quo_label.Rd = c("quo_label", 
#&gt;         "quo_text", "quo_name"), quo_squash.Rd = "quo_squash", 
#&gt;         quosure.Rd = c("quosure", "is_quosure", "quo_is_missing", 
#&gt;         "quo_is_symbol", "quo_is_call", "quo_is_symbolic", "quo_is_null", 
#&gt;         "quo_get_expr", "quo_get_env", "quo_set_expr", "quo_set_env"
#&gt;         ), quotation.Rd = c("quotation", "expr", "enexpr", "exprs", 
#&gt;         "enexprs", "ensym", "ensyms", "quo", "enquo", "quos", 
#&gt;         "enquos"), rep_along.Rd = c("rep_along", "rep_named"), 
#&gt;         restarting.Rd = "restarting", return_from.Rd = c("return_from", 
#&gt;         "return_to"), rlang_backtrace_on_error.Rd = c("rlang_backtrace_on_error", 
#&gt;         "add_backtrace"), rst_abort.Rd = "rst_abort", rst_list.Rd = c("rst_list", 
#&gt;         "rst_exists", "rst_jump", "rst_maybe_jump"), `scalar-type-predicates.Rd` = c("scalar-type-predicates", 
#&gt;         "is_scalar_list", "is_scalar_atomic", "is_scalar_vector", 
#&gt;         "is_scalar_integer", "is_scalar_double", "is_scalar_character", 
#&gt;         "is_scalar_logical", "is_scalar_raw", "is_string", "is_scalar_bytes", 
#&gt;         "is_bool"), scoped_bindings.Rd = c("scoped_bindings", 
#&gt;         "with_bindings"), scoped_env.Rd = c("scoped_env", "is_scoped", 
#&gt;         "scoped_envs", "scoped_names"), scoped_options.Rd = c("scoped_options", 
#&gt;         "with_options", "push_options", "peek_options", "peek_option"
#&gt;         ), search_envs.Rd = c("search_envs", "search_env", "pkg_env", 
#&gt;         "pkg_env_name", "is_attached", "base_env", "global_env"
#&gt;         ), seq2.Rd = c("seq2", "seq2_along"), set_attrs.Rd = c("set_attrs", 
#&gt;         "mut_attrs"), set_expr.Rd = c("set_expr", "get_expr"), 
#&gt;         set_names.Rd = "set_names", splice.Rd = c("splice", "is_spliced", 
#&gt;         "is_spliced_bare", "dots_splice"), stack.Rd = c("stack", 
#&gt;         "global_frame", "current_frame", "ctxt_frame", "call_frame", 
#&gt;         "ctxt_depth", "call_depth", "ctxt_stack", "call_stack"
#&gt;         ), stack_trim.Rd = "stack_trim", string.Rd = "string", 
#&gt;         switch_type.Rd = c("switch_type", "coerce_type", "switch_class", 
#&gt;         "coerce_class"), sym.Rd = c("sym", "syms"), `tidy-dots.Rd` = c("tidy-dots", 
#&gt;         "dots_list", "list2"), `tidyeval-data.Rd` = c("tidyeval-data", 
#&gt;         ".data"), trace_back.Rd = c("trace_back", "trace_length"
#&gt;         ), `type-predicates.Rd` = c("type-predicates", "is_list", 
#&gt;         "is_atomic", "is_vector", "is_integer", "is_double", 
#&gt;         "is_character", "is_logical", "is_raw", "is_bytes", "is_null"
#&gt;         ), type_of.Rd = "type_of", vec_poke_n.Rd = c("vec_poke_n", 
#&gt;         "vec_poke_range"), `vector-coercion.Rd` = c("vector-coercion", 
#&gt;         "as_logical", "as_integer", "as_double", "as_complex", 
#&gt;         "as_character", "as_list"), `vector-construction.Rd` = c("vector-construction", 
#&gt;         "lgl", "int", "dbl", "cpl", "chr", "bytes", "ll"), `vector-old-ctors.Rd` = c("node", 
#&gt;         "vector-old-ctors", "lgl_len", "int_len", "dbl_len", 
#&gt;         "chr_len", "cpl_len", "raw_len", "bytes_len", "list_len", 
#&gt;         "lgl_along", "int_along", "dbl_along", "chr_along", "cpl_along", 
#&gt;         "raw_along", "bytes_along", "list_along"), with_abort.Rd = "with_abort", 
#&gt;         with_env.Rd = c("with_env", "locally"), with_handlers.Rd = c("with_handlers", 
#&gt;         "calling"), with_restarts.Rd = "with_restarts", wref_key.Rd = c("wref_key", 
#&gt;         "wref_value"), zap.Rd = c("zap", "is_zap")), funs = list(
#&gt;         abort.Rd = c("abort()", "warn()", "inform()", "signal()", 
#&gt;         "interrupt()"), are_na.Rd = c("are_na()", "is_na()", 
#&gt;         "is_lgl_na()", "is_int_na()", "is_dbl_na()", "is_chr_na()", 
#&gt;         "is_cpl_na()"), arg_match.Rd = "arg_match()", as_box.Rd = c("as_box()", 
#&gt;         "as_box_if()"), as_bytes.Rd = "as_bytes()", as_data_mask.Rd = c("as_data_mask()", 
#&gt;         "as_data_pronoun()", "new_data_mask()"), as_env.Rd = "as_env()", 
#&gt;         as_environment.Rd = "as_environment()", as_function.Rd = c("as_function()", 
#&gt;         "is_lambda()", "as_closure()"), as_label.Rd = "as_label()", 
#&gt;         as_name.Rd = "as_name()", as_overscope.Rd = c("as_overscope()", 
#&gt;         "new_overscope()", "overscope_clean()"), as_pairlist.Rd = "as_pairlist()", 
#&gt;         as_quosure.Rd = c("as_quosure()", "new_quosure()"), as_string.Rd = "as_string()", 
#&gt;         as_utf8_character.Rd = "as_utf8_character()", `bare-type-predicates.Rd` = c("is_bare_list()", 
#&gt;         "is_bare_atomic()", "is_bare_vector()", "is_bare_double()", 
#&gt;         "is_bare_integer()", "is_bare_numeric()", "is_bare_character()", 
#&gt;         "is_bare_logical()", "is_bare_raw()", "is_bare_string()", 
#&gt;         "is_bare_bytes()"), box.Rd = c("new_box()", "is_box()", 
#&gt;         "unbox()"), call2.Rd = "call2()", call_args.Rd = c("call_args()", 
#&gt;         "call_args_names()"), call_fn.Rd = "call_fn()", call_inspect.Rd = "call_inspect()", 
#&gt;         call_modify.Rd = "call_modify()", call_name.Rd = c("call_name()", 
#&gt;         "call_ns()"), call_standardise.Rd = "call_standardise()", 
#&gt;         caller_env.Rd = c("caller_env()", "current_env()"), caller_fn.Rd = c("caller_fn()", 
#&gt;         "current_fn()"), caller_frame.Rd = "caller_frame()", 
#&gt;         catch_cnd.Rd = "catch_cnd()", chr_unserialise_unicode.Rd = "chr_unserialise_unicode()", 
#&gt;         cnd.Rd = c("error_cnd()", "cnd()", "warning_cnd()", "message_cnd()"
#&gt;         ), cnd_message.Rd = c("cnd_message()", "cnd_issue()", 
#&gt;         "cnd_bullets()", "format_bullets()"), cnd_muffle.Rd = "cnd_muffle()", 
#&gt;         cnd_signal.Rd = "cnd_signal()", cnd_type.Rd = "cnd_type()", 
#&gt;         done.Rd = c("done()", "is_done_box()"), dots_definitions.Rd = "dots_definitions()", 
#&gt;         dots_n.Rd = "dots_n()", dots_values.Rd = "dots_values()", 
#&gt;         duplicate.Rd = "duplicate()", empty_env.Rd = "empty_env()", 
#&gt;         entrace.Rd = c("entrace()", "cnd_entrace()"), env.Rd = c("env()", 
#&gt;         "child_env()", "new_environment()"), env_bind.Rd = c("env_bind()", 
#&gt;         "env_bind_lazy()", "env_bind_active()"), env_bind_exprs.Rd = c("env_bind_exprs()", 
#&gt;         "env_bind_fns()"), env_binding_are_active.Rd = c("env_binding_are_active()", 
#&gt;         "env_binding_are_lazy()"), env_binding_lock.Rd = c("env_binding_lock()", 
#&gt;         "env_binding_unlock()", "env_binding_are_locked()"), 
#&gt;         env_bury.Rd = "env_bury()", env_clone.Rd = "env_clone()", 
#&gt;         env_depth.Rd = "env_depth()", env_get.Rd = c("env_get()", 
#&gt;         "env_get_list()"), env_has.Rd = "env_has()", env_inherits.Rd = "env_inherits()", 
#&gt;         env_lock.Rd = c("env_lock()", "env_is_locked()"), env_name.Rd = c("env_name()", 
#&gt;         "env_label()"), env_names.Rd = c("env_names()", "env_length()"
#&gt;         ), env_parent.Rd = c("env_parent()", "env_tail()", "env_parents()"
#&gt;         ), env_poke.Rd = "env_poke()", env_print.Rd = "env_print()", 
#&gt;         env_unbind.Rd = "env_unbind()", env_unlock.Rd = "env_unlock()", 
#&gt;         eval_bare.Rd = "eval_bare()", eval_tidy.Rd = "eval_tidy()", 
#&gt;         exec.Rd = "exec()", exiting.Rd = "exiting()", expr_interp.Rd = "expr_interp()", 
#&gt;         expr_label.Rd = c("expr_label()", "expr_name()", "expr_text()"
#&gt;         ), expr_print.Rd = c("expr_print()", "expr_deparse()"
#&gt;         ), exprs_auto_name.Rd = c("exprs_auto_name()", "quos_auto_name()"
#&gt;         ), f_rhs.Rd = c("f_rhs()", "`f_rhs&lt;-`()", "f_lhs()", 
#&gt;         "`f_lhs&lt;-`()", "f_env()", "`f_env&lt;-`()"), f_text.Rd = c("f_text()", 
#&gt;         "f_name()", "f_label()"), flatten.Rd = c("flatten()", 
#&gt;         "flatten_lgl()", "flatten_int()", "flatten_dbl()", "flatten_cpl()", 
#&gt;         "flatten_chr()", "flatten_raw()", "squash()", "squash_lgl()", 
#&gt;         "squash_int()", "squash_dbl()", "squash_cpl()", "squash_chr()", 
#&gt;         "squash_raw()", "flatten_if()", "squash_if()"), fn_body.Rd = c("fn_body()", 
#&gt;         "`fn_body&lt;-`()"), fn_env.Rd = c("fn_env()", "`fn_env&lt;-`()"
#&gt;         ), fn_fmls.Rd = c("fn_fmls()", "fn_fmls_names()", "fn_fmls_syms()", 
#&gt;         "`fn_fmls&lt;-`()", "`fn_fmls_names&lt;-`()"), frame_position.Rd = "frame_position()", 
#&gt;         friendly_type.Rd = "friendly_type()", get_env.Rd = c("get_env()", 
#&gt;         "set_env()", "env_poke_parent()"), has_length.Rd = "has_length()", 
#&gt;         has_name.Rd = "has_name()", inherits_any.Rd = c("inherits_any()", 
#&gt;         "inherits_all()", "inherits_only()"), invoke.Rd = "invoke()", 
#&gt;         is_call.Rd = "is_call()", is_callable.Rd = "is_callable()", 
#&gt;         is_condition.Rd = "is_condition()", is_copyable.Rd = "is_copyable()", 
#&gt;         is_empty.Rd = "is_empty()", is_env.Rd = c("is_env()", 
#&gt;         "is_bare_env()"), is_environment.Rd = c("is_environment()", 
#&gt;         "is_bare_environment()"), is_expr.Rd = "is_expr()", is_expression.Rd = c("is_expression()", 
#&gt;         "is_syntactic_literal()", "is_symbolic()"), is_formula.Rd = c("is_formula()", 
#&gt;         "is_bare_formula()"), is_frame.Rd = "is_frame()", is_function.Rd = c("is_function()", 
#&gt;         "is_closure()", "is_primitive()", "is_primitive_eager()", 
#&gt;         "is_primitive_lazy()"), is_installed.Rd = "is_installed()", 
#&gt;         is_integerish.Rd = c("is_integerish()", "is_bare_integerish()", 
#&gt;         "is_scalar_integerish()"), is_interactive.Rd = c("is_interactive()", 
#&gt;         "scoped_interactive()", "with_interactive()"), is_lang.Rd = c("is_lang()", 
#&gt;         "is_unary_lang()", "is_binary_lang()", "quo_is_lang()"
#&gt;         ), is_named.Rd = c("is_named()", "is_dictionaryish()", 
#&gt;         "have_name()"), is_namespace.Rd = "is_namespace()", is_pairlist.Rd = c("is_pairlist()", 
#&gt;         "is_node()", "is_node_list()"), is_reference.Rd = "is_reference()", 
#&gt;         is_stack.Rd = c("is_stack()", "is_eval_stack()", "is_call_stack()"
#&gt;         ), is_symbol.Rd = "is_symbol()", is_true.Rd = c("is_true()", 
#&gt;         "is_false()"), is_weakref.Rd = "is_weakref()", lang.Rd = c("lang()", 
#&gt;         "new_language()"), lang_head.Rd = c("lang_head()", "lang_tail()"
#&gt;         ), lang_modify.Rd = c("lang_modify()", "lang_standardise()", 
#&gt;         "lang_fn()", "lang_name()", "lang_args()", "lang_args_names()"
#&gt;         ), last_error.Rd = c("last_error()", "last_trace()"), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = c("na_lgl", 
#&gt;         "na_int", "na_dbl", "na_chr", "na_cpl"), missing_arg.Rd = c("missing_arg()", 
#&gt;         "is_missing()", "maybe_missing()"), mut_node_car.Rd = c("mut_node_car()", 
#&gt;         "mut_node_cdr()", "mut_node_caar()", "mut_node_cadr()", 
#&gt;         "mut_node_cdar()", "mut_node_cddr()", "mut_node_tag()"
#&gt;         ), names2.Rd = "names2()", `new-vector-along-retired.Rd` = c("new_logical_along()", 
#&gt;         "new_integer_along()", "new_double_along()", "new_character_along()", 
#&gt;         "new_complex_along()", "new_raw_along()", "new_list_along()"
#&gt;         ), `new-vector.Rd` = c("new_logical()", "new_integer()", 
#&gt;         "new_double()", "new_character()", "new_complex()", "new_raw()", 
#&gt;         "new_list()"), new_call.Rd = "new_call()", new_formula.Rd = "new_formula()", 
#&gt;         new_function.Rd = "new_function()", new_node.Rd = c("new_node()", 
#&gt;         "node_car()", "node_cdr()", "node_caar()", "node_cadr()", 
#&gt;         "node_cdar()", "node_cddr()", "node_poke_car()", "node_poke_cdr()", 
#&gt;         "node_poke_caar()", "node_poke_cadr()", "node_poke_cdar()", 
#&gt;         "node_poke_cddr()", "node_tag()", "node_poke_tag()"), 
#&gt;         new_quosures.Rd = c("new_quosures()", "as_quosures()", 
#&gt;         "is_quosures()"), new_weakref.Rd = "new_weakref()", ns_env.Rd = c("ns_env()", 
#&gt;         "ns_imports_env()", "ns_env_name()"), `op-definition.Rd` = c("is_definition()", 
#&gt;         "new_definition()", "is_formulaish()"), `op-get-attr.Rd` = c("`%@%`", 
#&gt;         "`%@%&lt;-`()"), `op-na-default.Rd` = "`%|%`", `op-null-default.Rd` = "`%||%`", 
#&gt;         overscope_eval_next.Rd = "overscope_eval_next()", pairlist2.Rd = "pairlist2()", 
#&gt;         parse_expr.Rd = c("parse_expr()", "parse_exprs()", "parse_quo()", 
#&gt;         "parse_quos()"), parse_quosure.Rd = c("parse_quosure()", 
#&gt;         "parse_quosures()"), prepend.Rd = c("prepend()", "modify()"
#&gt;         ), prim_name.Rd = "prim_name()", quasiquotation.Rd = "qq_show()", 
#&gt;         quo_expr.Rd = "quo_expr()", quo_label.Rd = c("quo_label()", 
#&gt;         "quo_text()", "quo_name()"), quo_squash.Rd = "quo_squash()", 
#&gt;         quosure.Rd = c("is_quosure()", "quo_is_missing()", "quo_is_symbol()", 
#&gt;         "quo_is_call()", "quo_is_symbolic()", "quo_is_null()", 
#&gt;         "quo_get_expr()", "quo_get_env()", "quo_set_expr()", 
#&gt;         "quo_set_env()"), quotation.Rd = c("expr()", "enexpr()", 
#&gt;         "exprs()", "enexprs()", "ensym()", "ensyms()", "quo()", 
#&gt;         "enquo()", "quos()", "enquos()"), rep_along.Rd = c("rep_along()", 
#&gt;         "rep_named()"), restarting.Rd = "restarting()", return_from.Rd = c("return_from()", 
#&gt;         "return_to()"), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = "rst_abort()", rst_list.Rd = c("rst_list()", 
#&gt;         "rst_exists()", "rst_jump()", "rst_maybe_jump()"), `scalar-type-predicates.Rd` = c("is_scalar_list()", 
#&gt;         "is_scalar_atomic()", "is_scalar_vector()", "is_scalar_integer()", 
#&gt;         "is_scalar_double()", "is_scalar_character()", "is_scalar_logical()", 
#&gt;         "is_scalar_raw()", "is_string()", "is_scalar_bytes()", 
#&gt;         "is_bool()"), scoped_bindings.Rd = c("scoped_bindings()", 
#&gt;         "with_bindings()"), scoped_env.Rd = c("scoped_env()", 
#&gt;         "is_scoped()", "scoped_envs()", "scoped_names()"), scoped_options.Rd = c("scoped_options()", 
#&gt;         "with_options()", "push_options()", "peek_options()", 
#&gt;         "peek_option()"), search_envs.Rd = c("search_envs()", 
#&gt;         "search_env()", "pkg_env()", "pkg_env_name()", "is_attached()", 
#&gt;         "base_env()", "global_env()"), seq2.Rd = c("seq2()", 
#&gt;         "seq2_along()"), set_attrs.Rd = c("set_attrs()", "mut_attrs()"
#&gt;         ), set_expr.Rd = c("set_expr()", "get_expr()"), set_names.Rd = "set_names()", 
#&gt;         splice.Rd = c("splice()", "is_spliced()", "is_spliced_bare()", 
#&gt;         "dots_splice()"), stack.Rd = c("global_frame()", "current_frame()", 
#&gt;         "ctxt_frame()", "call_frame()", "ctxt_depth()", "call_depth()", 
#&gt;         "ctxt_stack()", "call_stack()"), stack_trim.Rd = "stack_trim()", 
#&gt;         string.Rd = "string()", switch_type.Rd = c("switch_type()", 
#&gt;         "coerce_type()", "switch_class()", "coerce_class()"), 
#&gt;         sym.Rd = c("sym()", "syms()"), `tidy-dots.Rd` = c("dots_list()", 
#&gt;         "list2()"), `tidyeval-data.Rd` = ".data", trace_back.Rd = c("trace_back()", 
#&gt;         "trace_length()"), `type-predicates.Rd` = c("is_list()", 
#&gt;         "is_atomic()", "is_vector()", "is_integer()", "is_double()", 
#&gt;         "is_character()", "is_logical()", "is_raw()", "is_bytes()", 
#&gt;         "is_null()"), type_of.Rd = "type_of()", vec_poke_n.Rd = c("vec_poke_n()", 
#&gt;         "vec_poke_range()"), `vector-coercion.Rd` = c("as_logical()", 
#&gt;         "as_integer()", "as_double()", "as_complex()", "as_character()", 
#&gt;         "as_list()"), `vector-construction.Rd` = c("lgl()", "int()", 
#&gt;         "dbl()", "cpl()", "chr()", "bytes()"), `vector-old-ctors.Rd` = c("node()", 
#&gt;         "lgl_len()", "int_len()", "dbl_len()", "chr_len()", "cpl_len()", 
#&gt;         "raw_len()", "bytes_len()", "list_len()", "lgl_along()", 
#&gt;         "int_along()", "dbl_along()", "chr_along()", "cpl_along()", 
#&gt;         "raw_along()", "bytes_along()", "list_along()"), with_abort.Rd = "with_abort()", 
#&gt;         with_env.Rd = c("with_env()", "locally()"), with_handlers.Rd = c("with_handlers()", 
#&gt;         "calling()"), with_restarts.Rd = "with_restarts()", wref_key.Rd = c("wref_key()", 
#&gt;         "wref_value()"), zap.Rd = c("zap()", "is_zap()")), title = c("Signal an error, warning, or message", 
#&gt;     "Test for missing values", "Match an argument to a character vector", 
#&gt;     "Convert object to a box", "Coerce to a raw vector", "Create a data mask", 
#&gt;     "Coerce to an environment", "Coerce to an environment", "Convert to function or closure", 
#&gt;     "Create a default name for an R object", "Extract names from symbols", 
#&gt;     "Create an overscope", "Coerce to pairlist", "Coerce object to quosure", 
#&gt;     "Cast symbol to string", "Coerce to a character vector and attempt encoding conversion", 
#&gt;     "Bare type predicates", "Box a value", "Create a call", "Extract arguments from a call", 
#&gt;     "Extract function from a call", "Inspect a call", "Modify the arguments of a call", 
#&gt;     "Extract function name or namespaced of a call", "Standardise a call", 
#&gt;     "Get the current or caller environment", "Get properties of the current or caller frame", 
#&gt;     "Get caller frame", "Catch a condition", "Translate unicode points to UTF-8", 
#&gt;     "Create a condition object", "Build an error message from a main issue and bullet messages", 
#&gt;     "Muffle a condition", "Signal a condition object", "What type is a condition?", 
#&gt;     "Box a final value for early termination", "Capture definition objects", 
#&gt;     "How many arguments are currently forwarded in dots?", "Evaluate dots with preliminary splicing", 
#&gt;     "Duplicate an R object", "Get the empty environment", "Add backtrace from error handler", 
#&gt;     "Create a new environment", "Bind symbols to objects in an environment", 
#&gt;     "Bind a promise or active binding", "What kind of environment binding?", 
#&gt;     "Lock or unlock environment bindings", "Mask bindings by defining symbols deeper in a scope", 
#&gt;     "Clone an environment", "Depth of an environment chain", 
#&gt;     "Get an object in an environment", "Does an environment have or see bindings?", 
#&gt;     "Does environment inherit from another environment?", "Lock an environment", 
#&gt;     "Label of an environment", "Names and numbers of symbols bound in an environment", 
#&gt;     "Get parent environments", "Poke an object in an environment", 
#&gt;     "Pretty-print an environment", "Remove bindings from an environment", 
#&gt;     "Unlock an environment", "Evaluate an expression in an environment", 
#&gt;     "Evaluate an expression with quosures and pronoun support", 
#&gt;     "Execute a function", "Exiting handler", "Process unquote operators in a captured expression", 
#&gt;     "Turn an expression to a label", "Print an expression", "Ensure that all elements of a list of expressions are named", 
#&gt;     "Get or set formula components", "Turn RHS of formula into a string or label", 
#&gt;     "Flatten or squash a list of lists into a simpler vector", 
#&gt;     "Get or set function body", "Return the closure environment of a function", 
#&gt;     "Extract arguments from a function", "Find the position or distance of a frame on the evaluation stack", 
#&gt;     "Format a type for error messages", "Get or set the environment of an object", 
#&gt;     "How long is an object?", "Does an object have an element with this name?", 
#&gt;     "Does an object inherit from a set of classes?", "Invoke a function with a list of arguments", 
#&gt;     "Is object a call?", "Is an object callable?", "Is object a condition?", 
#&gt;     "Is an object copyable?", "Is object an empty vector or NULL?", 
#&gt;     "Is an object an environment?", "Is object an environment?", 
#&gt;     "Is an object an expression?", "Is an object an expression?", 
#&gt;     "Is object a formula?", "Is object a frame?", "Is object a function?", 
#&gt;     "Is a package installed in the library?", "Is a vector integer-like?", 
#&gt;     "Is R running interactively?", "Is object a call?", "Is object named?", 
#&gt;     "Is an object a namespace environment?", "Is object a node or pairlist?", 
#&gt;     "Is an object referencing another?", "Is object a stack?", 
#&gt;     "Is object a symbol?", "Is object identical to TRUE or FALSE?", 
#&gt;     "Is object a weak reference?", "Create a call", "Return the head or tail of a call", 
#&gt;     "Manipulate or access a call", "Last &lt;code&gt;abort()&lt;/code&gt; error", 
#&gt;     "Life cycle of the rlang package", "Missing values", "Generate or handle a missing argument", 
#&gt;     "Mutate node components", "Get names of a vector", "Create vectors matching the length of a given vector", 
#&gt;     "Create vectors matching a given length", "Create a new call from components", 
#&gt;     "Create a formula", "Create a function", "Helpers for pairlist and language nodes", 
#&gt;     "Create a list of quosures", "Create a weak reference", "Get the namespace of a package", 
#&gt;     "Definition operator", "Infix attribute accessor and setter", 
#&gt;     "Replace missing values", "Default value for &lt;code&gt;NULL&lt;/code&gt;", 
#&gt;     "Evaluate next quosure in a data mask", "Create pairlists with splicing support", 
#&gt;     "Parse R code", "Parse text into a quosure", "Prepend a vector", 
#&gt;     "Name of a primitive function", "Quasiquotation of an expression", 
#&gt;     "Squash a quosure", "Format quosures for printing or labelling", 
#&gt;     "Squash a quosure", "Quosure getters, setters and testers", 
#&gt;     "Quotation", "Create vectors matching the length of a given vector", 
#&gt;     "Create a restarting handler", "Jump to or from a frame", 
#&gt;     "Display backtrace on error", "Jump to the abort restart", 
#&gt;     "Restarts utilities", "Scalar type predicates", "Temporarily change bindings of an environment", 
#&gt;     "Retired &lt;code&gt;scoped&lt;/code&gt; functions", "Change global options", 
#&gt;     "Search path environments", "Increasing sequence of integers in an interval", 
#&gt;     "Add attributes to an object", "Set and get an expression", 
#&gt;     "Set names of a vector", "Splice lists", "Call stack information", 
#&gt;     "Trim top call layers from the evaluation stack", "Create a string", 
#&gt;     "Dispatch on base types", "Create a symbol or list of symbols", 
#&gt;     "Collect dots as lists", "Data pronoun for tidy evaluation", 
#&gt;     "Capture a backtrace", "Type predicates", "Base type of an object", 
#&gt;     "Poke values into a vector", "Coerce an object to a base type", 
#&gt;     "Create vectors", "Retired vector construction by length", 
#&gt;     "Promote all errors to rlang errors", "Evaluate an expression within a given environment", 
#&gt;     "Establish handlers on the stack", "Establish a restart point on the stack", 
#&gt;     "Get key/value from a weak reference object", "Create zap objects"
#&gt;     ), rd = list(abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/cnd-abort.R, R/cnd-signal.R", 
#&gt;         "\n", list("abort"), "\n", list("abort"), "\n", list(
#&gt;             "warn"), "\n", list("inform"), "\n", list("signal"), 
#&gt;         "\n", list("interrupt"), "\n", list("Signal an error, warning, or message"), 
#&gt;         "\n", list("\n", "abort(message = \"\", .subclass = NULL, ..., trace = NULL,\n", 
#&gt;             "  call = NULL, parent = NULL, msg, type)\n", "\n", 
#&gt;             "warn(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "inform(message, .subclass = NULL, ..., call = NULL, msg, type)\n", 
#&gt;             "\n", "signal(message, .subclass, ...)\n", "\n", 
#&gt;             "interrupt()\n"), "\n", list("\n", list(list("message"), 
#&gt;             list("The message to display.\n", "\n", "Experimental: Can also be a named character vector, in which case\n", 
#&gt;                 "the message is assembled as a list of bullets. See\n", 
#&gt;                 list(list("cnd_message()")), " to learn how names control the bulleted output.")), 
#&gt;             "\n", "\n", list(list(".subclass"), list("Subclass of the condition. This allows your users\n", 
#&gt;                 "to selectively handle the conditions signalled by your functions.")), 
#&gt;             "\n", "\n", list(list("..."), list("Additional data to be stored in the condition object.")), 
#&gt;             "\n", "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                 " object created by ", list(list("trace_back()")), 
#&gt;                 ".")), "\n", "\n", list(list("call"), list("Defunct as of rlang 0.4.0. Storing the full\n", 
#&gt;                 "backtrace is now preferred to storing a simple call.")), 
#&gt;             "\n", "\n", list(list("parent"), list("A parent condition object created by ", 
#&gt;                 list(list("abort()")), ".")), "\n", "\n", list(
#&gt;                 list("msg, type"), list("These arguments were renamed to ", 
#&gt;                   list("message"), " and\n", list(".subclass"), 
#&gt;                   " and are defunct as of rlang 0.4.0.")), "\n"), 
#&gt;         "\n", list("\n", "These functions are equivalent to base functions ", 
#&gt;             list(list("base::stop()")), ",\n", list(list("base::warning()")), 
#&gt;             " and ", list(list("base::message()")), ", but make it easy to supply\n", 
#&gt;             "condition metadata:\n", list("\n", list(), " Supply ", 
#&gt;                 list(".subclass"), " to create a classed condition. Typed\n", 
#&gt;                 "conditions can be captured or handled selectively, allowing for\n", 
#&gt;                 "finer-grained error handling.\n", list(), " Supply metadata with named ", 
#&gt;                 list("..."), " arguments. This data will be\n", 
#&gt;                 "stored in the condition object and can be examined by handlers.\n"), 
#&gt;             "\n", "\n", list("interrupt()"), " allows R code to simulate a user interrupt of the\n", 
#&gt;             "kind that is signalled with ", list("Ctrl-C"), ". It is currently not possible\n", 
#&gt;             "to create custom interrupt condition objects.\n"), 
#&gt;         "\n", list(list("Backtrace"), list("\n", "\n", "\n", 
#&gt;             "Unlike ", list("stop()"), " and ", list("warning()"), 
#&gt;             ", these functions don't include call\n", "information by default. This saves you from typing ", 
#&gt;             list("call. = FALSE"), "\n", "and produces cleaner error messages.\n", 
#&gt;             "\n", "A backtrace is always saved into error objects. You can print a\n", 
#&gt;             "simplified backtrace of the last error by calling ", 
#&gt;             list(list("last_error()")), "\n", "and a full backtrace with ", 
#&gt;             list("summary(last_error())"), ".\n", "\n", "You can also display a backtrace with the error message by setting\n", 
#&gt;             "the option ", list("rlang_backtrace_on_error"), 
#&gt;             ". It supports the following\n", "values:\n", list(
#&gt;                 "\n", list(), " ", list("\"reminder\""), ": Invite users to call ", 
#&gt;                 list("rlang::last_error()"), " to see a\n", "backtrace.\n", 
#&gt;                 list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                 list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                 list(), " ", list("\"full\""), ": Display a full backtrace tree.\n", 
#&gt;                 list(), " ", list("\"none\""), ": Display nothing.\n"), 
#&gt;             "\n")), "\n", "\n", list(list("Mufflable conditions"), 
#&gt;             list("\n", "\n", "\n", "Signalling a condition with ", 
#&gt;                 list("inform()"), " or ", list("warn()"), " causes a message\n", 
#&gt;                 "to be displayed in the console. These messages can be muffled with\n", 
#&gt;                 list(list("base::suppressMessages()")), " or ", 
#&gt;                 list(list("base::suppressWarnings()")), ".\n", 
#&gt;                 "\n", "On recent R versions (&gt;= R 3.5.0), interrupts are typically\n", 
#&gt;                 "signalled with a ", list("\"resume\""), " restart. This is however not\n", 
#&gt;                 "guaranteed.\n")), "\n", "\n", list(list("Lifecycle"), 
#&gt;             list("\n", "\n", "\n", "These functions were changed in rlang 0.3.0 to take condition\n", 
#&gt;                 "metadata with ", list("..."), ". Consequently:\n", 
#&gt;                 list("\n", list(), " All arguments were renamed to be prefixed with a dot, except for\n", 
#&gt;                   list("type"), " which was renamed to ", list(
#&gt;                     ".subclass"), ".\n", list(), " ", list(".call"), 
#&gt;                   " (previously ", list("call"), ") can no longer be passed positionally.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# These examples are guarded to avoid throwing errors\n", 
#&gt;             "if (FALSE) {\n", "\n", "# Signal an error with a message just like stop():\n", 
#&gt;             "abort(\"Something bad happened\")\n", "\n", "# Give a class to the error:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\")\n", 
#&gt;             "\n", "# This will allow your users to handle the error selectively\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    warn(err$message) # Demote the error to a warning\n", 
#&gt;             "    NA                # Return an alternative value\n", 
#&gt;             "  }\n", ")\n", "\n", "# You can also specify metadata that will be stored in the condition:\n", 
#&gt;             "abort(\"Something bad happened\", \"somepkg_bad_error\", data = 1:10)\n", 
#&gt;             "\n", "# This data can then be consulted by user handlers:\n", 
#&gt;             "tryCatch(\n", "  somepkg_function(),\n", "  somepkg_bad_error = function(err) {\n", 
#&gt;             "    # Compute an alternative return value with the data:\n", 
#&gt;             "    recover_error(err$data)\n", "  }\n", ")\n", 
#&gt;             "\n", "# If you call low-level APIs it is good practice to catch technical\n", 
#&gt;             "# errors and rethrow them with a more meaningful message. Pass on\n", 
#&gt;             "# the caught error as `parent` to get a nice decomposition of\n", 
#&gt;             "# errors and backtraces:\n", "file &lt;- \"http://foo.bar/baz\"\n", 
#&gt;             "tryCatch(\n", "  download(file),\n", "  error = function(err) {\n", 
#&gt;             "    msg &lt;- sprintf(\"Can't download `%s`\", file)\n", 
#&gt;             "    abort(msg, parent = err)\n", "})\n", "\n", "# Unhandled errors are saved automatically by `abort()` and can be\n", 
#&gt;             "# retrieved with `last_error()`. The error prints with a simplified\n", 
#&gt;             "# backtrace:\n", "abort(\"Saved error?\")\n", "last_error()\n", 
#&gt;             "\n", "# Use `summary()` to print the full backtrace and the condition fields:\n", 
#&gt;             "summary(last_error())\n", "\n", "}\n"), "\n", list(
#&gt;             "\n", list(list("with_abort()")), " to convert all errors to rlang errors.\n"), 
#&gt;         "\n"), are_na.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;         "\n", "% Please edit documentation in R/vec-na.R", "\n", 
#&gt;         list("are_na"), "\n", list("are_na"), "\n", list("is_na"), 
#&gt;         "\n", list("is_lgl_na"), "\n", list("is_int_na"), "\n", 
#&gt;         list("is_dbl_na"), "\n", list("is_chr_na"), "\n", list(
#&gt;             "is_cpl_na"), "\n", list("Test for missing values"), 
#&gt;         "\n", list("\n", "are_na(x)\n", "\n", "is_na(x)\n", "\n", 
#&gt;             "is_lgl_na(x)\n", "\n", "is_int_na(x)\n", "\n", "is_dbl_na(x)\n", 
#&gt;             "\n", "is_chr_na(x)\n", "\n", "is_cpl_na(x)\n"), 
#&gt;         "\n", list("\n", list(list("x"), list("An object to test")), 
#&gt;             "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;             "\n", "\n", list("are_na()"), " checks for missing values in a vector and is equivalent\n", 
#&gt;             "to ", list(list("base::is.na()")), ". It is a vectorised predicate, meaning that its\n", 
#&gt;             "output is always the same length as its input. On the other hand,\n", 
#&gt;             list("is_na()"), " is a scalar predicate and always returns a scalar\n", 
#&gt;             "boolean, ", list("TRUE"), " or ", list("FALSE"), 
#&gt;             ". If its input is not scalar, it returns\n", list(
#&gt;                 "FALSE"), ". Finally, there are typed versions that check for\n", 
#&gt;             "particular ", list("missing types"), ".\n"), "\n", 
#&gt;         list("\n", "The scalar predicates accept non-vector inputs. They are equivalent\n", 
#&gt;             "to ", list(list("is_null()")), " in that respect. In contrast the vectorised\n", 
#&gt;             "predicate ", list("are_na()"), " requires a vector input since it is defined\n", 
#&gt;             "over vector values.\n"), "\n", list(list("Life cycle"), 
#&gt;             list("\n", "\n", "\n", "These functions might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;         "\n", "\n", list("\n", "# are_na() is vectorised and works regardless of the type\n", 
#&gt;             "are_na(c(1, 2, NA))\n", "are_na(c(1L, NA, 3L))\n", 
#&gt;             "\n", "# is_na() checks for scalar input and works for all types\n", 
#&gt;             "is_na(NA)\n", "is_na(na_dbl)\n", "is_na(character(0))\n", 
#&gt;             "\n", "# There are typed versions as well:\n", "is_lgl_na(NA)\n", 
#&gt;             "is_lgl_na(na_dbl)\n"), "\n", list("internal"), "\n"), 
#&gt;         arg_match.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("arg_match"), "\n", list("arg_match"), "\n", 
#&gt;             list("Match an argument to a character vector"), 
#&gt;             "\n", list("\n", "arg_match(arg, values = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("arg"), list("A symbol referring to an argument accepting strings.")), 
#&gt;                 "\n", "\n", list(list("values"), list("The possible values that ", 
#&gt;                   list("arg"), " can take. If ", list("NULL"), 
#&gt;                   ",\n", "the values are taken from the function definition of the ", 
#&gt;                   list("caller frame"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "The string supplied to ", list("arg"), 
#&gt;                 ".\n"), "\n", list("\n", "This is equivalent to ", 
#&gt;                 list(list("base::match.arg()")), " with a few differences:\n", 
#&gt;                 list("\n", list(), " Partial matches trigger an error.\n", 
#&gt;                   list(), " Error messages are a bit more informative and obey the tidyverse\n", 
#&gt;                   "standards.\n"), "\n"), "\n", list("\n", "fn &lt;- function(x = c(\"foo\", \"bar\")) arg_match(x)\n", 
#&gt;                 "fn(\"bar\")\n", "\n", "# This would throw an informative error if run:\n", 
#&gt;                 "# fn(\"b\")\n", "# fn(\"baz\")\n"), "\n"), as_box.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "as_box"), "\n", list("as_box"), "\n", list("as_box_if"), 
#&gt;             "\n", list("Convert object to a box"), "\n", list(
#&gt;                 "\n", "as_box(x, class = NULL)\n", "\n", "as_box_if(.x, .p, .class = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("class, .class"), list(
#&gt;                   "A box class. If the input is already a box of\n", 
#&gt;                   "that class, it is returned as is. If the input needs to be boxed,\n", 
#&gt;                   list("class"), " is passed to ", list(list(
#&gt;                     "new_box()")), ".")), "\n", "\n", list(list(
#&gt;                   ".x"), list("An R object.")), "\n", "\n", list(
#&gt;                   list(".p"), list("A predicate function.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed to ", 
#&gt;                   list(".p"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("as_box()"), " boxes its input only if it is not already a box. The\n", 
#&gt;                   "class is also checked if supplied.\n", list(), 
#&gt;                   " ", list("as_box_if()"), " boxes its input only if it not already a box, or if\n", 
#&gt;                   "the predicate ", list(".p"), " returns ", 
#&gt;                   list("TRUE"), ".\n"), "\n"), "\n"), as_bytes.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_bytes"), "\n", list("as_bytes"), "\n", 
#&gt;             list("Coerce to a raw vector"), "\n", list("\n", 
#&gt;                 "as_bytes(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("A string.")), "\n"), "\n", list("\n", 
#&gt;                 "A raw vector of bytes.\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This currently only works with strings, and returns its hexadecimal\n", 
#&gt;                 "representation.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "Raw vector functions are experimental.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_data_mask.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/eval-tidy.R", "\n", 
#&gt;             list("as_data_mask"), "\n", list("as_data_mask"), 
#&gt;             "\n", list("as_data_pronoun"), "\n", list("new_data_mask"), 
#&gt;             "\n", list("Create a data mask"), "\n", list("\n", 
#&gt;                 "as_data_mask(data, parent = NULL)\n", "\n", 
#&gt;                 "as_data_pronoun(data)\n", "\n", "new_data_mask(bottom, top = bottom, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("Deprecated. This argument no longer has any effect.\n", 
#&gt;                   "The parent of the data mask is determined from either:\n", 
#&gt;                   list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                     list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"))), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "A data mask that you can supply to ", 
#&gt;                 list(list("eval_tidy()")), ".\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "A data mask is an environment (or possibly multiple environments\n", 
#&gt;                 "forming an ancestry) containing user-supplied objects. Objects in\n", 
#&gt;                 "the mask have precedence over objects in the environment (i.e. they\n", 
#&gt;                 "mask those objects). Many R functions evaluate quoted expressions\n", 
#&gt;                 "in a data mask so these expressions can refer to objects within the\n", 
#&gt;                 "user data.\n", "\n", "These functions let you construct a tidy eval data mask manually.\n", 
#&gt;                 "They are meant for developers of tidy eval interfaces rather than\n", 
#&gt;                 "for end users.\n"), "\n", list(list("Why build a data mask?"), 
#&gt;                 list("\n", "\n", "\n", "Most of the time you can just call ", 
#&gt;                   list(list("eval_tidy()")), " with a list or a\n", 
#&gt;                   "data frame and the data mask will be constructed automatically.\n", 
#&gt;                   "There are three main use cases for manual creation of data masks:\n", 
#&gt;                   list("\n", list(), " When ", list(list("eval_tidy()")), 
#&gt;                     " is called with the same data in a tight loop.\n", 
#&gt;                     "Because there is some overhead to creating tidy eval data masks,\n", 
#&gt;                     "constructing the mask once and reusing it for subsequent\n", 
#&gt;                     "evaluations may improve performance.\n", 
#&gt;                     list(), " When several expressions should be evaluated in the exact same\n", 
#&gt;                     "environment because a quoted expression might create new objects\n", 
#&gt;                     "that can be referred in other quoted expressions evaluated at a\n", 
#&gt;                     "later time. One example of this is ", list(
#&gt;                       "tibble::lst()"), " where new\n", "columns can refer to previous ones.\n", 
#&gt;                     list(), " When your data mask requires special features. For instance the\n", 
#&gt;                     "data frame columns in dplyr data masks are implemented with\n", 
#&gt;                     list("active bindings"), ".\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Building your own data mask"), 
#&gt;                 list("\n", "\n", "\n", "Unlike ", list(list("base::eval()")), 
#&gt;                   " which takes any kind of environments as data\n", 
#&gt;                   "mask, ", list(list("eval_tidy()")), " has specific requirements in order to support\n", 
#&gt;                   list("quosures"), ". For this reason you can't supply bare\n", 
#&gt;                   "environments.\n", "\n", "There are two ways of constructing an rlang data mask manually:\n", 
#&gt;                   list("\n", list(), " ", list("as_data_mask()"), 
#&gt;                     " transforms a list or data frame to a data mask.\n", 
#&gt;                     "It automatically installs the data pronoun ", 
#&gt;                     list(list(".data")), ".\n", list(), " ", 
#&gt;                     list("new_data_mask()"), " is a bare bones data mask constructor for\n", 
#&gt;                     "environments. You can supply a bottom and a top environment in\n", 
#&gt;                     "case your data mask comprises multiple environments (see section\n", 
#&gt;                     "below).\n", "\n", "Unlike ", list("as_data_mask()"), 
#&gt;                     " it does not install the ", list(".data"), 
#&gt;                     " pronoun\n", "so you need to provide one yourself. You can provide a pronoun\n", 
#&gt;                     "constructed with ", list("as_data_pronoun()"), 
#&gt;                     " or your own pronoun class.\n", "\n", list(
#&gt;                       "as_data_pronoun()"), " will create a pronoun from a list, an\n", 
#&gt;                     "environment, or an rlang data mask. In the latter case, the whole\n", 
#&gt;                     "ancestry is looked up from the bottom to the top of the mask.\n", 
#&gt;                     "Functions stored in the mask are bypassed by the pronoun.\n"), 
#&gt;                   "\n", "\n", "Once you have built a data mask, simply pass it to ", 
#&gt;                   list(list("eval_tidy()")), " as\n", "the ", 
#&gt;                   list("data"), " argument. You can repeat this as many times as\n", 
#&gt;                   "needed. Note that any objects created there (perhaps because of a\n", 
#&gt;                   "call to ", list("&lt;-"), ") will persist in subsequent evaluations.\n")), 
#&gt;             "\n", "\n", list(list("Top and bottom of data mask"), 
#&gt;                 list("\n", "\n", "\n", "In some cases you'll need several levels in your data mask. One\n", 
#&gt;                   "good reason is when you include functions in the mask. It's a good\n", 
#&gt;                   "idea to keep data objects one level lower than function objects, so\n", 
#&gt;                   "that the former cannot override the definitions of the latter (see\n", 
#&gt;                   "examples).\n", "\n", "In that case, set up all your environments and keep track of the\n", 
#&gt;                   "bottom child and the top parent. You'll need to pass both to\n", 
#&gt;                   list("new_data_mask()"), ".\n", "\n", "Note that the parent of the top environment is completely\n", 
#&gt;                   "undetermined, you shouldn't expect it to remain the same at all\n", 
#&gt;                   "times. This parent is replaced during evaluation by ", 
#&gt;                   list(list("eval_tidy()")), "\n", "to one of the following environments:\n", 
#&gt;                   list("\n", list(), " The default environment passed as the ", 
#&gt;                     list("env"), " argument of ", list("eval_tidy()"), 
#&gt;                     ".\n", list(), " The environment of the current quosure being evaluated, if applicable.\n"), 
#&gt;                   "\n", "\n", "Consequently, all masking data should be contained between the\n", 
#&gt;                   "bottom and top environment of the data mask.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "The ", list("parent"), " argument no longer has any effect and is defunct as of\n", 
#&gt;                 "rlang 0.4.0. The parent of the data mask is determined from either:\n", 
#&gt;                 list("\n", list(), " The ", list("env"), " argument of ", 
#&gt;                   list("eval_tidy()"), "\n", list(), " Quosure environments when applicable\n"), 
#&gt;                 "\n", "\n", "Passing environments to ", list(
#&gt;                   "as_data_mask()"), " is deprecated as of rlang\n", 
#&gt;                 "0.3.0. Please use ", list("new_data_mask()"), 
#&gt;                 " instead.\n", "\n", list("rlang 0.2.0"), "\n", 
#&gt;                 "\n", "In early versions of rlang data masks were called overscopes. We\n", 
#&gt;                 "think data mask is a more natural name in R. It makes reference to\n", 
#&gt;                 "masking in the search path which occurs through the same mechanism\n", 
#&gt;                 "(in technical terms, lexical scoping with hierarchically nested\n", 
#&gt;                 "environments). We say that objects from user data mask objects\n", 
#&gt;                 "in the current environment.\n", "\n", "Following this change in terminology, ", 
#&gt;                 list("as_overscope()"), " and\n", list("new_overscope()"), 
#&gt;                 " were deprecated in rlang 0.2.0 in favour of\n", 
#&gt;                 list("as_data_mask()"), " and ", list("new_data_mask()"), 
#&gt;                 ".\n")), "\n", "\n", list("\n", "# Evaluating in a tidy evaluation environment enables all tidy\n", 
#&gt;                 "# features:\n", "mask &lt;- as_data_mask(mtcars)\n", 
#&gt;                 "eval_tidy(quo(letters), mask)\n", "\n", "# You can install new pronouns in the mask:\n", 
#&gt;                 "mask$.pronoun &lt;- as_data_pronoun(list(foo = \"bar\", baz = \"bam\"))\n", 
#&gt;                 "eval_tidy(quo(.pronoun$foo), mask)\n", "\n", 
#&gt;                 "# In some cases the data mask can leak to the user, for example if\n", 
#&gt;                 "# a function or formula is created in the data mask environment:\n", 
#&gt;                 "cyl &lt;- \"user variable from the context\"\n", 
#&gt;                 "fn &lt;- eval_tidy(quote(function() cyl), mask)\n", 
#&gt;                 "fn()\n", "\n", "# If new objects are created in the mask, they persist in the\n", 
#&gt;                 "# subsequent calls:\n", "eval_tidy(quote(new &lt;- cyl + am), mask)\n", 
#&gt;                 "eval_tidy(quote(new * 2), mask)\n", "\n", "\n", 
#&gt;                 "# In some cases your data mask is a whole chain of environments\n", 
#&gt;                 "# rather than a single environment. You'll have to use\n", 
#&gt;                 "# `new_data_mask()` and let it know about the bottom of the mask\n", 
#&gt;                 "# (the last child of the environment chain) and the topmost parent.\n", 
#&gt;                 "\n", "# A common situation where you'll want a multiple-environment mask\n", 
#&gt;                 "# is when you include functions in your mask. In that case you'll\n", 
#&gt;                 "# put functions in the top environment and data in the bottom. This\n", 
#&gt;                 "# will prevent the data from overwriting the functions.\n", 
#&gt;                 "top &lt;- new_environment(list(`+` = base::paste, c = base::paste))\n", 
#&gt;                 "\n", "# Let's add a middle environment just for sport:\n", 
#&gt;                 "middle &lt;- env(top)\n", "\n", "# And finally the bottom environment containing data:\n", 
#&gt;                 "bottom &lt;- env(middle, a = \"a\", b = \"b\", c = \"c\")\n", 
#&gt;                 "\n", "# We can now create a mask by supplying the top and bottom\n", 
#&gt;                 "# environments:\n", "mask &lt;- new_data_mask(bottom, top = top)\n", 
#&gt;                 "\n", "# This data mask can be passed to eval_tidy() instead of a list or\n", 
#&gt;                 "# data frame:\n", "eval_tidy(quote(a + b + c), data = mask)\n", 
#&gt;                 "\n", "# Note how the function `c()` and the object `c` are looked up\n", 
#&gt;                 "# properly because of the multi-level structure:\n", 
#&gt;                 "eval_tidy(quote(c(a, b, c)), data = mask)\n", 
#&gt;                 "\n", "# new_data_mask() does not create data pronouns, but\n", 
#&gt;                 "# data pronouns can be added manually:\n", "mask$.fns &lt;- as_data_pronoun(top)\n", 
#&gt;                 "\n", "# The `.data` pronoun should generally be created from the\n", 
#&gt;                 "# mask. This will ensure data is looked up throughout the whole\n", 
#&gt;                 "# ancestry. Only non-function objects are looked up from this\n", 
#&gt;                 "# pronoun:\n", "mask$.data &lt;- as_data_pronoun(mask)\n", 
#&gt;                 "mask$.data$c\n", "\n", "# Now we can reference the values with the pronouns:\n", 
#&gt;                 "eval_tidy(quote(c(.data$a, .data$b, .data$c)), data = mask)\n"), 
#&gt;             "\n"), as_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_env"), "\n", list("as_env"), "\n", 
#&gt;             list("Coerce to an environment"), "\n", list("\n", 
#&gt;                 "as_env(x, parent = NULL)\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated as it was renamed to ", 
#&gt;                 list(list("as_environment()")), "\n", "in rlang 0.2.0.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "as_environment"), "\n", list("as_environment"), 
#&gt;             "\n", list("Coerce to an environment"), "\n", list(
#&gt;                 "\n", "as_environment(x, parent = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("A parent environment, ", 
#&gt;                   list(list("empty_env()")), " by default. This\n", 
#&gt;                   "argument is only used when ", list("x"), " is data actually coerced to an\n", 
#&gt;                   "environment (as opposed to data representing an environment, like\n", 
#&gt;                   list("NULL"), " representing the empty environment).")), 
#&gt;                 "\n"), "\n", list("\n", list("as_environment()"), 
#&gt;                 " coerces named vectors (including lists) to an\n", 
#&gt;                 "environment. The names must be unique. If supplied an unnamed\n", 
#&gt;                 "string, it returns the corresponding package environment (see\n", 
#&gt;                 list(list("pkg_env()")), ").\n"), "\n", list(
#&gt;                 "\n", "If ", list("x"), " is an environment and ", 
#&gt;                 list("parent"), " is not ", list("NULL"), ", the\n", 
#&gt;                 "environment is duplicated before being set a new parent. The return\n", 
#&gt;                 "value is therefore a different environment than ", 
#&gt;                 list("x"), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("as_env()"), " was soft-deprecated and renamed to ", 
#&gt;                   list("as_environment()"), " in\n", "rlang 0.2.0. This is for consistency as type predicates should not\n", 
#&gt;                   "be abbreviated.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Coerce a named vector to an environment:\n", 
#&gt;                 "env &lt;- as_environment(mtcars)\n", "\n", "# By default it gets the empty environment as parent:\n", 
#&gt;                 "identical(env_parent(env), empty_env())\n", 
#&gt;                 "\n", "\n", "# With strings it is a handy shortcut for pkg_env():\n", 
#&gt;                 "as_environment(\"base\")\n", "as_environment(\"rlang\")\n", 
#&gt;                 "\n", "# With NULL it returns the empty environment:\n", 
#&gt;                 "as_environment(NULL)\n"), "\n"), as_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "as_function"), "\n", list("as_function"), "\n", 
#&gt;             list("is_lambda"), "\n", list("as_closure"), "\n", 
#&gt;             list("Convert to function or closure"), "\n", list(
#&gt;                 "\n", "as_function(x, env = caller_env())\n", 
#&gt;                 "\n", "is_lambda(x)\n", "\n", "as_closure(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function or formula.\n", 
#&gt;                 "\n", "If a ", list("function"), ", it is used as is.\n", 
#&gt;                 "\n", "If a ", list("formula"), ", e.g. ", list(
#&gt;                   "~ .x + 2"), ", it is converted to a function\n", 
#&gt;                 "with up to two arguments: ", list(".x"), " (single argument) or ", 
#&gt;                 list(".x"), " and ", list(".y"), "\n", "(two arguments). The ", 
#&gt;                 list("."), " placeholder can be used instead of ", 
#&gt;                 list(".x"), ".\n", "This allows you to create very compact anonymous functions (lambdas) with up\n", 
#&gt;                 "to two inputs. Functions created from formulas have a special\n", 
#&gt;                 "class. Use ", list("is_lambda()"), " to test for it.\n", 
#&gt;                 "\n", "Lambdas currently do not support ", list(
#&gt;                   "quasiquotation"), ",\n", "due to the way the arguments are handled internally.")), 
#&gt;                 "\n", "\n", list(list("env"), list("Environment in which to fetch the function in case ", 
#&gt;                   list("x"), "\n", "is a string.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("as_function()"), 
#&gt;                   " transforms a one-sided formula into a function.\n", 
#&gt;                   "This powers the lambda syntax in packages like purrr.\n", 
#&gt;                   list(), " ", list("as_closure()"), " first passes its argument to ", 
#&gt;                   list("as_function()"), ". If\n", "the result is a primitive function, it regularises it to a proper\n", 
#&gt;                   list("closure"), " (see ", list(list("is_function()")), 
#&gt;                   " about primitive functions). Some\n", "special control flow primitives like ", 
#&gt;                   list("if"), ", ", list("for"), ", or ", list(
#&gt;                     "break"), "\n", "can't be coerced to a closure.\n"), 
#&gt;                 "\n"), "\n", list("\n", "f &lt;- as_function(~ .x + 1)\n", 
#&gt;                 "f(10)\n", "\n", "g &lt;- as_function(~ -1 * .)\n", 
#&gt;                 "g(4)\n", "\n", "h &lt;- as_function(~ .x - .y)\n", 
#&gt;                 "h(6, 3)\n", "\n", "# Functions created from a formula have a special class:\n", 
#&gt;                 "is_lambda(f)\n", "is_lambda(as_function(function() \"foo\"))\n", 
#&gt;                 "\n", "# Primitive functions are regularised as closures\n", 
#&gt;                 "as_closure(list)\n", "as_closure(\"list\")\n", 
#&gt;                 "\n", "# Operators have `.x` and `.y` as arguments, just like lambda\n", 
#&gt;                 "# functions created with the formula syntax:\n", 
#&gt;                 "as_closure(`+`)\n", "as_closure(`~`)\n", "\n", 
#&gt;                 "# Use a regular function for tidy evaluation, also when calling functions\n", 
#&gt;                 "# that use tidy evaluation:\n", "## Bad:\n", 
#&gt;                 "e &lt;- as_function(~ as_label(ensym(.x)))\n", 
#&gt;                 "## Good:\n", "e &lt;- as_function(function(x) as_label(ensym(x)))\n", 
#&gt;                 "\n", "e(y)\n"), "\n"), as_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/deparse.R", 
#&gt;             "\n", list("as_label"), "\n", list("as_label"), "\n", 
#&gt;             list("Create a default name for an R object"), "\n", 
#&gt;             list("\n", "as_label(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object.")), "\n"), "\n", 
#&gt;             list("\n", list("as_label()"), " transforms R objects into a short, human-readable\n", 
#&gt;                 "description. You can use labels to:\n", list(
#&gt;                   "\n", list(), " Display an object in a concise way, for example to labellise axes\n", 
#&gt;                   "in a graphical plot.\n", list(), " Give default names to columns in a data frame. In this case,\n", 
#&gt;                   "labelling is the first step before name repair.\n"), 
#&gt;                 "\n", "\n", "See also ", list(list("as_name()")), 
#&gt;                 " for transforming symbols back to a\n", "string. Unlike ", 
#&gt;                 list("as_label()"), ", ", list("as_string()"), 
#&gt;                 " is a well defined\n", "operation that guarantees the roundtrip symbol -&gt; string -&gt;\n", 
#&gt;                 "symbol.\n", "\n", "In general, if you don't know for sure what kind of object you're\n", 
#&gt;                 "dealing with (a call, a symbol, an unquoted constant), use\n", 
#&gt;                 list("as_label()"), " and make no assumption about the resulting string. If\n", 
#&gt;                 "you know you have a symbol and need the name of the object it\n", 
#&gt;                 "refers to, use ", list(list("as_string()")), 
#&gt;                 ". For instance, use ", list("as_label()"), " with\n", 
#&gt;                 "objects captured with ", list("enquo()"), " and ", 
#&gt;                 list("as_string()"), " with symbols\n", "captured with ", 
#&gt;                 list("ensym()"), ".\n"), "\n", list(list("Transformation to string"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Quosures are ", 
#&gt;                   list("squashed"), " before being labelled.\n", 
#&gt;                   list(), " Symbols are transformed to string with ", 
#&gt;                   list("as_string()"), ".\n", list(), " Calls are abbreviated.\n", 
#&gt;                   list(), " Numbers are represented as such.\n", 
#&gt;                   list(), " Other constants are represented by their type, such as ", 
#&gt;                   list("&lt;dbl&gt;"), "\n", "or ", list("&lt;data.frame&gt;"), 
#&gt;                   ".\n"), "\n", "\n", "Note that simple symbols should generally be transformed to strings\n", 
#&gt;                   "with ", list(list("as_name()")), ". Labelling is not a well defined operation and\n", 
#&gt;                   "no assumption should be made about how the label is created. On the\n", 
#&gt;                   "other hand, ", list("as_name()"), " only works with symbols and is a well\n", 
#&gt;                   "defined, deterministic operation.\n")), "\n", 
#&gt;             "\n", list("\n", "# as_label() is useful with quoted expressions:\n", 
#&gt;                 "as_label(expr(foo(bar)))\n", "as_label(expr(foobar))\n", 
#&gt;                 "\n", "# It works with any R object. This is also useful for quoted\n", 
#&gt;                 "# arguments because the user might unquote constant objects:\n", 
#&gt;                 "as_label(1:3)\n", "as_label(base::list)\n"), 
#&gt;             "\n", list("\n", list(list("as_name()")), " for transforming symbols back to a string\n", 
#&gt;                 "deterministically.\n"), "\n"), as_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/deparse.R", "\n", 
#&gt;             list("as_name"), "\n", list("as_name"), "\n", list(
#&gt;                 "Extract names from symbols"), "\n", list("\n", 
#&gt;                 "as_name(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("A string or symbol, possibly wrapped in a ", 
#&gt;                   list("quosure"), ".\n", "If a string, the attributes are removed, if any.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of length 1.\n"), 
#&gt;             "\n", list("\n", list("as_name()"), " converts ", 
#&gt;                 list("symbols"), " to character strings. The\n", 
#&gt;                 "conversion is deterministic. That is, the roundtrip symbol -&gt; name\n", 
#&gt;                 "-&gt; symbol always gets the same result.\n", list(
#&gt;                   "\n", list(), " Use ", list("as_name()"), " when you need to transform a symbol to a string\n", 
#&gt;                   "to ", list("refer"), " to an object by its name.\n", 
#&gt;                   list(), " Use ", list(list("as_label()")), 
#&gt;                   " when you need to transform any kind of object to\n", 
#&gt;                   "a string to ", list("represent"), " that object with a short description.\n"), 
#&gt;                 "\n", "\n", "Expect ", list("as_name()"), " to gain\n", 
#&gt;                 list(list("https://principles.tidyverse.org/names-attribute.html#minimal-unique-universal"), 
#&gt;                   list("name-repairing")), "\n", "features in the future.\n", 
#&gt;                 "\n", "Note that ", list("rlang::as_name()"), 
#&gt;                 " is the ", list("opposite"), " of\n", list(list(
#&gt;                   "base::as.name()")), ". If you're writing base R code, we recommend\n", 
#&gt;                 "using ", list(list("base::as.symbol()")), " which is an alias of ", 
#&gt;                 list("as.name()"), " that\n", "follows a more modern terminology (R types instead of S modes).\n"), 
#&gt;             "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_name() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_name(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_name(bar))\n", "\n", "# as_name() unwraps quosured symbols automatically:\n", 
#&gt;                 "as_name(quo(foo))\n"), "\n", list("\n", list(
#&gt;                 list("as_label()")), " for converting any object to a single string\n", 
#&gt;                 "suitable as a label. ", list(list("as_string()")), 
#&gt;                 " for a lower-level version that\n", "doesn't unwrap quosures.\n"), 
#&gt;             "\n"), as_overscope.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("as_overscope"), "\n", list("as_overscope"), 
#&gt;             "\n", list("new_overscope"), "\n", list("overscope_clean"), 
#&gt;             "\n", list("Create an overscope"), "\n", list("\n", 
#&gt;                 "as_overscope(quo, data = NULL)\n", "\n", "new_overscope(bottom, top = NULL, enclosure = NULL)\n", 
#&gt;                 "\n", "overscope_clean(overscope)\n"), "\n", 
#&gt;             list("\n", list(list("quo"), list("A ", list("quosure"), 
#&gt;                 ".")), "\n", "\n", list(list("data"), list("A data frame or named vector of masking data.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The environment containing masking objects if the\n", 
#&gt;                   "data mask is one environment deep. The bottom environment if the\n", 
#&gt;                   "data mask comprises multiple environment.\n", 
#&gt;                   "\n", "If you haven't supplied ", list("top"), 
#&gt;                   ", this ", list("must"), " be an environment\n", 
#&gt;                   "that you own, i.e. that you have created yourself.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The last environment of the data mask. If the data mask\n", 
#&gt;                   "is only one environment deep, ", list("top"), 
#&gt;                   " should be the same as\n", list("bottom"), 
#&gt;                   ".\n", "\n", "This ", list("must"), " be an environment that you own, i.e. that you have\n", 
#&gt;                   "created yourself. The parent of ", list("top"), 
#&gt;                   " will be changed by the tidy\n", "eval engine and should be considered undetermined. Never make\n", 
#&gt;                   "assumption about the parent of ", list("top"), 
#&gt;                   ".")), "\n", "\n", list(list("enclosure"), 
#&gt;                   list("The ", list("parent"), " argument of ", 
#&gt;                     list(list("new_data_mask()")), ".")), "\n", 
#&gt;                 "\n", list(list("overscope"), list("A data mask.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions have been deprecated in rlang 0.2.0. Please use\n", 
#&gt;                 list(list("as_data_mask()")), " and ", list(list(
#&gt;                   "new_data_mask()")), " instead. We no longer\n", 
#&gt;                 "require the mask to be cleaned up so ", list(
#&gt;                   "overscope_clean()"), " does not\n", "have a replacement.\n"), 
#&gt;             "\n", list("internal"), "\n"), as_pairlist.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/node.R", "\n", 
#&gt;             list("as_pairlist"), "\n", list("as_pairlist"), "\n", 
#&gt;             list("Coerce to pairlist"), "\n", list("\n", "as_pairlist(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", "This transforms vector objects to a linked pairlist of nodes. See\n", 
#&gt;                 "the ", list("pairlist"), " type help page.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("as_pairlist()"), " is experimental because we are still figuring out\n", 
#&gt;                 "the naming scheme for pairlists and node-like objects.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), as_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "as_quosure"), "\n", list("as_quosure"), "\n", 
#&gt;             list("new_quosure"), "\n", list("Coerce object to quosure"), 
#&gt;             "\n", list("\n", "as_quosure(x, env = NULL)\n", "\n", 
#&gt;                 "new_quosure(expr, env = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to convert. Either an ", 
#&gt;                 list("expression"), " or a\n", "formula.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which the expression should be\n", 
#&gt;                   "evaluated. Only used for symbols and calls. This should typically\n", 
#&gt;                   "be the environment in which the expression was created.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("The expression wrapped by the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "While ", list("new_quosure()"), 
#&gt;                 " wraps any R object (including expressions,\n", 
#&gt;                 "formulas, or other quosures) into a quosure, ", 
#&gt;                 list("as_quosure()"), "\n", "converts formulas and quosures and does not double-wrap.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("as_quosure()"), " now requires an explicit default environment for\n", 
#&gt;                 "creating quosures from symbols and calls.\n", 
#&gt;                 list(), " ", list("as_quosureish()"), " is deprecated as of rlang 0.2.0. This function\n", 
#&gt;                 "assumes that quosures are formulas which is currently true but\n", 
#&gt;                 "might not be in the future.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "# as_quosure() converts expressions or any R object to a validly\n", 
#&gt;                 "# scoped quosure:\n", "env &lt;- env(var = \"thing\")\n", 
#&gt;                 "as_quosure(quote(var), env)\n", "\n", "\n", 
#&gt;                 "# The environment is ignored for formulas:\n", 
#&gt;                 "as_quosure(~foo, env)\n", "as_quosure(~foo)\n", 
#&gt;                 "\n", "# However you must supply it for symbols and calls:\n", 
#&gt;                 "try(as_quosure(quote(var)))\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), ", ", list(list("is_quosure()")), 
#&gt;                 "\n"), "\n"), as_string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("as_string"), "\n", list("as_string"), "\n", 
#&gt;             list("Cast symbol to string"), "\n", list("\n", "as_string(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or symbol. If a string, the attributes are\n", 
#&gt;                 "removed, if any.")), "\n"), "\n", list("\n", 
#&gt;                 "A character vector of length 1.\n"), "\n", list(
#&gt;                 "\n", list("as_string()"), " converts ", list(
#&gt;                   "symbols"), " to character strings.\n"), "\n", 
#&gt;             list(list("Unicode tags"), list("\n", "\n", "\n", 
#&gt;                 "Unlike ", list(list("base::as.symbol()")), " and ", 
#&gt;                 list(list("base::as.name()")), ", ", list("as_string()"), 
#&gt;                 "\n", "automatically transforms unicode tags such as ", 
#&gt;                 list("\"&lt;U+5E78&gt;\""), " to the\n", "proper UTF-8 character. This is important on Windows because:\n", 
#&gt;                 list("\n", list(), " R on Windows has no UTF-8 support, and uses native encoding instead.\n", 
#&gt;                   list(), " The native encodings do not cover all Unicode characters. For\n", 
#&gt;                   "example, Western encodings do not support CKJ characters.\n", 
#&gt;                   list(), " When a lossy UTF-8 -&gt; native transformation occurs, uncovered\n", 
#&gt;                   "characters are transformed to an ASCII unicode tag like ", 
#&gt;                   list("\"&lt;U+5E78&gt;\""), ".\n", list(), " Symbols are always encoded in native. This means that\n", 
#&gt;                   "transforming the column names of a data frame to symbols might be\n", 
#&gt;                   "a lossy operation.\n", list(), " This operation is very common in the tidyverse because of data\n", 
#&gt;                   "masking APIs like dplyr where data frames are transformed to\n", 
#&gt;                   "environments. While the names of a data frame are stored as a\n", 
#&gt;                   "character vector, the bindings of environments are stored as\n", 
#&gt;                   "symbols.\n"), "\n", "\n", "Because it reencodes the ASCII unicode tags to their UTF-8\n", 
#&gt;                 "representation, the string -&gt; symbol -&gt; string roundtrip is\n", 
#&gt;                 "more stable with ", list("as_string()"), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# Let's create some symbols:\n", 
#&gt;                 "foo &lt;- quote(foo)\n", "bar &lt;- sym(\"bar\")\n", 
#&gt;                 "\n", "# as_string() converts symbols to strings:\n", 
#&gt;                 "foo\n", "as_string(foo)\n", "\n", "typeof(bar)\n", 
#&gt;                 "typeof(as_string(bar))\n"), "\n", list("\n", 
#&gt;                 list(list("as_name()")), " for a higher-level variant of ", 
#&gt;                 list("as_string()"), "\n", "that automatically unwraps quosures.\n"), 
#&gt;             "\n"), as_utf8_character.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("as_utf8_character"), "\n", list("as_utf8_character"), 
#&gt;             "\n", list("Coerce to a character vector and attempt encoding conversion"), 
#&gt;             "\n", list("\n", "as_utf8_character(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("An object to coerce.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Unlike specifying the ", list("encoding"), 
#&gt;                 " argument in ", list("as_string()"), " and\n", 
#&gt;                 list("as_character()"), ", which is only declarative, these functions\n", 
#&gt;                 "actually attempt to convert the encoding of their input. There are\n", 
#&gt;                 "two possible cases:\n", list("\n", list(), " The string is tagged as UTF-8 or latin1, the only two encodings\n", 
#&gt;                   "for which R has specific support. In this case, converting to the\n", 
#&gt;                   "same encoding is a no-op, and converting to native always works\n", 
#&gt;                   "as expected, as long as the native encoding, the one specified by\n", 
#&gt;                   "the ", list("LC_CTYPE"), " locale has support for all characters occurring in\n", 
#&gt;                   "the strings. Unrepresentable characters are serialised as unicode\n", 
#&gt;                   "points: \"&lt;U+xxxx&gt;\".\n", list(), " The string is not tagged. R assumes that it is encoded in the\n", 
#&gt;                   "native encoding. Conversion to native is a no-op, and conversion\n", 
#&gt;                   "to UTF-8 should work as long as the string is actually encoded in\n", 
#&gt;                   "the locale codeset.\n"), "\n", "\n", "When translating to UTF-8, the strings are parsed for serialised\n", 
#&gt;                 "unicode points (e.g. strings looking like \"U+xxxx\") with\n", 
#&gt;                 list(list("chr_unserialise_unicode()")), ". This helps to alleviate the effects of\n", 
#&gt;                 "character-to-symbol-to-character roundtrips on systems with\n", 
#&gt;                 "non-UTF-8 native encoding.\n"), "\n", list("\n", 
#&gt;                 "# Let's create a string marked as UTF-8 (which is guaranteed by the\n", 
#&gt;                 "# Unicode escaping in the string):\n", "utf8 &lt;- \"caf\\uE9\"\n", 
#&gt;                 "Encoding(utf8)\n", "as_bytes(utf8)\n"), "\n", 
#&gt;             list("internal"), "\n"), `bare-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("bare-type-predicates"), "\n", list("bare-type-predicates"), 
#&gt;             "\n", list("is_bare_list"), "\n", list("is_bare_atomic"), 
#&gt;             "\n", list("is_bare_vector"), "\n", list("is_bare_double"), 
#&gt;             "\n", list("is_bare_integer"), "\n", list("is_bare_numeric"), 
#&gt;             "\n", list("is_bare_character"), "\n", list("is_bare_logical"), 
#&gt;             "\n", list("is_bare_raw"), "\n", list("is_bare_string"), 
#&gt;             "\n", list("is_bare_bytes"), "\n", list("Bare type predicates"), 
#&gt;             "\n", list("\n", "is_bare_list(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_atomic(x, n = NULL)\n", "\n", "is_bare_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_double(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_integer(x, n = NULL)\n", "\n", "is_bare_numeric(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_bare_logical(x, n = NULL)\n", "\n", 
#&gt;                 "is_bare_raw(x, n = NULL)\n", "\n", "is_bare_string(x, n = NULL)\n", 
#&gt;                 "\n", "is_bare_bytes(x, n = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check for a given type but only return ", 
#&gt;                 list("TRUE"), " for\n", "bare R objects. Bare objects have no class attributes. For example,\n", 
#&gt;                 "a data frame is a list, but not a bare list.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " The predicates for vectors include the ", 
#&gt;                 list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                 list(), " Like ", list(list("is_atomic()")), 
#&gt;                 " and unlike base R ", list("is.atomic()"), ",\n", 
#&gt;                 list("is_bare_atomic()"), " does not return ", 
#&gt;                 list("TRUE"), " for ", list("NULL"), ".\n", list(), 
#&gt;                 " Unlike base R ", list("is.numeric()"), ", ", 
#&gt;                 list("is_bare_double()"), " only returns\n", 
#&gt;                 list("TRUE"), " for floating point numbers.\n"), 
#&gt;                 "\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("scalar-type-predicates"), "\n"), 
#&gt;             "\n"), box.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("box"), "\n", list("box"), "\n", list("new_box"), 
#&gt;             "\n", list("is_box"), "\n", list("unbox"), "\n", 
#&gt;             list("Box a value"), "\n", list("\n", "new_box(.x, class = NULL, ...)\n", 
#&gt;                 "\n", "is_box(x, class = NULL)\n", "\n", "unbox(box)\n"), 
#&gt;             "\n", list("\n", list(list("class"), list("For ", 
#&gt;                 list("new_box()"), ", an additional class for the\n", 
#&gt;                 "boxed value (in addition to ", list("rlang_box"), 
#&gt;                 "). For ", list("is_box()"), ", a class\n", "or vector of classes passed to ", 
#&gt;                 list(list("inherits_all()")), ".")), "\n", "\n", 
#&gt;                 list(list("..."), list("Additional attributes passed to ", 
#&gt;                   list(list("base::structure()")), ".")), "\n", 
#&gt;                 "\n", list(list("x, .x"), list("An R object.")), 
#&gt;                 "\n", "\n", list(list("box"), list("A boxed value to unbox.")), 
#&gt;                 "\n"), "\n", list("\n", list("new_box()"), " is similar to ", 
#&gt;                 list(list("base::I()")), " but it protects a value by\n", 
#&gt;                 "wrapping it in a scalar list rather than by adding an attribute.\n", 
#&gt;                 list("unbox()"), " retrieves the boxed value. ", 
#&gt;                 list("is_box()"), " tests whether an\n", "object is boxed with optional class. ", 
#&gt;                 list("as_box()"), " ensures that a\n", "value is wrapped in a box. ", 
#&gt;                 list("as_box_if()"), " does the same but only if\n", 
#&gt;                 "the value matches a predicate.\n"), "\n", list(
#&gt;                 "\n", "boxed &lt;- new_box(letters, \"mybox\")\n", 
#&gt;                 "is_box(boxed)\n", "is_box(boxed, \"mybox\")\n", 
#&gt;                 "is_box(boxed, \"otherbox\")\n", "\n", "unbox(boxed)\n", 
#&gt;                 "\n", "# as_box() avoids double-boxing:\n", "boxed2 &lt;- as_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed2\n", "unbox(boxed2)\n", "\n", "# Compare to:\n", 
#&gt;                 "boxed_boxed &lt;- new_box(boxed, \"mybox\")\n", 
#&gt;                 "boxed_boxed\n", "unbox(unbox(boxed_boxed))\n", 
#&gt;                 "\n", "# Use `as_box_if()` with a predicate if you need to ensure a box\n", 
#&gt;                 "# only for a subset of values:\n", "as_box_if(NULL, is_null, \"null_box\")\n", 
#&gt;                 "as_box_if(\"foo\", is_null, \"null_box\")\n"), 
#&gt;             "\n"), call2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call2"), "\n", list("call2"), "\n", list(
#&gt;                 "Create a call"), "\n", list("\n", "call2(.fn, ..., .ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Quoted function calls are one of the two types of\n", 
#&gt;                 list("symbolic"), " objects in R. They represent the action of\n", 
#&gt;                 "calling a function, possibly with arguments. There are two ways of\n", 
#&gt;                 "creating a quoted call:\n", list("\n", list(), 
#&gt;                   " By ", list("quoting"), " it. Quoting prevents functions from being\n", 
#&gt;                   "called. Instead, you get the description of the function call as\n", 
#&gt;                   "an R object. That is, a quoted function call.\n", 
#&gt;                   list(), " By constructing it with ", list(list(
#&gt;                     "base::call()")), ", ", list(list("base::as.call()")), 
#&gt;                   ", or\n", list("call2()"), ". In this case, you pass the call elements (the function\n", 
#&gt;                   "to call and the arguments to call it with) separately.\n"), 
#&gt;                 "\n", "\n", "See section below for the difference between ", 
#&gt;                 list("call2()"), " and the base\n", "constructors.\n"), 
#&gt;             "\n", list(list("Difference with base constructors"), 
#&gt;                 list("\n", "\n", "\n", list("call2()"), " is more flexible and convenient than ", 
#&gt;                   list("base::call()"), ":\n", list("\n", list(), 
#&gt;                     " The function to call can be a string or a ", 
#&gt;                     list("callable"), "\n", "object: a symbol, another call (e.g. a ", 
#&gt;                     list("$"), " or ", list("[["), " call), or a\n", 
#&gt;                     "function to inline. ", list("base::call()"), 
#&gt;                     " only supports strings and you\n", "need to use ", 
#&gt;                     list("base::as.call()"), " to construct a call with a callable\n", 
#&gt;                     "object.", list("call2(list, 1, 2)\n", "\n", 
#&gt;                       "as.call(list(list, 1, 2))\n"), "\n", list(), 
#&gt;                     " The ", list(".ns"), " argument is convenient for creating namespaced calls.", 
#&gt;                     list("call2(\"list\", 1, 2, .ns = \"base\")\n", 
#&gt;                       "\n", "ns_call &lt;- as.call(list(as.name(\"::\"), as.name(\"list\"), as.name(\"base\")))\n", 
#&gt;                       "as.call(list(ns_call, 1, 2))\n"), "\n", 
#&gt;                     list(), " ", list("call2()"), " has ", list(
#&gt;                       "tidy dots"), " support and you can splice lists\n", 
#&gt;                     "of arguments with ", list("!!!"), ". With base R, you need to use ", 
#&gt;                     list("as.call()"), "\n", "instead of ", list(
#&gt;                       "call()"), " if the arguments are in a list.", 
#&gt;                     list("args &lt;- list(na.rm = TRUE, trim = 0)\n", 
#&gt;                       "\n", "call2(\"mean\", 1:10, !!!args)\n", 
#&gt;                       "\n", "as.call(c(list(as.name(\"mean\"), 1:10), args))\n"), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "In rlang 0.2.0 ", list(
#&gt;                   "lang()"), " was soft-deprecated and renamed to\n", 
#&gt;                   list("call2()"), ".\n", "\n", "In early versions of rlang calls were called \"language\" objects in\n", 
#&gt;                   "order to follow the R type nomenclature as returned by\n", 
#&gt;                   list(list("base::typeof()")), ". The goal was to avoid adding to the confusion\n", 
#&gt;                   "between S modes and R types. With hindsight we find it is better to\n", 
#&gt;                   "use more meaningful type names.\n")), "\n", 
#&gt;             "\n", list("\n", "# fn can either be a string, a symbol or a call\n", 
#&gt;                 "call2(\"f\", a = 1)\n", "call2(quote(f), a = 1)\n", 
#&gt;                 "call2(quote(f()), a = 1)\n", "\n", "#' Can supply arguments individually or in a list\n", 
#&gt;                 "call2(quote(f), a = 1, b = 2)\n", "call2(quote(f), !!!list(a = 1, b = 2))\n", 
#&gt;                 "\n", "# Creating namespaced calls is easy:\n", 
#&gt;                 "call2(\"fun\", arg = quote(baz), .ns = \"mypkg\")\n", 
#&gt;                 "\n", "# Empty arguments are preserved:\n", "call2(\"[\", quote(x), , drop = )\n"), 
#&gt;             "\n", list("\n", "call_modify\n"), "\n"), call_args.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_args"), "\n", list("call_args"), "\n", 
#&gt;             list("call_args_names"), "\n", list("Extract arguments from a call"), 
#&gt;             "\n", list("\n", "call_args(call)\n", "\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A named list of arguments.\n"), 
#&gt;             "\n", list("\n", "Extract arguments from a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_args()"), " and ", 
#&gt;                 list("lang_args_names()"), " were\n", "deprecated and renamed to ", 
#&gt;                 list("call_args()"), " and ", list("call_args_names()"), 
#&gt;                 ".\n", "See lifecycle section in ", list(list(
#&gt;                   "call2()")), " for more about this change.\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(f(a, b))\n", 
#&gt;                 "\n", "# Subsetting a call returns the arguments converted to a language\n", 
#&gt;                 "# object:\n", "call[-1]\n", "\n", "# On the other hand, call_args() returns a regular list that is\n", 
#&gt;                 "# often easier to work with:\n", "str(call_args(call))\n", 
#&gt;                 "\n", "# When the arguments are unnamed, a vector of empty strings is\n", 
#&gt;                 "# supplied (rather than NULL):\n", "call_args_names(call)\n"), 
#&gt;             "\n", list("\n", list(list("fn_fmls()")), " and ", 
#&gt;                 list(list("fn_fmls_names()")), "\n"), "\n"), 
#&gt;         call_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_fn"), "\n", list("call_fn"), "\n", 
#&gt;             list("Extract function from a call"), "\n", list(
#&gt;                 "\n", "call_fn(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "If a frame or formula, the function will be retrieved from the\n", 
#&gt;                 "associated environment. Otherwise, it is looked up in the calling\n", 
#&gt;                 "frame.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", "In rlang 0.2.0, ", list("lang_fn()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_fn()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about this\n", "change.\n")), "\n", 
#&gt;             "\n", list("\n", "# Extract from a quoted call:\n", 
#&gt;                 "call_fn(quote(matrix()))\n", "call_fn(quo(matrix()))\n", 
#&gt;                 "\n", "# Extract the calling function\n", "test &lt;- function() call_fn(call_frame())\n", 
#&gt;                 "test()\n"), "\n", list("\n", list(list("call_name()")), 
#&gt;                 "\n"), "\n"), call_inspect.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("call_inspect"), "\n", list("call_inspect"), 
#&gt;             "\n", list("Inspect a call"), "\n", list("\n", "call_inspect(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Arguments to display in the returned call.")), 
#&gt;                 "\n"), "\n", list("\n", "This function is useful for quick testing and debugging when you\n", 
#&gt;                 "manipulate expressions and calls. It lets you check that a function\n", 
#&gt;                 "is called with the right arguments. This can be useful in unit\n", 
#&gt;                 "tests for instance. Note that this is just a simple wrapper around\n", 
#&gt;                 list(list("base::match.call()")), ".\n"), "\n", 
#&gt;             list("\n", "call_inspect(foo(bar), \"\" %&gt;% identity())\n"), 
#&gt;             "\n"), call_modify.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_modify"), "\n", list("call_modify"), 
#&gt;             "\n", list("Modify the arguments of a call"), "\n", 
#&gt;             list("\n", "call_modify(.call, ..., .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),\n", 
#&gt;                 "  .standardise = NULL, .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".call"), list("Can be a call, a formula quoting a call in the\n", 
#&gt;                 "right-hand side, or a frame object from which to extract the call\n", 
#&gt;                 "expression.")), "\n", "\n", list(list("..."), 
#&gt;                 list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                 list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".standardise, .env"), 
#&gt;                   list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n"), "\n", list("\n", "A quosure if ", 
#&gt;                 list(".call"), " is a quosure, a call otherwise.\n"), 
#&gt;             "\n", list("\n", "If you are working with a user-supplied call, make sure the\n", 
#&gt;                 "arguments are standardised with ", list(list(
#&gt;                   "call_standardise()")), " before\n", "modifying the call.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " The ", list(".standardise"), 
#&gt;                 " argument is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " In rlang 0.2.0, ", list("lang_modify()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_modify()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more about\n", "this change.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "call &lt;- quote(mean(x, na.rm = TRUE))\n", 
#&gt;                 "\n", "# Modify an existing argument\n", "call_modify(call, na.rm = FALSE)\n", 
#&gt;                 "call_modify(call, x = quote(y))\n", "\n", "# Remove an argument\n", 
#&gt;                 "call_modify(call, na.rm = zap())\n", "\n", "# Add a new argument\n", 
#&gt;                 "call_modify(call, trim = 0.1)\n", "\n", "# Add an explicit missing argument:\n", 
#&gt;                 "call_modify(call, na.rm = )\n", "\n", "# Supply a list of new arguments with `!!!`\n", 
#&gt;                 "newargs &lt;- list(na.rm = NULL, trim = 0.1)\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "# Remove multiple arguments by splicing zaps:\n", 
#&gt;                 "newargs &lt;- rep_named(c(\"na.rm\", \"trim\"), list(zap()))\n", 
#&gt;                 "call &lt;- call_modify(call, !!!newargs)\n", "call\n", 
#&gt;                 "\n", "\n", "# Modify the `...` arguments as if it were a named argument:\n", 
#&gt;                 "call &lt;- call_modify(call, ... = )\n", "call\n", 
#&gt;                 "\n", "call &lt;- call_modify(call, ... = zap())\n", 
#&gt;                 "call\n", "\n", "\n", "# When you're working with a user-supplied call, standardise it\n", 
#&gt;                 "# beforehand because it might contain unmatched arguments:\n", 
#&gt;                 "user_call &lt;- quote(matrix(x, nc = 3))\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "# Standardising applies the usual argument matching rules:\n", 
#&gt;                 "user_call &lt;- call_standardise(user_call)\n", 
#&gt;                 "user_call\n", "call_modify(user_call, ncol = 1)\n", 
#&gt;                 "\n", "\n", "# You can also modify quosures inplace:\n", 
#&gt;                 "f &lt;- quo(matrix(bar))\n", "call_modify(f, quote(foo))\n", 
#&gt;                 "\n", "\n", "# By default, arguments with the same name are kept. This has\n", 
#&gt;                 "# subtle implications, for instance you can move an argument to\n", 
#&gt;                 "# last position by removing it and remapping it:\n", 
#&gt;                 "call &lt;- quote(foo(bar = , baz))\n", "call_modify(call, bar = NULL, bar = missing_arg())\n", 
#&gt;                 "\n", "# You can also choose to keep only the first or last homonym\n", 
#&gt;                 "# arguments:\n", "args &lt;-  list(bar = NULL, bar = missing_arg())\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"first\")\n", 
#&gt;                 "call_modify(call, !!!args, .homonyms = \"last\")\n"), 
#&gt;             "\n"), call_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("call_name"), "\n", list("call_name"), 
#&gt;             "\n", list("call_ns"), "\n", list("Extract function name or namespaced of a call"), 
#&gt;             "\n", list("\n", "call_name(call)\n", "\n", "call_ns(call)\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n"), "\n", list("\n", "A string with the function name, or ", 
#&gt;                 list("NULL"), " if the function\n", "is anonymous.\n"), 
#&gt;             "\n", list("\n", "Extract function name or namespaced of a call\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_name()"), " was deprecated and renamed to\n", 
#&gt;                 list("call_name()"), ". See lifecycle section in ", 
#&gt;                 list(list("call2()")), " for more about\n", "this change.\n")), 
#&gt;             "\n", "\n", list("\n", "# Extract the function name from quoted calls:\n", 
#&gt;                 "call_name(quote(foo(bar)))\n", "call_name(quo(foo(bar)))\n", 
#&gt;                 "\n", "# Namespaced calls are correctly handled:\n", 
#&gt;                 "call_name(~base::matrix(baz))\n", "\n", "# Anonymous and subsetted functions return NULL:\n", 
#&gt;                 "call_name(quote(foo$bar()))\n", "call_name(quote(foo[[bar]]()))\n", 
#&gt;                 "call_name(quote(foo()()))\n", "\n", "# Extract namespace of a call with call_ns():\n", 
#&gt;                 "call_ns(quote(base::bar()))\n", "\n", "# If not namespaced, call_ns() returns NULL:\n", 
#&gt;                 "call_ns(quote(bar()))\n"), "\n", list("\n", 
#&gt;                 list(list("call_fn()")), "\n"), "\n"), call_standardise.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("call_standardise"), "\n", list("call_standardise"), 
#&gt;             "\n", list("Standardise a call"), "\n", list("\n", 
#&gt;                 "call_standardise(call, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("Can be a call or a quosure that wraps a call.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment where to find the definition of the\n", 
#&gt;                   "function quoted in ", list("call"), " in case ", 
#&gt;                   list("call"), " is not wrapped in a\n", "quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure if ", list(
#&gt;                 "call"), " is a quosure, a raw call otherwise.\n"), 
#&gt;             "\n", list("\n", "This is essentially equivalent to ", 
#&gt;                 list(list("base::match.call()")), ", but with\n", 
#&gt;                 "experimental handling of primitive functions.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "In rlang 0.2.0, ", list("lang_standardise()"), 
#&gt;                 " was deprecated and renamed to\n", list("call_standardise()"), 
#&gt;                 ". See lifecycle section in ", list(list("call2()")), 
#&gt;                 " for more\n", "about this change.\n")), "\n", 
#&gt;             "\n"), caller_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("caller_env"), "\n", list("caller_env"), 
#&gt;             "\n", list("current_env"), "\n", list("Get the current or caller environment"), 
#&gt;             "\n", list("\n", "caller_env(n = 1)\n", "\n", "current_env()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " The current environment is the execution environment of the\n", 
#&gt;                 "current function (the one currently being evaluated).\n", 
#&gt;                 list(), " The caller environment is the execution environment of the\n", 
#&gt;                 "function that called the current function.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Let's create a function that returns its current environment and\n", 
#&gt;                 "# its caller environment:\n", "fn &lt;- function() list(current = current_env(), caller = caller_env())\n", 
#&gt;                 "\n", "# The current environment is an unique execution environment\n", 
#&gt;                 "# created when `fn()` was called. The caller environment is the\n", 
#&gt;                 "# global env because that's where we called `fn()`.\n", 
#&gt;                 "fn()\n", "\n", "# Let's call `fn()` again but this time within a function:\n", 
#&gt;                 "g &lt;- function() fn()\n", "\n", "# Now the caller environment is also an unique execution environment.\n", 
#&gt;                 "# This is the exec env created by R for our call to g():\n", 
#&gt;                 "g()\n"), "\n", list("\n", list(list("caller_frame()")), 
#&gt;                 " and ", list(list("current_frame()")), "\n"), 
#&gt;             "\n"), caller_fn.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("caller_fn"), "\n", list("caller_fn"), 
#&gt;             "\n", list("current_fn"), "\n", list("Get properties of the current or caller frame"), 
#&gt;             "\n", list("\n", "caller_fn(n = 1)\n", "\n", "current_fn()\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The number of generations to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("\n", list(), " The current frame is the execution context of the function that\n", 
#&gt;                   "is currently being evaluated.\n", list(), 
#&gt;                   " The caller frame is the execution context of the function that\n", 
#&gt;                   "called the function currently being evaluated.\n"), 
#&gt;                 "\n", "\n", "See the ", list("call stack"), " topic for more information.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental.\n")), "\n", 
#&gt;             "\n", list("\n", list(list("caller_env()")), " and ", 
#&gt;                 list(list("current_env()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), caller_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("caller_frame"), "\n", list("caller_frame"), 
#&gt;             "\n", list("Get caller frame"), "\n", list("\n", 
#&gt;                 "caller_frame(n = 1)\n"), "\n", list("\n", list(
#&gt;                 list("n"), list("Number of frames to go back.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), catch_cnd.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("catch_cnd"), "\n", list("catch_cnd"), 
#&gt;             "\n", list("Catch a condition"), "\n", list("\n", 
#&gt;                 "catch_cnd(expr, classes = \"condition\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("Expression to be evaluated with a catching condition\n", 
#&gt;                 "handler.")), "\n", "\n", list(list("classes"), 
#&gt;                 list("A character vector of condition classes to catch. By\n", 
#&gt;                   "default, catches all conditions.")), "\n"), 
#&gt;             "\n", list("\n", "A condition if any was signalled, ", 
#&gt;                 list("NULL"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This is a small wrapper around ", list("tryCatch()"), 
#&gt;                 " that captures any\n", "condition signalled while evaluating its argument. It is useful for\n", 
#&gt;                 "situations where you expect a specific condition to be signalled,\n", 
#&gt;                 "for debugging, and for unit testing.\n"), "\n", 
#&gt;             list("\n", "catch_cnd(10)\n", "catch_cnd(abort(\"an error\"))\n", 
#&gt;                 "catch_cnd(cnd_signal(\"my_condition\", .msg = \"a condition\"))\n"), 
#&gt;             "\n"), chr_unserialise_unicode.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("chr_unserialise_unicode"), "\n", list(
#&gt;                 "chr_unserialise_unicode"), "\n", list("Translate unicode points to UTF-8"), 
#&gt;             "\n", list("\n", "chr_unserialise_unicode(chr)\n"), 
#&gt;             "\n", list("\n", list(list("chr"), list("A character vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "For historical reasons, R translates strings to the native encoding\n", 
#&gt;                 "when they are converted to symbols. This string-to-symbol\n", 
#&gt;                 "conversion is not a rare occurrence and happens for instance to the\n", 
#&gt;                 "names of a list of arguments converted to a call by ", 
#&gt;                 list("do.call()"), ".\n", "\n", "If the string contains unicode characters that cannot be\n", 
#&gt;                 "represented in the native encoding, R serialises those as an ASCII\n", 
#&gt;                 "sequence representing the unicode point. This is why Windows users\n", 
#&gt;                 "with western locales often see strings looking like ", 
#&gt;                 list("&lt;U+xxxx&gt;"), ". To\n", "alleviate some of the pain, rlang parses strings and looks for\n", 
#&gt;                 "serialised unicode points to translate them back to the proper\n", 
#&gt;                 "UTF-8 representation. This transformation occurs automatically in\n", 
#&gt;                 "functions like ", list(list("env_names()")), 
#&gt;                 " and can be manually triggered with\n", list(
#&gt;                   "as_utf8_character()"), " and ", list("chr_unserialise_unicode()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "This function is experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "ascii &lt;- \"&lt;U+5E78&gt;\"\n", 
#&gt;                 "chr_unserialise_unicode(ascii)\n", "\n", "identical(chr_unserialise_unicode(ascii), \"\\u5e78\")\n"), 
#&gt;             "\n", list("internal"), "\n"), cnd.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-error.R, R/cnd.R", 
#&gt;             "\n", list("error_cnd"), "\n", list("error_cnd"), 
#&gt;             "\n", list("cnd"), "\n", list("warning_cnd"), "\n", 
#&gt;             list("message_cnd"), "\n", list("Create a condition object"), 
#&gt;             "\n", list("\n", "error_cnd(.subclass = NULL, ..., message = \"\", trace = NULL,\n", 
#&gt;                 "  parent = NULL)\n", "\n", "cnd(.subclass, ..., message = \"\")\n", 
#&gt;                 "\n", "warning_cnd(.subclass = NULL, ..., message = \"\")\n", 
#&gt;                 "\n", "message_cnd(.subclass = NULL, ..., message = \"\")\n"), 
#&gt;             "\n", list("\n", list(list(".subclass"), list("The condition subclass.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named data fields stored inside the condition\n", 
#&gt;                   "object. These dots are evaluated with ", list(
#&gt;                     "explicit splicing"), ".")), "\n", "\n", 
#&gt;                 list(list("message"), list("A default message to inform the user about the\n", 
#&gt;                   "condition when it is signalled.")), "\n", 
#&gt;                 "\n", list(list("trace"), list("A ", list("trace"), 
#&gt;                   " object created by ", list(list("trace_back()")), 
#&gt;                   ".")), "\n", "\n", list(list("parent"), list(
#&gt;                   "A parent condition object created by ", list(
#&gt;                     list("abort()")), ".")), "\n"), "\n", list(
#&gt;                 "\n", "These constructors make it easy to create subclassed conditions.\n", 
#&gt;                 "Conditions are objects that power the error system in R. They can\n", 
#&gt;                 "also be used for passing messages to pre-established handlers.\n"), 
#&gt;             "\n", list("\n", list("cnd()"), " creates objects inheriting from ", 
#&gt;                 list("condition"), ". Conditions\n", "created with ", 
#&gt;                 list("error_cnd()"), ", ", list("warning_cnd()"), 
#&gt;                 " and ", list("message_cnd()"), "\n", "inherit from ", 
#&gt;                 list("error"), ", ", list("warning"), " or ", 
#&gt;                 list("message"), ".\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "The ", list(".type"), 
#&gt;                   " and ", list(".msg"), " arguments have been renamed to ", 
#&gt;                   list(".subclass"), "\n", "and ", list("message"), 
#&gt;                   ". They are deprecated as of rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "# Create a condition inheriting from the s3 type \"foo\":\n", 
#&gt;                 "cnd &lt;- cnd(\"foo\")\n", "\n", "# Signal the condition to potential handlers. Since this is a bare\n", 
#&gt;                 "# condition the signal has no effect if no handlers are set up:\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# When a relevant handler is set up, the signal causes the handler\n", 
#&gt;                 "# to be called:\n", "with_handlers(cnd_signal(cnd), foo = exiting(function(c) \"caught!\"))\n", 
#&gt;                 "\n", "# Handlers can be thrown or executed inplace. See with_handlers()\n", 
#&gt;                 "# documentation for more on this.\n", "\n", 
#&gt;                 "# Signalling an error condition aborts the current computation:\n", 
#&gt;                 "err &lt;- error_cnd(\"foo\", message = \"I am an error\")\n", 
#&gt;                 "try(cnd_signal(err))\n"), "\n", list("\n", list(
#&gt;                 list("cnd_signal()")), ", ", list(list("with_handlers()")), 
#&gt;                 ".\n"), "\n", list("internal"), "\n"), cnd_message.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-message.R", 
#&gt;             "\n", list("cnd_message"), "\n", list("cnd_message"), 
#&gt;             "\n", list("cnd_issue"), "\n", list("cnd_bullets"), 
#&gt;             "\n", list("format_bullets"), "\n", list("Build an error message from a main issue and bullet messages"), 
#&gt;             "\n", list("\n", "cnd_message(cnd)\n", "\n", "cnd_issue(cnd, ...)\n", 
#&gt;                 "\n", "cnd_bullets(cnd, ...)\n", "\n", "format_bullets(x)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A named character vector of messages. Elements named as\n", 
#&gt;                   list("x"), " or ", list("i"), " are prefixed with the corresponding bullet.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " assembles an error message from two components:\n", 
#&gt;                 list("\n", list(), " The ", list("cnd_issue()"), 
#&gt;                   " generic. Methods should return a single line.\n", 
#&gt;                   list(), " The ", list("cnd_bullets()"), " generic. Methods should return a named vector\n", 
#&gt;                   "of lines. These lines are automatically prefixed with a bullet by\n", 
#&gt;                   list("cnd_message()"), " (see the section on error statements).\n"), 
#&gt;                 "\n", "\n", list("cnd_message()"), " is automatically called by the ", 
#&gt;                 list("conditionMessage()"), "\n", "for rlang errors so that errors thrown with ", 
#&gt;                 list(list("abort()")), " only need to\n", "implement ", 
#&gt;                 list("cnd_issue()"), " and ", list("cnd_bullets()"), 
#&gt;                 ". It can also be called\n", "in custom ", list(
#&gt;                   "conditionMessage()"), " methods.\n", "\n", 
#&gt;                 "Note that if you pass a named character vector to ", 
#&gt;                 list(list("abort()")), ", you\n", "get the same formatting behaviour as ", 
#&gt;                 list("cnd_message()"), ".\n"), "\n", list(list(
#&gt;                 "Error statements"), list("\n", "\n", "\n", "This experimental infrastructure is based on the idea that\n", 
#&gt;                 "sentences in error messages are best kept short and simple. From\n", 
#&gt;                 "this point of view, the best way to present the information is as a\n", 
#&gt;                 "bullet list of simple sentences containing a single clause.\n", 
#&gt;                 list("cnd_message()"), " helps following this structure by building an error\n", 
#&gt;                 "message from two parts: the ", list("issue"), 
#&gt;                 " and the ", list("bullets"), ".\n", "\n", list(
#&gt;                   "cnd_issue()"), " is the generic for the main error message. It should\n", 
#&gt;                 "be as generic as possible, but since it is a generic it is easy to\n", 
#&gt;                 "override by error subclasses.\n", "\n", "The ", 
#&gt;                 list("cnd_bullets()"), " methods should return a character vector of\n", 
#&gt;                 "sentences. These are automatically prefixed with bullets by\n", 
#&gt;                 list("cnd_message()"), ", according to the following scheme:\n", 
#&gt;                 list("\n", list(), " Elements named ", list("\"i\""), 
#&gt;                   " are prefixed with a blue \"info\" symbol.\n", 
#&gt;                   list(), " Elements named ", list("\"x\""), 
#&gt;                   " are prefixed with a red \"cross\" symbol.\n", 
#&gt;                   list(), " Unnamed elements are prefixed with a \"*\" symbol.\n"), 
#&gt;                 "\n", "\n", "While you are free to lay out the bullets in the order that you\n", 
#&gt;                 "like, \"x\" bullets should usually precede \"i\" bullets.\n")), 
#&gt;             "\n", "\n", list(list("Overriding ", list("cnd_bullets()")), 
#&gt;                 list("\n", "\n", "\n", "Sometimes the generation of an error message depends on the state\n", 
#&gt;                   "of the type checking. In that case, it can be tricky to lazily\n", 
#&gt;                   "generate error messages with ", list("cnd_bullets()"), 
#&gt;                   ": you can either\n", "overspecify your error class hierarchies with one class per state,\n", 
#&gt;                   "or replicate the type-checking control flow within the\n", 
#&gt;                   list("cnd_bullets()"), " method. None of these options are ideal.\n", 
#&gt;                   "\n", "A better option is to define a ", list(
#&gt;                     "cnd_bullets"), " field in your error\n", 
#&gt;                   "object. This should be a function (or a lambda-formula which will\n", 
#&gt;                   "be passed to ", list(list("as_function()")), 
#&gt;                   ") with the same signature as\n", list("cnd_bullets()"), 
#&gt;                   " methods. This function overrides the\n", 
#&gt;                   list("cnd_bullets()"), " generic and can generate an error message tailored\n", 
#&gt;                   "to the state in which the error was constructed.\n", 
#&gt;                   "\n", "Note that as a rule, ", list("cnd_issue()"), 
#&gt;                   " should be a general thematic\n", "issues that does not depend on state. For this reason, it isn't\n", 
#&gt;                   "possible to define an overriding method in the condition object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "This infrastructure is experimental. In particular, the output of\n", 
#&gt;                 list("cnd_message()"), " is likely to change in the future and you shouldn't\n", 
#&gt;                 "test it verbatim in a way that makes R CMD check fail. Instead, use\n", 
#&gt;                 list(list("testthat::verify_output()")), " to monitor the output without causing\n", 
#&gt;                 "CRAN check failures when it changes.\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), cnd_muffle.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("cnd_muffle"), "\n", list("cnd_muffle"), 
#&gt;             "\n", list("Muffle a condition"), "\n", list("\n", 
#&gt;                 "cnd_muffle(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition to muffle.")), "\n"), 
#&gt;             "\n", list("\n", "Unlike ", list(list("exiting()")), 
#&gt;                 " handlers, ", list(list("calling()")), " handlers must be explicit\n", 
#&gt;                 "that they have handled a condition to stop it from propagating to\n", 
#&gt;                 "other handlers. Use ", list("cnd_muffle()"), 
#&gt;                 " within a calling handler (or as\n", "a calling handler, see examples) to prevent any other handlers from\n", 
#&gt;                 "being called for that condition.\n"), "\n", 
#&gt;             list(list("Mufflable conditions"), list("\n", "\n", 
#&gt;                 "\n", "Most conditions signalled by base R are muffable, although the name\n", 
#&gt;                 "of the restart varies. cnd_muffle() will automatically call the\n", 
#&gt;                 "correct restart for you. It is compatible with the following\n", 
#&gt;                 "conditions:\n", list("\n", list(), " ", list(
#&gt;                   "warning"), " and ", list("message"), " conditions. In this case ", 
#&gt;                   list("cnd_muffle()"), "\n", "is equivalent to ", 
#&gt;                   list(list("base::suppressMessages()")), " and\n", 
#&gt;                   list(list("base::suppressWarnings()")), ".\n", 
#&gt;                   list(), " Bare conditions signalled with ", 
#&gt;                   list("signal()"), " or ", list(list("cnd_signal()")), 
#&gt;                   ". Note\n", "that conditions signalled with ", 
#&gt;                   list(list("base::signalCondition()")), " are not\n", 
#&gt;                   "mufflable.\n", list(), " Interrupts are sometimes signalled with a ", 
#&gt;                   list("resume"), " restart on\n", "recent R versions. When this is the case, you can muffle the\n", 
#&gt;                   "interrupt with ", list("cnd_muffle()"), ". Check if a restart is available\n", 
#&gt;                   "with ", list("base::findRestart(\"resume\")"), 
#&gt;                   ".\n"), "\n", "\n", "If you call ", list("cnd_muffle()"), 
#&gt;                 " with a condition that is not mufflable\n", 
#&gt;                 "you will cause a new error to be signalled.\n", 
#&gt;                 list("\n", list(), " Errors are not mufflable since they are signalled in critical\n", 
#&gt;                   "situations where execution cannot continue safely.\n", 
#&gt;                   list(), " Conditions captured with ", list(
#&gt;                     list("base::tryCatch()")), ", ", list(list(
#&gt;                     "with_handlers()")), " or\n", list(list("catch_cnd()")), 
#&gt;                   " are no longer mufflable. Muffling restarts ", 
#&gt;                   list("must"), "\n", "be called from a ", list(
#&gt;                     "calling"), " handler.\n"), "\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() {\n", "  inform(\"Beware!\", \"my_particular_msg\")\n", 
#&gt;                 "  inform(\"On your guard!\")\n", "  \"foobar\"\n", 
#&gt;                 "}\n", "\n", "# Let's install a muffling handler for the condition thrown by `fn()`.\n", 
#&gt;                 "# This will suppress all `my_particular_wng` warnings but let other\n", 
#&gt;                 "# types of warnings go through:\n", "with_handlers(fn(),\n", 
#&gt;                 "  my_particular_msg = calling(function(cnd) {\n", 
#&gt;                 "    inform(\"Dealt with this particular message\")\n", 
#&gt;                 "    cnd_muffle(cnd)\n", "  })\n", ")\n", "\n", 
#&gt;                 "# Note how execution of `fn()` continued normally after dealing\n", 
#&gt;                 "# with that particular message.\n", "\n", "# cnd_muffle() can also be passed to with_handlers() as a calling\n", 
#&gt;                 "# handler:\n", "with_handlers(fn(),\n", "  my_particular_msg = calling(cnd_muffle)\n", 
#&gt;                 ")\n"), "\n", list("internal"), "\n"), cnd_signal.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-signal.R", 
#&gt;             "\n", list("cnd_signal"), "\n", list("cnd_signal"), 
#&gt;             "\n", list("Signal a condition object"), "\n", list(
#&gt;                 "\n", "cnd_signal(cnd, .cnd, .mufflable)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("A condition object (see ", 
#&gt;                 list(list("cnd()")), ").")), "\n", "\n", list(
#&gt;                 list(".cnd, .mufflable"), list("These arguments are deprecated.")), 
#&gt;                 "\n"), "\n", list("\n", "The type of signal depends on the class of the condition:\n", 
#&gt;                 list("\n", list(), " A message is signalled if the condition inherits from\n", 
#&gt;                   list("\"message\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("inform()")), " or\n", list(list(
#&gt;                     "base::message()")), ".\n", list(), " A warning is signalled if the condition inherits from\n", 
#&gt;                   list("\"warning\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("warn()")), " or\n", list(list("base::warning()")), 
#&gt;                   ".\n", list(), " An error is signalled if the condition inherits from\n", 
#&gt;                   list("\"error\""), ". This is equivalent to signalling with ", 
#&gt;                   list(list("abort()")), " or\n", list(list("base::stop()")), 
#&gt;                   ".\n", list(), " An interrupt is signalled if the condition inherits from\n", 
#&gt;                   list("\"interrupt\""), ". This is equivalent to signalling with\n", 
#&gt;                   list(list("interrupt()")), ".\n"), "\n", "\n", 
#&gt;                 "Use ", list(list("cnd_type()")), " to determine the type of a condition.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list(".cnd"), " has been renamed to ", 
#&gt;                 list("cnd"), " and is deprecated as of rlang 0.3.0.\n", 
#&gt;                 list(), " The ", list(".mufflable"), " argument is deprecated as of rlang 0.3.0 and no\n", 
#&gt;                 "longer has any effect. Non-critical conditions are always\n", 
#&gt;                 "signalled with a muffle restart.\n", list(), 
#&gt;                 " Creating a condition object with ", list(list(
#&gt;                   "cnd_signal()")), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                 list(list("signal()")), " instead.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# The type of signal depends on the class. If the condition\n", 
#&gt;                 "# inherits from \"warning\", a warning is issued:\n", 
#&gt;                 "cnd &lt;- warning_cnd(\"my_warning_class\", message = \"This is a warning\")\n", 
#&gt;                 "cnd_signal(cnd)\n", "\n", "# If it inherits from \"error\", an error is raised:\n", 
#&gt;                 "cnd &lt;- error_cnd(\"my_error_class\", message = \"This is an error\")\n", 
#&gt;                 "try(cnd_signal(cnd))\n"), "\n", list("\n", list(
#&gt;                 list("abort()")), ", ", list(list("warn()")), 
#&gt;                 " and ", list(list("inform()")), " for creating and\n", 
#&gt;                 "signalling structured R conditions. See ", list(
#&gt;                   list("with_handlers()")), " for\n", "establishing condition handlers.\n"), 
#&gt;             "\n"), cnd_type.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("cnd_type"), "\n", list("cnd_type"), "\n", list(
#&gt;                 "What type is a condition?"), "\n", list("\n", 
#&gt;                 "cnd_type(cnd)\n"), "\n", list("\n", list(list(
#&gt;                 "cnd"), list("A condition object.")), "\n"), 
#&gt;             "\n", list("\n", "A string, either ", list("\"condition\""), 
#&gt;                 ", ", list("\"message\""), ", ", list("\"warning\""), 
#&gt;                 ",\n", list("\"error\""), " or ", list("\"interrupt\""), 
#&gt;                 ".\n"), "\n", list("\n", "Use ", list("cnd_type()"), 
#&gt;                 " to check what type a condition is.\n"), "\n", 
#&gt;             list("\n", "cnd_type(catch_cnd(abort(\"Abort!\")))\n", 
#&gt;                 "cnd_type(catch_cnd(interrupt()))\n"), "\n", 
#&gt;             list("internal"), "\n"), done.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/s3.R", "\n", 
#&gt;             list("done"), "\n", list("done"), "\n", list("is_done_box"), 
#&gt;             "\n", list("Box a final value for early termination"), 
#&gt;             "\n", list("\n", "done(x)\n", "\n", "is_done_box(x, empty = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("For ", list(
#&gt;                 "done()"), ", a value to box. For ", list("is_done_box()"), 
#&gt;                 ", a\n", "value to test.")), "\n", "\n", list(
#&gt;                 list("empty"), list("Whether the box is empty. If ", 
#&gt;                   list("NULL"), ", ", list("is_done_box()"), 
#&gt;                   "\n", "returns ", list("TRUE"), " for all done boxes. If ", 
#&gt;                   list("TRUE"), ", it returns ", list("TRUE"), 
#&gt;                   "\n", "only for empty boxes. Otherwise it returns ", 
#&gt;                   list("TRUE"), " only for\n", "non-empty boxes.")), 
#&gt;                 "\n"), "\n", list("\n", "A ", list("boxed"), 
#&gt;                 " value.\n"), "\n", list("\n", "A value boxed with ", 
#&gt;                 list("done()"), " signals to its caller that it\n", 
#&gt;                 "should stop iterating. Use it to shortcircuit a loop.\n"), 
#&gt;             "\n", list("\n", "done(3)\n", "\n", "x &lt;- done(3)\n", 
#&gt;                 "is_done_box(x)\n"), "\n"), dots_definitions.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_definitions"), "\n", list("dots_definitions"), 
#&gt;             "\n", list("Capture definition objects"), "\n", list(
#&gt;                 "\n", "dots_definitions(..., .named = FALSE, .ignore_empty = c(\"trailing\",\n", 
#&gt;                 "  \"none\", \"all\"))\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("For ", list("enexprs()"), 
#&gt;                   ", ", list("ensyms()"), " and ", list("enquos()"), 
#&gt;                   ", names of\n", "arguments to capture without evaluation (including ", 
#&gt;                   list("..."), "). For\n", list("exprs()"), " and ", 
#&gt;                   list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                   "(including expressions contained in ", list(
#&gt;                     "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n"), "\n", list("\n", "Capture definition objects\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("dots_definitions()"), " is experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("internal"), "\n"), dots_n.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/dots.R", "\n", 
#&gt;             list("dots_n"), "\n", list("dots_n"), "\n", list(
#&gt;                 "How many arguments are currently forwarded in dots?"), 
#&gt;             "\n", list("\n", "dots_n(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Forwarded arguments.")), 
#&gt;                 "\n"), "\n", list("\n", "This returns the number of arguments currently forwarded in ", 
#&gt;                 list("..."), "\n", "as an integer.\n"), "\n", 
#&gt;             list("\n", "fn &lt;- function(...) dots_n(..., baz)\n", 
#&gt;                 "fn(foo, bar)\n"), "\n", list("internal"), "\n"), 
#&gt;         dots_values.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("dots_values"), "\n", list("dots_values"), 
#&gt;             "\n", list("Evaluate dots with preliminary splicing"), 
#&gt;             "\n", list("\n", "dots_values(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("..."), list("Arguments to evaluate and process splicing operators.")), 
#&gt;                 "\n", "\n", list(list(".ignore_empty"), list(
#&gt;                   "Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a tool for advanced users. It captures dots, processes\n", 
#&gt;                 "unquoting and splicing operators, and evaluates them. Unlike\n", 
#&gt;                 list(list("dots_list()")), ", it does not flatten spliced objects, instead they\n", 
#&gt;                 "are attributed a ", list("spliced"), " class (see ", 
#&gt;                 list(list("splice()")), "). You can process\n", 
#&gt;                 "spliced objects manually, perhaps with a custom predicate (see\n", 
#&gt;                 list(list("flatten_if()")), ").\n"), "\n", list(
#&gt;                 "\n", "dots &lt;- dots_values(!!! list(1, 2), 3)\n", 
#&gt;                 "dots\n", "\n", "# Flatten the objects marked as spliced:\n", 
#&gt;                 "flatten_if(dots, is_spliced)\n"), "\n", list(
#&gt;                 "internal"), "\n"), duplicate.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sexp.R", 
#&gt;             "\n", list("duplicate"), "\n", list("duplicate"), 
#&gt;             "\n", list("Duplicate an R object"), "\n", list("\n", 
#&gt;                 "duplicate(x, shallow = FALSE)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("Any R object. However, uncopyable types like symbols and\n", 
#&gt;                   "environments are returned as is (just like with ", 
#&gt;                   list("&lt;-"), ").")), "\n", "\n", list(list("shallow"), 
#&gt;                   list("This is relevant for recursive data structures like\n", 
#&gt;                     "lists, calls and pairlists. A shallow copy only duplicates the\n", 
#&gt;                     "top-level data structure. The objects contained in the list are\n", 
#&gt;                     "still the same.")), "\n"), "\n", list("\n", 
#&gt;                 "In R semantics, objects are copied by value. This means that\n", 
#&gt;                 "modifying the copy leaves the original object intact. Since\n", 
#&gt;                 "copying data in memory is an expensive operation, copies in R are\n", 
#&gt;                 "as lazy as possible. They only happen when the new object is\n", 
#&gt;                 "actually modified. However, some operations (like ", 
#&gt;                 list(list("node_poke_car()")), "\n", "or ", list(
#&gt;                   list("node_poke_cdr()")), ") do not support copy-on-write. In those cases,\n", 
#&gt;                 "it is necessary to duplicate the object manually in order to\n", 
#&gt;                 "preserve copy-by-value semantics.\n"), "\n", 
#&gt;             list("\n", "Some objects are not duplicable, like symbols and environments.\n", 
#&gt;                 list("duplicate()"), " returns its input for these unique objects.\n"), 
#&gt;             "\n", list("\n", "pairlist\n"), "\n", list("internal"), 
#&gt;             "\n"), empty_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("empty_env"), "\n", list("empty_env"), 
#&gt;             "\n", list("Get the empty environment"), "\n", list(
#&gt;                 "\n", "empty_env()\n"), "\n", list("\n", "The empty environment is the only one that does not have a parent.\n", 
#&gt;                 "It is always used as the tail of an environment chain such as the\n", 
#&gt;                 "search path (see ", list(list("search_envs()")), 
#&gt;                 ").\n"), "\n", list("\n", "# Create environments with nothing in scope:\n", 
#&gt;                 "child_env(empty_env())\n"), "\n"), entrace.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("entrace"), "\n", list("entrace"), "\n", 
#&gt;             list("cnd_entrace"), "\n", list("Add backtrace from error handler"), 
#&gt;             "\n", list("\n", "entrace(cnd, ..., top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "cnd_entrace(cnd, ..., top = NULL, bottom = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("cnd"), list("When ", 
#&gt;                 list("entrace()"), " is used as a calling handler, ", 
#&gt;                 list("cnd"), " is\n", "the condition to handle.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Unused. These dots are for future extensions.")), 
#&gt;                 "\n", "\n", list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n"), "\n", 
#&gt;             list("\n", list("entrace()"), " interrupts an error throw to add an ", 
#&gt;                 list("rlang backtrace"), " to the error. The error throw is\n", 
#&gt;                 "immediately resumed. ", list("cnd_entrace()"), 
#&gt;                 " adds a backtrace to a\n", "condition object, without any other effect. Both functions should\n", 
#&gt;                 "be called directly from an error handler.\n", 
#&gt;                 "\n", "Set the ", list("error"), " global option to ", 
#&gt;                 list("quote(rlang::entrace())"), " to\n", "transform base errors to rlang errors. These enriched errors\n", 
#&gt;                 "include a backtrace. The RProfile is a good place to set the\n", 
#&gt;                 "handler. See ", list("rlang_backtrace_on_error"), 
#&gt;                 " for details.\n", "\n", list("entrace()"), " also works as a ", 
#&gt;                 list("calling"), " handler, though it\n", "is often more practical to use the higher-level function\n", 
#&gt;                 list(list("with_abort()")), ".\n"), "\n", list(
#&gt;                 "\n", "if (FALSE) {  # Not run\n", "\n", "# Set the error handler in your RProfile like this:\n", 
#&gt;                 "if (requireNamespace(\"rlang\", quietly = TRUE)) {\n", 
#&gt;                 "  options(error = rlang::entrace)\n", "}\n", 
#&gt;                 "\n", "}\n"), "\n", list("\n", list(list("with_abort()")), 
#&gt;                 " to promote conditions to rlang errors.\n", 
#&gt;                 list(list("cnd_entrace()")), " to manually add a backtrace to a condition.\n"), 
#&gt;             "\n"), env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env"), "\n", list("env"), "\n", list("child_env"), 
#&gt;             "\n", list("new_environment"), "\n", list("Create a new environment"), 
#&gt;             "\n", list("\n", "env(...)\n", "\n", "child_env(.parent, ...)\n", 
#&gt;                 "\n", "new_environment(data = list(), parent = empty_env())\n"), 
#&gt;             "\n", list("\n", list(list("..., data"), list("Named values. You can supply one unnamed to specify\n", 
#&gt;                 "a custom parent, otherwise it defaults to the current\n", 
#&gt;                 "environment. These dots support ", list("tidy dots"), 
#&gt;                 "\n", "features.")), "\n", "\n", list(list(".parent, parent"), 
#&gt;                 list("A parent environment. Can be an object\n", 
#&gt;                   "supported by ", list(list("as_environment()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "These functions create new environments.\n", 
#&gt;                 list("\n", list(), " ", list("env()"), " creates a child of the current environment by default\n", 
#&gt;                   "and takes a variable number of named objects to populate it.\n", 
#&gt;                   list(), " ", list("new_environment()"), " creates a child of the empty environment by\n", 
#&gt;                   "default and takes a named list of objects to populate it.\n"), 
#&gt;                 "\n"), "\n", list(list("Environments as objects"), 
#&gt;                 list("\n", "\n", "\n", "Environments are containers of uniquely named objects. Their most\n", 
#&gt;                   "common use is to provide a scope for the evaluation of R\n", 
#&gt;                   "expressions. Not all languages have first class environments,\n", 
#&gt;                   "i.e. can manipulate scope as regular objects. Reification of scope\n", 
#&gt;                   "is one of the most powerful features of R as it allows you to change\n", 
#&gt;                   "what objects a function or expression sees when it is evaluated.\n", 
#&gt;                   "\n", "Environments also constitute a data structure in their own\n", 
#&gt;                   "right. They are a collection of uniquely named objects, subsettable\n", 
#&gt;                   "by name and modifiable by reference. This latter property (see\n", 
#&gt;                   "section on reference semantics) is especially useful for creating\n", 
#&gt;                   "mutable OO systems (cf the ", list(list("https://github.com/wch/R6"), 
#&gt;                     list("R6 package")), "\n", "and the ", list(
#&gt;                     list("http://ggplot2.tidyverse.org/articles/extending-ggplot2.html"), 
#&gt;                     list("ggproto system")), "\n", "for extending ggplot2).\n")), 
#&gt;             "\n", "\n", list(list("Inheritance"), list("\n", 
#&gt;                 "\n", "\n", "All R environments (except the ", 
#&gt;                 list("empty environment"), ") are\n", "defined with a parent environment. An environment and its\n", 
#&gt;                 "grandparents thus form a linear hierarchy that is the basis for\n", 
#&gt;                 list(list("https://en.wikipedia.org/wiki/Scope_(computer_science)"), 
#&gt;                   list("lexical scoping")), " in\n", "R. When R evaluates an expression, it looks up symbols in a given\n", 
#&gt;                 "environment. If it cannot find these symbols there, it keeps\n", 
#&gt;                 "looking them up in parent environments. This way, objects defined\n", 
#&gt;                 "in child environments have precedence over objects defined in\n", 
#&gt;                 "parent environments.\n", "\n", "The ability of overriding specific definitions is used in the\n", 
#&gt;                 "tidyeval framework to create powerful domain-specific grammars. A\n", 
#&gt;                 "common use of masking is to put data frame columns in scope. See\n", 
#&gt;                 "for example ", list(list("as_data_mask()")), 
#&gt;                 ".\n")), "\n", "\n", list(list("Reference semantics"), 
#&gt;                 list("\n", "\n", "\n", "Unlike regular objects such as vectors, environments are an\n", 
#&gt;                   list("uncopyable"), " object type. This means that if you\n", 
#&gt;                   "have multiple references to a given environment (by assigning the\n", 
#&gt;                   "environment to another symbol with ", list(
#&gt;                     "&lt;-"), " or passing the environment\n", "as argument to a function), modifying the bindings of one of those\n", 
#&gt;                   "references changes all other references as well.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("child_env()"), 
#&gt;                   " is in the questioning stage. It is redundant now\n", 
#&gt;                   "that ", list("env()"), " accepts parent environments.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# env() creates a new environment which has the current environment\n", 
#&gt;                 "# as parent\n", "env &lt;- env(a = 1, b = \"foo\")\n", 
#&gt;                 "env$b\n", "identical(env_parent(env), current_env())\n", 
#&gt;                 "\n", "# Supply one unnamed argument to override the default:\n", 
#&gt;                 "env &lt;- env(base_env(), a = 1, b = \"foo\")\n", 
#&gt;                 "identical(env_parent(env), base_env())\n", "\n", 
#&gt;                 "\n", "# child_env() lets you specify a parent:\n", 
#&gt;                 "child &lt;- child_env(env, c = \"bar\")\n", "identical(env_parent(child), env)\n", 
#&gt;                 "\n", "# This child environment owns `c` but inherits `a` and `b` from `env`:\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "env_has(child, c(\"a\", \"b\", \"c\", \"d\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# `parent` is passed to as_environment() to provide handy\n", 
#&gt;                 "# shortcuts. Pass a string to create a child of a package\n", 
#&gt;                 "# environment:\n", "child_env(\"rlang\")\n", 
#&gt;                 "env_parent(child_env(\"rlang\"))\n", "\n", "# Or `NULL` to create a child of the empty environment:\n", 
#&gt;                 "child_env(NULL)\n", "env_parent(child_env(NULL))\n", 
#&gt;                 "\n", "# The base package environment is often a good default choice for a\n", 
#&gt;                 "# parent environment because it contains all standard base\n", 
#&gt;                 "# functions. Also note that it will never inherit from other loaded\n", 
#&gt;                 "# package environments since R keeps the base package at the tail\n", 
#&gt;                 "# of the search path:\n", "base_child &lt;- child_env(\"base\")\n", 
#&gt;                 "env_has(base_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# On the other hand, a child of the empty environment doesn't even\n", 
#&gt;                 "# see a definition for `(`\n", "empty_child &lt;- child_env(NULL)\n", 
#&gt;                 "env_has(empty_child, c(\"lapply\", \"(\"), inherit = TRUE)\n", 
#&gt;                 "\n", "# Note that all other package environments inherit from base_env()\n", 
#&gt;                 "# as well:\n", "rlang_child &lt;- child_env(\"rlang\")\n", 
#&gt;                 "env_has(rlang_child, \"env\", inherit = TRUE)     # rlang function\n", 
#&gt;                 "env_has(rlang_child, \"lapply\", inherit = TRUE)  # base function\n", 
#&gt;                 "\n", "\n", "# Both env() and child_env() support tidy dots features:\n", 
#&gt;                 "objs &lt;- list(b = \"foo\", c = \"bar\")\n", "env &lt;- env(a = 1, !!! objs)\n", 
#&gt;                 "env$c\n", "\n", "# You can also unquote names with the definition operator `:=`\n", 
#&gt;                 "var &lt;- \"a\"\n", "env &lt;- env(!!var := \"A\")\n", 
#&gt;                 "env$a\n", "\n", "\n", "# Use new_environment() to create containers with the empty\n", 
#&gt;                 "# environment as parent:\n", "env &lt;- new_environment()\n", 
#&gt;                 "env_parent(env)\n", "\n", "# Like other new_ constructors, it takes an object rather than dots:\n", 
#&gt;                 "new_environment(list(a = \"foo\", b = \"bar\"))\n"), 
#&gt;             "\n", list("\n", list(list("env_has()")), ", ", list(
#&gt;                 list("env_bind()")), ".\n"), "\n"), env_bind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bind"), "\n", list("env_bind"), "\n", 
#&gt;             list("env_bind_lazy"), "\n", list("env_bind_active"), 
#&gt;             "\n", list("Bind symbols to objects in an environment"), 
#&gt;             "\n", list("\n", "env_bind(.env, ...)\n", "\n", "env_bind_lazy(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_active(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", "The input object ", 
#&gt;                 list(".env"), ", with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", "These functions create bindings in an environment. The bindings are\n", 
#&gt;                 "supplied through ", list("..."), " as pairs of names and values or expressions.\n", 
#&gt;                 list("env_bind()"), " is equivalent to evaluating a ", 
#&gt;                 list("&lt;-"), " expression within\n", "the given environment. This function should take care of the\n", 
#&gt;                 "majority of use cases but the other variants can be useful for\n", 
#&gt;                 "specific problems.\n", list("\n", list(), " ", 
#&gt;                   list("env_bind()"), " takes named ", list("values"), 
#&gt;                   " which are bound in ", list(".env"), ".\n", 
#&gt;                   list("env_bind()"), " is equivalent to ", list(
#&gt;                     list("base::assign()")), ".\n", list(), " ", 
#&gt;                   list("env_bind_active()"), " takes named ", 
#&gt;                   list("functions"), " and creates active\n", 
#&gt;                   "bindings in ", list(".env"), ". This is equivalent to\n", 
#&gt;                   list(list("base::makeActiveBinding()")), ". An active binding executes a\n", 
#&gt;                   "function each time it is evaluated. The arguments are passed to\n", 
#&gt;                   list(list("as_function()")), " so you can supply formulas instead of functions.\n", 
#&gt;                   "\n", "Remember that functions are scoped in their own environment.\n", 
#&gt;                   "These functions can thus refer to symbols from this enclosure\n", 
#&gt;                   "that are not actually in scope in the dynamic environment where\n", 
#&gt;                   "the active bindings are invoked. This allows creative solutions\n", 
#&gt;                   "to difficult problems (see the implementations of ", 
#&gt;                   list("dplyr::do()"), "\n", "methods for an example).\n", 
#&gt;                   list(), " ", list("env_bind_lazy()"), " takes named ", 
#&gt;                   list("expressions"), ". This is equivalent\n", 
#&gt;                   "to ", list(list("base::delayedAssign()")), 
#&gt;                   ". The arguments are captured with\n", list(
#&gt;                     list("exprs()")), " (and thus support call-splicing and unquoting) and\n", 
#&gt;                   "assigned to symbols in ", list(".env"), ". These expressions are not\n", 
#&gt;                   "evaluated immediately but lazily. Once a symbol is evaluated, the\n", 
#&gt;                   "corresponding expression is evaluated in turn and its value is\n", 
#&gt;                   "bound to the symbol (the expressions are thus evaluated only\n", 
#&gt;                   "once, if at all).\n"), "\n"), "\n", list(list(
#&gt;                 "Side effects"), list("\n", "\n", "\n", "Since environments have reference semantics (see relevant section\n", 
#&gt;                 "in ", list(list("env()")), " documentation), modifying the bindings of an environment\n", 
#&gt;                 "produces effects in all other references to that environment. In\n", 
#&gt;                 "other words, ", list("env_bind()"), " and its variants have side effects.\n", 
#&gt;                 "\n", "Like other side-effecty functions like ", 
#&gt;                 list("par()"), " and ", list("options()"), ",\n", 
#&gt;                 list("env_bind()"), " and variants return the old values invisibly.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 "\n", "Passing an environment wrapper like a formula or a function instead\n", 
#&gt;                 "of an environment is soft-deprecated as of rlang 0.3.0. This\n", 
#&gt;                 "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                 "should now extract the environment separately before calling these\n", 
#&gt;                 "functions.\n")), "\n", "\n", list("\n", "# env_bind() is a programmatic way of assigning values to symbols\n", 
#&gt;                 "# with `&lt;-`. We can add bindings in the current environment:\n", 
#&gt;                 "env_bind(current_env(), foo = \"bar\")\n", "foo\n", 
#&gt;                 "\n", "# Or modify those bindings:\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "env_bind(current_env(), bar = \"BAR\")\n", "bar\n", 
#&gt;                 "\n", "# You can remove bindings by supplying zap sentinels:\n", 
#&gt;                 "env_bind(current_env(), foo = zap())\n", "try(foo)\n", 
#&gt;                 "\n", "# Unquote-splice a named list of zaps\n", 
#&gt;                 "zaps &lt;- rep_named(c(\"foo\", \"bar\"), list(zap()))\n", 
#&gt;                 "env_bind(current_env(), !!!zaps)\n", "try(bar)\n", 
#&gt;                 "\n", "# It is most useful to change other environments:\n", 
#&gt;                 "my_env &lt;- env()\n", "env_bind(my_env, foo = \"foo\")\n", 
#&gt;                 "my_env$foo\n", "\n", "# A useful feature is to splice lists of named values:\n", 
#&gt;                 "vals &lt;- list(a = 10, b = 20)\n", "env_bind(my_env, !!!vals, c = 30)\n", 
#&gt;                 "my_env$b\n", "my_env$c\n", "\n", "# You can also unquote a variable referring to a symbol or a string\n", 
#&gt;                 "# as binding name:\n", "var &lt;- \"baz\"\n", "env_bind(my_env, !!var := \"BAZ\")\n", 
#&gt;                 "my_env$baz\n", "\n", "\n", "# The old values of the bindings are returned invisibly:\n", 
#&gt;                 "old &lt;- env_bind(my_env, a = 1, b = 2, baz = \"baz\")\n", 
#&gt;                 "old\n", "\n", "# You can restore the original environment state by supplying the\n", 
#&gt;                 "# old values back:\n", "env_bind(my_env, !!!old)\n", 
#&gt;                 "\n", "# env_bind_lazy() assigns expressions lazily:\n", 
#&gt;                 "env &lt;- env()\n", "env_bind_lazy(env, name = { cat(\"forced!\\n\"); \"value\" })\n", 
#&gt;                 "\n", "# Referring to the binding will cause evaluation:\n", 
#&gt;                 "env$name\n", "\n", "# But only once, subsequent references yield the final value:\n", 
#&gt;                 "env$name\n", "\n", "# You can unquote expressions:\n", 
#&gt;                 "expr &lt;- quote(message(\"forced!\"))\n", "env_bind_lazy(env, name = !!expr)\n", 
#&gt;                 "env$name\n", "\n", "\n", "# By default the expressions are evaluated in the current\n", 
#&gt;                 "# environment. For instance we can create a local binding and refer\n", 
#&gt;                 "# to it, even though the variable is bound in a different\n", 
#&gt;                 "# environment:\n", "who &lt;- \"mickey\"\n", "env_bind_lazy(env, name = paste(who, \"mouse\"))\n", 
#&gt;                 "env$name\n", "\n", "# You can specify another evaluation environment with `.eval_env`:\n", 
#&gt;                 "eval_env &lt;- env(who = \"minnie\")\n", "env_bind_lazy(env, name = paste(who, \"mouse\"), .eval_env = eval_env)\n", 
#&gt;                 "env$name\n", "\n", "# Or by unquoting a quosure:\n", 
#&gt;                 "quo &lt;- local({\n", "  who &lt;- \"fievel\"\n", 
#&gt;                 "  quo(paste(who, \"mouse\"))\n", "})\n", "env_bind_lazy(env, name = !!quo)\n", 
#&gt;                 "env$name\n", "\n", "# You can create active bindings with env_bind_active(). Active\n", 
#&gt;                 "# bindings execute a function each time they are evaluated:\n", 
#&gt;                 "fn &lt;- function() {\n", "  cat(\"I have been called\\n\")\n", 
#&gt;                 "  rnorm(1)\n", "}\n", "\n", "env &lt;- env()\n", 
#&gt;                 "env_bind_active(env, symbol = fn)\n", "\n", 
#&gt;                 "# `fn` is executed each time `symbol` is evaluated or retrieved:\n", 
#&gt;                 "env$symbol\n", "env$symbol\n", "eval_bare(quote(symbol), env)\n", 
#&gt;                 "eval_bare(quote(symbol), env)\n", "\n", "# All arguments are passed to as_function() so you can use the\n", 
#&gt;                 "# formula shortcut:\n", "env_bind_active(env, foo = ~ runif(1))\n", 
#&gt;                 "env$foo\n", "env$foo\n"), "\n"), env_bind_exprs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("env_bind_exprs"), "\n", list("env_bind_exprs"), 
#&gt;             "\n", list("env_bind_fns"), "\n", list("Bind a promise or active binding"), 
#&gt;             "\n", list("\n", "env_bind_exprs(.env, ..., .eval_env = caller_env())\n", 
#&gt;                 "\n", "env_bind_fns(.env, ...)\n"), "\n", list(
#&gt;                 "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".eval_env"), 
#&gt;                   list("The environment where the expressions will be\n", 
#&gt;                     "evaluated when the symbols are forced.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.3.0, ", list("env_bind_exprs()"), 
#&gt;                 " and ", list("env_bind_fns()"), " have\n", "been renamed to ", 
#&gt;                 list(list("env_bind_lazy()")), " and ", list(
#&gt;                   list("env_bind_active()")), " for\n", "consistency.\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_are_active.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_are_active"), "\n", list(
#&gt;                 "env_binding_are_active"), "\n", list("env_binding_are_lazy"), 
#&gt;             "\n", list("What kind of environment binding?"), 
#&gt;             "\n", list("\n", "env_binding_are_active(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_lazy(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "A logical vector as long as ", list("nms"), 
#&gt;                 " and named after it.\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n"), 
#&gt;             "\n", list("internal"), "\n"), env_binding_lock.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_binding_lock"), "\n", list("env_binding_lock"), 
#&gt;             "\n", list("env_binding_unlock"), "\n", list("env_binding_are_locked"), 
#&gt;             "\n", list("Lock or unlock environment bindings"), 
#&gt;             "\n", list("\n", "env_binding_lock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_unlock(env, nms = NULL)\n", 
#&gt;                 "\n", "env_binding_are_locked(env, nms = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("Names of bindings. Defaults to all bindings in ", 
#&gt;                   list("env"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("env_binding_are_unlocked()"), " returns a logical vector as\n", 
#&gt;                 "long as ", list("nms"), " and named after it. ", 
#&gt;                 list("env_binding_lock()"), " and\n", list("env_binding_unlock()"), 
#&gt;                 " return the old value of\n", list("env_binding_are_unlocked()"), 
#&gt;                 " invisibly.\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environment bindings trigger an error when an attempt is\n", 
#&gt;                 "made to redefine the binding.\n"), "\n", list(
#&gt;                 "\n", "# Bindings are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = \"A\", b = \"B\")\n", "env_binding_are_locked(env)\n", 
#&gt;                 "\n", "# But can optionally be locked:\n", "env_binding_lock(env, \"a\")\n", 
#&gt;                 "env_binding_are_locked(env)\n", "\n", "# If run, the following would now return an error because `a` is locked:\n", 
#&gt;                 "# env_bind(env, a = \"foo\")\n", "# with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "\n", "# Let's unlock it. Note that the return value indicate which\n", 
#&gt;                 "# bindings were locked:\n", "were_locked &lt;- env_binding_unlock(env)\n", 
#&gt;                 "were_locked\n", "\n", "# Now that it is unlocked we can modify it again:\n", 
#&gt;                 "env_bind(env, a = \"foo\")\n", "with_env(env, a &lt;- \"bar\")\n", 
#&gt;                 "env$a\n"), "\n", list("\n", list(list("env_lock()")), 
#&gt;                 " for locking an environment.\n"), "\n", list(
#&gt;                 "internal"), "\n"), env_bury.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_bury"), "\n", list("env_bury"), "\n", 
#&gt;             list("Mask bindings by defining symbols deeper in a scope"), 
#&gt;             "\n", list("\n", "env_bury(.env, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Pairs of names and expressions, values or functions.\n", 
#&gt;                   "Pass ", list(list("zap()")), " objects to remove bindings.\n", 
#&gt;                   "\n", "These dots support ", list("tidy dots"), 
#&gt;                   " features.")), "\n"), "\n", list("\n", "A copy of ", 
#&gt;                 list(".env"), " enclosing the new environment containing\n", 
#&gt;                 "bindings to ", list("..."), " arguments.\n"), 
#&gt;             "\n", list("\n", list("env_bury()"), " is like ", 
#&gt;                 list(list("env_bind()")), " but it creates the bindings in a\n", 
#&gt;                 "new child environment. This makes sure the new bindings have\n", 
#&gt;                 "precedence over old ones, without altering existing environments.\n", 
#&gt;                 "Unlike ", list("env_bind()"), ", this function does not have side effects and\n", 
#&gt;                 "returns a new environment (or object wrapping that environment).\n"), 
#&gt;             "\n", list("\n", "orig_env &lt;- env(a = 10)\n", "fn &lt;- set_env(function() a, orig_env)\n", 
#&gt;                 "\n", "# fn() currently sees `a` as the value `10`:\n", 
#&gt;                 "fn()\n", "\n", "# env_bury() will bury the current scope of fn() behind a new\n", 
#&gt;                 "# environment:\n", "fn &lt;- env_bury(fn, a = 1000)\n", 
#&gt;                 "fn()\n", "\n", "# Even though the symbol `a` is still defined deeper in the scope:\n", 
#&gt;                 "orig_env$a\n"), "\n", list("\n", list(list("env_bind()")), 
#&gt;                 ", ", list(list("env_unbind()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), env_clone.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_clone"), "\n", list("env_clone"), "\n", 
#&gt;             list("Clone an environment"), "\n", list("\n", "env_clone(env, parent = env_parent(env))\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("parent"), list("The parent of the cloned environment.")), 
#&gt;                 "\n"), "\n", list("\n", "This creates a new environment containing exactly the same objects,\n", 
#&gt;                 "optionally with a new parent.\n"), "\n", list(
#&gt;                 "\n", "env &lt;- env(!!! mtcars)\n", "clone &lt;- env_clone(env)\n", 
#&gt;                 "identical(env, clone)\n", "identical(env$cyl, clone$cyl)\n"), 
#&gt;             "\n"), env_depth.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_depth"), "\n", list("env_depth"), "\n", 
#&gt;             list("Depth of an environment chain"), "\n", list(
#&gt;                 "\n", "env_depth(env)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n"), 
#&gt;             "\n", list("\n", "An integer.\n"), "\n", list("\n", 
#&gt;                 "This function returns the number of environments between ", 
#&gt;                 list("env"), " and\n", "the ", list("empty environment"), 
#&gt;                 ", including ", list("env"), ". The depth of\n", 
#&gt;                 list("env"), " is also the number of parents of ", 
#&gt;                 list("env"), " (since the empty\n", "environment counts as a parent).\n"), 
#&gt;             "\n", list("\n", "env_depth(empty_env())\n", "env_depth(pkg_env(\"rlang\"))\n"), 
#&gt;             "\n", list("\n", "The section on inheritance in ", 
#&gt;                 list(list("env()")), " documentation.\n"), "\n"), 
#&gt;         env_get.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_get"), "\n", list("env_get"), "\n", 
#&gt;             list("env_get_list"), "\n", list("Get an object in an environment"), 
#&gt;             "\n", list("\n", "env_get(env = caller_env(), nm, default, inherit = FALSE)\n", 
#&gt;                 "\n", "env_get_list(env = caller_env(), nms, default, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nm, nms"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default value in case there is no binding for ", 
#&gt;                   list("nm"), "\n", "in ", list("env"), ".")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "An object if it exists. Otherwise, throws an error.\n"), 
#&gt;             "\n", list("\n", list("env_get()"), " extracts an object from an enviroment ", 
#&gt;                 list("env"), ". By\n", "default, it does not look in the parent environments.\n", 
#&gt;                 list("env_get_list()"), " extracts multiple objects from an environment into\n", 
#&gt;                 "a named list.\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# This throws an error because `foo` is not directly defined in env:\n", 
#&gt;                 "# env_get(env, \"foo\")\n", "\n", "# However `foo` can be fetched in the parent environment:\n", 
#&gt;                 "env_get(env, \"foo\", inherit = TRUE)\n", "\n", 
#&gt;                 "# You can also avoid an error by supplying a default value:\n", 
#&gt;                 "env_get(env, \"foo\", default = \"FOO\")\n"), 
#&gt;             "\n"), env_has.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_has"), "\n", list("env_has"), "\n", 
#&gt;             list("Does an environment have or see bindings?"), 
#&gt;             "\n", list("\n", "env_has(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "A named logical vector as long as ", list("nms"), 
#&gt;                 ".\n"), "\n", list("\n", list("env_has()"), " is a vectorised predicate that queries whether an\n", 
#&gt;                 "environment owns bindings personally (with ", 
#&gt;                 list("inherit"), " set to\n", list("FALSE"), 
#&gt;                 ", the default), or sees them in its own environment or in\n", 
#&gt;                 "any of its parents (with ", list("inherit = TRUE"), 
#&gt;                 ").\n"), "\n", list("\n", "parent &lt;- child_env(NULL, foo = \"foo\")\n", 
#&gt;                 "env &lt;- child_env(parent, bar = \"bar\")\n", 
#&gt;                 "\n", "# env does not own `foo` but sees it in its parent environment:\n", 
#&gt;                 "env_has(env, \"foo\")\n", "env_has(env, \"foo\", inherit = TRUE)\n"), 
#&gt;             "\n"), env_inherits.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_inherits"), "\n", list("env_inherits"), 
#&gt;             "\n", list("Does environment inherit from another environment?"), 
#&gt;             "\n", list("\n", "env_inherits(env, ancestor)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("ancestor"), list("Another environment from which ", 
#&gt;                   list("x"), " might inherit.")), "\n"), "\n", 
#&gt;             list("\n", "This returns ", list("TRUE"), " if ", 
#&gt;                 list("x"), " has ", list("ancestor"), " among its parents.\n"), 
#&gt;             "\n"), env_lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_lock"), "\n", list("env_lock"), "\n", list(
#&gt;                 "env_is_locked"), "\n", list("Lock an environment"), 
#&gt;             "\n", list("\n", "env_lock(env)\n", "\n", "env_is_locked(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "The old value of ", 
#&gt;                 list("env_is_locked()"), " invisibly.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "Locked environments cannot be modified. An important example is\n", 
#&gt;                 "namespace environments which are locked by R when loaded in a\n", 
#&gt;                 "session. Once an environment is locked it normally cannot be\n", 
#&gt;                 "unlocked.\n", "\n", "Note that only the environment as a container is locked, not the\n", 
#&gt;                 "individual bindings. You can't remove or add a binding but you can\n", 
#&gt;                 "still modify the values of existing bindings. See\n", 
#&gt;                 list(list("env_binding_lock()")), " for locking individual bindings.\n"), 
#&gt;             "\n", list("\n", "# New environments are unlocked by default:\n", 
#&gt;                 "env &lt;- env(a = 1)\n", "env_is_locked(env)\n", 
#&gt;                 "\n", "# Use env_lock() to lock them:\n", "env_lock(env)\n", 
#&gt;                 "env_is_locked(env)\n", "\n", "# Now that `env` is locked, it is no longer possible to remove or\n", 
#&gt;                 "# add bindings. If run, the following would fail:\n", 
#&gt;                 "# env_unbind(env, \"a\")\n", "# env_bind(env, b = 2)\n", 
#&gt;                 "\n", "# Note that even though the environment as a container is locked,\n", 
#&gt;                 "# the individual bindings are still unlocked and can be modified:\n", 
#&gt;                 "env$a &lt;- 10\n"), "\n", list("\n", list(list(
#&gt;                 "env_binding_lock()")), "\n"), "\n", list("internal"), 
#&gt;             "\n"), env_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("env_name"), "\n", list("env_name"), "\n", 
#&gt;             list("env_label"), "\n", list("Label of an environment"), 
#&gt;             "\n", list("\n", "env_name(env)\n", "\n", "env_label(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Special environments like the global environment have their own\n", 
#&gt;                 "names. ", list("env_name()"), " returns:\n", 
#&gt;                 list("\n", list(), " \"global\" for the global environment.\n", 
#&gt;                   list(), " \"empty\" for the empty environment.\n", 
#&gt;                   list(), " \"base\" for the base package environment (the last environment on\n", 
#&gt;                   "the search path).\n", list(), " \"namespace:pkg\" if ", 
#&gt;                   list("env"), " is the namespace of the package \"pkg\".\n", 
#&gt;                   list(), " The ", list("name"), " attribute of ", 
#&gt;                   list("env"), " if it exists. This is how the\n", 
#&gt;                   list("package environments"), " and the ", 
#&gt;                   list("imports environments"), " store their names. The name of package\n", 
#&gt;                   "environments is typically \"package:pkg\".\n", 
#&gt;                   list(), " The empty string ", list("\"\""), 
#&gt;                   " otherwise.\n"), "\n", "\n", list("env_label()"), 
#&gt;                 " is exactly like ", list("env_name()"), " but returns the memory\n", 
#&gt;                 "address of anonymous environments as fallback.\n"), 
#&gt;             "\n", list("\n", "# Some environments have specific names:\n", 
#&gt;                 "env_name(global_env())\n", "env_name(ns_env(\"rlang\"))\n", 
#&gt;                 "\n", "# Anonymous environments don't have names but are labelled by their\n", 
#&gt;                 "# address in memory:\n", "env_name(env())\n", 
#&gt;                 "env_label(env())\n"), "\n"), env_names.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_names"), "\n", list("env_names"), 
#&gt;             "\n", list("env_length"), "\n", list("Names and numbers of symbols bound in an environment"), 
#&gt;             "\n", list("\n", "env_names(env)\n", "\n", "env_length(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A character vector of object names.\n"), 
#&gt;             "\n", list("\n", list("env_names()"), " returns object names from an enviroment ", 
#&gt;                 list("env"), " as a\n", "character vector. All names are returned, even those starting with\n", 
#&gt;                 "a dot. ", list("env_length()"), " returns the number of bindings.\n"), 
#&gt;             "\n", list(list("Names of symbols and objects"), 
#&gt;                 list("\n", "\n", "\n", "Technically, objects are bound to symbols rather than strings,\n", 
#&gt;                   "since the R interpreter evaluates symbols (see ", 
#&gt;                   list(list("is_expression()")), " for a\n", 
#&gt;                   "discussion of symbolic objects versus literal objects). However it\n", 
#&gt;                   "is often more convenient to work with strings. In rlang\n", 
#&gt;                   "terminology, the string corresponding to a symbol is called the\n", 
#&gt;                   list("name"), " of the symbol (or by extension the name of an object bound\n", 
#&gt;                   "to a symbol).\n")), "\n", "\n", list(list(
#&gt;                 "Encoding"), list("\n", "\n", "\n", "There are deep encoding issues when you convert a string to symbol\n", 
#&gt;                 "and vice versa. Symbols are ", list("always"), 
#&gt;                 " in the native encoding. If\n", "that encoding (let's say latin1) cannot support some characters,\n", 
#&gt;                 "these characters are serialised to ASCII. That's why you sometimes\n", 
#&gt;                 "see strings looking like ", list("&lt;U+1234&gt;"), 
#&gt;                 ", especially if you're running\n", "Windows (as R doesn't support UTF-8 as native encoding on that\n", 
#&gt;                 "platform).\n", "\n", "To alleviate some of the encoding pain, ", 
#&gt;                 list("env_names()"), " always\n", "returns a UTF-8 character vector (which is fine even on Windows)\n", 
#&gt;                 "with ASCII unicode points translated back to UTF-8.\n")), 
#&gt;             "\n", "\n", list("\n", "env &lt;- env(a = 1, b = 2)\n", 
#&gt;                 "env_names(env)\n"), "\n"), env_parent.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "env_parent"), "\n", list("env_parent"), "\n", 
#&gt;             list("env_tail"), "\n", list("env_parents"), "\n", 
#&gt;             list("Get parent environments"), "\n", list("\n", 
#&gt;                 "env_parent(env = caller_env(), n = 1)\n", "\n", 
#&gt;                 "env_tail(env = caller_env(), last = global_env(), sentinel = NULL)\n", 
#&gt;                 "\n", "env_parents(env = caller_env(), last = global_env())\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of generations to go up.")), 
#&gt;                 "\n", "\n", list(list("last"), list("The environment at which to stop. Defaults to the\n", 
#&gt;                   "global environment. The empty environment is always a stopping\n", 
#&gt;                   "condition so it is safe to leave the default even when taking the\n", 
#&gt;                   "tail or the parents of an environment on the search path.\n", 
#&gt;                   "\n", list("env_tail()"), " returns the environment which has ", 
#&gt;                   list("last"), " as parent\n", "and ", list(
#&gt;                     "env_parents()"), " returns the list of environments up to ", 
#&gt;                   list("last"), ".")), "\n", "\n", list(list(
#&gt;                   "sentinel"), list("This argument is defunct, please use ", 
#&gt;                   list("last"), " instead.")), "\n"), "\n", list(
#&gt;                 "\n", "An environment for ", list("env_parent()"), 
#&gt;                 " and ", list("env_tail()"), ", a list\n", "of environments for ", 
#&gt;                 list("env_parents()"), ".\n"), "\n", list("\n", 
#&gt;                 list("\n", list(), " ", list("env_parent()"), 
#&gt;                   " returns the parent environment of ", list(
#&gt;                     "env"), " if called\n", "with ", list("n = 1"), 
#&gt;                   ", the grandparent with ", list("n = 2"), ", etc.\n", 
#&gt;                   list(), " ", list("env_tail()"), " searches through the parents and returns the one\n", 
#&gt;                   "which has ", list(list("empty_env()")), " as parent.\n", 
#&gt;                   list(), " ", list("env_parents()"), " returns the list of all parents, including the\n", 
#&gt;                   "empty environment. This list is named using ", 
#&gt;                   list(list("env_name()")), ".\n"), "\n", "\n", 
#&gt;                 "See the section on ", list("inheritance"), " in ", 
#&gt;                 list(list("env()")), "'s documentation.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "The ", list("sentinel"), " argument of ", list(
#&gt;                   "env_tail()"), " has been deprecated in\n", 
#&gt;                 "rlang 0.2.0 and renamed to ", list("last"), 
#&gt;                 ". It is defunct as of rlang 0.4.0.\n")), "\n", 
#&gt;             "\n", list("\n", "# Get the parent environment with env_parent():\n", 
#&gt;                 "env_parent(global_env())\n", "\n", "# Or the tail environment with env_tail():\n", 
#&gt;                 "env_tail(global_env())\n", "\n", "# By default, env_parent() returns the parent environment of the\n", 
#&gt;                 "# current evaluation frame. If called at top-level (the global\n", 
#&gt;                 "# frame), the following two expressions are equivalent:\n", 
#&gt;                 "env_parent()\n", "env_parent(base_env())\n", 
#&gt;                 "\n", "# This default is more handy when called within a function. In this\n", 
#&gt;                 "# case, the enclosure environment of the function is returned\n", 
#&gt;                 "# (since it is the parent of the evaluation frame):\n", 
#&gt;                 "enclos_env &lt;- env()\n", "fn &lt;- set_env(function() env_parent(), enclos_env)\n", 
#&gt;                 "identical(enclos_env, fn())\n"), "\n"), env_poke.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_poke"), "\n", list("env_poke"), "\n", 
#&gt;             list("Poke an object in an environment"), "\n", list(
#&gt;                 "\n", "env_poke(env = caller_env(), nm, value, inherit = FALSE,\n", 
#&gt;                 "  create = !inherit)\n"), "\n", list("\n", list(
#&gt;                 list("env"), list("An environment.")), "\n", 
#&gt;                 "\n", list(list("nm"), list("Names of bindings. ", 
#&gt;                   list("nm"), " must be a single string.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for a new binding.")), 
#&gt;                 "\n", "\n", list(list("inherit"), list("Whether to look for bindings in the parent\n", 
#&gt;                   "environments.")), "\n", "\n", list(list("create"), 
#&gt;                   list("Whether to create a binding if it does not already\n", 
#&gt;                     "exist in the environment.")), "\n"), "\n", 
#&gt;             list("\n", "The old value of ", list("nm"), " or a ", 
#&gt;                 list("zap sentinel"), " if the\n", "binding did not exist yet.\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("env_poke()"), " will assign or reassign a binding in ", 
#&gt;                 list("env"), " if ", list("create"), "\n", "is ", 
#&gt;                 list("TRUE"), ". If ", list("create"), " is ", 
#&gt;                 list("FALSE"), " and a binding does not already\n", 
#&gt;                 "exists, an error is issued.\n"), "\n", list(
#&gt;                 "\n", "If ", list("inherit"), " is ", list("TRUE"), 
#&gt;                 ", the parents environments are checked for\n", 
#&gt;                 "an existing binding to reassign. If not found and ", 
#&gt;                 list("create"), " is\n", list("TRUE"), ", a new binding is created in ", 
#&gt;                 list("env"), ". The default value for\n", list(
#&gt;                   "create"), " is a function of ", list("inherit"), 
#&gt;                 ": ", list("FALSE"), " when inheriting,\n", list(
#&gt;                   "TRUE"), " otherwise.\n", "\n", "This default makes sense because the inheriting case is mostly\n", 
#&gt;                 "for overriding an existing binding. If not found, something\n", 
#&gt;                 "probably went wrong and it is safer to issue an error. Note that\n", 
#&gt;                 "this is different to the base R operator ", 
#&gt;                 list("&lt;&lt;-"), " which will create\n", "a binding in the global environment instead of the current\n", 
#&gt;                 "environment when no existing binding is found in the parents.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 list("env_poke()"), " is experimental. We are still experimenting with\n", 
#&gt;                 "reducing the number of redundant functions by using quasiquotation.\n", 
#&gt;                 "It is possible ", list("env_poke()"), " will be deprecated in favour of\n", 
#&gt;                 list("env_bind()"), " and name-unquoting with ", 
#&gt;                 list(":="), ".\n")), "\n", "\n", list("internal"), 
#&gt;             "\n"), env_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_print"), "\n", list("env_print"), "\n", 
#&gt;             list("Pretty-print an environment"), "\n", list("\n", 
#&gt;                 "env_print(env = caller_env())\n"), "\n", list(
#&gt;                 "\n", list(list("env"), list("An environment, or object that can be converted to an\n", 
#&gt;                   "environment by ", list(list("get_env()")), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This prints:\n", 
#&gt;                 list("\n", list(), " The ", list("label"), " and the parent label.\n", 
#&gt;                   list(), " Whether the environment is ", list(
#&gt;                     "locked"), ".\n", list(), " The bindings in the environment (up to 20 bindings). They are\n", 
#&gt;                   "printed succintly using ", list("pillar::type_sum()"), 
#&gt;                   " (if available,\n", "otherwise uses an internal version of that generic). In addition\n", 
#&gt;                   list("fancy bindings"), " (actives and promises) are\n", 
#&gt;                   "indicated as such.\n", list(), " Locked bindings get a ", 
#&gt;                   list("[L]"), " tag\n"), "\n"), "\n"), env_unbind.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("env_unbind"), "\n", list("env_unbind"), 
#&gt;             "\n", list("Remove bindings from an environment"), 
#&gt;             "\n", list("\n", "env_unbind(env = caller_env(), nms, inherit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("nms"), list("A character vector containing the names of the bindings\n", 
#&gt;                   "to remove.")), "\n", "\n", list(list("inherit"), 
#&gt;                   list("Whether to look for bindings in the parent\n", 
#&gt;                     "environments.")), "\n"), "\n", list("\n", 
#&gt;                 "The input object ", list("env"), " with its associated environment\n", 
#&gt;                 "modified in place, invisibly.\n"), "\n", list(
#&gt;                 "\n", list("env_unbind()"), " is the complement of ", 
#&gt;                 list(list("env_bind()")), ". Like ", list("env_has()"), 
#&gt;                 ",\n", "it ignores the parent environments of ", 
#&gt;                 list("env"), " by default. Set\n", list("inherit"), 
#&gt;                 " to ", list("TRUE"), " to track down bindings in parent environments.\n"), 
#&gt;             "\n", list("\n", "data &lt;- set_names(as.list(letters), letters)\n", 
#&gt;                 "env_bind(environment(), !!! data)\n", "env_has(environment(), letters)\n", 
#&gt;                 "\n", "# env_unbind() removes bindings:\n", "env_unbind(environment(), letters)\n", 
#&gt;                 "env_has(environment(), letters)\n", "\n", "# With inherit = TRUE, it removes bindings in parent environments\n", 
#&gt;                 "# as well:\n", "parent &lt;- child_env(NULL, foo = \"a\")\n", 
#&gt;                 "env &lt;- child_env(parent, foo = \"b\")\n", "env_unbind(env, \"foo\", inherit = TRUE)\n", 
#&gt;                 "env_has(env, \"foo\", inherit = TRUE)\n"), "\n"), 
#&gt;         env_unlock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env.R", "\n", 
#&gt;             list("env_unlock"), "\n", list("env_unlock"), "\n", 
#&gt;             list("Unlock an environment"), "\n", list("\n", "env_unlock(env)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Whether the environment has been unlocked.\n"), 
#&gt;             "\n", list("\n", "This function should only be used in development tools or\n", 
#&gt;                 "interactively.\n"), "\n", list("internal"), 
#&gt;             "\n"), eval_bare.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("eval_bare"), "\n", list("eval_bare"), 
#&gt;             "\n", list("Evaluate an expression in an environment"), 
#&gt;             "\n", list("\n", "eval_bare(expr, env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate the expression.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_bare()"), " is a lower-level version of function ", 
#&gt;                 list(list("base::eval()")), ".\n", "Technically, it is a simple wrapper around the C function\n", 
#&gt;                 list("Rf_eval()"), ". You generally don't need to use ", 
#&gt;                 list("eval_bare()"), " instead\n", "of ", list(
#&gt;                   "eval()"), ". Its main advantage is that it handles stack-sensitive\n", 
#&gt;                 "(calls such as ", list("return()"), ", ", list(
#&gt;                   "on.exit()"), " or ", list("parent.frame()"), 
#&gt;                 ") more\n", "consistently when you pass an enviroment of a frame on the call\n", 
#&gt;                 "stack.\n"), "\n", list("\n", "These semantics are possible because ", 
#&gt;                 list("eval_bare()"), " creates only one\n", "frame on the call stack whereas ", 
#&gt;                 list("eval()"), " creates two frames, the\n", 
#&gt;                 "second of which has the user-supplied environment as frame\n", 
#&gt;                 "environment. When you supply an existing frame environment to\n", 
#&gt;                 list("base::eval()"), " there will be two frames on the stack with the same\n", 
#&gt;                 "frame environment. Stack-sensitive functions only detect the\n", 
#&gt;                 "topmost of these frames. We call these evaluation semantics\n", 
#&gt;                 "\"stack inconsistent\".\n", "\n", "Evaluating expressions in the actual frame environment has useful\n", 
#&gt;                 "practical implications for ", list("eval_bare()"), 
#&gt;                 ":\n", list("\n", list(), " ", list("return()"), 
#&gt;                   " calls are evaluated in frame environments that might\n", 
#&gt;                   "be burried deep in the call stack. This causes a long return that\n", 
#&gt;                   "unwinds multiple frames (triggering the ", 
#&gt;                   list("on.exit()"), " event for\n", "each frame). By contrast ", 
#&gt;                   list("eval()"), " only returns from the ", 
#&gt;                   list("eval()"), "\n", "call, one level up.\n", 
#&gt;                   list(), " ", list("on.exit()"), ", ", list(
#&gt;                     "parent.frame()"), ", ", list("sys.call()"), 
#&gt;                   ", and generally all\n", "the stack inspection functions ", 
#&gt;                   list("sys.xxx()"), " are evaluated in the\n", 
#&gt;                   "correct frame environment. This is similar to how this type of\n", 
#&gt;                   "calls can be evaluated deep in the call stack because of lazy\n", 
#&gt;                   "evaluation, when you force an argument that has been passed\n", 
#&gt;                   "around several times.\n"), "\n", "\n", "The flip side of the semantics of ", 
#&gt;                 list("eval_bare()"), " is that it can't\n", "evaluate ", 
#&gt;                 list("break"), " or ", list("next"), " expressions even if called within a\n", 
#&gt;                 "loop.\n"), "\n", list("\n", "# eval_bare() works just like base::eval() but you have to create\n", 
#&gt;                 "# the evaluation environment yourself:\n", "eval_bare(quote(foo), env(foo = \"bar\"))\n", 
#&gt;                 "\n", "# eval() has different evaluation semantics than eval_bare(). It\n", 
#&gt;                 "# can return from the supplied environment even if its an\n", 
#&gt;                 "# environment that is not on the call stack (i.e. because you've\n", 
#&gt;                 "# created it yourself). The following would trigger an error with\n", 
#&gt;                 "# eval_bare():\n", "ret &lt;- quote(return(\"foo\"))\n", 
#&gt;                 "eval(ret, env())\n", "# eval_bare(ret, env())  # \"no function to return from\" error\n", 
#&gt;                 "\n", "# Another feature of eval() is that you can control surround loops:\n", 
#&gt;                 "bail &lt;- quote(break)\n", "while (TRUE) {\n", 
#&gt;                 "  eval(bail)\n", "  # eval_bare(bail)  # \"no loop for break/next\" error\n", 
#&gt;                 "}\n", "\n", "# To explore the consequences of stack inconsistent semantics, let's\n", 
#&gt;                 "# create a function that evaluates `parent.frame()` deep in the call\n", 
#&gt;                 "# stack, in an environment corresponding to a frame in the middle of\n", 
#&gt;                 "# the stack. For consistency with R's lazy evaluation semantics, we'd\n", 
#&gt;                 "# expect to get the caller of that frame as result:\n", 
#&gt;                 "fn &lt;- function(eval_fn) {\n", "  list(\n", "    returned_env = middle(eval_fn),\n", 
#&gt;                 "    actual_env = current_env()\n", "  )\n", 
#&gt;                 "}\n", "middle &lt;- function(eval_fn) {\n", "  deep(eval_fn, current_env())\n", 
#&gt;                 "}\n", "deep &lt;- function(eval_fn, eval_env) {\n", 
#&gt;                 "  expr &lt;- quote(parent.frame())\n", "  eval_fn(expr, eval_env)\n", 
#&gt;                 "}\n", "\n", "# With eval_bare(), we do get the expected environment:\n", 
#&gt;                 "fn(rlang::eval_bare)\n", "\n", "# But that's not the case with base::eval():\n", 
#&gt;                 "fn(base::eval)\n"), "\n", list("\n", list(list(
#&gt;                 "eval_tidy()")), " for evaluation with data mask and quosure\n", 
#&gt;                 "support.\n"), "\n"), eval_tidy.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("eval_tidy"), "\n", list("eval_tidy"), 
#&gt;             "\n", list("Evaluate an expression with quosures and pronoun support"), 
#&gt;             "\n", list("\n", "eval_tidy(expr, data = NULL, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression or quosure to evaluate.")), 
#&gt;                 "\n", "\n", list(list("data"), list("A data frame, or named list or vector. Alternatively, a\n", 
#&gt;                   "data mask created with ", list(list("as_data_mask()")), 
#&gt;                   " or\n", list(list("new_data_mask()")), ". Objects in ", 
#&gt;                   list("data"), " have priority over those in\n", 
#&gt;                   list("env"), ". See the section about data masking.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which to evaluate ", 
#&gt;                   list("expr"), ". This\n", "environment is not applicable for quosures because they have\n", 
#&gt;                   "their own environments.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", list("eval_tidy()"), " is a variant of ", 
#&gt;                 list(list("base::eval()")), " that powers the tidy\n", 
#&gt;                 "evaluation framework. Like ", list("eval()"), 
#&gt;                 " it accepts user data as\n", "argument. Whereas ", 
#&gt;                 list("eval()"), " simply transforms the data to an\n", 
#&gt;                 "environment, ", list("eval_tidy()"), " transforms it to a ", 
#&gt;                 list("data mask"), " with\n", list(list("as_data_mask()")), 
#&gt;                 ". Evaluating in a data mask enables the following\n", 
#&gt;                 "features:\n", list("\n", list(), " ", list("Quosures"), 
#&gt;                   ". Quosures are expressions bundled with an\n", 
#&gt;                   "environment. If ", list("data"), " is supplied, objects in the data mask\n", 
#&gt;                   "always have precedence over the quosure environment, i.e. the\n", 
#&gt;                   "data masks the environment.\n", list(), " ", 
#&gt;                   list("Pronouns"), ". If ", list("data"), " is supplied, the ", 
#&gt;                   list(".env"), " and ", list(".data"), "\n", 
#&gt;                   "pronouns are installed in the data mask. ", 
#&gt;                   list(".env"), " is a reference to\n", "the calling environment and ", 
#&gt;                   list(".data"), " refers to the ", list("data"), 
#&gt;                   " argument.\n", "These pronouns lets you be explicit about where to find\n", 
#&gt;                   "values and throw errors if you try to access non-existent values.\n"), 
#&gt;                 "\n"), "\n", list(list("Data masking"), list(
#&gt;                 "\n", "\n", "\n", "Data masking refers to how columns or objects inside ", 
#&gt;                 list("data"), " have\n", "priority over objects defined in ", 
#&gt;                 list("env"), " (or in the quosure\n", "environment, if applicable). If there is a column ", 
#&gt;                 list("var"), " in ", list("data"), "\n", "and an object ", 
#&gt;                 list("var"), " in ", list("env"), ", and ", list(
#&gt;                   "expr"), " refers to ", list("var"), ", the\n", 
#&gt;                 "column has priority:", list("var &lt;- \"this one?\"\n", 
#&gt;                   "data &lt;- data.frame(var = rep(\"Or that one?\", 3))\n", 
#&gt;                   "\n", "within &lt;- function(data, expr) {\n", 
#&gt;                   "  eval_tidy(enquo(expr), data)\n", "}\n", 
#&gt;                   "\n", "within(data, toupper(var))\n", "#&gt; [1] \"OR THAT ONE?\" \"OR THAT ONE?\" \"OR THAT ONE?\"\n"), 
#&gt;                 "\n", "\n", "Because the columns or objects in ", 
#&gt;                 list("data"), " are always found first,\n", "before objects from ", 
#&gt;                 list("env"), ", we say that the data \"masks\" the\n", 
#&gt;                 "environment.\n")), "\n", "\n", list(list("When should eval_tidy() be used instead of eval()?"), 
#&gt;                 list("\n", "\n", "\n", list("base::eval()"), 
#&gt;                   " is sufficient for simple evaluation. Use\n", 
#&gt;                   list("eval_tidy()"), " when you'd like to support expressions referring to\n", 
#&gt;                   "the ", list(".data"), " pronoun, or when you need to support quosures.\n", 
#&gt;                   "\n", "If you're evaluating an expression captured with quasiquotation\n", 
#&gt;                   "support, it is recommended to use ", list(
#&gt;                     "eval_tidy()"), " because users will\n", 
#&gt;                   "likely unquote quosures.\n", "\n", "Note that unwrapping a quosure with ", 
#&gt;                   list(list("quo_get_expr()")), " does not\n", 
#&gt;                   "guarantee that there is no quosures inside the expression. Quosures\n", 
#&gt;                   "might be unquoted anywhere. For instance, the following does not\n", 
#&gt;                   "work reliably in the presence of nested quosures:", 
#&gt;                   list("my_quoting_fn &lt;- function(x) {\n", "  x &lt;- enquo(x)\n", 
#&gt;                     "  expr &lt;- quo_get_expr(x)\n", "  env &lt;- quo_get_env(x)\n", 
#&gt;                     "  eval(expr, env)\n", "}\n", "\n", "# Works:\n", 
#&gt;                     "my_quoting_fn(toupper(letters))\n", "\n", 
#&gt;                     "# Fails because of a nested quosure:\n", 
#&gt;                     "my_quoting_fn(toupper(!!quo(letters)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("rlang 0.3.0"), "\n", 
#&gt;                   "\n", "Passing an environment to ", list("data"), 
#&gt;                   " is deprecated. Please construct an\n", "rlang data mask with ", 
#&gt;                   list(list("new_data_mask()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "\n", "# With simple quoted expressions eval_tidy() works the same way as\n", 
#&gt;                 "# eval():\n", "apple &lt;- \"apple\"\n", "kiwi &lt;- \"kiwi\"\n", 
#&gt;                 "expr &lt;- quote(paste(apple, kiwi))\n", "expr\n", 
#&gt;                 "\n", "eval(expr)\n", "eval_tidy(expr)\n", "\n", 
#&gt;                 "# Both accept a data mask as argument:\n", "data &lt;- list(apple = \"CARROT\", kiwi = \"TOMATO\")\n", 
#&gt;                 "eval(expr, data)\n", "eval_tidy(expr, data)\n", 
#&gt;                 "\n", "\n", "# In addition eval_tidy() has support for quosures:\n", 
#&gt;                 "with_data &lt;- function(data, expr) {\n", "  quo &lt;- enquo(expr)\n", 
#&gt;                 "  eval_tidy(quo, data)\n", "}\n", "with_data(NULL, apple)\n", 
#&gt;                 "with_data(data, apple)\n", "with_data(data, list(apple, kiwi))\n", 
#&gt;                 "\n", "# Secondly eval_tidy() installs handy pronouns that allow users to\n", 
#&gt;                 "# be explicit about where to find symbols:\n", 
#&gt;                 "with_data(data, .data$apple)\n", "with_data(data, .env$apple)\n", 
#&gt;                 "\n", "\n", "# Note that instead of using `.env` it is often equivalent and may\n", 
#&gt;                 "# be preferred to unquote a value. There are two differences. First\n", 
#&gt;                 "# unquoting happens earlier, when the quosure is created. Secondly,\n", 
#&gt;                 "# subsetting `.env` with the `$` operator may be brittle because\n", 
#&gt;                 "# `$` does not look through the parents of the environment.\n", 
#&gt;                 "#\n", "# For instance using `.env$name` in a magrittr pipeline is an\n", 
#&gt;                 "# instance where this poses problem, because the magrittr pipe\n", 
#&gt;                 "# currently (as of v1.5.0) evaluates its operands in a *child* of\n", 
#&gt;                 "# the current environment (this child environment is where it\n", 
#&gt;                 "# defines the pronoun `.`).\n", list("\n", "  data %&gt;% with_data(!!kiwi)     # \"kiwi\"\n", 
#&gt;                   "  data %&gt;% with_data(.env$kiwi)  # NULL\n"), 
#&gt;                 "\n"), "\n", list("\n", list("quasiquotation"), 
#&gt;                 " for the second leg of the tidy evaluation\n", 
#&gt;                 "framework.\n"), "\n"), exec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("exec"), "\n", list("exec"), "\n", list(
#&gt;                 "Execute a function"), "\n", list("\n", "exec(.fn, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list(".fn"), list("A function, or function name as a string.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to function.\n", 
#&gt;                   "\n", "These dots support ", list("tidy-dots"), 
#&gt;                   " features.")), "\n", "\n", list(list(".env"), 
#&gt;                   list("Environment in which to evaluate the call. This will be\n", 
#&gt;                     "most useful if ", list("f"), " is a string, or the function has side-effects.")), 
#&gt;                 "\n"), "\n", list("\n", "This function constructs and evaluates a call to ", 
#&gt;                 list(".fn"), ".\n", "It has two primary uses:\n", 
#&gt;                 list("\n", list(), " To call a function with arguments stored in a list (if the function\n", 
#&gt;                   "doesn't support ", list("tidy-dots"), ")\n", 
#&gt;                   list(), " To call every function stored in a list (in conjunction with ", 
#&gt;                   list("map()"), "/\n", list(list("lapply()")), 
#&gt;                   ")\n"), "\n"), "\n", list("\n", "args &lt;- list(x = c(1:10, 100, NA), na.rm = TRUE)\n", 
#&gt;                 "exec(\"mean\", !!!args)\n", "exec(\"mean\", !!!args, trim = 0.2)\n", 
#&gt;                 "\n", "fs &lt;- list(a = function() \"a\", b = function() \"b\")\n", 
#&gt;                 "lapply(fs, exec)\n", "\n", "# Compare to do.call it will not automatically inline expressions\n", 
#&gt;                 "# into the evaluated call.\n", "x &lt;- 10\n", 
#&gt;                 "args &lt;- exprs(x1 = x + 1, x2 = x * 2)\n", "exec(list, !!!args)\n", 
#&gt;                 "do.call(list, args)\n", "\n", "# exec() is not designed to generate pretty function calls. This is\n", 
#&gt;                 "# most easily seen if you call a function that captures the call:\n", 
#&gt;                 "f &lt;- disp ~ cyl\n", "exec(\"lm\", f, data = mtcars)\n", 
#&gt;                 "\n", "# If you need finer control over the generated call, you'll need to\n", 
#&gt;                 "# construct it yourself. This may require creating a new environment\n", 
#&gt;                 "# with carefully constructed bindings\n", "data_env &lt;- env(data = mtcars)\n", 
#&gt;                 "eval(expr(lm(!!f, data)), data_env)\n"), "\n"), 
#&gt;         exiting.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("exiting"), "\n", list("exiting"), "\n", 
#&gt;             list("Exiting handler"), "\n", list("\n", "exiting(handler)\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", list("exiting()"), " is no longer necessary as handlers are exiting by default.\n"), 
#&gt;             "\n", list("internal"), "\n"), expr_interp.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("expr_interp"), "\n", list("expr_interp"), 
#&gt;             "\n", list("Process unquote operators in a captured expression"), 
#&gt;             "\n", list("\n", "expr_interp(x, env = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A function, raw expression, or formula to interpolate.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment in which unquoted expressions should be\n", 
#&gt;                   "evaluated. By default, the formula or closure environment if a\n", 
#&gt;                   "formula or a function, or the current environment otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "While all capturing functions in the tidy evaluation framework\n", 
#&gt;                 "perform unquote on capture (most notably ", 
#&gt;                 list(list("quo()")), "),\n", list("expr_interp()"), 
#&gt;                 " manually processes unquoting operators in\n", 
#&gt;                 "expressions that are already captured. ", list(
#&gt;                   "expr_interp()"), " should be\n", "called in all user-facing functions expecting a formula as argument\n", 
#&gt;                 "to provide the same quasiquotation functionality as NSE functions.\n"), 
#&gt;             "\n", list("\n", "# All tidy NSE functions like quo() unquote on capture:\n", 
#&gt;                 "quo(list(!!(1 + 2)))\n", "\n", "# expr_interp() is meant to provide the same functionality when you\n", 
#&gt;                 "# have a formula or expression that might contain unquoting\n", 
#&gt;                 "# operators:\n", "f &lt;- ~list(!!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "# Note that only the outer formula is unquoted (which is a reason\n", 
#&gt;                 "# to use expr_interp() as early as possible in all user-facing\n", 
#&gt;                 "# functions):\n", "f &lt;- ~list(~!!(1 + 2), !!(1 + 2))\n", 
#&gt;                 "expr_interp(f)\n", "\n", "\n", "# Another purpose for expr_interp() is to interpolate a closure's\n", 
#&gt;                 "# body. This is useful to inline a function within another. The\n", 
#&gt;                 "# important limitation is that all formal arguments of the inlined\n", 
#&gt;                 "# function should be defined in the receiving function:\n", 
#&gt;                 "other_fn &lt;- function(x) toupper(x)\n", "\n", 
#&gt;                 "fn &lt;- expr_interp(function(x) {\n", "  x &lt;- paste0(x, \"_suffix\")\n", 
#&gt;                 "  !!! body(other_fn)\n", "})\n", "fn\n", "fn(\"foo\")\n"), 
#&gt;             "\n"), expr_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_label"), "\n", list("expr_label"), 
#&gt;             "\n", list("expr_name"), "\n", list("expr_text"), 
#&gt;             "\n", list("Turn an expression to a label"), "\n", 
#&gt;             list("\n", "expr_label(expr)\n", "\n", "expr_name(expr)\n", 
#&gt;                 "\n", "expr_text(expr, width = 60L, nlines = Inf)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression to labellise.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("expr_text()"), " turns the expression into a single string, which\n", 
#&gt;                 "might be multi-line. ", list("expr_name()"), 
#&gt;                 " is suitable for formatting\n", "names. It works best with symbols and scalar types, but also\n", 
#&gt;                 "accepts calls. ", list("expr_label()"), " formats the expression nicely for use\n", 
#&gt;                 "in messages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are in the questioning stage because they are\n", 
#&gt;                   "redundant with the ", list("quo_"), " variants and do not handle quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# To labellise a function argument, first capture it with\n", 
#&gt;                 "# substitute():\n", "fn &lt;- function(x) expr_label(substitute(x))\n", 
#&gt;                 "fn(x:y)\n", "\n", "# Strings are encoded\n", 
#&gt;                 "expr_label(\"a\\nb\")\n", "\n", "# Names and expressions are quoted with ``\n", 
#&gt;                 "expr_label(quote(x))\n", "expr_label(quote(a + b + c))\n", 
#&gt;                 "\n", "# Long expressions are collapsed\n", "expr_label(quote(foo({\n", 
#&gt;                 "  1 + 2\n", "  print(x)\n", "})))\n"), "\n"), 
#&gt;         expr_print.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("expr_print"), "\n", list("expr_print"), 
#&gt;             "\n", list("expr_deparse"), "\n", list("Print an expression"), 
#&gt;             "\n", list("\n", "expr_print(x, width = peek_option(\"width\"))\n", 
#&gt;                 "\n", "expr_deparse(x, width = peek_option(\"width\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object or expression to print.")), 
#&gt;                 "\n", "\n", list(list("width"), list("The width of the deparsed or printed expression.\n", 
#&gt;                   "Defaults to the global option ", list("width"), 
#&gt;                   ".")), "\n"), "\n", list("\n", list("expr_print()"), 
#&gt;                 ", powered by ", list("expr_deparse()"), ", is an alternative\n", 
#&gt;                 "printer for R expressions with a few improvements over the base R\n", 
#&gt;                 "printer.\n", list("\n", list(), " It colourises ", 
#&gt;                   list("quosures"), " according to their environment.\n", 
#&gt;                   "Quosures from the global environment are printed normally while\n", 
#&gt;                   "quosures from local environments are printed in unique colour (or\n", 
#&gt;                   "in italic when all colours are taken).\n", 
#&gt;                   list(), " It wraps inlined objects in angular brackets. For instance, an\n", 
#&gt;                   "integer vector unquoted in a function call (e.g.\n", 
#&gt;                   list("expr(foo(!!(1:3)))"), ") is printed like this: ", 
#&gt;                   list("foo(&lt;int: 1L, 2L, 3L&gt;)"), " while by default R prints the code to create that vector:\n", 
#&gt;                   list("foo(1:3)"), " which is ambiguous.\n", 
#&gt;                   list(), " It respects the width boundary (from the global option ", 
#&gt;                   list("width"), ")\n", "in more cases.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# It supports any object. Non-symbolic objects are always printed\n", 
#&gt;                 "# within angular brackets:\n", "expr_print(1:3)\n", 
#&gt;                 "expr_print(function() NULL)\n", "\n", "# Contrast this to how the code to create these objects is printed:\n", 
#&gt;                 "expr_print(quote(1:3))\n", "expr_print(quote(function() NULL))\n", 
#&gt;                 "\n", "# The main cause of non-symbolic objects in expressions is\n", 
#&gt;                 "# quasiquotation:\n", "expr_print(expr(foo(!!(1:3))))\n", 
#&gt;                 "\n", "\n", "# Quosures from the global environment are printed normally:\n", 
#&gt;                 "expr_print(quo(foo))\n", "expr_print(quo(foo(!!quo(bar))))\n", 
#&gt;                 "\n", "# Quosures from local environments are colourised according to\n", 
#&gt;                 "# their environments (if you have crayon installed):\n", 
#&gt;                 "local_quo &lt;- local(quo(foo))\n", "expr_print(local_quo)\n", 
#&gt;                 "\n", "wrapper_quo &lt;- local(quo(bar(!!local_quo, baz)))\n", 
#&gt;                 "expr_print(wrapper_quo)\n"), "\n"), exprs_auto_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quotation.R", "\n", 
#&gt;             list("exprs_auto_name"), "\n", list("exprs_auto_name"), 
#&gt;             "\n", list("quos_auto_name"), "\n", list("Ensure that all elements of a list of expressions are named"), 
#&gt;             "\n", list("\n", "exprs_auto_name(exprs, width = NULL, printer = NULL)\n", 
#&gt;                 "\n", "quos_auto_name(quos, width = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("exprs"), list("A list of expressions.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Deprecated. Maximum width of names.")), 
#&gt;                 "\n", "\n", list(list("printer"), list("Deprecated. A function that takes an expression\n", 
#&gt;                   "and converts it to a string. This function must take an\n", 
#&gt;                   "expression as the first argument and ", list(
#&gt;                     "width"), " as the second\n", "argument.")), 
#&gt;                 "\n", "\n", list(list("quos"), list("A list of quosures.")), 
#&gt;                 "\n"), "\n", list("\n", "This gives default names to unnamed elements of a list of\n", 
#&gt;                 "expressions (or expression wrappers such as formulas or\n", 
#&gt;                 "quosures). ", list("exprs_auto_name()"), " deparses the expressions with\n", 
#&gt;                 list(list("expr_name()")), " by default. ", list(
#&gt;                   "quos_auto_name()"), " deparses with\n", list(
#&gt;                   list("quo_name()")), ".\n"), "\n"), f_rhs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("f_rhs"), "\n", list("f_rhs"), "\n", list("f_rhs&lt;-"), 
#&gt;             "\n", list("f_lhs"), "\n", list("f_lhs&lt;-"), "\n", 
#&gt;             list("f_env"), "\n", list("f_env&lt;-"), "\n", list(
#&gt;                 "Get or set formula components"), "\n", list(
#&gt;                 "\n", "f_rhs(f)\n", "\n", "f_rhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_lhs(f)\n", "\n", "f_lhs(x) &lt;- value\n", 
#&gt;                 "\n", "f_env(f)\n", "\n", "f_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("f, x"), list("A formula")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value to replace with.")), 
#&gt;                 "\n"), "\n", list("\n", list("f_rhs"), " and ", 
#&gt;                 list("f_lhs"), " return language objects (i.e.  atomic\n", 
#&gt;                 "vectors of length 1, a name, or a call). ", 
#&gt;                 list("f_env"), " returns an\n", "environment.\n"), 
#&gt;             "\n", list("\n", list("f_rhs"), " extracts the righthand side, ", 
#&gt;                 list("f_lhs"), " extracts the lefthand\n", "side, and ", 
#&gt;                 list("f_env"), " extracts the environment. All functions throw an\n", 
#&gt;                 "error if ", list("f"), " is not a formula.\n"), 
#&gt;             "\n", list("\n", "f_rhs(~ 1 + 2 + 3)\n", "f_rhs(~ x)\n", 
#&gt;                 "f_rhs(~ \"A\")\n", "f_rhs(1 ~ 2)\n", "\n", "f_lhs(~ y)\n", 
#&gt;                 "f_lhs(x ~ y)\n", "\n", "f_env(~ x)\n"), "\n"), 
#&gt;         f_text.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("f_text"), "\n", list("f_text"), "\n", 
#&gt;             list("f_name"), "\n", list("f_label"), "\n", list(
#&gt;                 "Turn RHS of formula into a string or label"), 
#&gt;             "\n", list("\n", "f_text(x, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "f_name(x)\n", "\n", "f_label(x)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A formula.")), "\n", 
#&gt;                 "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", "Equivalent of ", list(
#&gt;                 list("expr_text()")), " and ", list(list("expr_label()")), 
#&gt;                 " for formulas.\n"), "\n", list("\n", "f &lt;- ~ a + b + bc\n", 
#&gt;                 "f_text(f)\n", "f_label(f)\n", "\n", "# Names a quoted with ``\n", 
#&gt;                 "f_label(~ x)\n", "# Strings are encoded\n", 
#&gt;                 "f_label(~ \"a\\nb\")\n", "# Long expressions are collapsed\n", 
#&gt;                 "f_label(~ foo({\n", "  1 + 2\n", "  print(x)\n", 
#&gt;                 "}))\n"), "\n"), flatten.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-squash.R", 
#&gt;             "\n", list("flatten"), "\n", list("flatten"), "\n", 
#&gt;             list("flatten_lgl"), "\n", list("flatten_int"), "\n", 
#&gt;             list("flatten_dbl"), "\n", list("flatten_cpl"), "\n", 
#&gt;             list("flatten_chr"), "\n", list("flatten_raw"), "\n", 
#&gt;             list("squash"), "\n", list("squash_lgl"), "\n", list(
#&gt;                 "squash_int"), "\n", list("squash_dbl"), "\n", 
#&gt;             list("squash_cpl"), "\n", list("squash_chr"), "\n", 
#&gt;             list("squash_raw"), "\n", list("flatten_if"), "\n", 
#&gt;             list("squash_if"), "\n", list("Flatten or squash a list of lists into a simpler vector"), 
#&gt;             "\n", list("\n", "flatten(x)\n", "\n", "flatten_lgl(x)\n", 
#&gt;                 "\n", "flatten_int(x)\n", "\n", "flatten_dbl(x)\n", 
#&gt;                 "\n", "flatten_cpl(x)\n", "\n", "flatten_chr(x)\n", 
#&gt;                 "\n", "flatten_raw(x)\n", "\n", "squash(x)\n", 
#&gt;                 "\n", "squash_lgl(x)\n", "\n", "squash_int(x)\n", 
#&gt;                 "\n", "squash_dbl(x)\n", "\n", "squash_cpl(x)\n", 
#&gt;                 "\n", "squash_chr(x)\n", "\n", "squash_raw(x)\n", 
#&gt;                 "\n", "flatten_if(x, predicate = is_spliced)\n", 
#&gt;                 "\n", "squash_if(x, predicate = is_spliced)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A list to flatten or squash. The contents of the list can\n", 
#&gt;                 "be anything for unsuffixed functions ", list(
#&gt;                   "flatten()"), " and ", list("squash()"), "\n", 
#&gt;                 "(as a list is returned), but the contents must match the type for\n", 
#&gt;                 "the other functions.")), "\n", "\n", list(list(
#&gt;                 "predicate"), list("A function of one argument returning whether it\n", 
#&gt;                 "should be spliced.")), "\n"), "\n", list("\n", 
#&gt;                 list("flatten()"), " returns a list, ", list(
#&gt;                   "flatten_lgl()"), " a logical\n", "vector, ", 
#&gt;                 list("flatten_int()"), " an integer vector, ", 
#&gt;                 list("flatten_dbl()"), " a\n", "double vector, and ", 
#&gt;                 list("flatten_chr()"), " a character vector. Similarly\n", 
#&gt;                 "for ", list("squash()"), " and the typed variants (", 
#&gt;                 list("squash_lgl()"), " etc).\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("flatten()"), " removes one level hierarchy from a list, while\n", 
#&gt;                 list("squash()"), " removes all levels. These functions are similar to\n", 
#&gt;                 list(list("unlist()")), " but they are type-stable so you always know what the\n", 
#&gt;                 "type of the output is.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "These functions are in the questioning stage. They have slightly\n", 
#&gt;                 "different semantics than the flattening functions in purrr and we\n", 
#&gt;                 "are currently rethinking our approach to flattening with the new\n", 
#&gt;                 "typing facilities of the vctrs package.\n")), 
#&gt;             "\n", "\n", list("\n", "x &lt;- replicate(2, sample(4), simplify = FALSE)\n", 
#&gt;                 "x\n", "\n", "flatten(x)\n", "flatten_int(x)\n", 
#&gt;                 "\n", "# With flatten(), only one level gets removed at a time:\n", 
#&gt;                 "deep &lt;- list(1, list(2, list(3)))\n", "flatten(deep)\n", 
#&gt;                 "flatten(flatten(deep))\n", "\n", "# But squash() removes all levels:\n", 
#&gt;                 "squash(deep)\n", "squash_dbl(deep)\n", "\n", 
#&gt;                 "# The typed flatten functions remove one level and coerce to an atomic\n", 
#&gt;                 "# vector at the same time:\n", "flatten_dbl(list(1, list(2)))\n", 
#&gt;                 "\n", "# Only bare lists are flattened, but you can splice S3 lists\n", 
#&gt;                 "# explicitly:\n", "foo &lt;- set_attrs(list(\"bar\"), class = \"foo\")\n", 
#&gt;                 "str(flatten(list(1, foo, list(100))))\n", "str(flatten(list(1, splice(foo), list(100))))\n", 
#&gt;                 "\n", "# Instead of splicing manually, flatten_if() and squash_if() let\n", 
#&gt;                 "# you specify a predicate function:\n", "is_foo &lt;- function(x) inherits(x, \"foo\") || is_bare_list(x)\n", 
#&gt;                 "str(flatten_if(list(1, foo, list(100)), is_foo))\n", 
#&gt;                 "\n", "# squash_if() does the same with deep lists:\n", 
#&gt;                 "deep_foo &lt;- list(1, list(foo, list(foo, 100)))\n", 
#&gt;                 "str(deep_foo)\n", "\n", "str(squash(deep_foo))\n", 
#&gt;                 "str(squash_if(deep_foo, is_foo))\n"), "\n", 
#&gt;             list("internal"), "\n"), fn_body.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_body"), "\n", list("fn_body"), "\n", list(
#&gt;                 "fn_body&lt;-"), "\n", list("Get or set function body"), 
#&gt;             "\n", list("\n", "fn_body(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_body(fn) &lt;- value\n"), "\n", list("\n", list(
#&gt;                 list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                   "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_body()"), " is a simple wrapper around ", 
#&gt;                 list(list("base::body()")), ". It always\n", 
#&gt;                 "returns a ", list("{"), " expression and throws an error when the input is a\n", 
#&gt;                 "primitive function (whereas ", list("body()"), 
#&gt;                 " returns ", list("NULL"), "). The setter\n", 
#&gt;                 "version preserves attributes, unlike ", list(
#&gt;                   "body&lt;-"), ".\n"), "\n", list("\n", "# fn_body() is like body() but always returns a block:\n", 
#&gt;                 "fn &lt;- function() do()\n", "body(fn)\n", "fn_body(fn)\n", 
#&gt;                 "\n", "# It also throws an error when used on a primitive function:\n", 
#&gt;                 "try(fn_body(base::list))\n"), "\n"), fn_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "fn_env"), "\n", list("fn_env"), "\n", list("fn_env&lt;-"), 
#&gt;             "\n", list("Return the closure environment of a function"), 
#&gt;             "\n", list("\n", "fn_env(fn)\n", "\n", "fn_env(x) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn, x"), list("A function.")), 
#&gt;                 "\n", "\n", list(list("value"), list("A new closure environment for the function.")), 
#&gt;                 "\n"), "\n", list("\n", "Closure environments define the scope of functions (see ", 
#&gt;                 list(list("env()")), ").\n", "When a function call is evaluated, R creates an evaluation frame\n", 
#&gt;                 "(see ", list(list("ctxt_stack()")), ") that inherits from the closure environment.\n", 
#&gt;                 "This makes all objects defined in the closure environment and all\n", 
#&gt;                 "its parents available to code executed within the function.\n"), 
#&gt;             "\n", list("\n", list("fn_env()"), " returns the closure environment of ", 
#&gt;                 list("fn"), ". There is also\n", "an assignment method to set a new closure environment.\n"), 
#&gt;             "\n", list("\n", "env &lt;- child_env(\"base\")\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(fn_env(fn), env)\n", 
#&gt;                 "\n", "other_env &lt;- child_env(\"base\")\n", "fn_env(fn) &lt;- other_env\n", 
#&gt;                 "identical(fn_env(fn), other_env)\n"), "\n"), 
#&gt;         fn_fmls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("fn_fmls"), "\n", list("fn_fmls"), "\n", list(
#&gt;                 "fn_fmls_names"), "\n", list("fn_fmls_syms"), 
#&gt;             "\n", list("fn_fmls&lt;-"), "\n", list("fn_fmls_names&lt;-"), 
#&gt;             "\n", list("Extract arguments from a function"), 
#&gt;             "\n", list("\n", "fn_fmls(fn = caller_fn())\n", "\n", 
#&gt;                 "fn_fmls_names(fn = caller_fn())\n", "\n", "fn_fmls_syms(fn = caller_fn())\n", 
#&gt;                 "\n", "fn_fmls(fn) &lt;- value\n", "\n", "fn_fmls_names(fn) &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("fn"), list("A function. It is lookep up in the calling frame if not\n", 
#&gt;                 "supplied.")), "\n", "\n", list(list("value"), 
#&gt;                 list("New formals or formals names for ", list(
#&gt;                   "fn"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "fn_fmls()"), " returns a named list of formal arguments.\n", 
#&gt;                 list("fn_fmls_names()"), " returns the names of the arguments.\n", 
#&gt;                 list("fn_fmls_syms()"), " returns formals as a named list of symbols. This\n", 
#&gt;                 "is especially useful for forwarding arguments in ", 
#&gt;                 list("constructed calls"), ".\n"), "\n", list(
#&gt;                 "\n", "Unlike ", list("formals()"), ", these helpers throw an error with primitive\n", 
#&gt;                 "functions instead of returning ", list("NULL"), 
#&gt;                 ".\n"), "\n", list("\n", "# Extract from current call:\n", 
#&gt;                 "fn &lt;- function(a = 1, b = 2) fn_fmls()\n", "fn()\n", 
#&gt;                 "\n", "# fn_fmls_syms() makes it easy to forward arguments:\n", 
#&gt;                 "call2(\"apply\", !!! fn_fmls_syms(lapply))\n", 
#&gt;                 "\n", "# You can also change the formals:\n", 
#&gt;                 "fn_fmls(fn) &lt;- list(A = 10, B = 20)\n", "fn()\n", 
#&gt;                 "\n", "fn_fmls_names(fn) &lt;- c(\"foo\", \"bar\")\n", 
#&gt;                 "fn()\n"), "\n", list("\n", list(list("call_args()")), 
#&gt;                 " and ", list(list("call_args_names()")), "\n"), 
#&gt;             "\n"), frame_position.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("frame_position"), "\n", list("frame_position"), 
#&gt;             "\n", list("Find the position or distance of a frame on the evaluation stack"), 
#&gt;             "\n", list("\n", "frame_position(frame, from = c(\"global\", \"current\"))\n"), 
#&gt;             "\n", list("\n", list(list("frame"), list("The environment of a frame. Can be any object with a\n", 
#&gt;                 list(list("get_env()")), " method. Note that for frame objects, the position from\n", 
#&gt;                 "the global frame is simply ", list("frame$pos"), 
#&gt;                 ". Alternatively, ", list("frame"), "\n", "can be an integer that represents the position on the stack (and\n", 
#&gt;                 "is thus returned as is if ", list("from"), " is \"global\".")), 
#&gt;                 "\n", "\n", list(list("from"), list("Whether to compute distance from the global frame (the\n", 
#&gt;                   "bottom of the evaluation stack), or from the current frame (the\n", 
#&gt;                   "top of the evaluation stack).")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "The frame position on the stack can be computed by counting frames\n", 
#&gt;                 "from the global frame (the bottom of the stack, the default) or\n", 
#&gt;                 "from the current frame (the top of the stack).\n"), 
#&gt;             "\n", list("\n", "While this function returns the position of the frame on the\n", 
#&gt;                 "evaluation stack, it can safely be called with intervening frames\n", 
#&gt;                 "as those will be discarded.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are deprecated and replaced by ", 
#&gt;                   list(list("trace_back()")), ".\n")), "\n", 
#&gt;             "\n", list("\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) frame_position(env)\n", "\n", 
#&gt;                 "# frame_position() returns the position of the frame on the evaluation stack:\n", 
#&gt;                 "fn()\n", "identity(identity(fn()))\n", "\n", 
#&gt;                 "# Note that it trims off intervening calls before counting so you\n", 
#&gt;                 "# can safely nest it within other calls:\n", 
#&gt;                 "g &lt;- function(env) identity(identity(frame_position(env)))\n", 
#&gt;                 "fn()\n", "\n", "# You can also ask for the position from the current frame rather\n", 
#&gt;                 "# than the global frame:\n", "fn &lt;- function() g(environment())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) frame_position(env, from = \"current\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), friendly_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("friendly_type"), "\n", list("friendly_type"), 
#&gt;             "\n", list("Format a type for error messages"), "\n", 
#&gt;             list("\n", "friendly_type(type)\n"), "\n", list("\n", 
#&gt;                 list(list("type"), list("A type as returned by ", 
#&gt;                   list(list("typeof()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "A string of the prettified type, qualified with an\n", 
#&gt;                 "indefinite article.\n"), "\n", list("\n", "Format a type for error messages\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", list(
#&gt;                 "\n", list(), " ", list("friendly_type()"), " is experimental.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "friendly_type(\"logical\")\n", 
#&gt;                 "friendly_type(\"integer\")\n", "friendly_type(\"string\")\n"), 
#&gt;             "\n", list("internal"), "\n"), get_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env.R", "\n", list(
#&gt;                 "get_env"), "\n", list("get_env"), "\n", list(
#&gt;                 "set_env"), "\n", list("env_poke_parent"), "\n", 
#&gt;             list("Get or set the environment of an object"), 
#&gt;             "\n", list("\n", "get_env(env, default = NULL)\n", 
#&gt;                 "\n", "set_env(env, new_env = caller_env())\n", 
#&gt;                 "\n", "env_poke_parent(env, new_env)\n"), "\n", 
#&gt;             list("\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The default environment in case ", 
#&gt;                   list("env"), " does not wrap\n", "an environment. If ", 
#&gt;                   list("NULL"), " and no environment could be extracted,\n", 
#&gt;                   "an error is issued.")), "\n", "\n", list(list(
#&gt;                   "new_env"), list("An environment to replace ", 
#&gt;                   list("env"), " with.")), "\n"), "\n", list(
#&gt;                 "\n", "These functions dispatch internally with methods for functions,\n", 
#&gt;                 "formulas and frames. If called with a missing argument, the\n", 
#&gt;                 "environment of the current evaluation frame (see ", 
#&gt;                 list(list("ctxt_stack()")), ") is\n", "returned. If you call ", 
#&gt;                 list("get_env()"), " with an environment, it acts as\n", 
#&gt;                 "the identity function and the environment is simply returned (this\n", 
#&gt;                 "helps simplifying code when writing generic functions for\n", 
#&gt;                 "environments).\n"), "\n", list("\n", "While ", 
#&gt;                 list("set_env()"), " returns a modified copy and does not have side\n", 
#&gt;                 "effects, ", list("env_poke_parent()"), " operates changes the environment by\n", 
#&gt;                 "side effect. This is because environments are\n", 
#&gt;                 list("uncopyable"), ". Be careful not to change environments\n", 
#&gt;                 "that you don't own, e.g. a parent environment of a function from a\n", 
#&gt;                 "package.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " Using ", 
#&gt;                   list("get_env()"), " without supplying ", list(
#&gt;                     "env"), " is deprecated as\n", "of rlang 0.3.0. Please use ", 
#&gt;                   list(list("current_env()")), " to retrieve the\n", 
#&gt;                   "current environment.\n", list(), " Passing environment wrappers like formulas or functions instead\n", 
#&gt;                   "of bare environments is deprecated as of rlang 0.3.0. This\n", 
#&gt;                   "internal genericity was causing confusion (see issue #427). You\n", 
#&gt;                   "should now extract the environment separately before calling\n", 
#&gt;                   "these functions.\n"), "\n")), "\n", "\n", 
#&gt;             list("\n", "# Environment of closure functions:\n", 
#&gt;                 "fn &lt;- function() \"foo\"\n", "get_env(fn)\n", 
#&gt;                 "\n", "# Or of quosures or formulas:\n", "get_env(~foo)\n", 
#&gt;                 "get_env(quo(foo))\n", "\n", "\n", "# Provide a default in case the object doesn't bundle an environment.\n", 
#&gt;                 "# Let's create an unevaluated formula:\n", "f &lt;- quote(~foo)\n", 
#&gt;                 "\n", "# The following line would fail if run because unevaluated formulas\n", 
#&gt;                 "# don't bundle an environment (they didn't have the chance to\n", 
#&gt;                 "# record one yet):\n", "# get_env(f)\n", "\n", 
#&gt;                 "# It is often useful to provide a default when you're writing\n", 
#&gt;                 "# functions accepting formulas as input:\n", 
#&gt;                 "default &lt;- env()\n", "identical(get_env(f, default), default)\n", 
#&gt;                 "\n", "# set_env() can be used to set the enclosure of functions and\n", 
#&gt;                 "# formulas. Let's create a function with a particular environment:\n", 
#&gt;                 "env &lt;- child_env(\"base\")\n", "fn &lt;- set_env(function() NULL, env)\n", 
#&gt;                 "\n", "# That function now has `env` as enclosure:\n", 
#&gt;                 "identical(get_env(fn), env)\n", "identical(get_env(fn), current_env())\n", 
#&gt;                 "\n", "# set_env() does not work by side effect. Setting a new environment\n", 
#&gt;                 "# for fn has no effect on the original function:\n", 
#&gt;                 "other_env &lt;- child_env(NULL)\n", "set_env(fn, other_env)\n", 
#&gt;                 "identical(get_env(fn), other_env)\n", "\n", 
#&gt;                 "# Since set_env() returns a new function with a different\n", 
#&gt;                 "# environment, you'll need to reassign the result:\n", 
#&gt;                 "fn &lt;- set_env(fn, other_env)\n", "identical(get_env(fn), other_env)\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_env()")), " and ", 
#&gt;                 list(list("quo_set_env()")), " for versions of\n", 
#&gt;                 list(list("get_env()")), " and ", list(list("set_env()")), 
#&gt;                 " that only work on quosures.\n"), "\n"), has_length.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/attr.R", "\n", 
#&gt;             list("has_length"), "\n", list("has_length"), "\n", 
#&gt;             list("How long is an object?"), "\n", list("\n", 
#&gt;                 "has_length(x, n = NULL)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("A R object.")), "\n", "\n", 
#&gt;                 list(list("n"), list("A specific length to test ", 
#&gt;                   list("x"), " with. If ", list("NULL"), ",\n", 
#&gt;                   list("has_length()"), " returns ", list("TRUE"), 
#&gt;                   " if ", list("x"), " has length greater than\n", 
#&gt;                   "zero, and ", list("FALSE"), " otherwise.")), 
#&gt;                 "\n"), "\n", list("\n", "This is a function for the common task of testing the length of an\n", 
#&gt;                 "object. It checks the length of an object in a non-generic way:\n", 
#&gt;                 list(list("base::length()")), " methods are ignored.\n"), 
#&gt;             "\n", list("\n", "has_length(list())\n", "has_length(list(), 0)\n", 
#&gt;                 "\n", "has_length(letters)\n", "has_length(letters, 20)\n", 
#&gt;                 "has_length(letters, 26)\n"), "\n", list("internal"), 
#&gt;             "\n"), has_name.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("has_name"), "\n", list("has_name"), "\n", 
#&gt;             list("Does an object have an element with this name?"), 
#&gt;             "\n", list("\n", "has_name(x, name)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A data frame or another named object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Element name(s) to check")), 
#&gt;                 "\n"), "\n", list("\n", "A logical vector of the same length as ", 
#&gt;                 list("name"), "\n"), "\n", list("\n", "This function returns a logical value that indicates if a data\n", 
#&gt;                 "frame or another named object contains an element with a specific\n", 
#&gt;                 "name. Note that ", list("has_name()"), " only works with vectors. For instance,\n", 
#&gt;                 "environments need the specialised function ", 
#&gt;                 list(list("env_has()")), ".\n"), "\n", list("\n", 
#&gt;                 "Unnamed objects are treated as if all names are empty strings. ", 
#&gt;                 list("NA"), "\n", "input gives ", list("FALSE"), 
#&gt;                 " as output.\n"), "\n", list("\n", "has_name(iris, \"Species\")\n", 
#&gt;                 "has_name(mtcars, \"gears\")\n"), "\n"), inherits_any.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "inherits_any"), "\n", list("inherits_any"), 
#&gt;             "\n", list("inherits_all"), "\n", list("inherits_only"), 
#&gt;             "\n", list("Does an object inherit from a set of classes?"), 
#&gt;             "\n", list("\n", "inherits_any(x, class)\n", "\n", 
#&gt;                 "inherits_all(x, class)\n", "\n", "inherits_only(x, class)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test for inheritance.")), 
#&gt;                 "\n", "\n", list(list("class"), list("A character vector of classes.")), 
#&gt;                 "\n"), "\n", list("\n", list("\n", list(), " ", 
#&gt;                 list("inherits_any()"), " is like ", list(list(
#&gt;                   "base::inherits()")), " but is more explicit\n", 
#&gt;                 "about its behaviour with multiple classes. If ", 
#&gt;                 list("classes"), " contains\n", "several elements and the object inherits from at least one of\n", 
#&gt;                 "them, ", list("inherits_any()"), " returns ", 
#&gt;                 list("TRUE"), ".\n", list(), " ", list("inherits_all()"), 
#&gt;                 " tests that an object inherits from all of the\n", 
#&gt;                 "classes in the supplied order. This is usually the best way to\n", 
#&gt;                 "test for inheritance of multiple classes.\n", 
#&gt;                 list(), " ", list("inherits_only()"), " tests that the class vectors are identical. It\n", 
#&gt;                 "is a shortcut for ", list("identical(class(x), class)"), 
#&gt;                 ".\n"), "\n"), "\n", list("\n", "obj &lt;- structure(list(), class = c(\"foo\", \"bar\", \"baz\"))\n", 
#&gt;                 "\n", "# With the _any variant only one class must match:\n", 
#&gt;                 "inherits_any(obj, c(\"foobar\", \"bazbaz\"))\n", 
#&gt;                 "inherits_any(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "\n", "# With the _all variant all classes must match:\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"bazbaz\"))\n", 
#&gt;                 "inherits_all(obj, c(\"foo\", \"baz\"))\n", "\n", 
#&gt;                 "# The order of classes must match as well:\n", 
#&gt;                 "inherits_all(obj, c(\"baz\", \"foo\"))\n", "\n", 
#&gt;                 "# inherits_only() checks that the class vectors are identical:\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"baz\"))\n", 
#&gt;                 "inherits_only(obj, c(\"foo\", \"bar\", \"baz\"))\n"), 
#&gt;             "\n"), invoke.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("invoke"), "\n", list("invoke"), "\n", 
#&gt;             list("Invoke a function with a list of arguments"), 
#&gt;             "\n", list("\n", "invoke(.fn, .args = list(), ..., .env = caller_env(),\n", 
#&gt;                 "  .bury = c(\".fn\", \"\"))\n"), "\n", list(
#&gt;                 "\n", list(list(".fn"), list("A function to invoke. Can be a function object or the\n", 
#&gt;                   "name of a function in scope of ", list(".env"), 
#&gt;                   ".")), "\n", "\n", list(list(".args, ..."), 
#&gt;                   list("List of arguments (possibly named) to be passed to\n", 
#&gt;                     list(".fn"), ".")), "\n", "\n", list(list(
#&gt;                   ".env"), list("The environment in which to call ", 
#&gt;                   list(".fn"), ".")), "\n", "\n", list(list(".bury"), 
#&gt;                   list("A character vector of length 2. The first string\n", 
#&gt;                     "specifies which name should the function have in the call\n", 
#&gt;                     "recorded in the evaluation stack. The second string specifies a\n", 
#&gt;                     "prefix for the argument names. Set ", list(
#&gt;                       ".bury"), " to ", list("NULL"), " if you\n", 
#&gt;                     "prefer to inline the function and its arguments in the call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "Normally, you invoke a R function by typing arguments manually. A\n", 
#&gt;                 "powerful alternative is to call a function with a list of arguments\n", 
#&gt;                 "assembled programmatically. This is the purpose of ", 
#&gt;                 list("invoke()"), ".\n"), "\n", list("\n", "Technically, ", 
#&gt;                 list("invoke()"), " is basically a version of ", 
#&gt;                 list(list("base::do.call()")), "\n", "that creates cleaner call traces because it does not inline the\n", 
#&gt;                 "function and the arguments in the call (see examples). To achieve\n", 
#&gt;                 "this, ", list("invoke()"), " creates a child environment of ", 
#&gt;                 list(".env"), " with ", list(".fn"), "\n", "and all arguments bound to new symbols (see ", 
#&gt;                 list(list("env_bury()")), "). It then\n", "uses the same strategy as ", 
#&gt;                 list(list("eval_bare()")), " to evaluate with minimal\n", 
#&gt;                 "noise.\n"), "\n", list(list("Life cycle"), list(
#&gt;                 "\n", "\n", "\n", list("invoke()"), " is soft-deprecated in favour of ", 
#&gt;                 list(list("exec()")), ". Now that we\n", "understand better the interaction between unquoting and dots\n", 
#&gt;                 "capture, we can take a simpler approach in ", 
#&gt;                 list("exec()"), ".\n", "\n", "If you need finer control over the generated call, you should construct\n", 
#&gt;                 "an environment and call yourself, manually burying large objects\n", 
#&gt;                 "or complex expressions.\n")), "\n", "\n", list(
#&gt;                 "\n", "# invoke() has the same purpose as do.call():\n", 
#&gt;                 "invoke(paste, letters)\n", "\n", "# But it creates much cleaner calls:\n", 
#&gt;                 "invoke(call_inspect, mtcars)\n", "\n", "# and stacktraces:\n", 
#&gt;                 "fn &lt;- function(...) sys.calls()\n", "invoke(fn, list(mtcars))\n", 
#&gt;                 "\n", "# Compare to do.call():\n", "do.call(call_inspect, mtcars)\n", 
#&gt;                 "do.call(fn, list(mtcars))\n", "\n", "\n", "# Specify the function name either by supplying a string\n", 
#&gt;                 "# identifying the function (it should be visible in .env):\n", 
#&gt;                 "invoke(\"call_inspect\", letters)\n", "\n", 
#&gt;                 "# Or by changing the .bury argument, with which you can also change\n", 
#&gt;                 "# the argument prefix:\n", "invoke(call_inspect, mtcars, .bury = c(\"inspect!\", \"col\"))\n"), 
#&gt;             "\n", list("internal"), "\n"), is_call.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("is_call"), "\n", list("is_call"), "\n", list(
#&gt;                 "Is object a call?"), "\n", list("\n", "is_call(x, name = NULL, n = NULL, ns = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                 "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                 list("An optional name that the call should match. It is\n", 
#&gt;                   "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                   "and you can supply a vector of names to match. In this case,\n", 
#&gt;                   list("is_call()"), " returns ", list("TRUE"), 
#&gt;                   " if at least one name matches.")), "\n", "\n", 
#&gt;                 list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n"), "\n", list("\n", "This function tests if ", 
#&gt;                 list("x"), " is a ", list("call"), ". This is a\n", 
#&gt;                 "pattern-matching predicate that returns ", list(
#&gt;                   "FALSE"), " if ", list("name"), " and ", list(
#&gt;                   "n"), "\n", "are supplied and the call does not match these properties.\n", 
#&gt;                 list("is_unary_call()"), " and ", list("is_binary_call()"), 
#&gt;                 " hardcode ", list("n"), " to 1 and 2.\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                 "is_lang()"), " has been soft-deprecated and renamed to ", 
#&gt;                 list("is_call()"), " in\n", "rlang 0.2.0 and similarly for ", 
#&gt;                 list("is_unary_lang()"), " and\n", list("is_binary_lang()"), 
#&gt;                 ". This renaming follows the general switch from\n", 
#&gt;                 "\"language\" to \"call\" in the rlang type nomenclature. See lifecycle\n", 
#&gt;                 "section in ", list(list("call2()")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "is_call(quote(foo(bar)))\n", 
#&gt;                 "\n", "# You can pattern-match the call with additional arguments:\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\")\n", "is_call(quote(foo(bar)), \"bar\")\n", 
#&gt;                 "is_call(quote(foo(bar)), quote(foo))\n", "\n", 
#&gt;                 "# Match the number of arguments with is_call():\n", 
#&gt;                 "is_call(quote(foo(bar)), \"foo\", 1)\n", "is_call(quote(foo(bar)), \"foo\", 2)\n", 
#&gt;                 "\n", "\n", "# By default, namespaced calls are tested unqualified:\n", 
#&gt;                 "ns_expr &lt;- quote(base::list())\n", "is_call(ns_expr, \"list\")\n", 
#&gt;                 "\n", "# You can also specify whether the call shouldn't be namespaced by\n", 
#&gt;                 "# supplying an empty string:\n", "is_call(ns_expr, \"list\", ns = \"\")\n", 
#&gt;                 "\n", "# Or if it should have a namespace:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"utils\")\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = \"base\")\n", 
#&gt;                 "\n", "# You can supply multiple namespaces:\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"base\"))\n", 
#&gt;                 "is_call(ns_expr, \"list\", ns = c(\"utils\", \"stats\"))\n", 
#&gt;                 "\n", "# If one of them is \"\", unnamespaced calls will match as well:\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = \"base\")\n", 
#&gt;                 "is_call(quote(list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "is_call(quote(base::list()), \"list\", ns = c(\"base\", \"\"))\n", 
#&gt;                 "\n", "\n", "# The name argument is vectorised so you can supply a list of names\n", 
#&gt;                 "# to match with:\n", "is_call(quote(foo(bar)), c(\"bar\", \"baz\"))\n", 
#&gt;                 "is_call(quote(foo(bar)), c(\"bar\", \"foo\"))\n", 
#&gt;                 "is_call(quote(base::list), c(\"::\", \":::\", \"$\", \"@\"))\n"), 
#&gt;             "\n", list("\n", list(list("is_expression()")), "\n"), 
#&gt;             "\n"), is_callable.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/call.R", 
#&gt;             "\n", list("is_callable"), "\n", list("is_callable"), 
#&gt;             "\n", list("Is an object callable?"), "\n", list(
#&gt;                 "\n", "is_callable(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", "A callable object is an object that can appear in the function\n", 
#&gt;                 "position of a call (as opposed to argument position). This includes\n", 
#&gt;                 list("symbolic objects"), " that evaluate to a function or\n", 
#&gt;                 "literal functions embedded in the call.\n"), 
#&gt;             "\n", list("\n", "Note that strings may look like callable objects because\n", 
#&gt;                 "expressions of the form ", list("\"list\"()"), 
#&gt;                 " are valid R code. However,\n", "that's only because the R parser transforms strings to symbols. It\n", 
#&gt;                 "is not legal to manually set language heads to strings.\n"), 
#&gt;             "\n", list("\n", "# Symbolic objects and functions are callable:\n", 
#&gt;                 "is_callable(quote(foo))\n", "is_callable(base::identity)\n", 
#&gt;                 "\n", "# node_poke_car() lets you modify calls without any checking:\n", 
#&gt;                 "lang &lt;- quote(foo(10))\n", "node_poke_car(lang, current_env())\n", 
#&gt;                 "\n", "# Use is_callable() to check an input object is safe to put as CAR:\n", 
#&gt;                 "obj &lt;- base::identity\n", "\n", "if (is_callable(obj)) {\n", 
#&gt;                 "  lang &lt;- node_poke_car(lang, obj)\n", "} else {\n", 
#&gt;                 "  abort(\"`obj` must be callable\")\n", "}\n", 
#&gt;                 "\n", "eval_bare(lang)\n"), "\n", list("internal"), 
#&gt;             "\n"), is_condition.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd.R", "\n", 
#&gt;             list("is_condition"), "\n", list("is_condition"), 
#&gt;             "\n", list("Is object a condition?"), "\n", list(
#&gt;                 "\n", "is_condition(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is object a condition?\n"), 
#&gt;             "\n", list("internal"), "\n"), is_copyable.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_copyable"), "\n", list("is_copyable"), "\n", 
#&gt;             list("Is an object copyable?"), "\n", list("\n", 
#&gt;                 "is_copyable(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "When an object is modified, R generally copies it (sometimes\n", 
#&gt;                 "lazily) to enforce ", list(list("https://en.wikipedia.org/wiki/Value_semantics"), 
#&gt;                   list("value semantics")), ".\n", "However, some internal types are uncopyable. If you try to copy\n", 
#&gt;                 "them, either with ", list("&lt;-"), " or by argument passing, you actually create\n", 
#&gt;                 "references to the original object rather than actual\n", 
#&gt;                 "copies. Modifying these references can thus have far reaching side\n", 
#&gt;                 "effects.\n"), "\n", list("\n", "# Let's add attributes with structure() to uncopyable types. Since\n", 
#&gt;                 "# they are not copied, the attributes are changed in place:\n", 
#&gt;                 "env &lt;- env()\n", "structure(env, foo = \"bar\")\n", 
#&gt;                 "env\n", "\n", "# These objects that can only be changed with side effect are not\n", 
#&gt;                 "# copyable:\n", "is_copyable(env)\n", "\n", 
#&gt;                 "structure(base::list, foo = \"bar\")\n", "str(base::list)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_empty.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_empty"), "\n", list("is_empty"), "\n", list(
#&gt;                 "Is object an empty vector or NULL?"), "\n", 
#&gt;             list("\n", "is_empty(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("object to test")), "\n"), "\n", 
#&gt;             list("\n", "Is object an empty vector or NULL?\n"), 
#&gt;             "\n", list("\n", "is_empty(NULL)\n", "is_empty(list())\n", 
#&gt;                 "is_empty(list(NULL))\n"), "\n"), is_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_env"), "\n", list("is_env"), "\n", 
#&gt;             list("is_bare_env"), "\n", list("Is an object an environment?"), 
#&gt;             "\n", list("\n", "is_env(x)\n", "\n", "is_bare_env(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("is_environment()")), "\n", "and ", 
#&gt;                 list(list("is_bare_environment()")), " in rlang 0.2.0. This is for consistency\n", 
#&gt;                 "with other type predicates which are not abbreviated.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_environment.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_environment"), "\n", list("is_environment"), 
#&gt;             "\n", list("is_bare_environment"), "\n", list("Is object an environment?"), 
#&gt;             "\n", list("\n", "is_environment(x)\n", "\n", "is_bare_environment(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("is_bare_environment()"), 
#&gt;                 " tests whether ", list("x"), " is an environment without a s3 or\n", 
#&gt;                 "s4 class.\n"), "\n"), is_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_expr"), "\n", list("is_expr"), "\n", 
#&gt;             list("Is an object an expression?"), "\n", list("\n", 
#&gt;                 "is_expr(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to test.")), "\n"), "\n", list(
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "This function was deprecated and renamed to ", 
#&gt;                 list(list("is_expression()")), " in\n", "rlang 0.2.0. This is for consistency with other type predicates\n", 
#&gt;                 "which are not abbreviated.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_expression.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/expr.R", 
#&gt;             "\n", list("is_expression"), "\n", list("is_expression"), 
#&gt;             "\n", list("is_syntactic_literal"), "\n", list("is_symbolic"), 
#&gt;             "\n", list("Is an object an expression?"), "\n", 
#&gt;             list("\n", "is_expression(x)\n", "\n", "is_syntactic_literal(x)\n", 
#&gt;                 "\n", "is_symbolic(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_expression()"), " tests for expressions, the set of objects that can be\n", 
#&gt;                 "obtained from parsing R code. An expression can be one of two\n", 
#&gt;                 "things: either a symbolic object (for which ", 
#&gt;                 list("is_symbolic()"), " returns\n", list("TRUE"), 
#&gt;                 "), or a syntactic literal (testable with\n", 
#&gt;                 list("is_syntactic_literal()"), "). Technically, calls can contain any R\n", 
#&gt;                 "object, not necessarily symbolic objects or syntactic\n", 
#&gt;                 "literals. However, this only happens in artificial\n", 
#&gt;                 "situations. Expressions as we define them only contain numbers,\n", 
#&gt;                 "strings, ", list("NULL"), ", symbols, and calls: this is the complete set of R\n", 
#&gt;                 "objects that can be created when R parses source code (e.g. from\n", 
#&gt;                 "using ", list(list("parse_expr()")), ").\n", 
#&gt;                 "\n", "Note that we are using the term expression in its colloquial sense\n", 
#&gt;                 "and not to refer to ", list(list("expression()")), 
#&gt;                 " vectors, a data type that wraps\n", "expressions in a vector and which isn't used much in modern R code.\n"), 
#&gt;             "\n", list("\n", list("is_symbolic()"), " returns ", 
#&gt;                 list("TRUE"), " for symbols and calls (objects with\n", 
#&gt;                 "type ", list("language"), "). Symbolic objects are replaced by their value\n", 
#&gt;                 "during evaluation. Literals are the complement of symbolic\n", 
#&gt;                 "objects. They are their own value and return themselves during\n", 
#&gt;                 "evaluation.\n", "\n", list("is_syntactic_literal()"), 
#&gt;                 " is a predicate that returns ", list("TRUE"), 
#&gt;                 " for the\n", "subset of literals that are created by R when parsing text (see\n", 
#&gt;                 list(list("parse_expr()")), "): numbers, strings and ", 
#&gt;                 list("NULL"), ". Along with symbols,\n", "these literals are the terminating nodes in an AST.\n", 
#&gt;                 "\n", "Note that in the most general sense, a literal is any R object that\n", 
#&gt;                 "evaluates to itself and that can be evaluated in the empty\n", 
#&gt;                 "environment. For instance, ", list("quote(c(1, 2))"), 
#&gt;                 " is not a literal, it is\n", "a call. However, the result of evaluating it in ", 
#&gt;                 list(list("base_env()")), " is a\n", "literal(in this case an atomic vector).\n", 
#&gt;                 "\n", "Pairlists are also a kind of language objects. However, since they\n", 
#&gt;                 "are mostly an internal data structure, ", list(
#&gt;                   "is_expression()"), " returns ", list("FALSE"), 
#&gt;                 "\n", "for pairlists. You can use ", list("is_pairlist()"), 
#&gt;                 " to explicitly check for\n", "them. Pairlists are the data structure for function arguments. They\n", 
#&gt;                 "usually do not arise from R code because subsetting a call is a\n", 
#&gt;                 "type-preserving operation. However, you can obtain the pairlist of\n", 
#&gt;                 "arguments by taking the CDR of the call object from C code. The\n", 
#&gt;                 "rlang function ", list(list("node_cdr()")), 
#&gt;                 " will do it from R. Another way in\n", "which pairlist of arguments arise is by extracting the argument\n", 
#&gt;                 "list of a closure with ", list(list("base::formals()")), 
#&gt;                 " or ", list(list("fn_fmls()")), ".\n"), "\n", 
#&gt;             list("\n", "q1 &lt;- quote(1)\n", "is_expression(q1)\n", 
#&gt;                 "is_syntactic_literal(q1)\n", "\n", "q2 &lt;- quote(x)\n", 
#&gt;                 "is_expression(q2)\n", "is_symbol(q2)\n", "\n", 
#&gt;                 "q3 &lt;- quote(x + 1)\n", "is_expression(q3)\n", 
#&gt;                 "is_call(q3)\n", "\n", "\n", "# Atomic expressions are the terminating nodes of a call tree:\n", 
#&gt;                 "# NULL or a scalar atomic vector:\n", "is_syntactic_literal(\"string\")\n", 
#&gt;                 "is_syntactic_literal(NULL)\n", "\n", "is_syntactic_literal(letters)\n", 
#&gt;                 "is_syntactic_literal(quote(call()))\n", "\n", 
#&gt;                 "# Parsable literals have the property of being self-quoting:\n", 
#&gt;                 "identical(\"foo\", quote(\"foo\"))\n", "identical(1L, quote(1L))\n", 
#&gt;                 "identical(NULL, quote(NULL))\n", "\n", "# Like any literals, they can be evaluated within the empty\n", 
#&gt;                 "# environment:\n", "eval_bare(quote(1L), empty_env())\n", 
#&gt;                 "\n", "# Whereas it would fail for symbolic expressions:\n", 
#&gt;                 "# eval_bare(quote(c(1L, 2L)), empty_env())\n", 
#&gt;                 "\n", "\n", "# Pairlists are also language objects representing argument lists.\n", 
#&gt;                 "# You will usually encounter them with extracted formals:\n", 
#&gt;                 "fmls &lt;- formals(is_expression)\n", "typeof(fmls)\n", 
#&gt;                 "\n", "# Since they are mostly an internal data structure, is_expression()\n", 
#&gt;                 "# returns FALSE for pairlists, so you will have to check explicitly\n", 
#&gt;                 "# for them:\n", "is_expression(fmls)\n", "is_pairlist(fmls)\n"), 
#&gt;             "\n", list("\n", list(list("is_call()")), " for a call predicate.\n"), 
#&gt;             "\n"), is_formula.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/formula.R", 
#&gt;             "\n", list("is_formula"), "\n", list("is_formula"), 
#&gt;             "\n", list("is_bare_formula"), "\n", list("Is object a formula?"), 
#&gt;             "\n", list("\n", "is_formula(x, scoped = NULL, lhs = NULL)\n", 
#&gt;                 "\n", "is_bare_formula(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("scoped"), list("A boolean indicating whether the quosure is scoped,\n", 
#&gt;                   "that is, has a valid environment attribute. If ", 
#&gt;                   list("NULL"), ", the scope\n", "is not inspected.")), 
#&gt;                 "\n", "\n", list(list("lhs"), list("A boolean indicating whether the ", 
#&gt;                   list("formula"), "\n", "or ", list("definition"), 
#&gt;                   " has a left-hand side. If ", list("NULL"), 
#&gt;                   ",\n", "the LHS is not inspected.")), "\n"), 
#&gt;             "\n", list("\n", list("is_formula()"), " tests if ", 
#&gt;                 list("x"), " is a call to ", list("~"), ". ", 
#&gt;                 list("is_bare_formula()"), "\n", "tests in addition that ", 
#&gt;                 list("x"), " does not inherit from anything else than\n", 
#&gt;                 list("\"formula\""), ".\n"), "\n", list("\n", 
#&gt;                 "The ", list("scoped"), " argument patterns-match on whether the scoped bundled\n", 
#&gt;                 "with the quosure is valid or not. Invalid scopes may happen in\n", 
#&gt;                 "nested quotations like ", list("~~expr"), ", where the outer quosure is validly\n", 
#&gt;                 "scoped but not the inner one. This is because ", 
#&gt;                 list("~"), " saves the\n", "environment when it is evaluated, and quoted formulas are by\n", 
#&gt;                 "definition not evaluated.\n"), "\n", list("\n", 
#&gt;                 "x &lt;- disp ~ am\n", "is_formula(x)\n", "\n", 
#&gt;                 "is_formula(~10)\n", "is_formula(10)\n", "\n", 
#&gt;                 "is_formula(quo(foo))\n", "is_bare_formula(quo(foo))\n", 
#&gt;                 "\n", "# Note that unevaluated formulas are treated as bare formulas even\n", 
#&gt;                 "# though they don't inherit from \"formula\":\n", 
#&gt;                 "f &lt;- quote(~foo)\n", "is_bare_formula(f)\n", 
#&gt;                 "\n", "# However you can specify `scoped` if you need the predicate to\n", 
#&gt;                 "# return FALSE for these unevaluated formulas:\n", 
#&gt;                 "is_bare_formula(f, scoped = TRUE)\n", "is_bare_formula(eval(f), scoped = TRUE)\n"), 
#&gt;             "\n"), is_frame.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_frame"), "\n", list("is_frame"), "\n", 
#&gt;             list("Is object a frame?"), "\n", list("\n", "is_frame(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to test")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "is_function"), "\n", list("is_function"), "\n", 
#&gt;             list("is_closure"), "\n", list("is_primitive"), "\n", 
#&gt;             list("is_primitive_eager"), "\n", list("is_primitive_lazy"), 
#&gt;             "\n", list("Is object a function?"), "\n", list("\n", 
#&gt;                 "is_function(x)\n", "\n", "is_closure(x)\n", 
#&gt;                 "\n", "is_primitive(x)\n", "\n", "is_primitive_eager(x)\n", 
#&gt;                 "\n", "is_primitive_lazy(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n"), "\n", list("\n", "The R language defines two different types of functions: primitive\n", 
#&gt;                 "functions, which are low-level, and closures, which are the regular\n", 
#&gt;                 "kind of functions.\n"), "\n", list("\n", "Closures are functions written in R, named after the way their\n", 
#&gt;                 "arguments are scoped within nested environments (see\n", 
#&gt;                 "https://en.wikipedia.org/wiki/Closure_(computer_programming)). The\n", 
#&gt;                 "root environment of the closure is called the closure\n", 
#&gt;                 "environment. When closures are evaluated, a new environment called\n", 
#&gt;                 "the evaluation frame is created with the closure environment as\n", 
#&gt;                 "parent. This is where the body of the closure is evaluated. These\n", 
#&gt;                 "closure frames appear on the evaluation stack (see ", 
#&gt;                 list(list("ctxt_stack()")), "),\n", "as opposed to primitive functions which do not necessarily have\n", 
#&gt;                 "their own evaluation frame and never appear on the stack.\n", 
#&gt;                 "\n", "Primitive functions are more efficient than closures for two\n", 
#&gt;                 "reasons. First, they are written entirely in fast low-level\n", 
#&gt;                 "code. Second, the mechanism by which they are passed arguments is\n", 
#&gt;                 "more efficient because they often do not need the full procedure of\n", 
#&gt;                 "argument matching (dealing with positional versus named arguments,\n", 
#&gt;                 "partial matching, etc). One practical consequence of the special\n", 
#&gt;                 "way in which primitives are passed arguments is that they\n", 
#&gt;                 "technically do not have formal arguments, and ", 
#&gt;                 list(list("formals()")), " will\n", "return ", 
#&gt;                 list("NULL"), " if called on a primitive function. Finally, primitive\n", 
#&gt;                 "functions can either take arguments lazily, like R closures do,\n", 
#&gt;                 "or evaluate them eagerly before being passed on to the C code.\n", 
#&gt;                 "The former kind of primitives are called \"special\" in R terminology,\n", 
#&gt;                 "while the latter is referred to as \"builtin\". ", 
#&gt;                 list("is_primitive_eager()"), "\n", "and ", list(
#&gt;                   "is_primitive_lazy()"), " allow you to check whether a primitive\n", 
#&gt;                 "function evaluates arguments eagerly or lazily.\n", 
#&gt;                 "\n", "You will also encounter the distinction between primitive and\n", 
#&gt;                 "internal functions in technical documentation. Like primitive\n", 
#&gt;                 "functions, internal functions are defined at a low level and\n", 
#&gt;                 "written in C. However, internal functions have no representation in\n", 
#&gt;                 "the R language. Instead, they are called via a call to\n", 
#&gt;                 list(list("base::.Internal()")), " within a regular closure. This ensures that\n", 
#&gt;                 "they appear as normal R function objects: they obey all the usual\n", 
#&gt;                 "rules of argument passing, and they appear on the evaluation stack\n", 
#&gt;                 "as any other closures. As a result, ", list(
#&gt;                   list("fn_fmls()")), " does not need to\n", 
#&gt;                 "look in the ", list(".ArgsEnv"), " environment to obtain a representation of\n", 
#&gt;                 "their arguments, and there is no way of querying from R whether\n", 
#&gt;                 "they are lazy ('special' in R terminology) or eager ('builtin').\n", 
#&gt;                 "\n", "You can call primitive functions with ", 
#&gt;                 list(list(".Primitive()")), " and internal\n", 
#&gt;                 "functions with ", list(list(".Internal()")), 
#&gt;                 ". However, calling internal functions\n", "in a package is forbidden by CRAN's policy because they are\n", 
#&gt;                 "considered part of the private API. They often assume that they\n", 
#&gt;                 "have been called with correctly formed arguments, and may cause R\n", 
#&gt;                 "to crash if you call them with unexpected objects.\n"), 
#&gt;             "\n", list("\n", "# Primitive functions are not closures:\n", 
#&gt;                 "is_closure(base::c)\n", "is_primitive(base::c)\n", 
#&gt;                 "\n", "# On the other hand, internal functions are wrapped in a closure\n", 
#&gt;                 "# and appear as such from the R side:\n", "is_closure(base::eval)\n", 
#&gt;                 "\n", "# Both closures and primitives are functions:\n", 
#&gt;                 "is_function(base::c)\n", "is_function(base::eval)\n", 
#&gt;                 "\n", "# Primitive functions never appear in evaluation stacks:\n", 
#&gt;                 "is_primitive(base::`[[`)\n", "is_primitive(base::list)\n", 
#&gt;                 "list(ctxt_stack())[[1]]\n", "\n", "# While closures do:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# Many primitive functions evaluate arguments eagerly:\n", 
#&gt;                 "is_primitive_eager(base::c)\n", "is_primitive_eager(base::list)\n", 
#&gt;                 "is_primitive_eager(base::`+`)\n", "\n", "# However, primitives that operate on expressions, like quote() or\n", 
#&gt;                 "# substitute(), are lazy:\n", "is_primitive_lazy(base::quote)\n", 
#&gt;                 "is_primitive_lazy(base::substitute)\n"), "\n"), 
#&gt;         is_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_installed"), "\n", list("is_installed"), 
#&gt;             "\n", list("Is a package installed in the library?"), 
#&gt;             "\n", list("\n", "is_installed(pkg)\n"), "\n", list(
#&gt;                 "\n", list(list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", list("TRUE"), " if the package is installed, ", 
#&gt;                 list("FALSE"), " otherwise.\n"), "\n", list("\n", 
#&gt;                 "This checks that a package is installed with minimal side effects.\n", 
#&gt;                 "If installed, the package will be loaded but not attached.\n"), 
#&gt;             "\n", list("\n", "is_installed(\"utils\")\n", "is_installed(\"ggplot5\")\n"), 
#&gt;             "\n"), is_integerish.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/types.R", 
#&gt;             "\n", list("is_integerish"), "\n", list("is_integerish"), 
#&gt;             "\n", list("is_bare_integerish"), "\n", list("is_scalar_integerish"), 
#&gt;             "\n", list("Is a vector integer-like?"), "\n", list(
#&gt;                 "\n", "is_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_bare_integerish(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_scalar_integerish(x, finite = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n"), "\n", list("\n", "These predicates check whether R considers a number vector to be\n", 
#&gt;                 "integer-like, according to its own tolerance check (which is in\n", 
#&gt;                 "fact delegated to the C library). This function is not adapted to\n", 
#&gt;                 "data analysis, see the help for ", list(list(
#&gt;                   "base::is.integer()")), " for examples\n", 
#&gt;                 "of how to check for whole numbers.\n", "\n", 
#&gt;                 "Things to consider when checking for integer-like doubles:\n", 
#&gt;                 list("\n", list(), " This check can be expensive because the whole double vector has\n", 
#&gt;                   "to be traversed and checked.\n", list(), " Large double values may be integerish but may still not be\n", 
#&gt;                   "coercible to integer. This is because integers in R only support\n", 
#&gt;                   "values up to ", list("2^31 - 1"), " while numbers stored as double can be\n", 
#&gt;                   "much larger.\n"), "\n"), "\n", list("\n", 
#&gt;                 "is_integerish(10L)\n", "is_integerish(10.0)\n", 
#&gt;                 "is_integerish(10.0, n = 2)\n", "is_integerish(10.000001)\n", 
#&gt;                 "is_integerish(TRUE)\n"), "\n", list("\n", list(
#&gt;                 list("is_bare_numeric()")), " for testing whether an object is a\n", 
#&gt;                 "base numeric type (a bare double or integer vector).\n"), 
#&gt;             "\n"), is_interactive.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/state.R", 
#&gt;             "\n", list("is_interactive"), "\n", list("is_interactive"), 
#&gt;             "\n", list("scoped_interactive"), "\n", list("with_interactive"), 
#&gt;             "\n", list("Is R running interactively?"), "\n", 
#&gt;             list("\n", "is_interactive()\n", "\n", "scoped_interactive(value = TRUE, frame = caller_env())\n", 
#&gt;                 "\n", "with_interactive(expr, value = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("value"), list("A single ", 
#&gt;                 list("TRUE"), " or ", list("FALSE"), ". This overrides the return\n", 
#&gt;                 "value of ", list("is_interactive()"), ".")), 
#&gt;                 "\n", "\n", list(list("frame"), list("The environment of a running function which defines\n", 
#&gt;                   "the scope of the temporary options. When the function returns,\n", 
#&gt;                   "the options are reset to their original values.")), 
#&gt;                 "\n", "\n", list(list("expr"), list("An expression to evaluate with interactivity set to\n", 
#&gt;                   list("value"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "Like ", list(list("base::interactive()")), ", ", 
#&gt;                 list("is_interactive()"), " returns ", list("TRUE"), 
#&gt;                 " when\n", "the function runs interactively and ", 
#&gt;                 list("FALSE"), " when it runs in batch\n", "mode. It also checks, in this order:\n", 
#&gt;                 list("\n", list(), " The ", list("rlang_interactive"), 
#&gt;                   " global option. If set to a single ", list(
#&gt;                     "TRUE"), "\n", "or ", list("FALSE"), ", ", 
#&gt;                   list("is_interactive()"), " returns that value immediately. This\n", 
#&gt;                   "escape hatch is useful in unit tests or to manually turn on\n", 
#&gt;                   "interactive features in RMarkdown outputs.\n", 
#&gt;                   list(), " Whether knitr, an RStudio notebook, or testthat is in progress.\n"), 
#&gt;                 "\n", "\n", list("with_interactive()"), " and ", 
#&gt;                 list("scoped_interactive()"), " set the global\n", 
#&gt;                 "option conveniently.\n"), "\n"), is_lang.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_lang"), "\n", list("is_lang"), "\n", 
#&gt;             list("is_unary_lang"), "\n", list("is_binary_lang"), 
#&gt;             "\n", list("quo_is_lang"), "\n", list("Is object a call?"), 
#&gt;             "\n", list("\n", "is_lang(x, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_unary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "is_binary_lang(x, name = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_lang(quo)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test. If a formula, the right-hand side is\n", 
#&gt;                   "extracted.")), "\n", "\n", list(list("name"), 
#&gt;                   list("An optional name that the call should match. It is\n", 
#&gt;                     "passed to ", list(list("sym()")), " before matching. This argument is vectorised\n", 
#&gt;                     "and you can supply a vector of names to match. In this case,\n", 
#&gt;                     list("is_call()"), " returns ", list("TRUE"), 
#&gt;                     " if at least one name matches.")), "\n", 
#&gt;                 "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("is_call()")), " and its ", list("n"), 
#&gt;                 "\n", "argument instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), is_named.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("is_named"), "\n", list("is_named"), "\n", 
#&gt;             list("is_dictionaryish"), "\n", list("have_name"), 
#&gt;             "\n", list("Is object named?"), "\n", list("\n", 
#&gt;                 "is_named(x)\n", "\n", "is_dictionaryish(x)\n", 
#&gt;                 "\n", "have_name(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("An object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " and ", list(
#&gt;                 "is_dictionaryish()"), " are scalar predicates\n", 
#&gt;                 "and return ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ". ", list("have_name()"), " is vectorised and\n", 
#&gt;                 "returns a logical vector as long as the input.\n"), 
#&gt;             "\n", list("\n", list("is_named()"), " checks that ", 
#&gt;                 list("x"), " has names attributes, and that none of\n", 
#&gt;                 "the names are missing or empty (", list("NA"), 
#&gt;                 " or ", list("\"\""), "). ", list("is_dictionaryish()"), 
#&gt;                 "\n", "checks that an object is a dictionary: that it has actual names and\n", 
#&gt;                 "in addition that there are no duplicated names. ", 
#&gt;                 list("have_name()"), "\n", "is a vectorised version of ", 
#&gt;                 list("is_named()"), ".\n"), "\n", list("\n", 
#&gt;                 "# A data frame usually has valid, unique names\n", 
#&gt;                 "is_named(mtcars)\n", "have_name(mtcars)\n", 
#&gt;                 "is_dictionaryish(mtcars)\n", "\n", "# But data frames can also have duplicated columns:\n", 
#&gt;                 "dups &lt;- cbind(mtcars, cyl = seq_len(nrow(mtcars)))\n", 
#&gt;                 "is_dictionaryish(dups)\n", "\n", "# The names are still valid:\n", 
#&gt;                 "is_named(dups)\n", "have_name(dups)\n", "\n", 
#&gt;                 "\n", "# For empty objects the semantics are slightly different.\n", 
#&gt;                 "# is_dictionaryish() returns TRUE for empty objects:\n", 
#&gt;                 "is_dictionaryish(list())\n", "\n", "# But is_named() will only return TRUE if there is a names\n", 
#&gt;                 "# attribute (a zero-length character vector in this case):\n", 
#&gt;                 "x &lt;- set_names(list(), character(0))\n", "is_named(x)\n", 
#&gt;                 "\n", "\n", "# Empty and missing names are invalid:\n", 
#&gt;                 "invalid &lt;- dups\n", "names(invalid)[2] &lt;- \"\"\n", 
#&gt;                 "names(invalid)[5] &lt;- NA\n", "\n", "# is_named() performs a global check while have_name() can show you\n", 
#&gt;                 "# where the problem is:\n", "is_named(invalid)\n", 
#&gt;                 "have_name(invalid)\n", "\n", "# have_name() will work even with vectors that don't have a names\n", 
#&gt;                 "# attribute:\n", "have_name(letters)\n"), "\n"), 
#&gt;         is_namespace.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("is_namespace"), "\n", list("is_namespace"), 
#&gt;             "\n", list("Is an object a namespace environment?"), 
#&gt;             "\n", list("\n", "is_namespace(x)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", "Is an object a namespace environment?\n"), 
#&gt;             "\n"), is_pairlist.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("is_pairlist"), "\n", list("is_pairlist"), 
#&gt;             "\n", list("is_node"), "\n", list("is_node_list"), 
#&gt;             "\n", list("Is object a node or pairlist?"), "\n", 
#&gt;             list("\n", "is_pairlist(x)\n", "\n", "is_node(x)\n", 
#&gt;                 "\n", "is_node_list(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Object to test.")), "\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("is_pairlist()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), ".\n", list(), " ", list("is_node()"), 
#&gt;                 " checks that ", list("x"), " has type ", list(
#&gt;                   "pairlist"), " or ", list("language"), ".\n", 
#&gt;                 "It tests whether ", list("x"), " is a node that has a CAR and a CDR,\n", 
#&gt;                 "including callable nodes (language objects).\n", 
#&gt;                 list(), " ", list("is_node_list()"), " checks that ", 
#&gt;                 list("x"), " has type ", list("pairlist"), " or ", 
#&gt;                 list("NULL"), ".\n", list("NULL"), " is the empty node list.\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are experimental. We are still figuring out a good\n", 
#&gt;                 "naming convention to refer to the different lisp-like lists in R.\n")), 
#&gt;             "\n", "\n", list("\n", list(list("is_call()")), " tests for language nodes.\n"), 
#&gt;             "\n", list("internal"), "\n"), is_reference.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_reference"), "\n", list("is_reference"), 
#&gt;             "\n", list("Is an object referencing another?"), 
#&gt;             "\n", list("\n", "is_reference(x, y)\n"), "\n", list(
#&gt;                 "\n", list(list("x, y"), list("R objects.")), 
#&gt;                 "\n"), "\n", list("\n", "There are typically two situations where two symbols may refer to\n", 
#&gt;                 "the same object.\n", list("\n", list(), " R objects usually have copy-on-write semantics. This is an\n", 
#&gt;                   "optimisation that ensures that objects are only copied if\n", 
#&gt;                   "needed. When you copy a vector, no memory is actually copied\n", 
#&gt;                   "until you modify either the original object or the copy is\n", 
#&gt;                   "modified.\n", "\n", "Note that the copy-on-write optimisation is an implementation\n", 
#&gt;                   "detail that is not guaranteed by the specification of the R\n", 
#&gt;                   "language.\n", list(), " Assigning an ", list(
#&gt;                     "uncopyable"), " object (like an\n", "environment) creates a reference. These objects are never copied\n", 
#&gt;                   "even if you modify one of the references.\n"), 
#&gt;                 "\n"), "\n", list("\n", "# Reassigning an uncopyable object such as an environment creates a\n", 
#&gt;                 "# reference:\n", "env &lt;- env()\n", "ref &lt;- env\n", 
#&gt;                 "is_reference(ref, env)\n", "\n", "# Due to copy-on-write optimisation, a copied vector can\n", 
#&gt;                 "# temporarily reference the original vector:\n", 
#&gt;                 "vec &lt;- 1:10\n", "copy &lt;- vec\n", "is_reference(copy, vec)\n", 
#&gt;                 "\n", "# Once you modify on of them, the copy is triggered in the\n", 
#&gt;                 "# background and the objects cease to reference each other:\n", 
#&gt;                 "vec[[1]] &lt;- 100\n", "is_reference(copy, vec)\n"), 
#&gt;             "\n", list("internal"), "\n"), is_stack.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("is_stack"), "\n", list("is_stack"), "\n", 
#&gt;             list("is_eval_stack"), "\n", list("is_call_stack"), 
#&gt;             "\n", list("Is object a stack?"), "\n", list("\n", 
#&gt;                 "is_stack(x)\n", "\n", "is_eval_stack(x)\n", 
#&gt;                 "\n", "is_call_stack(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n"), "\n", list("internal"), "\n"), is_symbol.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/sym.R", "\n", list(
#&gt;                 "is_symbol"), "\n", list("is_symbol"), "\n", 
#&gt;             list("Is object a symbol?"), "\n", list("\n", "is_symbol(x, name = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An optional name or vector of names that the symbol\n", 
#&gt;                   "should match.")), "\n"), "\n", list("\n", 
#&gt;                 "Is object a symbol?\n"), "\n"), is_true.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("is_true"), "\n", list("is_true"), "\n", list(
#&gt;                 "is_false"), "\n", list("Is object identical to TRUE or FALSE?"), 
#&gt;             "\n", list("\n", "is_true(x)\n", "\n", "is_false(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to test")), 
#&gt;                 "\n"), "\n", list("\n", "These functions bypass R's automatic conversion rules and check\n", 
#&gt;                 "that ", list("x"), " is literally ", list("TRUE"), 
#&gt;                 " or ", list("FALSE"), ".\n"), "\n", list("\n", 
#&gt;                 "is_true(TRUE)\n", "is_true(1)\n", "\n", "is_false(FALSE)\n", 
#&gt;                 "is_false(0)\n"), "\n"), is_weakref.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("is_weakref"), "\n", list("is_weakref"), "\n", 
#&gt;             list("Is object a weak reference?"), "\n", list("\n", 
#&gt;                 "is_weakref(x)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("An object to test.")), "\n"), "\n", 
#&gt;             list("\n", "Is object a weak reference?\n"), "\n"), 
#&gt;         lang.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang"), "\n", list("lang"), "\n", list(
#&gt;                 "new_language"), "\n", list("Create a call"), 
#&gt;             "\n", list("\n", "lang(.fn, ..., .ns = NULL)\n", 
#&gt;                 "\n", "new_language(head, tail = NULL)\n"), "\n", 
#&gt;             list("\n", list(list(".fn"), list("Function to call. Must be a callable object: a string,\n", 
#&gt;                 "symbol, call, or a function.")), "\n", "\n", 
#&gt;                 list(list("..."), list("Arguments to the call either in or out of a list. These dots\n", 
#&gt;                   "support ", list("tidy dots"), " features. Empty arguments are preserved.")), 
#&gt;                 "\n", "\n", list(list(".ns"), list("Namespace with which to prefix ", 
#&gt;                   list(".fn"), ". Must be a string\n", "or symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call2()")), " and\n", list(list("new_call()")), 
#&gt;                 " instead.\n"), "\n", list("internal"), "\n"), 
#&gt;         lang_head.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_head"), "\n", list("lang_head"), 
#&gt;             "\n", list("lang_tail"), "\n", list("Return the head or tail of a call"), 
#&gt;             "\n", list("\n", "lang_head(lang)\n", "\n", "lang_tail(lang)\n"), 
#&gt;             "\n", list("\n", list(list("lang"), list("A call.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "As of rlang 0.2.0 these functions are retired (deprecated for now)\n", 
#&gt;                 "because they are low level accessors that are rarely needed for end\n", 
#&gt;                 "users.\n"), "\n", list("internal"), "\n"), lang_modify.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("lang_modify"), "\n", list("lang_modify"), 
#&gt;             "\n", list("lang_standardise"), "\n", list("lang_fn"), 
#&gt;             "\n", list("lang_name"), "\n", list("lang_args"), 
#&gt;             "\n", list("lang_args_names"), "\n", list("Manipulate or access a call"), 
#&gt;             "\n", list("\n", "lang_modify(.lang, ..., .standardise = FALSE)\n", 
#&gt;                 "\n", "lang_standardise(lang)\n", "\n", "lang_fn(lang)\n", 
#&gt;                 "\n", "lang_name(lang)\n", "\n", "lang_args(lang)\n", 
#&gt;                 "\n", "lang_args_names(lang)\n"), "\n", list(
#&gt;                 "\n", list(list("..."), list("Named or unnamed expressions (constants, names or calls)\n", 
#&gt;                   "used to modify the call. Use ", list(list(
#&gt;                     "zap()")), " to remove arguments. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features. Empty arguments are\n", 
#&gt;                   "allowed and preserved.")), "\n", "\n", list(
#&gt;                   list(".standardise"), list("Soft-deprecated as of rlang 0.3.0. Please\n", 
#&gt;                     "call ", list(list("call_standardise()")), 
#&gt;                     " manually.")), "\n", "\n", list(list("lang, .lang"), 
#&gt;                   list("The ", list("call"), " or ", list(".call"), 
#&gt;                     " argument of the renamed\n", "functions.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated, please use ", 
#&gt;                 list(list("call_modify()")), ",\n", list(list(
#&gt;                   "call_standardise()")), ", or ", list(list(
#&gt;                   "call_fn()")), " instead.\n"), "\n", list("internal"), 
#&gt;             "\n"), last_error.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-abort.R", 
#&gt;             "\n", list("last_error"), "\n", list("last_error"), 
#&gt;             "\n", list("last_trace"), "\n", list("Last ", list(
#&gt;                 "abort()"), " error"), "\n", list("\n", "last_error()\n", 
#&gt;                 "\n", "last_trace()\n"), "\n", list("\n", list(
#&gt;                 "\n", list(), " ", list("last_error()"), " returns the last error thrown with ", 
#&gt;                 list(list("abort()")), ". The\n", "error is printed with a backtrace in simplified form.\n", 
#&gt;                 list(), " ", list("last_trace()"), " is a shortcut to return the backtrace stored in\n", 
#&gt;                 "the last error. This backtrace is printed in full form.\n"), 
#&gt;                 "\n"), "\n"), lifecycle.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle.R", 
#&gt;             "\n", list("lifecycle"), "\n", list("lifecycle"), 
#&gt;             "\n", list("Life cycle of the rlang package"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"maturing\")"), 
#&gt;                 "\n", "\n", "The rlang package is currently maturing. Unless otherwise stated,\n", 
#&gt;                 "this applies to all its exported functions. Maturing functions are\n", 
#&gt;                 "susceptible to API changes. Only use these in packages if you're\n", 
#&gt;                 "prepared to make changes as the package evolves. See sections below\n", 
#&gt;                 "for a list of functions marked as stable.\n", 
#&gt;                 "\n", "The documentation pages of retired functions contain life cycle\n", 
#&gt;                 "sections that explain the reasons for their retirements.\n"), 
#&gt;             "\n", list(list("Stable functions"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("eval_tidy()")), 
#&gt;                   "\n", list(), " ", list("!!"), ", ", list("!!!"), 
#&gt;                   "\n", list(), " ", list(list("enquo()")), ", ", 
#&gt;                   list(list("quo()")), ", ", list(list("quos()")), 
#&gt;                   "\n", list(), " ", list(list("enexpr()")), 
#&gt;                   ", ", list(list("expr()")), ", ", list(list(
#&gt;                     "exprs()")), "\n", list(), " ", list(list(
#&gt;                     "sym()")), ", ", list(list("syms()")), "\n", 
#&gt;                   list(), " ", list(list("new_quosure()")), ", ", 
#&gt;                   list(list("is_quosure()")), "\n", list(), " ", 
#&gt;                   list(list("missing_arg()")), ", ", list(list(
#&gt;                     "is_missing()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_expr()")), ", ", list(list(
#&gt;                     "quo_set_expr()")), "\n", list(), " ", list(
#&gt;                     list("quo_get_env()")), ", ", list(list("quo_set_env()")), 
#&gt;                   "\n", list(), " ", list(list("eval_bare()")), 
#&gt;                   "\n", list(), " ", list(list("set_names()")), 
#&gt;                   ", ", list(list("names2()")), "\n", list(), 
#&gt;                   " ", list(list("as_function()")), ", ", list(
#&gt;                     list("new_function()")), "\n"), "\n")), "\n", 
#&gt;             "\n", list(list("Experimental functions"), list("\n", 
#&gt;                 "\n", "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These functions are not yet part of the rlang API. Expect breaking\n", 
#&gt;                 "changes.\n", list("\n", list(), " ", list(list(
#&gt;                   "with_env()")), ", ", list(list("locally()")), 
#&gt;                   ", ", list(list("env_poke()")), "\n", list(), 
#&gt;                   " ", list(list("pkg_env()")), ", ", list(list(
#&gt;                     "pkg_env_name()")), ", ", list(list("ns_env()")), 
#&gt;                   ", ", list(list("ns_imports_env()")), ", ", 
#&gt;                   list(list("ns_env_name()")), "\n", list(), 
#&gt;                   " ", list(list("is_pairlist()")), ", ", list(
#&gt;                     list("as_pairlist()")), ", ", list(list("is_node()")), 
#&gt;                   ", ", list(list("is_node_list()")), "\n", list(), 
#&gt;                   " ", list(list("is_definition()")), ", ", list(
#&gt;                     list("new_definition()")), ", ", list(list(
#&gt;                     "is_formulaish()")), ",\n", list(list("dots_definitions()")), 
#&gt;                   "\n", list(), " ", list(list("scoped_options()")), 
#&gt;                   ", ", list(list("with_options()")), ", ", list(
#&gt;                     list("push_options()")), ",\n", list(list(
#&gt;                     "peek_options()")), ", ", list(list("peek_option()")), 
#&gt;                   "\n", list(), " ", list(list("as_bytes()")), 
#&gt;                   ", ", list(list("chr_unserialise_unicode()")), 
#&gt;                   "\n", list(), " ", list(list("caller_fn()")), 
#&gt;                   ", ", list(list("current_fn()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Questioning stage"), list(
#&gt;                 "\n", "\n", "\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("In the questioning stage as of rlang 0.4.0"), 
#&gt;                 "\n", "\n", "These functions are likely to be moved to the vctrs package:\n", 
#&gt;                 list("\n", list(), " ", list(list("lgl()")), 
#&gt;                   ", ", list(list("int()")), ", etc.\n", list(), 
#&gt;                   " ", list(list("new_logical()")), ", ", list(
#&gt;                     list("new_integer()")), ", etc.\n", list(), 
#&gt;                   " ", list("na_lgl"), ", ", list("na_int"), 
#&gt;                   ", ", list(list("is_lgl_na()")), ", ", list(
#&gt;                     list("is_int_na()")), ", etc.\n"), "\n", 
#&gt;                 "\n", list("In the questioning stage as of rlang 0.3.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("child_env()")), 
#&gt;                   "\n", list(), " ", list(list("flatten()")), 
#&gt;                   ", ", list(list("squash()")), ", and their atomic vector variants\n", 
#&gt;                   list(), " ", list(list("modify()")), " and ", 
#&gt;                   list(list("prepend()")), "\n", list(), " ", 
#&gt;                   list(list("with_restarts()")), ", ", list(list(
#&gt;                     "rst_list()")), ", ", list(list("rst_exists()")), 
#&gt;                   ", ", list(list("rst_jump()")), ",\n", list(
#&gt;                     list("rst_maybe_jump()")), ", ", list(list(
#&gt;                     "rst_abort()")), ". It is not clear yet whether we\n", 
#&gt;                   "want to recommend restarts as a style of programming in R.\n", 
#&gt;                   list(), " ", list(list("return_from()")), " and ", 
#&gt;                   list(list("return_to()")), ".\n", list(), " ", 
#&gt;                   list(list("expr_label()")), ", ", list(list(
#&gt;                     "expr_name()")), ", and ", list(list("expr_text()")), 
#&gt;                   ".\n"), "\n", "\n", list("In the questioning stage as of rlang 0.2.0"), 
#&gt;                 "\n", list("\n", list(), " ", list(list("UQ()")), 
#&gt;                   ", ", list(list("UQS()")), "\n", list(), " ", 
#&gt;                   list(list("dots_splice()")), ", ", list(list(
#&gt;                     "splice()")), "\n"), "\n")), "\n", "\n", 
#&gt;             list(list("Soft-deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                   "\n", "\n", list("Soft-deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("exiting()")), 
#&gt;                     ": Handlers are now treated as exiting by default.\n", 
#&gt;                     list(), " ", list(list("invoke()")), ": Use the simpler ", 
#&gt;                     list(list("exec()")), " instead.\n", list(), 
#&gt;                     " ", list(list("as_logical()")), ", ", list(
#&gt;                       list("as_integer()")), ", etc. =&gt; ", list(
#&gt;                       "vctrs::vec_cast()"), ".\n", list(), " ", 
#&gt;                     list(list("type_of()")), ", ", list(list(
#&gt;                       "switch_type()")), ", ", list(list("coerce_type()")), 
#&gt;                     ", ", list(list("switch_class()")), ",\n", 
#&gt;                     list(list("coerce_class()")), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Deprecated functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                   "\n", "\n", list("Bumped to deprecated in rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list(list("modify()")), 
#&gt;                     " and ", list(list("prepend()")), ".\n", 
#&gt;                     list(), " ", list("new_logical_along()"), 
#&gt;                     ", ", list("new_integer_along()"), ",\n", 
#&gt;                     list("new_double_along()"), ", ", list("new_complex_along()"), 
#&gt;                     ",\n", list("new_character_along()"), ", ", 
#&gt;                     list("new_raw_along()"), ", ", list("new_list_along()"), 
#&gt;                     ".\n", list(), " ", list(list("lang_modify()")), 
#&gt;                     " =&gt; ", list(list("call_modify()")), "\n", 
#&gt;                     list(), " ", list(list("lang_standardise()")), 
#&gt;                     " =&gt; ", list(list("call_standardise()")), 
#&gt;                     "\n", list(), " ", list(list("lang_fn()")), 
#&gt;                     " =&gt; ", list(list("call_fn()")), "\n", list(), 
#&gt;                     " ", list(list("lang_name()")), " =&gt; ", list(
#&gt;                       list("call_name()")), "\n", list(), " ", 
#&gt;                     list(list("lang_args()")), " =&gt; ", list(list(
#&gt;                       "call_args()")), "\n", list(), " ", list(
#&gt;                       list("lang_args_names()")), " =&gt; ", list(
#&gt;                       list("call_args_names()")), "\n", list(), 
#&gt;                     " ", list(list("lang_head()")), ", ", list(
#&gt;                       list("lang_tail()")), "\n", list(), " ", 
#&gt;                     list(list("lang()")), " =&gt; ", list(list("call2()")), 
#&gt;                     "\n", list(), " ", list(list("new_language()")), 
#&gt;                     " =&gt; ", list(list("new_call()")), "\n", list(), 
#&gt;                     " ", list(list("is_lang()")), " =&gt; ", list(
#&gt;                       list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("is_unary_lang()")), " =&gt; Use the ", 
#&gt;                     list("n"), " argument of ", list(list("is_call()")), 
#&gt;                     "\n", list(), " ", list(list("is_binary_lang()")), 
#&gt;                     " =&gt; Use the ", list("n"), " argument of ", 
#&gt;                     list(list("is_call()")), "\n", list(), " ", 
#&gt;                     list(list("quo_is_lang()")), " =&gt; ", list(
#&gt;                       list("quo_is_call()")), "\n", list(), " ", 
#&gt;                     list(list("call_modify()")), ": ", list(".standardise"), 
#&gt;                     " and ", list(".env"), " arguments.\n", list(), 
#&gt;                     " ", list(list("is_expr()")), " =&gt; ", list(
#&gt;                       list("is_expression()")), "\n", list(), 
#&gt;                     " ", list("quo_expr()"), " =&gt; ", list(list(
#&gt;                       "quo_squash()")), "\n", list(), " ", list(
#&gt;                       list("parse_quosure()")), " =&gt; ", list(
#&gt;                       list("parse_quo()")), "\n", list(), " ", 
#&gt;                     list(list("parse_quosures()")), " =&gt; ", list(
#&gt;                       list("parse_quos()")), "\n", list(), " Assigning non-quosure objects to quosure lists.\n", 
#&gt;                     list(), " ", list("as.character()"), " on quosures.\n", 
#&gt;                     list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": ", list(".cnd"), " =&gt; ", list("cnd"), 
#&gt;                     "\n", list(), " ", list(list("cnd_signal()")), 
#&gt;                     ": The ", list(".mufflable"), " argument no longer has any effect\n", 
#&gt;                     list(), " ", list("scoped_names()"), " =&gt; ", 
#&gt;                     list(list("base::search()")), "\n", list(), 
#&gt;                     " ", list("is_scoped()"), " =&gt; ", list(list(
#&gt;                       "is_attached()")), "\n", list(), " ", list(
#&gt;                       "scoped_env()"), " =&gt; ", list(list("search_env()")), 
#&gt;                     "\n", list(), " ", list("scoped_envs()"), 
#&gt;                     " =&gt; ", list(list("search_envs()")), "\n", 
#&gt;                     list(), " ", list("env_bind_exprs()"), " =&gt; ", 
#&gt;                     list(list("env_bind_lazy()")), "\n", list(), 
#&gt;                     " ", list("env_bind_fns()"), " =&gt; ", list(
#&gt;                       list("env_bind_active()")), "\n", list(), 
#&gt;                     " Passing a function or formula to ", list(
#&gt;                       "env_depth()"), ",\n", list("env_poke_parent()"), 
#&gt;                     ", ", list("env_parent&lt;-"), ", ", list("env_tail()"), 
#&gt;                     ", ", list("set_env()"), ",\n", list("env_clone()"), 
#&gt;                     ", ", list("env_inherits()"), ", ", list(
#&gt;                       "env_bind()"), ",\n", list("scoped_bindings()"), 
#&gt;                     ", ", list("with_bindings()"), ", ", list(
#&gt;                       "env_poke()"), ",\n", list("env_has()"), 
#&gt;                     ", ", list("env_get()"), ", ", list("env_names()"), 
#&gt;                     ", ", list("env_bind_exprs()"), " and\n", 
#&gt;                     list("env_bind_fns()"), ". This internal genericity was causing confusion\n", 
#&gt;                     "(see issue #427). You should now extract the environment\n", 
#&gt;                     "separately before calling these functions.\n", 
#&gt;                     list(), " ", list(list("get_env()")), ": The ", 
#&gt;                     list("env"), " argument no longer has a default and must be supplied\n", 
#&gt;                     list(), " ", list(list("is_frame()")), ", ", 
#&gt;                     list(list("global_frame()")), ", ", list(
#&gt;                       list("current_frame()")), ",\n", list(list(
#&gt;                       "ctxt_frame()")), ", ", list(list("call_frame()")), 
#&gt;                     ", ", list(list("frame_position()")), ",\n", 
#&gt;                     list(list("caller_frame()")), "\n", list(), 
#&gt;                     " ", list(list("ctxt_depth()")), ", ", list(
#&gt;                       list("call_depth()")), ", ", list(list(
#&gt;                       "ctxt_stack()")), ", ", list(list("call_stack()")), 
#&gt;                     ",\n", list(list("stack_trim()")), "\n", 
#&gt;                     list(), " ", list(list("set_attrs()")), ", ", 
#&gt;                     list(list("mut_attrs()")), "\n", list(), 
#&gt;                     " The ", list("width"), " and ", list("printer"), 
#&gt;                     " arguments of ", list(list("exprs_auto_name()")), 
#&gt;                     " and\n", list(list("quos_auto_name()")), 
#&gt;                     " no longer have any effect. For the same\n", 
#&gt;                     "reason, passing a width as ", list(".named"), 
#&gt;                     " argument of dots collectors\n", "like ", 
#&gt;                     list("quos()"), " is deprecated.\n", list(), 
#&gt;                     " ", list("as_overscope()"), " =&gt; ", list(
#&gt;                       list("as_data_mask()")), "\n", list(), 
#&gt;                     " ", list("new_overscope()"), " =&gt; ", list(
#&gt;                       list("new_data_mask()")), "\n", list(), 
#&gt;                     " ", list("overscope_eval_next()"), " =&gt; ", 
#&gt;                     list(list("eval_tidy()")), "\n", list(), 
#&gt;                     " ", list("overscope_clean()"), "\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Defunct functions and arguments"), 
#&gt;                 list("\n", "\n", "\n", list("rlang:::lifecycle(\"defunct\")"), 
#&gt;                   "\n", "\n", list("Defunct as of rlang 0.4.0"), 
#&gt;                   "\n", list("\n", list(), " ", list("length()"), 
#&gt;                     " and ", list("names()"), " on tidy eval ", 
#&gt;                     list(".data"), " pronouns.\n", list(), " Supplying a named ", 
#&gt;                     list("!!!"), " call.\n", list(), " ", list(
#&gt;                       list("as_data_mask()")), ": ", list("parent"), 
#&gt;                     " argument\n", list(), " ", list(list("new_data_mask()")), 
#&gt;                     ": ", list("parent"), " argument\n", list(), 
#&gt;                     " ", list(list("env_tail()")), ": ", list(
#&gt;                       "sentinel"), " =&gt; ", list("last"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ": ", list("msg"), ", ", list("type"), " =&gt; ", 
#&gt;                     list(".msg"), ", ", list(".type"), "\n", 
#&gt;                     list(), " ", list(list("abort()")), ", ", 
#&gt;                     list(list("warn()")), ", ", list(list("inform()")), 
#&gt;                     ", ", list(list("cnd()")), ", ", list(list(
#&gt;                       "error_cnd()")), ",\n", list(list("warning_cnd()")), 
#&gt;                     ", ", list(list("message_cnd()")), ": ", 
#&gt;                     list("call"), " argument.\n", list(), " ", 
#&gt;                     list(list("is_character()")), ", ", list(
#&gt;                       list("is_string()")), ", and variants: The ", 
#&gt;                     list("encoding"), "\n", "argument.\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Archived"), list("\n", "\n", 
#&gt;                 "\n", list("rlang:::lifecycle(\"archived\")"), 
#&gt;                 "\n", "\n", "These functions were entirely removed from the package. You will\n", 
#&gt;                 "find them in the commit history and previous releases.\n", 
#&gt;                 "\n", list("Archived as of rlang 0.4.0"), "\n", 
#&gt;                 list("\n", list(), " ", list("UQE()"), "\n", 
#&gt;                   list(), " ", list("as_dictionary()"), ", ", 
#&gt;                   list("is_dictionary()"), "\n", list(), " ", 
#&gt;                   list("as_quosureish()"), ", ", list("is_quosureish()"), 
#&gt;                   "\n", list(), " ", list("eval_tidy_()"), "\n", 
#&gt;                   list(), " ", list("mut_utf8_locale()"), ", ", 
#&gt;                   list("mut_latin1_locale()"), ", ", list("mut_mbcs_locale()"), 
#&gt;                   "\n", list(), " ", list("set_chr_encoding()"), 
#&gt;                   ", ", list("chr_encoding()"), ", ", list("set_str_encoding()"), 
#&gt;                   ", ", list("str_encoding()"), "\n", list(), 
#&gt;                   " ", list("as_native_character()"), ", ", list(
#&gt;                     "as_utf8_string()"), ", ", list("as_native_string()"), 
#&gt;                   "\n", list(), " ", list("lang_type_of()"), 
#&gt;                   ", ", list("switch_lang()"), ", ", list("coerce_lang()"), 
#&gt;                   "\n"), "\n", "\n", list("Archived as of rlang 0.3.0:"), 
#&gt;                 "\n", list("\n", list(), " ", list("cnd_inform()"), 
#&gt;                   ", ", list("cnd_warn()"), " and ", list("cnd_abort()"), 
#&gt;                   "\n", list(), " ", list("new_cnd()"), " =&gt; ", 
#&gt;                   list(list("cnd()")), "\n", list(), " ", list(
#&gt;                     "cnd_message()"), " =&gt; ", list(list("message_cnd()")), 
#&gt;                   "\n", list(), " ", list("cnd_warning()"), " =&gt; ", 
#&gt;                   list(list("warning_cnd()")), "\n", list(), 
#&gt;                   " ", list("cnd_error()"), " =&gt; ", list(list(
#&gt;                     "error_cnd()")), "\n", list(), " ", list(
#&gt;                     "rst_muffle()"), " =&gt; ", list(list("cnd_muffle()")), 
#&gt;                   "\n", list(), " ", list("inplace()"), " =&gt; ", 
#&gt;                   list(list("calling()")), ". The ", list("muffle"), 
#&gt;                   " argument of ", list("inplace()"), "\n", "has not been implemented in ", 
#&gt;                   list("calling()"), " and is now defunct.\n", 
#&gt;                   list(), " ", list(list("cnd_signal()")), ": ", 
#&gt;                   list(".msg"), " and ", list(".call"), ".\n", 
#&gt;                   list(), " ", list(list("cnd()")), ", ", list(
#&gt;                     list("error_cnd()")), ", ", list(list("warning_cnd()")), 
#&gt;                   " and ", list(list("message_cnd()")), ":\n", 
#&gt;                   list(".msg"), " =&gt; ", list("message"), ".\n"), 
#&gt;                 "\n")), "\n", "\n", list("internal"), "\n"), 
#&gt;         missing.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-na.R", 
#&gt;             "\n", list("data"), "\n", list("missing"), "\n", 
#&gt;             list("missing"), "\n", list("na_lgl"), "\n", list(
#&gt;                 "na_int"), "\n", list("na_dbl"), "\n", list("na_chr"), 
#&gt;             "\n", list("na_cpl"), "\n", list("Missing values"), 
#&gt;             "\n", list("An object of class ", list("logical"), 
#&gt;                 " of length 1."), "\n", list("\n", "na_lgl\n", 
#&gt;                 "\n", "na_int\n", "\n", "na_dbl\n", "\n", "na_chr\n", 
#&gt;                 "\n", "na_cpl\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Missing values are represented in R with the general symbol\n", 
#&gt;                 list("NA"), ". They can be inserted in almost all data containers: all\n", 
#&gt;                 "atomic vectors except raw vectors can contain missing values. To\n", 
#&gt;                 "achieve this, R automatically converts the general ", 
#&gt;                 list("NA"), " symbol to a\n", "typed missing value appropriate for the target vector. The objects\n", 
#&gt;                 "provided here are aliases for those typed ", 
#&gt;                 list("NA"), " objects.\n"), "\n", list("\n", 
#&gt;                 "Typed missing values are necessary because R needs sentinel values\n", 
#&gt;                 "of the same type (i.e. the same machine representation of the data)\n", 
#&gt;                 "as the containers into which they are inserted. The official typed\n", 
#&gt;                 "missing values are ", list("NA_integer_"), ", ", 
#&gt;                 list("NA_real_"), ", ", list("NA_character_"), 
#&gt;                 " and\n", list("NA_complex_"), ". The missing value for logical vectors is simply the\n", 
#&gt;                 "default ", list("NA"), ". The aliases provided in rlang are consistently named\n", 
#&gt;                 "and thus simpler to remember. Also, ", list(
#&gt;                   "na_lgl"), " is provided as an\n", "alias to ", 
#&gt;                 list("NA"), " that makes intent clearer.\n", 
#&gt;                 "\n", "Since ", list("na_lgl"), " is the default ", 
#&gt;                 list("NA"), ", expressions such as ", list("c(NA, NA)"), 
#&gt;                 "\n", "yield logical vectors as no data is available to give a clue of the\n", 
#&gt;                 "target type. In the same way, since lists and environments can\n", 
#&gt;                 "contain any types, expressions like ", list(
#&gt;                   "list(NA)"), " store a logical\n", list("NA"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These shortcuts might be moved to the vctrs package at some\n", 
#&gt;                 "point. This is why they are marked as questioning.\n")), 
#&gt;             "\n", "\n", list("\n", "typeof(NA)\n", "typeof(na_lgl)\n", 
#&gt;                 "typeof(na_int)\n", "\n", "# Note that while the base R missing symbols cannot be overwritten,\n", 
#&gt;                 "# that's not the case for rlang's aliases:\n", 
#&gt;                 "na_dbl &lt;- NA\n", "typeof(na_dbl)\n"), "\n", 
#&gt;             list("datasets"), "\n", list("internal"), "\n"), 
#&gt;         missing_arg.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/arg.R", "\n", 
#&gt;             list("missing_arg"), "\n", list("missing_arg"), "\n", 
#&gt;             list("is_missing"), "\n", list("maybe_missing"), 
#&gt;             "\n", list("Generate or handle a missing argument"), 
#&gt;             "\n", list("\n", "missing_arg()\n", "\n", "is_missing(x)\n", 
#&gt;                 "\n", "maybe_missing(x, default = missing_arg())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object that might be the missing argument.")), 
#&gt;                 "\n", "\n", list(list("default"), list("The object to return if the input is missing,\n", 
#&gt;                   "defaults to ", list("missing_arg()"), ".")), 
#&gt;                 "\n"), "\n", list("\n", "These functions help using the missing argument as a regular R\n", 
#&gt;                 "object.\n", list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " generates a missing argument.\n", list(), 
#&gt;                   " ", list("is_missing()"), " is like ", list(
#&gt;                     list("base::missing()")), " but also supports\n", 
#&gt;                   "testing for missing arguments contained in other objects like\n", 
#&gt;                   "lists.\n", list(), " ", list("maybe_missing()"), 
#&gt;                   " is useful to pass down an input that might be\n", 
#&gt;                   "missing to another function, potentially substituting by a\n", 
#&gt;                   "default value. It avoids triggering an \"argument is missing\" error.\n"), 
#&gt;                 "\n"), "\n", list(list("Other ways to reify the missing argument"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "base::quote(expr = )"), " is the canonical way to create a missing\n", 
#&gt;                   "argument object.\n", list(), " ", list("expr()"), 
#&gt;                   " called without argument creates a missing argument.\n", 
#&gt;                   list(), " ", list("quo()"), " called without argument creates an empty quosure, i.e. a\n", 
#&gt;                   "quosure containing the missing argument object.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Fragility of the missing argument object"), 
#&gt;                 list("\n", "\n", "\n", "The missing argument is an object that triggers an error if and\n", 
#&gt;                   "only if it is the result of evaluating a symbol. No error is\n", 
#&gt;                   "produced when a function call evaluates to the missing argument\n", 
#&gt;                   "object. This means that expressions like ", 
#&gt;                   list("x[[1]] &lt;- missing_arg()"), "\n", "are perfectly safe. Likewise, ", 
#&gt;                   list("x[[1]]"), " is safe even if the result\n", 
#&gt;                   "is the missing object.\n", "\n", "However, as soon as the missing argument is passed down between\n", 
#&gt;                   "functions through an argument, you're at risk of triggering a\n", 
#&gt;                   "missing error. This is because arguments are passed through\n", 
#&gt;                   "symbols. To work around this, ", list("is_missing()"), 
#&gt;                   " and ", list("maybe_missing(x)"), "\n", "use a bit of magic to determine if the input is the missing\n", 
#&gt;                   "argument without triggering a missing error.\n", 
#&gt;                   "\n", list("maybe_missing()"), " is particularly useful for prototyping\n", 
#&gt;                   "meta-programming algorithms in R. The missing argument is a likely\n", 
#&gt;                   "input when computing on the language because it is a standard\n", 
#&gt;                   "object in formals lists. While C functions are always allowed to\n", 
#&gt;                   "return the missing argument and pass it to other C functions, this\n", 
#&gt;                   "is not the case on the R side. If you're implementing your\n", 
#&gt;                   "meta-programming algorithm in R, use ", list(
#&gt;                     "maybe_missing()"), " when an\n", "input might be the missing argument object.\n")), 
#&gt;             "\n", "\n", list(list("Life cycle"), list("\n", "\n", 
#&gt;                 list("\n", list(), " ", list("missing_arg()"), 
#&gt;                   " and ", list("is_missing()"), " are stable.\n", 
#&gt;                   list(), " Like the rest of rlang, ", list("maybe_missing()"), 
#&gt;                   " is maturing.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# The missing argument usually arises inside a function when the\n", 
#&gt;                 "# user omits an argument that does not have a default:\n", 
#&gt;                 "fn &lt;- function(x) is_missing(x)\n", "fn()\n", 
#&gt;                 "\n", "# Creating a missing argument can also be useful to generate calls\n", 
#&gt;                 "args &lt;- list(1, missing_arg(), 3, missing_arg())\n", 
#&gt;                 "quo(fn(!!! args))\n", "\n", "# Other ways to create that object include:\n", 
#&gt;                 "quote(expr = )\n", "expr()\n", "\n", "# It is perfectly valid to generate and assign the missing\n", 
#&gt;                 "# argument in a list.\n", "x &lt;- missing_arg()\n", 
#&gt;                 "l &lt;- list(missing_arg())\n", "\n", "# Just don't evaluate a symbol that contains the empty argument.\n", 
#&gt;                 "# Evaluating the object `x` that we created above would trigger an\n", 
#&gt;                 "# error.\n", "# x  # Not run\n", "\n", "# On the other hand accessing a missing argument contained in a\n", 
#&gt;                 "# list does not trigger an error because subsetting is a function\n", 
#&gt;                 "# call:\n", "l[[1]]\n", "is.null(l[[1]])\n", 
#&gt;                 "\n", "# In case you really need to access a symbol that might contain the\n", 
#&gt;                 "# empty argument object, use maybe_missing():\n", 
#&gt;                 "maybe_missing(x)\n", "is.null(maybe_missing(x))\n", 
#&gt;                 "is_missing(maybe_missing(x))\n", "\n", "\n", 
#&gt;                 "# Note that base::missing() only works on symbols and does not\n", 
#&gt;                 "# support complex expressions. For this reason the following lines\n", 
#&gt;                 "# would throw an error:\n", "\n", "#&gt; missing(missing_arg())\n", 
#&gt;                 "#&gt; missing(l[[1]])\n", "\n", "# while is_missing() will work as expected:\n", 
#&gt;                 "is_missing(missing_arg())\n", "is_missing(l[[1]])\n"), 
#&gt;             "\n"), mut_node_car.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("mut_node_car"), "\n", list("mut_node_car"), 
#&gt;             "\n", list("mut_node_cdr"), "\n", list("mut_node_caar"), 
#&gt;             "\n", list("mut_node_cadr"), "\n", list("mut_node_cdar"), 
#&gt;             "\n", list("mut_node_cddr"), "\n", list("mut_node_tag"), 
#&gt;             "\n", list("Mutate node components"), "\n", list(
#&gt;                 "\n", "mut_node_car(x, newcar)\n", "\n", "mut_node_cdr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_caar(x, newcar)\n", "\n", "mut_node_cadr(x, newcar)\n", 
#&gt;                 "\n", "mut_node_cdar(x, newcdr)\n", "\n", "mut_node_cddr(x, newcdr)\n", 
#&gt;                 "\n", "mut_node_tag(x, newtag)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newcar"), list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newcdr"), list("The new CAR or CDR for the node. These\n", 
#&gt;                     "can be any R objects.")), "\n", "\n", list(
#&gt;                   list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("node_poke_"), "\n", "prefix in rlang 0.2.0. This change follows a new naming convention\n", 
#&gt;                 "where mutation is referred to as \"poking\".\n"), 
#&gt;             "\n", list("internal"), "\n"), names2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("names2"), "\n", list("names2"), "\n", 
#&gt;             list("Get names of a vector"), "\n", list("\n", "names2(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This names getter always returns a character vector, even when an\n", 
#&gt;                 "object does not have a ", list("names"), " attribute. In this case, it returns\n", 
#&gt;                 "a vector of empty names ", list("\"\""), ". It also standardises missing names to\n", 
#&gt;                 list("\"\""), ".\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", list("names2()"), " is stable.\n")), 
#&gt;             "\n", "\n", list("\n", "names2(letters)\n", "\n", 
#&gt;                 "# It also takes care of standardising missing names:\n", 
#&gt;                 "x &lt;- set_names(1:3, c(\"a\", NA, \"b\"))\n", 
#&gt;                 "names2(x)\n"), "\n"), `new-vector-along-retired.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("new-vector-along-retired"), "\n", list(
#&gt;                 "new-vector-along-retired"), "\n", list("new_logical_along"), 
#&gt;             "\n", list("new_integer_along"), "\n", list("new_double_along"), 
#&gt;             "\n", list("new_character_along"), "\n", list("new_complex_along"), 
#&gt;             "\n", list("new_raw_along"), "\n", list("new_list_along"), 
#&gt;             "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "new_logical_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_integer_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_double_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_character_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_complex_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_raw_along(x, names = base::names(x))\n", 
#&gt;                 "\n", "new_list_along(x, names = base::names(x))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A vector.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions are deprecated as of rlang 0.3.0 because they\n", 
#&gt;                 "are longer to type than the equivalent ", list(
#&gt;                   list("rep_along()")), " or\n", list(list("rep_named()")), 
#&gt;                 " calls without added clarity.\n"), "\n", list(
#&gt;                 "internal"), "\n"), `new-vector.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("new-vector"), "\n", list("new-vector"), 
#&gt;             "\n", list("new_logical"), "\n", list("new_integer"), 
#&gt;             "\n", list("new_double"), "\n", list("new_character"), 
#&gt;             "\n", list("new_complex"), "\n", list("new_raw"), 
#&gt;             "\n", list("new_list"), "\n", list("Create vectors matching a given length"), 
#&gt;             "\n", list("\n", "new_logical(n, names = NULL)\n", 
#&gt;                 "\n", "new_integer(n, names = NULL)\n", "\n", 
#&gt;                 "new_double(n, names = NULL)\n", "\n", "new_character(n, names = NULL)\n", 
#&gt;                 "\n", "new_complex(n, names = NULL)\n", "\n", 
#&gt;                 "new_raw(n, names = NULL)\n", "\n", "new_list(n, names = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("n"), list("The vector length.")), 
#&gt;                 "\n", "\n", list(list("names"), list("Names for the new vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "These functions construct vectors of a given length, with attributes\n", 
#&gt;                 "specified via dots. Except for ", list("new_list()"), 
#&gt;                 " and ", list("new_raw()"), ", the\n", "empty vectors are filled with typed ", 
#&gt;                 list("missing"), " values. This is in\n", "contrast to the base function ", 
#&gt;                 list(list("base::vector()")), " which creates\n", 
#&gt;                 "zero-filled vectors.\n"), "\n", list(list("Lifecycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are likely to be replaced by a vctrs equivalent in\n", 
#&gt;                   "the future. They are in the questioning lifecycle stage.\n")), 
#&gt;             "\n", "\n", list("\n", "new_list(10)\n", "new_logical(10)\n"), 
#&gt;             "\n", list("\n", "rep_along\n"), "\n", list("internal"), 
#&gt;             "\n"), new_call.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_call"), "\n", list("new_call"), "\n", 
#&gt;             list("Create a new call from components"), "\n", 
#&gt;             list("\n", "new_call(car, cdr = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("car"), list("The head of the call. It should be a\n", 
#&gt;                 list("callable"), " object: a symbol, call, or literal\n", 
#&gt;                 "function.")), "\n", "\n", list(list("cdr"), 
#&gt;                 list("The tail of the call, i.e. a ", list("node list"), 
#&gt;                   " of\n", "arguments.")), "\n"), "\n", list(
#&gt;                 "\n", "Create a new call from components\n"), 
#&gt;             "\n", list("internal"), "\n"), new_formula.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/formula.R", "\n", 
#&gt;             list("new_formula"), "\n", list("new_formula"), "\n", 
#&gt;             list("Create a formula"), "\n", list("\n", "new_formula(lhs, rhs, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("lhs, rhs"), list("A call, name, or atomic vector.")), 
#&gt;                 "\n", "\n", list(list("env"), list("An environment.")), 
#&gt;                 "\n"), "\n", list("\n", "A formula object.\n"), 
#&gt;             "\n", list("\n", "Create a formula\n"), "\n", list(
#&gt;                 "\n", "new_formula(quote(a), quote(b))\n", "new_formula(NULL, quote(b))\n"), 
#&gt;             "\n", list("\n", list(list("new_quosure()")), "\n"), 
#&gt;             "\n"), new_function.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fn.R", "\n", 
#&gt;             list("new_function"), "\n", list("new_function"), 
#&gt;             "\n", list("Create a function"), "\n", list("\n", 
#&gt;                 "new_function(args, body, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("args"), list("A named list or pairlist of default arguments. Note\n", 
#&gt;                 "that if you want arguments that don't have defaults, you'll need\n", 
#&gt;                 "to use the special function ", list(list("pairlist2()")), 
#&gt;                 ". If you need quoted\n", "defaults, use ", list(
#&gt;                   list("exprs()")), ".")), "\n", "\n", list(list(
#&gt;                 "body"), list("A language object representing the code inside the\n", 
#&gt;                 "function. Usually this will be most easily generated with\n", 
#&gt;                 list(list("base::quote()")))), "\n", "\n", list(
#&gt;                 list("env"), list("The parent environment of the function, defaults to the\n", 
#&gt;                   "calling environment of ", list("new_function()"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This constructs a new function given its three components:\n", 
#&gt;                 "list of arguments, body code and parent environment.\n"), 
#&gt;             "\n", list("\n", "f &lt;- function() letters\n", "g &lt;- new_function(NULL, quote(letters))\n", 
#&gt;                 "identical(f, g)\n", "\n", "# Pass a list or pairlist of named arguments to create a function\n", 
#&gt;                 "# with parameters. The name becomes the parameter name and the\n", 
#&gt;                 "# argument the default value for this parameter:\n", 
#&gt;                 "new_function(list(x = 10), quote(x))\n", "new_function(pairlist2(x = 10), quote(x))\n", 
#&gt;                 "\n", "# Use `exprs()` to create quoted defaults. Compare:\n", 
#&gt;                 "new_function(pairlist2(x = 5 + 5), quote(x))\n", 
#&gt;                 "new_function(exprs(x = 5 + 5), quote(x))\n", 
#&gt;                 "\n", "# Pass empty arguments to omit defaults. `list()` doesn't allow\n", 
#&gt;                 "# empty arguments but `pairlist2()` does:\n", 
#&gt;                 "new_function(pairlist2(x = , y = 5 + 5), quote(x + y))\n", 
#&gt;                 "new_function(exprs(x = , y = 5 + 5), quote(x + y))\n"), 
#&gt;             "\n"), new_node.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/node.R", 
#&gt;             "\n", list("new_node"), "\n", list("new_node"), "\n", 
#&gt;             list("node_car"), "\n", list("node_cdr"), "\n", list(
#&gt;                 "node_caar"), "\n", list("node_cadr"), "\n", 
#&gt;             list("node_cdar"), "\n", list("node_cddr"), "\n", 
#&gt;             list("node_poke_car"), "\n", list("node_poke_cdr"), 
#&gt;             "\n", list("node_poke_caar"), "\n", list("node_poke_cadr"), 
#&gt;             "\n", list("node_poke_cdar"), "\n", list("node_poke_cddr"), 
#&gt;             "\n", list("node_tag"), "\n", list("node_poke_tag"), 
#&gt;             "\n", list("Helpers for pairlist and language nodes"), 
#&gt;             "\n", list("\n", "new_node(car, cdr = NULL)\n", "\n", 
#&gt;                 "node_car(x)\n", "\n", "node_cdr(x)\n", "\n", 
#&gt;                 "node_caar(x)\n", "\n", "node_cadr(x)\n", "\n", 
#&gt;                 "node_cdar(x)\n", "\n", "node_cddr(x)\n", "\n", 
#&gt;                 "node_poke_car(x, newcar)\n", "\n", "node_poke_cdr(x, newcdr)\n", 
#&gt;                 "\n", "node_poke_caar(x, newcar)\n", "\n", "node_poke_cadr(x, newcar)\n", 
#&gt;                 "\n", "node_poke_cdar(x, newcdr)\n", "\n", "node_poke_cddr(x, newcdr)\n", 
#&gt;                 "\n", "node_tag(x)\n", "\n", "node_poke_tag(x, newtag)\n"), 
#&gt;             "\n", list("\n", list(list("car, newcar, cdr, newcdr"), 
#&gt;                 list("The new CAR or CDR for the node. These\n", 
#&gt;                   "can be any R objects.")), "\n", "\n", list(
#&gt;                 list("x"), list("A language or pairlist node. Note that these functions are\n", 
#&gt;                   "barebones and do not perform any type checking.")), 
#&gt;                 "\n", "\n", list(list("newtag"), list("The new tag for the node. This should be a symbol.")), 
#&gt;                 "\n"), "\n", list("\n", "Setters like ", list(
#&gt;                 "node_poke_car()"), " invisibly return ", list(
#&gt;                 "x"), " modified\n", "in place. Getters return the requested node component.\n"), 
#&gt;             "\n", list("\n", list("Important"), ": These functions are for expert R programmers only.\n", 
#&gt;                 "You should only use them if you feel comfortable manipulating low\n", 
#&gt;                 "level R data structures at the C level. We export them at the R level\n", 
#&gt;                 "in order to make it easy to prototype C code. They don't perform\n", 
#&gt;                 "any type checking and can crash R very easily (try to take the CAR\n", 
#&gt;                 "of an integer vector --- save any important objects beforehand!).\n"), 
#&gt;             "\n", list("\n", list(list("duplicate()")), " for creating copy-safe objects and\n", 
#&gt;                 list(list("base::pairlist()")), " for an easier way of creating a linked list of\n", 
#&gt;                 "nodes.\n"), "\n", list("internal"), "\n"), new_quosures.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "new_quosures"), "\n", list("new_quosures"), 
#&gt;             "\n", list("as_quosures"), "\n", list("is_quosures"), 
#&gt;             "\n", list("Create a list of quosures"), "\n", list(
#&gt;                 "\n", "new_quosures(x)\n", "\n", "as_quosures(x, env, named = FALSE)\n", 
#&gt;                 "\n", "is_quosures(x)\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("A list of quosures or objects to coerce to quosures.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The default environment for the new quosures.")), 
#&gt;                 "\n", "\n", list(list("named"), list("Whether to name the list with ", 
#&gt;                   list(list("quos_auto_name()")), ".")), "\n"), 
#&gt;             "\n", list("\n", "This small S3 class provides methods for ", 
#&gt;                 list("["), " and ", list("c()"), " and ensures\n", 
#&gt;                 "the following invariants:\n", list("\n", list(), 
#&gt;                   " The list only contains quosures.\n", list(), 
#&gt;                   " It is always named, possibly with a vector of empty strings.\n"), 
#&gt;                 "\n", "\n", list("new_quosures()"), " takes a list of quosures and adds the ", 
#&gt;                 list("quosures"), "\n", "class and a vector of empty names if needed. ", 
#&gt;                 list("as_quosures()"), " calls\n", list(list(
#&gt;                   "as_quosure()")), " on all elements before creating the ", 
#&gt;                 list("quosures"), "\n", "object.\n"), "\n"), 
#&gt;         new_weakref.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/weakref.R", 
#&gt;             "\n", list("new_weakref"), "\n", list("new_weakref"), 
#&gt;             "\n", list("Create a weak reference"), "\n", list(
#&gt;                 "\n", "new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("key"), list("The key for the weak reference. Must be a reference object -- that\n", 
#&gt;                 "is, an environment or external pointer.")), 
#&gt;                 "\n", "\n", list(list("value"), list("The value for the weak reference. This can be ", 
#&gt;                   list("NULL"), ", if you\n", "want to use the weak reference like a weak pointer.")), 
#&gt;                 "\n", "\n", list(list("finalizer"), list("A function that is run after the key becomes unreachable.")), 
#&gt;                 "\n", "\n", list(list("on_quit"), list("Should the finalizer be run when R exits?")), 
#&gt;                 "\n"), "\n", list("\n", "A weak reference is a special R object which makes it possible to keep a\n", 
#&gt;                 "reference to an object without preventing garbage collection of that object.\n", 
#&gt;                 "It can also be used to keep data about an object without preventing GC of the\n", 
#&gt;                 "object, similar to WeakMaps in JavaScript.\n", 
#&gt;                 "\n", "Objects in R are considered ", list("reachable"), 
#&gt;                 " if they can be accessed by following\n", "a chain of references, starting from a ", 
#&gt;                 list("root node"), "; root nodes are\n", "specially-designated R objects, and include the global environment and base\n", 
#&gt;                 "environment. As long as the key is reachable, the value will not be garbage\n", 
#&gt;                 "collected. This is true even if the weak reference object becomes\n", 
#&gt;                 "unreachable. The key effectively prevents the weak reference and its value\n", 
#&gt;                 "from being collected, according to the following chain of ownership:\n", 
#&gt;                 list("weakref &lt;- key -&gt; value"), ".\n", "\n", 
#&gt;                 "When the key becomes unreachable, the key and value in the weak reference\n", 
#&gt;                 "object are replaced by ", list("NULL"), ", and the finalizer is scheduled to execute.\n"), 
#&gt;             "\n", list("\n", "e &lt;- env()\n", "\n", "# Create a weak reference to e\n", 
#&gt;                 "w &lt;- new_weakref(e, finalizer = function(e) message(\"finalized\"))\n", 
#&gt;                 "\n", "# Get the key object from the weak reference\n", 
#&gt;                 "identical(wref_key(w), e)\n", "\n", "# When the regular reference (the `e` binding) is removed and a GC occurs,\n", 
#&gt;                 "# the weak reference will not keep the object alive.\n", 
#&gt;                 "rm(e)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "\n", "\n", "# A weak reference with a key and value. The value contains data about the\n", 
#&gt;                 "# key.\n", "k &lt;- env()\n", "v &lt;- list(1, 2, 3)\n", 
#&gt;                 "w &lt;- new_weakref(k, v)\n", "\n", "identical(wref_key(w), k)\n", 
#&gt;                 "identical(wref_value(w), v)\n", "\n", "# When v is removed, the weak ref keeps it alive because k is still reachable.\n", 
#&gt;                 "rm(v)\n", "gc()\n", "identical(wref_value(w), list(1, 2, 3))\n", 
#&gt;                 "\n", "# When k is removed, the weak ref does not keep k or v alive.\n", 
#&gt;                 "rm(k)\n", "gc()\n", "identical(wref_key(w), NULL)\n", 
#&gt;                 "identical(wref_value(w), NULL)\n"), "\n", list(
#&gt;                 "\n", list(list("is_weakref()")), ", ", list(
#&gt;                   list("wref_key()")), " and ", list(list("wref_value()")), 
#&gt;                 ".\n"), "\n", list("experimental"), "\n"), ns_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("ns_env"), "\n", list("ns_env"), "\n", 
#&gt;             list("ns_imports_env"), "\n", list("ns_env_name"), 
#&gt;             "\n", list("Get the namespace of a package"), "\n", 
#&gt;             list("\n", "ns_env(x = caller_env())\n", "\n", "ns_imports_env(x = caller_env())\n", 
#&gt;                 "\n", "ns_env_name(x = caller_env())\n"), "\n", 
#&gt;             list("\n", list(list("x"), list(list("\n", list(), 
#&gt;                 " For ", list("ns_env()"), ", the name of a package or an environment as a\n", 
#&gt;                 "string.\n", list("\n", list(), " An environment (the current environment by default).\n", 
#&gt;                   list(), " A function.\n"), "\n", "\n", "In the latter two cases, the environment ancestry is searched for\n", 
#&gt;                 "a namespace with ", list(list("base::topenv()")), 
#&gt;                 ". If the environment doesn't\n", "inherit from a namespace, this is an error.\n"))), 
#&gt;                 "\n", "\n", list(list("env"), list("A namespace environment.")), 
#&gt;                 "\n"), "\n", list("\n", "Namespaces are the environment where all the functions of a package\n", 
#&gt;                 "live. The parent environments of namespaces are the ", 
#&gt;                 list("imports"), "\n", "environments, which contain all the functions imported from other\n", 
#&gt;                 "packages.\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental and may not belong to the rlang\n", 
#&gt;                   "package. Expect API changes.\n")), "\n", "\n", 
#&gt;             list("\n", list(list("pkg_env()")), "\n"), "\n", 
#&gt;             list("internal"), "\n"), `op-definition.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-definition"), "\n", list("op-definition"), 
#&gt;             "\n", list("is_definition"), "\n", list("new_definition"), 
#&gt;             "\n", list("is_formulaish"), "\n", list("Definition operator"), 
#&gt;             "\n", list("\n", "is_definition(x)\n", "\n", "new_definition(lhs, rhs, env = caller_env())\n", 
#&gt;                 "\n", "is_formulaish(x, scoped = NULL, lhs = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("lhs, rhs"), list("Expressions for the LHS and RHS of the definition.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The evaluation environment bundled with the definition.")), 
#&gt;                 "\n"), "\n", list("\n", "The definition operator is typically used in DSL packages like\n", 
#&gt;                 list("ggvis"), " and ", list("data.table"), ". It is also used in the tidyverse as a way\n", 
#&gt;                 "of unquoting names (see ", list("quasiquotation"), 
#&gt;                 ").\n", list("\n", list(), " ", list("is_definition()"), 
#&gt;                   " returns ", list("TRUE"), " for calls to ", 
#&gt;                   list(":="), ".\n", list(), " ", list("is_formulaish()"), 
#&gt;                   " returns ", list("TRUE"), " for both formulas and\n", 
#&gt;                   "colon-equals operators.\n"), "\n"), "\n", 
#&gt;             list("\n", "The recommended way to use it is to capture arguments as\n", 
#&gt;                 "expressions or quosures. You can then give a special function\n", 
#&gt;                 "definition for the ", list(":="), " symbol in an overscope. Note that if you\n", 
#&gt;                 "capture dots with ", list(list("exprs()")), 
#&gt;                 " or ", list(list("quos()")), ", you need to disable\n", 
#&gt;                 "interpretation of ", list(":="), " by setting ", 
#&gt;                 list(".unquote_names"), " to ", list("FALSE"), 
#&gt;                 ".\n", "\n", "From rlang and data.table perspectives, this operator is not meant\n", 
#&gt;                 "to be evaluated directly at top-level which is why the exported\n", 
#&gt;                 "definitions issue an error.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "\n", "# A predicate is provided to distinguish formulas from the\n", 
#&gt;                 "# colon-equals operator:\n", "is_definition(quote(a := b))\n", 
#&gt;                 "is_definition(a ~ b)\n", "\n", "\n", "# is_formulaish() tests for both definitions and formulas:\n", 
#&gt;                 "is_formulaish(a ~ b)\n", "is_formulaish(quote(a := b))\n"), 
#&gt;             "\n", list("internal"), "\n"), `op-get-attr.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-get-attr"), "\n", list("op-get-attr"), "\n", 
#&gt;             list("%@%"), "\n", list("%@%&lt;-"), "\n", list("Infix attribute accessor and setter"), 
#&gt;             "\n", list("\n", "x %@% name\n", "\n", "x %@% name &lt;- value\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object")), 
#&gt;                 "\n", "\n", list(list("name"), list("Attribute name")), 
#&gt;                 "\n", "\n", list(list("value"), list("New value for attribute ", 
#&gt;                   list("name"), ".")), "\n"), "\n", list("\n", 
#&gt;                 "This operator extracts or sets attributes for regular objects and\n", 
#&gt;                 "S4 fields for S4 objects.\n"), "\n", list("\n", 
#&gt;                 "# Unlike `@`, this operator extracts attributes for any kind of\n", 
#&gt;                 "# objects:\n", "factor(1:3) %@% \"levels\"\n", 
#&gt;                 "mtcars %@% class\n", "\n", "mtcars %@% class &lt;- NULL\n", 
#&gt;                 "mtcars\n", "\n", "# It also works on S4 objects:\n", 
#&gt;                 ".Person &lt;- setClass(\"Person\", slots = c(name = \"character\", species = \"character\"))\n", 
#&gt;                 "fievel &lt;- .Person(name = \"Fievel\", species = \"mouse\")\n", 
#&gt;                 "fievel %@% name\n"), "\n"), `op-na-default.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/operators.R", "\n", 
#&gt;             list("op-na-default"), "\n", list("op-na-default"), 
#&gt;             "\n", list("%|%"), "\n", list("Replace missing values"), 
#&gt;             "\n", list("\n", "x %|% y\n"), "\n", list("\n", list(
#&gt;                 list("x"), list("The original values.")), "\n", 
#&gt;                 "\n", list(list("y"), list("The replacement values. Must be of length 1 or the same length as ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "This infix function is similar to ", 
#&gt;                 list("%||%"), " but is vectorised\n", "and provides a default value for missing elements. It is faster\n", 
#&gt;                 "than using ", list(list("base::ifelse()")), 
#&gt;                 " and does not perform type conversions.\n"), 
#&gt;             "\n", list("\n", "c(\"a\", \"b\", NA, \"c\") %|% \"default\"\n", 
#&gt;                 "c(1L, NA, 3L, NA, NA) %|% (6L:10L)\n"), "\n", 
#&gt;             list("\n", list("op-null-default"), "\n"), "\n"), 
#&gt;         `op-null-default.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/operators.R", 
#&gt;             "\n", list("op-null-default"), "\n", list("op-null-default"), 
#&gt;             "\n", list("%||%"), "\n", list("Default value for ", 
#&gt;                 list("NULL")), "\n", list("\n", "x %||% y\n"), 
#&gt;             "\n", list("\n", list(list("x, y"), list("If ", list(
#&gt;                 "x"), " is NULL, will return ", list("y"), "; otherwise returns ", 
#&gt;                 list("x"), ".")), "\n"), "\n", list("\n", "This infix function makes it easy to replace ", 
#&gt;                 list("NULL"), "s with a default\n", "value. It's inspired by the way that Ruby's or operation (", 
#&gt;                 list("||"), ")\n", "works.\n"), "\n", list("\n", 
#&gt;                 "1 %||% 2\n", "NULL %||% 2\n"), "\n"), overscope_eval_next.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("overscope_eval_next"), "\n", list("overscope_eval_next"), 
#&gt;             "\n", list("Evaluate next quosure in a data mask"), 
#&gt;             "\n", list("\n", "overscope_eval_next(overscope, quo, env = base_env())\n"), 
#&gt;             "\n", list("\n", list(list("overscope"), list("A valid overscope containing bindings for ", 
#&gt;                 list("~"), ",\n", list(".top_env"), " and ", 
#&gt;                 list("_F"), " and whose parents contain overscoped bindings\n", 
#&gt;                 "for tidy evaluation.")), "\n", "\n", list(list(
#&gt;                 "quo"), list("A quosure.")), "\n", "\n", list(
#&gt;                 list("env"), list("The lexical enclosure in case ", 
#&gt;                   list("quo"), " is not a validly\n", "scoped quosure. This is the ", 
#&gt;                   list("base environment"), " by\n", "default.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("overscope_eval_next()"), " is deprecated as of rlang 0.2.0. Please use\n", 
#&gt;                 list("eval_tidy()"), " to which you can now supply an overscope.\n"), 
#&gt;             "\n", list("internal"), "\n"), pairlist2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/call.R", "\n", 
#&gt;             list("pairlist2"), "\n", list("pairlist2"), "\n", 
#&gt;             list("Create pairlists with splicing support"), "\n", 
#&gt;             list("\n", "pairlist2(...)\n"), "\n", list("\n", 
#&gt;                 list(list("..."), list("Arguments stored in the pairlist. Empty arguments are\n", 
#&gt;                   "preserved.")), "\n"), "\n", list("\n", "This pairlist constructor supports ", 
#&gt;                 list("tidy dots"), " features\n", "like ", list(
#&gt;                   "!!!"), ". Use it to manually create argument lists for calls or\n", 
#&gt;                 "parameter lists for functions.\n"), "\n", list(
#&gt;                 "\n", "# Unlike `exprs()`, `pairlist2()` evaluates its arguments.\n", 
#&gt;                 "new_function(pairlist2(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "new_function(exprs(x = 1, y = 3 * 6), quote(x * y))\n", 
#&gt;                 "\n", "# It preserves missing arguments, which is useful for creating\n", 
#&gt;                 "# parameters without defaults:\n", "new_function(pairlist2(x = , y = 3 * 6), quote(x * y))\n"), 
#&gt;             "\n"), parse_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parse.R", 
#&gt;             "\n", list("parse_expr"), "\n", list("parse_expr"), 
#&gt;             "\n", list("parse_exprs"), "\n", list("parse_quo"), 
#&gt;             "\n", list("parse_quos"), "\n", list("Parse R code"), 
#&gt;             "\n", list("\n", "parse_expr(x)\n", "\n", "parse_exprs(x)\n", 
#&gt;                 "\n", "parse_quo(x, env)\n", "\n", "parse_quos(x, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("parse_expr()"), 
#&gt;                 " returns an ", list("expression"), ",\n", list(
#&gt;                   "parse_exprs()"), " returns a list of expressions. Note that for the\n", 
#&gt;                 "plural variants the length of the output may be greater than the\n", 
#&gt;                 "length of the input. This would happen is one of the strings\n", 
#&gt;                 "contain several expressions (such as ", list(
#&gt;                   "\"foo; bar\""), ").\n"), "\n", list("\n", 
#&gt;                 "These functions parse and transform text into R expressions. This\n", 
#&gt;                 "is the first step to interpret or evaluate a piece of R code\n", 
#&gt;                 "written by a programmer.\n"), "\n", list("\n", 
#&gt;                 list("parse_expr()"), " returns one expression. If the text contains more\n", 
#&gt;                 "than one expression (separated by semicolons or new lines), an error is\n", 
#&gt;                 "issued. On the other hand ", list("parse_exprs()"), 
#&gt;                 " can handle multiple\n", "expressions. It always returns a list of expressions (compare to\n", 
#&gt;                 list(list("base::parse()")), " which returns a base::expression vector). All\n", 
#&gt;                 "functions also support R connections.\n", "\n", 
#&gt;                 "The versions suffixed with ", list("_quo"), 
#&gt;                 " and ", list("_quos"), " return\n", list("quosures"), 
#&gt;                 " rather than raw expressions.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " ", list("parse_quosure()"), " and ", 
#&gt;                   list("parse_quosures()"), " were soft-deprecated in\n", 
#&gt;                   "rlang 0.2.0 and renamed to ", list("parse_quo()"), 
#&gt;                   " and ", list("parse_quos()"), ". This\n", 
#&gt;                   "is consistent with the rule that abbreviated suffixes indicate\n", 
#&gt;                   "the return type of a function.\n"), "\n")), 
#&gt;             "\n", "\n", list("\n", "# parse_expr() can parse any R expression:\n", 
#&gt;                 "parse_expr(\"mtcars %&gt;% dplyr::mutate(cyl_prime = cyl / sd(cyl))\")\n", 
#&gt;                 "\n", "# A string can contain several expressions separated by ; or \\n\n", 
#&gt;                 "parse_exprs(\"NULL; list()\\n foo(bar)\")\n", 
#&gt;                 "\n", "# You can also parse source files by passing a R connection. Let's\n", 
#&gt;                 "# create a file containing R code:\n", "path &lt;- tempfile(\"my-file.R\")\n", 
#&gt;                 "cat(\"1; 2; mtcars\", file = path)\n", "\n", 
#&gt;                 "# We can now parse it by supplying a connection:\n", 
#&gt;                 "parse_exprs(file(path))\n"), "\n", list("\n", 
#&gt;                 list(list("base::parse()")), "\n"), "\n"), parse_quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("parse_quosure"), "\n", list("parse_quosure"), 
#&gt;             "\n", list("parse_quosures"), "\n", list("Parse text into a quosure"), 
#&gt;             "\n", list("\n", "parse_quosure(x, env = caller_env())\n", 
#&gt;                 "\n", "parse_quosures(x, env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Text containing expressions to parse_expr for\n", 
#&gt;                 list("parse_expr()"), " and ", list("parse_exprs()"), 
#&gt;                 ". Can also be an R connection,\n", "for instance to a file. If the supplied connection is not open,\n", 
#&gt;                 "it will be automatically closed and destroyed.")), 
#&gt;                 "\n", "\n", list(list("env"), list("The environment for the quosures. Depending on the use\n", 
#&gt;                   "case, a good default might be the ", list(
#&gt;                     "global environment"), " but you might also want to evaluate the\n", 
#&gt;                   "R code in an isolated context (perhaps a child of the global\n", 
#&gt;                   "environment or of the ", list("base environment"), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed to ", 
#&gt;                 list(list("parse_quo()")), "\n", "and ", list(
#&gt;                   list("parse_quos()")), " in rlang 0.2.0. This is for consistency with the\n", 
#&gt;                 "convention that suffixes indicating return types are not\n", 
#&gt;                 "abbreviated.\n"), "\n", list("internal"), "\n"), 
#&gt;         prepend.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("prepend"), "\n", list("prepend"), "\n", 
#&gt;             list("modify"), "\n", list("Prepend a vector"), "\n", 
#&gt;             list("\n", "prepend(x, values, before = 1)\n", "\n", 
#&gt;                 "modify(.x, ...)\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("the vector to be modified.")), "\n", 
#&gt;                 "\n", list(list("values"), list("to be included in the modified vector.")), 
#&gt;                 "\n", "\n", list(list("before"), list("a subscript, before which the values are to be appended.")), 
#&gt;                 "\n", "\n", list(list(".x"), list("A vector to modify.")), 
#&gt;                 "\n", "\n", list(list("..."), list("List of elements to merge into ", 
#&gt;                   list(".x"), ". Named elements\n", "already existing in ", 
#&gt;                   list(".x"), " are used as replacements. Elements that\n", 
#&gt;                   "have new or no names are inserted at the end. These dots support\n", 
#&gt;                   list("tidy dots"), " features.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "Vector functions are now out of scope for rlang. They might be\n", 
#&gt;                 "revived in the vctrs or funs packages.\n"), 
#&gt;             "\n", list("internal"), "\n"), prim_name.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fn.R", "\n", list(
#&gt;                 "prim_name"), "\n", list("prim_name"), "\n", 
#&gt;             list("Name of a primitive function"), "\n", list(
#&gt;                 "\n", "prim_name(prim)\n"), "\n", list("\n", 
#&gt;                 list(list("prim"), list("A primitive function such as ", 
#&gt;                   list(list("base::c()")), ".")), "\n"), "\n", 
#&gt;             list("\n", "Name of a primitive function\n"), "\n", 
#&gt;             list("internal"), "\n"), quasiquotation.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quasiquotation.R", 
#&gt;             "\n", list("quasiquotation"), "\n", list("quasiquotation"), 
#&gt;             "\n", list("UQ"), "\n", list("UQS"), "\n", list("{{}}"), 
#&gt;             "\n", list("{{"), "\n", list("!!"), "\n", list("!!!"), 
#&gt;             "\n", list(":="), "\n", list("qq_show"), "\n", list(
#&gt;                 "Quasiquotation of an expression"), "\n", list(
#&gt;                 "\n", "qq_show(expr)\n"), "\n", list("\n", list(
#&gt;                 list("expr"), list("An expression to be quasiquoted.")), 
#&gt;                 "\n"), "\n", list("\n", "Quasiquotation is the mechanism that makes it possible to program\n", 
#&gt;                 "flexibly with tidy evaluation grammars like dplyr. It is enabled in\n", 
#&gt;                 "all functions quoting their arguments with ", 
#&gt;                 list("enquo()"), ", ", list("enexpr()"), ",\n", 
#&gt;                 "or the plural variants.\n", "\n", "Quasiquotation is the combination of quoting an expression while\n", 
#&gt;                 "allowing immediate evaluation (unquoting) of part of that\n", 
#&gt;                 "expression. We provide both syntactic operators and functional\n", 
#&gt;                 "forms for unquoting.\n", list("\n", list(), 
#&gt;                   " The ", list("!!"), " operator unquotes its argument. It gets evaluated\n", 
#&gt;                   "immediately in the surrounding context.\n", 
#&gt;                   list(), " The ", list("!!!"), " operator unquotes and splices its argument. The\n", 
#&gt;                   "argument should represent a list or a vector. Each element will\n", 
#&gt;                   "be embedded in the surrounding call, i.e. each element is\n", 
#&gt;                   "inserted as an argument. If the vector is named, the names are\n", 
#&gt;                   "used as argument names.\n", "\n", "If the vector is a classed object (like a factor), it is\n", 
#&gt;                   "converted to a list with ", list(list("base::as.list()")), 
#&gt;                   " to ensure proper\n", "dispatch. If it is an S4 objects, it is converted to a list with\n", 
#&gt;                   list(list("methods::as()")), ".\n", list(), 
#&gt;                   " The ", list("{{ }}"), " operator quotes and unquotes its argument in one\n", 
#&gt;                   "go, a pattern that we call ", list("interpolation"), 
#&gt;                   ". It is an alias for\n", list("!!enquo(arg)"), 
#&gt;                   ".\n", "\n", "Like ", list("enquo()"), ", ", 
#&gt;                   list("{{ }}"), " is used in functions to capture an\n", 
#&gt;                   "argument as a quoted expression. This expression is immediately\n", 
#&gt;                   "unquoted in place.\n"), "\n", "\n", "Use ", 
#&gt;                 list("qq_show()"), " to experiment with quasiquotation or debug the\n", 
#&gt;                 "effect of unquoting operators. ", list("qq_show()"), 
#&gt;                 " quotes its input,\n", "processes unquoted parts, and prints the result with\n", 
#&gt;                 list(list("expr_print()")), ". This expression printer has a clearer output than\n", 
#&gt;                 "the base R printer (see the ", list("documentation topic"), 
#&gt;                 ").\n"), "\n", list(list("Unquoting names"), 
#&gt;                 list("\n", "\n", "\n", "When a function takes multiple named arguments\n", 
#&gt;                   "(e.g. ", list("dplyr::mutate()"), "), it is difficult to supply a variable as\n", 
#&gt;                   "name. Since the LHS of ", list("="), " is quoted, giving the name of a variable\n", 
#&gt;                   "results in the argument having the name of the variable rather than\n", 
#&gt;                   "the name stored in that variable. This problem is right up the\n", 
#&gt;                   "alley for the unquoting operator ", list("!!"), 
#&gt;                   ". If you were able to unquote\n", "the variable when supplying the name, the argument would be named\n", 
#&gt;                   "after the content of that variable.\n", "\n", 
#&gt;                   "Unfortunately R is very strict about the kind of expressions\n", 
#&gt;                   "supported on the LHS of ", list("="), ". This is why we have made the more\n", 
#&gt;                   "flexible ", list(":="), " operator an alias of ", 
#&gt;                   list("="), ". You can use it to supply\n", 
#&gt;                   "names, e.g. ", list("a := b"), " is equivalent to ", 
#&gt;                   list("a = b"), ". Since its syntax is\n", "more flexible you can unquote on the LHS:", 
#&gt;                   list("name &lt;- \"Jane\"\n", "\n", "list2(!!name := 1 + 2)\n", 
#&gt;                     "exprs(!!name := 1 + 2)\n", "quos(!!name := 1 + 2)\n"), 
#&gt;                   "\n", "\n", "Like ", list("="), ", the ", list(
#&gt;                     ":="), " operator expects strings or symbols on its LHS.\n", 
#&gt;                   "\n", "Note that unquoting on the LHS of ", 
#&gt;                   list(":="), " only works in top level\n", "expressions. These are all valid:", 
#&gt;                   list("exprs(!!nm := x)\n", "tibble(!!nm := x)\n", 
#&gt;                     "list2(!!nm := x)\n"), "\n", "\n", "But deep-unquoting names isn't supported:", 
#&gt;                   list("expr(foo(!!nm := x))\n", "exprs(foo(!!nm := x))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Theory"), list(
#&gt;                 "\n", "\n", "\n", "Formally, ", list("quo()"), 
#&gt;                 " and ", list("expr()"), " are quasiquote functions, ", 
#&gt;                 list("!!"), " is\n", "the unquote operator, and ", 
#&gt;                 list("!!!"), " is the unquote-splice operator.\n", 
#&gt;                 "These terms have a rich history in Lisp languages, and live on in\n", 
#&gt;                 "modern languages like\n", list(list("https://docs.julialang.org/en/v1/manual/metaprogramming/"), 
#&gt;                   list("Julia")), "\n", "and\n", list(list("https://docs.racket-lang.org/reference/quasiquote.html"), 
#&gt;                   list("Racket")), ".\n")), "\n", "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", list("\n", 
#&gt;                   list(), " Calling ", list("UQ()"), " and ", 
#&gt;                   list("UQS()"), " with the rlang namespace qualifier is\n", 
#&gt;                   "deprecated as of rlang 0.3.0. Just use the unqualified forms\n", 
#&gt;                   "instead:", list("# Bad\n", "rlang::expr(mean(rlang::UQ(var) * 100))\n", 
#&gt;                     "\n", "# Ok\n", "rlang::expr(mean(UQ(var) * 100))\n", 
#&gt;                     "\n", "# Good\n", "rlang::expr(mean(!!var * 100))\n"), 
#&gt;                   "\n", "\n", "Supporting namespace qualifiers complicates the implementation of\n", 
#&gt;                   "unquotation and is misleading as to the nature of unquoting\n", 
#&gt;                   "operators (which are syntactic operators that operates at\n", 
#&gt;                   "quotation-time rather than function calls at evaluation-time).\n", 
#&gt;                   list(), " ", list("UQ()"), " and ", list("UQS()"), 
#&gt;                   " were soft-deprecated in rlang 0.2.0 in order\n", 
#&gt;                   "to make the syntax of quasiquotation more consistent. The prefix\n", 
#&gt;                   "forms are now ", list("`!!`()"), " and ", 
#&gt;                   list("`!!!`()"), " which is\n", "consistent with other R operators (e.g. ", 
#&gt;                   list("`+`(a, b)"), " is the\n", "prefix form of ", 
#&gt;                   list("a + b"), ").\n", "\n", "Note that the prefix forms are not as relevant as before because\n", 
#&gt;                   list("!!"), " now has the right operator precedence, i.e. the same as\n", 
#&gt;                   "unary ", list("-"), " or ", list("+"), ". It is thus safe to mingle it with other\n", 
#&gt;                   "operators, e.g. ", list("!!a + !!b"), " does the right thing. In addition the\n", 
#&gt;                   "parser now strips one level of parentheses around unquoted\n", 
#&gt;                   "expressions. This way ", list("(!!\"foo\")(...)"), 
#&gt;                   " expands to ", list("foo(...)"), ".\n", "These changes make the prefix forms less useful.\n", 
#&gt;                   "\n", "Finally, the named functional forms ", 
#&gt;                   list("UQ()"), " and ", list("UQS()"), " were\n", 
#&gt;                   "misleading because they suggested that existing knowledge about\n", 
#&gt;                   "functions is applicable to quasiquotation. This was reinforced by\n", 
#&gt;                   "the visible definitions of these functions exported by rlang and\n", 
#&gt;                   "by the tidy eval parser interpreting ", list(
#&gt;                     "rlang::UQ()"), " as ", list("!!"), ". In\n", 
#&gt;                   "reality unquoting is ", list("not"), " a function call, it is a syntactic\n", 
#&gt;                   "operation. The operator form makes it clearer that unquoting is\n", 
#&gt;                   "special.\n"), "\n")), "\n", "\n", list("\n", 
#&gt;                 "# Interpolation with {{  }} is the easiest way to forward\n", 
#&gt;                 "# arguments to tidy eval functions:\n", "if (is_attached(\"package:dplyr\")) {\n", 
#&gt;                 "\n", "# Forward all arguments involving data frame columns by\n", 
#&gt;                 "# interpolating them within other data masked arguments.\n", 
#&gt;                 "# Here we interpolate `arg` in a `summarise()` call:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean({{ arg }}, na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "my_function(mtcars, cyl * 10)\n", 
#&gt;                 "\n", "# The  operator is just a shortcut for `!!enquo()`:\n", 
#&gt;                 "my_function &lt;- function(data, arg) {\n", "  summarise(data, avg = mean(!!enquo(arg), na.rm = TRUE))\n", 
#&gt;                 "}\n", "\n", "my_function(mtcars, cyl)\n", "\n", 
#&gt;                 "}\n", "\n", "# Quasiquotation functions quote expressions like base::quote()\n", 
#&gt;                 "quote(how_many(this))\n", "expr(how_many(this))\n", 
#&gt;                 "quo(how_many(this))\n", "\n", "# In addition, they support unquoting. Let's store symbols\n", 
#&gt;                 "# (i.e. object names) in variables:\n", "this &lt;- sym(\"apples\")\n", 
#&gt;                 "that &lt;- sym(\"oranges\")\n", "\n", "# With unquotation you can insert the contents of these variables\n", 
#&gt;                 "# inside the quoted expression:\n", "expr(how_many(!!this))\n", 
#&gt;                 "expr(how_many(!!that))\n", "\n", "# You can also insert values:\n", 
#&gt;                 "expr(how_many(!!(1 + 2)))\n", "quo(how_many(!!(1 + 2)))\n", 
#&gt;                 "\n", "\n", "# Note that when you unquote complex objects into an expression,\n", 
#&gt;                 "# the base R printer may be a bit misleading. For instance compare\n", 
#&gt;                 "# the output of `expr()` and `quo()` (which uses a custom printer)\n", 
#&gt;                 "# when we unquote an integer vector:\n", "expr(how_many(!!(1:10)))\n", 
#&gt;                 "quo(how_many(!!(1:10)))\n", "\n", "# This is why it's often useful to use qq_show() to examine the\n", 
#&gt;                 "# result of unquotation operators. It uses the same printer as\n", 
#&gt;                 "# quosures but does not return anything:\n", 
#&gt;                 "qq_show(how_many(!!(1:10)))\n", "\n", "\n", 
#&gt;                 "# Use `!!!` to add multiple arguments to a function. Its argument\n", 
#&gt;                 "# should evaluate to a list or vector:\n", "args &lt;- list(1:3, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!!args))\n", "\n", "# You can combine the two\n", 
#&gt;                 "var &lt;- quote(xyz)\n", "extra_args &lt;- list(trim = 0.9, na.rm = TRUE)\n", 
#&gt;                 "quo(mean(!!var , !!!extra_args))\n", "\n", "\n", 
#&gt;                 "# The plural versions have support for the `:=` operator.\n", 
#&gt;                 "# Like `=`, `:=` creates named arguments:\n", 
#&gt;                 "quos(mouse1 := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "# The `:=` is mainly useful to unquote names. Unlike `=` it\n", 
#&gt;                 "# supports `!!` on its LHS:\n", "var &lt;- \"unquote me!\"\n", 
#&gt;                 "quos(!!var := bernard, mouse2 = bianca)\n", 
#&gt;                 "\n", "\n", "# All these features apply to dots captured by enquos():\n", 
#&gt;                 "fn &lt;- function(...) enquos(...)\n", "fn(!!!args, !!var := penny)\n", 
#&gt;                 "\n", "\n", "# Unquoting is especially useful for building an expression by\n", 
#&gt;                 "# expanding around a variable part (the unquoted part):\n", 
#&gt;                 "quo1 &lt;- quo(toupper(foo))\n", "quo1\n", "\n", 
#&gt;                 "quo2 &lt;- quo(paste(!!quo1, bar))\n", "quo2\n", 
#&gt;                 "\n", "quo3 &lt;- quo(list(!!quo2, !!!syms(letters[1:5])))\n", 
#&gt;                 "quo3\n"), "\n"), quo_expr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("quo_expr"), "\n", list("quo_expr"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_expr(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "This function is deprecated, please use ", 
#&gt;                 list(list("quo_squash()")), " instead.\n"), "\n", 
#&gt;             list("internal"), "\n"), quo_label.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quo.R", "\n", 
#&gt;             list("quo_label"), "\n", list("quo_label"), "\n", 
#&gt;             list("quo_text"), "\n", list("quo_name"), "\n", list(
#&gt;                 "Format quosures for printing or labelling"), 
#&gt;             "\n", list("\n", "quo_label(quo)\n", "\n", "quo_text(quo, width = 60L, nlines = Inf)\n", 
#&gt;                 "\n", "quo_name(quo)\n"), "\n", list("\n", list(
#&gt;                 list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("width"), list("Width of each line.")), 
#&gt;                 "\n", "\n", list(list("nlines"), list("Maximum number of lines to extract.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", list("Note:"), " You should now use ", 
#&gt;                 list(list("as_label()")), " or ", list(list("as_name()")), 
#&gt;                 " instead\n", "of ", list("quo_name()"), ". See life cycle section below.\n", 
#&gt;                 "\n", "These functions take an arbitrary R object, typically an\n", 
#&gt;                 list("expression"), ", and represent it as a string.\n", 
#&gt;                 list("\n", list(), " ", list("quo_name()"), " returns an abbreviated representation of the object\n", 
#&gt;                   "as a single line string. It is suitable for default names.\n", 
#&gt;                   list(), " ", list("quo_text()"), " returns a multiline string. For instance block\n", 
#&gt;                   "expressions like ", list("{ foo; bar }"), 
#&gt;                   " are represented on 4 lines (one\n", "for each symbol, and the curly braces on their own lines).\n"), 
#&gt;                 "\n", "\n", "These deparsers are only suitable for creating default names or\n", 
#&gt;                 "printing output at the console. The behaviour of your functions\n", 
#&gt;                 "should not depend on deparsed objects. If you are looking for a way\n", 
#&gt;                 "of transforming symbols to strings, use ", list(
#&gt;                   list("as_string()")), " instead of\n", list(
#&gt;                   "quo_name()"), ". Unlike deparsing, the transformation between symbols\n", 
#&gt;                 "and strings is non-lossy and well defined.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are in the questioning life cycle stage.\n", 
#&gt;                 list("\n", list(), " ", list(list("as_label()")), 
#&gt;                   " and ", list(list("as_name()")), " should be used instead of\n", 
#&gt;                   list("quo_name()"), ". ", list("as_label()"), 
#&gt;                   " transforms any R object to a string\n", "but should only be used to create a default name. Labelisation is\n", 
#&gt;                   "not a well defined operation and no assumption should be made\n", 
#&gt;                   "about the label. On the other hand, ", list(
#&gt;                     "as_name()"), " only works with\n", "(possibly quosured) symbols, but is a well defined and\n", 
#&gt;                   "deterministic operation.\n", list(), " We don't have a good replacement for ", 
#&gt;                   list("quo_text()"), " yet. See\n", list("https://github.com/r-lib/rlang/issues/636"), 
#&gt;                   " to follow discussions\n", "about a new deparsing API.\n"), 
#&gt;                 "\n")), "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(foo(!! quo(bar)))\n", "quo\n", "\n", 
#&gt;                 "# quo_squash() unwraps all quosures and returns a raw expression:\n", 
#&gt;                 "quo_squash(quo)\n", "\n", "# This is used by quo_text() and quo_label():\n", 
#&gt;                 "quo_text(quo)\n", "\n", "# Compare to the unwrapped expression:\n", 
#&gt;                 "expr_text(quo)\n", "\n", "# quo_name() is helpful when you need really short labels:\n", 
#&gt;                 "quo_name(quo(sym))\n", "quo_name(quo(!! sym))\n"), 
#&gt;             "\n", list("\n", list(list("expr_label()")), ", ", 
#&gt;                 list(list("f_label()")), "\n"), "\n"), quo_squash.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quo_squash"), "\n", list("quo_squash"), "\n", 
#&gt;             list("Squash a quosure"), "\n", list("\n", "quo_squash(quo, warn = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("quo"), list("A quosure or expression.")), 
#&gt;                 "\n", "\n", list(list("warn"), list("Whether to warn if the quosure contains other quosures\n", 
#&gt;                   "(those will be collapsed). This is useful when you use\n", 
#&gt;                   list("quo_squash()"), " in order to make a non-tidyeval API compatible\n", 
#&gt;                   "with quosures. In that case, getting rid of the nested quosures\n", 
#&gt;                   "is likely to cause subtle bugs and it is good practice to warn\n", 
#&gt;                   "the user about it.")), "\n"), "\n", list("\n", 
#&gt;                 list("quo_squash()"), " flattens all nested quosures within an expression.\n", 
#&gt;                 "For example it transforms ", list("^foo(^bar(), ^baz)"), 
#&gt;                 " to the bare\n", "expression ", list("foo(bar(), baz)"), 
#&gt;                 ".\n", "\n", "This operation is safe if the squashed quosure is used for\n", 
#&gt;                 "labelling or printing (see ", list(list("quo_label()")), 
#&gt;                 " or ", list(list("quo_name()")), "). However\n", 
#&gt;                 "if the squashed quosure is evaluated, all expressions of the\n", 
#&gt;                 "flattened quosures are resolved in a single environment. This is a\n", 
#&gt;                 "source of bugs so it is good practice to set ", 
#&gt;                 list("warn"), " to ", list("TRUE"), " to\n", 
#&gt;                 "let the user know about the lossy squashing.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "This function replaces ", list("quo_expr()"), 
#&gt;                 " which was deprecated in\n", "rlang 0.2.0. ", 
#&gt;                 list("quo_expr()"), " was a misnomer because it implied that it\n", 
#&gt;                 "was a mere expression acccessor for quosures whereas it was really\n", 
#&gt;                 "a lossy operation that squashed all nested quosures.\n")), 
#&gt;             "\n", "\n", list("\n", "# Quosures can contain nested quosures:\n", 
#&gt;                 "quo &lt;- quo(wrapper(!!quo(wrappee)))\n", "quo\n", 
#&gt;                 "\n", "# quo_squash() flattens all the quosures and returns a simple expression:\n", 
#&gt;                 "quo_squash(quo)\n"), "\n"), quosure.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/quo.R", "\n", list(
#&gt;                 "quosure"), "\n", list("quosure"), "\n", list(
#&gt;                 "is_quosure"), "\n", list("quo_is_missing"), 
#&gt;             "\n", list("quo_is_symbol"), "\n", list("quo_is_call"), 
#&gt;             "\n", list("quo_is_symbolic"), "\n", list("quo_is_null"), 
#&gt;             "\n", list("quo_get_expr"), "\n", list("quo_get_env"), 
#&gt;             "\n", list("quo_set_expr"), "\n", list("quo_set_env"), 
#&gt;             "\n", list("Quosure getters, setters and testers"), 
#&gt;             "\n", list("\n", "is_quosure(x)\n", "\n", "quo_is_missing(quo)\n", 
#&gt;                 "\n", "quo_is_symbol(quo, name = NULL)\n", "\n", 
#&gt;                 "quo_is_call(quo, name = NULL, n = NULL, ns = NULL)\n", 
#&gt;                 "\n", "quo_is_symbolic(quo)\n", "\n", "quo_is_null(quo)\n", 
#&gt;                 "\n", "quo_get_expr(quo)\n", "\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo_set_expr(quo, expr)\n", "\n", "quo_set_env(quo, env)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An object to test.")), 
#&gt;                 "\n", "\n", list(list("quo"), list("A quosure to test.")), 
#&gt;                 "\n", "\n", list(list("name"), list("The name of the symbol or function call. If ", 
#&gt;                   list("NULL"), " the\n", "name is not tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("An optional number of arguments that the call should\n", 
#&gt;                   "match.")), "\n", "\n", list(list("ns"), list(
#&gt;                   "The namespace of the call. If ", list("NULL"), 
#&gt;                   ", the namespace\n", "doesn't participate in the pattern-matching. If an empty string\n", 
#&gt;                   list("\"\""), " and ", list("x"), " is a namespaced call, ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ". If any other string, ", list("is_call()"), 
#&gt;                   " checks that ", list("x"), " is\n", "namespaced within ", 
#&gt;                   list("ns"), ".\n", "\n", "Can be a character vector of namespaces, in which case the call\n", 
#&gt;                   "has to match at least one of them, otherwise ", 
#&gt;                   list("is_call()"), " returns\n", list("FALSE"), 
#&gt;                   ".")), "\n", "\n", list(list("expr"), list(
#&gt;                   "A new expression for the quosure.")), "\n", 
#&gt;                 "\n", list(list("env"), list("A new environment for the quosure.")), 
#&gt;                 "\n"), "\n", list("\n", "A quosure is a type of ", 
#&gt;                 list("quoted expression"), " that includes\n", 
#&gt;                 "a reference to the context where it was created. A quosure is thus\n", 
#&gt;                 "guaranteed to evaluate in its original environment and can refer to\n", 
#&gt;                 "local objects.\n", "\n", "You can access the quosure components (its expression and its\n", 
#&gt;                 "environment) with:\n", list("\n", list(), " ", 
#&gt;                   list(list("get_expr()")), " and ", list(list(
#&gt;                     "get_env()")), ". These getters also support other\n", 
#&gt;                   "kinds of objects such as formulas.\n", list(), 
#&gt;                   " ", list("quo_get_expr()"), " and ", list(
#&gt;                     "quo_get_env()"), ". These getters only work\n", 
#&gt;                   "with quosures and throw an error with other types of input.\n"), 
#&gt;                 "\n", "\n", "Test if an object is a quosure with ", 
#&gt;                 list("is_quosure()"), ". If you know an\n", "object is a quosure, use the ", 
#&gt;                 list("quo_"), " prefixed predicates to check\n", 
#&gt;                 "its contents, ", list("quo_is_missing()"), ", ", 
#&gt;                 list("quo_is_symbol()"), ", etc.\n"), "\n", list(
#&gt;                 list("Quosured constants"), list("\n", "\n", 
#&gt;                   "\n", "A quosure usually does not carry environments for ", 
#&gt;                   list("constant objects"), " like strings or numbers. ", 
#&gt;                   list(list("quo()")), " and\n", list(list("enquo()")), 
#&gt;                   " only capture an environment for ", list("symbolic expressions"), 
#&gt;                   ". For instance, all of these return the\n", 
#&gt;                   list("empty environment"), ":", list("quo_get_env(quo(\"constant\"))\n", 
#&gt;                     "quo_get_env(quo(100))\n", "quo_get_env(quo(NA))\n"), 
#&gt;                   "\n", "\n", "On the other hand, quosures capture the environment of symbolic\n", 
#&gt;                   "expressions, i.e. expressions whose meaning depends on the\n", 
#&gt;                   "environment in which they are evaluated and what objects are\n", 
#&gt;                   "defined there:", list("quo_get_env(quo(some_object))\n", 
#&gt;                     "quo_get_env(quo(some_function()))\n"), "\n")), 
#&gt;             "\n", "\n", list(list("Empty quosures"), list("\n", 
#&gt;                 "\n", "\n", "When missing arguments are captured as quosures, either through\n", 
#&gt;                 list(list("enquo()")), " or ", list(list("quos()")), 
#&gt;                 ", they are returned as an empty quosure. These\n", 
#&gt;                 "quosures contain the ", list("missing argument"), 
#&gt;                 " and typically\n", "have the ", list("empty environment"), 
#&gt;                 " as enclosure.\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "is_quosure()"), " is stable.\n", list(), " ", 
#&gt;                   list("quo_get_expr()"), " and ", list("quo_get_env()"), 
#&gt;                   " are stable.\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "quo &lt;- quo(my_quosure)\n", "quo\n", "\n", 
#&gt;                 "\n", "# Access and set the components of a quosure:\n", 
#&gt;                 "quo_get_expr(quo)\n", "quo_get_env(quo)\n", 
#&gt;                 "\n", "quo &lt;- quo_set_expr(quo, quote(baz))\n", 
#&gt;                 "quo &lt;- quo_set_env(quo, empty_env())\n", "quo\n", 
#&gt;                 "\n", "# Test wether an object is a quosure:\n", 
#&gt;                 "is_quosure(quo)\n", "\n", "# If it is a quosure, you can use the specialised type predicates\n", 
#&gt;                 "# to check what is inside it:\n", "quo_is_symbol(quo)\n", 
#&gt;                 "quo_is_call(quo)\n", "quo_is_null(quo)\n", "\n", 
#&gt;                 "# quo_is_missing() checks for a special kind of quosure, the one\n", 
#&gt;                 "# that contains the missing argument:\n", "quo()\n", 
#&gt;                 "quo_is_missing(quo())\n", "\n", "fn &lt;- function(arg) enquo(arg)\n", 
#&gt;                 "fn()\n", "quo_is_missing(fn())\n"), "\n", list(
#&gt;                 "\n", list(list("quo()")), " for creating quosures by quotation; ", 
#&gt;                 list(list("as_quosure()")), "\n", "and ", list(
#&gt;                   list("new_quosure()")), " for constructing quosures manually.\n"), 
#&gt;             "\n"), quotation.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/quotation.R", 
#&gt;             "\n", list("quotation"), "\n", list("quotation"), 
#&gt;             "\n", list("expr"), "\n", list("enexpr"), "\n", list(
#&gt;                 "exprs"), "\n", list("enexprs"), "\n", list("ensym"), 
#&gt;             "\n", list("ensyms"), "\n", list("quo"), "\n", list(
#&gt;                 "enquo"), "\n", list("quos"), "\n", list("enquos"), 
#&gt;             "\n", list("Quotation"), "\n", list("\n", "expr(expr)\n", 
#&gt;                 "\n", "enexpr(arg)\n", "\n", "exprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE)\n", "\n", 
#&gt;                 "enexprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "ensym(arg)\n", "\n", "ensyms(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "quo(expr)\n", "\n", "enquo(arg)\n", "\n", "quos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .unquote_names = TRUE)\n", "\n", "enquos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\",\n", 
#&gt;                 "  \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("expr"), list("An expression.")), 
#&gt;                 "\n", "\n", list(list("arg"), list("A symbol representing an argument. The expression\n", 
#&gt;                   "supplied to that argument will be captured instead of being\n", 
#&gt;                   "evaluated.")), "\n", "\n", list(list("..."), 
#&gt;                   list("For ", list("enexprs()"), ", ", list(
#&gt;                     "ensyms()"), " and ", list("enquos()"), ", names of\n", 
#&gt;                     "arguments to capture without evaluation (including ", 
#&gt;                     list("..."), "). For\n", list("exprs()"), 
#&gt;                     " and ", list("quos()"), ", the expressions to capture unevaluated\n", 
#&gt;                     "(including expressions contained in ", list(
#&gt;                       "..."), ").")), "\n", "\n", list(list(".named"), 
#&gt;                   list("Whether to ensure all dots are named. Unnamed\n", 
#&gt;                     "elements are processed with ", list(list(
#&gt;                       "quo_name()")), " to build a default\n", 
#&gt;                     "name. See also ", list(list("quos_auto_name()")), 
#&gt;                     ".")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                   list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty. Note that ", 
#&gt;                     list("\"trailing\""), "\n", "applies only to arguments passed in ", 
#&gt;                     list("..."), ", not to named\n", "arguments. On the other hand, ", 
#&gt;                     list("\"all\""), " also applies to named\n", 
#&gt;                     "arguments.")), "\n", "\n", list(list(".unquote_names"), 
#&gt;                   list("Whether to treat ", list(":="), " as ", 
#&gt;                     list("="), ". Unlike ", list("="), ", the\n", 
#&gt;                     list(":="), " syntax supports ", list("!!"), 
#&gt;                     " unquoting on the LHS.")), "\n", "\n", list(
#&gt;                   list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                     "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                     list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                     " to only keep the first occurrences, to ", 
#&gt;                     list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                     list("\"error\""), " to raise an informative\n", 
#&gt;                     "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "Quotation is a mechanism by which an expression supplied as\n", 
#&gt;                 "argument is captured by a function. Instead of seeing the value of\n", 
#&gt;                 "the argument, the function sees the recipe (the R code) to make\n", 
#&gt;                 "that value. This is possible because R ", list(
#&gt;                   "expressions"), " are\n", "representable as regular objects in R:\n", 
#&gt;                 list("\n", list(), " Calls represent the action of calling a function to\n", 
#&gt;                   "compute a new value. Evaluating a call causes that value to be\n", 
#&gt;                   "computed. Calls typically involve symbols to reference R objects.\n", 
#&gt;                   list(), " Symbols represent the name that is given to an object in a\n", 
#&gt;                   "particular context (an ", list("environment"), 
#&gt;                   ").\n"), "\n", "\n", "We call objects containing calls and symbols ", 
#&gt;                 list("expressions"), ".\n", "There are two ways to create R expressions. First you can ", 
#&gt;                 list("build"), "\n", "calls and symbols from parts and pieces (see ", 
#&gt;                 list(list("sym()")), ", ", list(list("syms()")), 
#&gt;                 " and\n", list(list("call2()")), "). The other way is by ", 
#&gt;                 list("quotation"), " or ", list("quasiquotation"), 
#&gt;                 ",\n", "i.e. by intercepting an expression instead of evaluating it.\n"), 
#&gt;             "\n", list(list("User expressions versus your expressions"), 
#&gt;                 list("\n", "\n", "\n", "There are two points of view when it comes to capturing an\n", 
#&gt;                   "expression:\n", list("\n", list(), " You can capture the expressions supplied by ", 
#&gt;                     list("the user"), " of your\n", "function. This is the purpose of ", 
#&gt;                     list("ensym()"), ", ", list("enexpr()"), 
#&gt;                     " and\n", list("enquo()"), " and their plural variants. These functions take an\n", 
#&gt;                     "argument name and capture the expression that was supplied to\n", 
#&gt;                     "that argument.\n", list(), " You can capture the expressions that ", 
#&gt;                     list("you"), " supply. To this end\n", "use ", 
#&gt;                     list("expr()"), " and ", list("quo()"), " and their plural variants ", 
#&gt;                     list("exprs()"), " and\n", list("quos()"), 
#&gt;                     ".\n"), "\n")), "\n", "\n", list(list("Capture raw expressions"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "enexpr()"), " and ", list("expr()"), " capture a single raw expression.\n", 
#&gt;                   list(), " ", list("enexprs()"), " and ", list(
#&gt;                     "exprs()"), " capture a list of raw expressions\n", 
#&gt;                   "including expressions contained in ", list(
#&gt;                     "..."), ".\n", list(), " ", list("ensym()"), 
#&gt;                   " and ", list("ensyms()"), " are variants of ", 
#&gt;                   list("enexpr()"), " and\n", list("enexprs()"), 
#&gt;                   " that check the captured expression is either a string\n", 
#&gt;                   "(which they convert to symbol) or a symbol. If anything else\n", 
#&gt;                   "is supplied they throw an error.\n"), "\n", 
#&gt;                   "\n", "In terms of base functions, ", list(
#&gt;                     "enexpr(arg)"), " corresponds to\n", list(
#&gt;                     "base::substitute(arg)"), " (though that function also features complex\n", 
#&gt;                   "substitution semantics) and ", list("expr()"), 
#&gt;                   " is like ", list(list("quote()")), " (and\n", 
#&gt;                   list(list("bquote()")), " if we consider unquotation syntax). The plural variant\n", 
#&gt;                   list("exprs()"), " is equivalent to ", list(
#&gt;                     list("base::alist()")), ". Finally there is no\n", 
#&gt;                   "function in base R that is equivalent to ", 
#&gt;                   list("enexprs()"), " but you can\n", "reproduce its behaviour with ", 
#&gt;                   list("eval(substitute(alist(...)))"), ".\n")), 
#&gt;             "\n", "\n", list(list("Capture expressions in quosures"), 
#&gt;                 list("\n", "\n", "\n", list("quo()"), " and ", 
#&gt;                   list("enquo()"), " are similar to their ", 
#&gt;                   list("expr"), " counterparts but\n", "capture both the expression and its environment in an object called\n", 
#&gt;                   "a quosure. This wrapper contains a reference to the original\n", 
#&gt;                   "environment in which that expression was captured. Keeping track of\n", 
#&gt;                   "the environments of expressions is important because this is where\n", 
#&gt;                   "functions and objects mentioned in the expression are defined.\n", 
#&gt;                   "\n", "Quosures are objects that can be evaluated with ", 
#&gt;                   list(list("eval_tidy()")), " just\n", "like symbols or function calls. Since they always evaluate in their\n", 
#&gt;                   "original environment, quosures can be seen as vehicles that allow\n", 
#&gt;                   "expressions to travel from function to function but that beam back\n", 
#&gt;                   "instantly to their original environment upon evaluation.\n", 
#&gt;                   "\n", "See the ", list("quosure"), " help topic about tools to work with quosures.\n")), 
#&gt;             "\n", "\n", list(list("Quasiquotation"), list("\n", 
#&gt;                 "\n", "\n", "All quotation functions in rlang have support for ", 
#&gt;                 list("unquoting operators"), ". The combination of quotation and\n", 
#&gt;                 "unquotation is called ", list("quasiquotation"), 
#&gt;                 ".\n", "\n", "Unquotation provides a way to refer to variables during quotation.\n", 
#&gt;                 "Variables are problematic when quoting because a captured\n", 
#&gt;                 "expression is essentially a constant, just like a string is a\n", 
#&gt;                 "constant. For instance in all the following cases ", 
#&gt;                 list("apple"), " is a\n", "constant: ", list(
#&gt;                   "~apple"), ", ", list("\"apple\""), " and ", 
#&gt;                 list("expr(apple)"), ". Unquoting allows\n", 
#&gt;                 "you to introduce a part of variability within a captured\n", 
#&gt;                 "expression.\n", list("\n", list(), " In the case of ", 
#&gt;                   list("enexpr()"), " and ", list("enquo()"), 
#&gt;                   ", unquoting provides an\n", "escape hatch to the users of your function that allows them to\n", 
#&gt;                   "manipulate the expression that you capture.\n", 
#&gt;                   list(), " In the case of ", list("expr()"), 
#&gt;                   " and ", list("quo()"), ", quasiquotation lets you\n", 
#&gt;                   "build a complex expressions where some parts are constant (the\n", 
#&gt;                   "parts that are captured) and some parts are variable (the parts\n", 
#&gt;                   "that are unquoted).\n"), "\n", "\n", "See the ", 
#&gt;                 list("quasiquotation"), " help topic for more about this as well as\n", 
#&gt;                 list(list("https://adv-r.hadley.nz/quasiquotation.html"), 
#&gt;                   list("the chapter in Advanced R")), ".\n")), 
#&gt;             "\n", "\n", list("\n", "# expr() and exprs() capture expressions that you supply:\n", 
#&gt;                 "expr(symbol)\n", "exprs(several, such, symbols)\n", 
#&gt;                 "\n", "# enexpr() and enexprs() capture expressions that your user supplied:\n", 
#&gt;                 "expr_inputs &lt;- function(arg, ...) {\n", "  user_exprs &lt;- enexprs(arg, ...)\n", 
#&gt;                 "  user_exprs\n", "}\n", "expr_inputs(hello)\n", 
#&gt;                 "expr_inputs(hello, bonjour, ciao)\n", "\n", 
#&gt;                 "# ensym() and ensyms() provide additional type checking to ensure\n", 
#&gt;                 "# the user calling your function has supplied bare object names:\n", 
#&gt;                 "sym_inputs &lt;- function(...) {\n", "  user_symbols &lt;- ensyms(...)\n", 
#&gt;                 "  user_symbols\n", "}\n", "sym_inputs(hello, \"bonjour\")\n", 
#&gt;                 "## sym_inputs(say(hello))  # Error: Must supply symbols or strings\n", 
#&gt;                 "expr_inputs(say(hello))\n", "\n", "\n", "# All these quoting functions have quasiquotation support. This\n", 
#&gt;                 "# means that you can unquote (evaluate and inline) part of the\n", 
#&gt;                 "# captured expression:\n", "what &lt;- sym(\"bonjour\")\n", 
#&gt;                 "expr(say(what))\n", "expr(say(!!what))\n", "\n", 
#&gt;                 "# This also applies to expressions supplied by the user. This is\n", 
#&gt;                 "# like an escape hatch that allows control over the captured\n", 
#&gt;                 "# expression:\n", "expr_inputs(say(!!what), !!what)\n", 
#&gt;                 "\n", "\n", "# Finally, you can capture expressions as quosures. A quosure is an\n", 
#&gt;                 "# object that contains both the expression and its environment:\n", 
#&gt;                 "quo &lt;- quo(letters)\n", "quo\n", "\n", "get_expr(quo)\n", 
#&gt;                 "get_env(quo)\n", "\n", "# Quosures can be evaluated with eval_tidy():\n", 
#&gt;                 "eval_tidy(quo)\n", "\n", "# They have the nice property that you can pass them around from\n", 
#&gt;                 "# context to context (that is, from function to function) and they\n", 
#&gt;                 "# still evaluate in their original environment:\n", 
#&gt;                 "multiply_expr_by_10 &lt;- function(expr) {\n", 
#&gt;                 "  # We capture the user expression and its environment:\n", 
#&gt;                 "  expr &lt;- enquo(expr)\n", "\n", "  # Then create an object that only exists in this function:\n", 
#&gt;                 "  local_ten &lt;- 10\n", "\n", "  # Now let's create a multiplication expression that (a) inlines\n", 
#&gt;                 "  # the user expression as LHS (still wrapped in its quosure) and\n", 
#&gt;                 "  # (b) refers to the local object in the RHS:\n", 
#&gt;                 "  quo(!!expr * local_ten)\n", "}\n", "quo &lt;- multiply_expr_by_10(2 + 3)\n", 
#&gt;                 "\n", "# The local parts of the quosure are printed in colour if your\n", 
#&gt;                 "# terminal is capable of displaying colours:\n", 
#&gt;                 "quo\n", "\n", "# All the quosures in the expression evaluate in their original\n", 
#&gt;                 "# context. The local objects are looked up properly and we get the\n", 
#&gt;                 "# expected result:\n", "eval_tidy(quo)\n"), 
#&gt;             "\n"), rep_along.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("rep_along"), "\n", list("rep_along"), 
#&gt;             "\n", list("rep_named"), "\n", list("Create vectors matching the length of a given vector"), 
#&gt;             "\n", list("\n", "rep_along(along, x)\n", "\n", "rep_named(names, x)\n"), 
#&gt;             "\n", list("\n", list(list("along"), list("Vector whose length determine how many times ", 
#&gt;                 list("x"), "\n", "is repeated.")), "\n", "\n", 
#&gt;                 list(list("x"), list("Values to repeat.")), "\n", 
#&gt;                 "\n", list(list("names"), list("Names for the new vector. The length of ", 
#&gt;                   list("names"), "\n", "determines how many times ", 
#&gt;                   list("x"), " is repeated.")), "\n"), "\n", 
#&gt;             list("\n", "These functions take the idea of ", list(
#&gt;                 list("seq_along()")), " and apply it to\n", "repeating values.\n"), 
#&gt;             "\n", list("\n", "x &lt;- 0:5\n", "rep_along(x, 1:2)\n", 
#&gt;                 "rep_along(x, 1)\n", "\n", "# Create fresh vectors by repeating missing values:\n", 
#&gt;                 "rep_along(x, na_int)\n", "rep_along(x, na_chr)\n", 
#&gt;                 "\n", "# rep_named() repeats a value along a names vectors\n", 
#&gt;                 "rep_named(c(\"foo\", \"bar\"), list(letters))\n"), 
#&gt;             "\n", list("\n", "new-vector\n"), "\n"), restarting.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("restarting"), "\n", list("restarting"), 
#&gt;             "\n", list("Create a restarting handler"), "\n", 
#&gt;             list("\n", "restarting(.restart, ..., .fields = NULL)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Additional arguments passed on the restart\n", 
#&gt;                   "function. These arguments are evaluated only once and\n", 
#&gt;                   "immediately, when creating the restarting handler. Furthermore,\n", 
#&gt;                   "they support ", list("tidy dots"), " features.")), 
#&gt;                 "\n", "\n", list(list(".fields"), list("A character vector specifying the fields of the\n", 
#&gt;                   "condition that should be passed as arguments to the restart. If\n", 
#&gt;                   "named, the names (except empty names ", list(
#&gt;                     "\"\""), ") are used as\n", "argument names for calling the restart function. Otherwise the\n", 
#&gt;                   "the fields themselves are used as argument names.")), 
#&gt;                 "\n"), "\n", list("\n", "This constructor automates the common task of creating an\n", 
#&gt;                 list(list("calling()")), " handler that invokes a restart.\n"), 
#&gt;             "\n", list("\n", "Jumping to a restart point from a calling handler has two\n", 
#&gt;                 "effects. First, the control flow jumps to wherever the restart was\n", 
#&gt;                 "established, and the restart function is called (with ", 
#&gt;                 list("..."), ", or\n", list(".fields"), " as arguments). Execution resumes from the\n", 
#&gt;                 list(list("with_restarts()")), " call. Secondly, the transfer of the control flow\n", 
#&gt;                 "out of the function that signalled the condition means that the\n", 
#&gt;                 "handler has dealt with the condition. Thus the condition will not\n", 
#&gt;                 "be passed on to other potential handlers established on the stack.\n"), 
#&gt;             "\n", list("\n", "# This is a restart that takes a data frame and names as arguments\n", 
#&gt;                 "rst_bar &lt;- function(df, nms) {\n", "  stats::setNames(df, nms)\n", 
#&gt;                 "}\n", "\n", "# This restart is simpler and does not take arguments\n", 
#&gt;                 "rst_baz &lt;- function() \"baz\"\n", "\n", "# Signalling a condition parameterised with a data frame\n", 
#&gt;                 "fn &lt;- function() {\n", "  with_restarts(signal(\"A foobar condition occurred\", \"foo\", foo_field = mtcars),\n", 
#&gt;                 "    rst_bar = rst_bar,\n", "    rst_baz = rst_baz\n", 
#&gt;                 "  )\n", "}\n", "\n", "# Creating a restarting handler that passes arguments `nms` and\n", 
#&gt;                 "# `df`, the latter taken from a data field of the condition object\n", 
#&gt;                 "restart_bar &lt;- restarting(\"rst_bar\",\n", "  nms = LETTERS[1:11], .fields = c(df = \"foo_field\")\n", 
#&gt;                 ")\n", "\n", "# The restarting handlers jumps to `rst_bar` when `foo` is signalled:\n", 
#&gt;                 "with_handlers(fn(), foo = restart_bar)\n", "\n", 
#&gt;                 "# The restarting() constructor is especially nice to use with\n", 
#&gt;                 "# restarts that do not need arguments:\n", "with_handlers(fn(), foo = restarting(\"rst_baz\"))\n"), 
#&gt;             "\n", list("\n", list(list("calling()")), " and ", 
#&gt;                 list(list("exiting()")), ".\n"), "\n", list("internal"), 
#&gt;             "\n"), return_from.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/stack.R", 
#&gt;             "\n", list("return_from"), "\n", list("return_from"), 
#&gt;             "\n", list("return_to"), "\n", list("Jump to or from a frame"), 
#&gt;             "\n", list("\n", "return_from(frame, value = NULL)\n", 
#&gt;                 "\n", "return_to(frame, value = NULL)\n"), "\n", 
#&gt;             list("\n", list(list("frame"), list("An environment, a frame object, or any object with an\n", 
#&gt;                 list(list("get_env()")), " method. The environment should be an evaluation\n", 
#&gt;                 "environment currently on the stack.")), "\n", 
#&gt;                 "\n", list(list("value"), list("The return value.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "While ", list(list("base::return()")), 
#&gt;                 " can only return from the current local\n", 
#&gt;                 "frame, these two functions will return from any frame on the\n", 
#&gt;                 "current evaluation stack, between the global and the currently\n", 
#&gt;                 "active context. They provide a way of performing arbitrary\n", 
#&gt;                 "non-local jumps out of the function currently under evaluation.\n"), 
#&gt;             "\n", list("\n", list("return_from()"), " will jump out of ", 
#&gt;                 list("frame"), ". ", list("return_to()"), " is a bit\n", 
#&gt;                 "trickier. It will jump out of the frame located just before ", 
#&gt;                 list("frame"), "\n", "in the evaluation stack, so that control flow ends up in ", 
#&gt;                 list("frame"), ",\n", "at the location where the previous frame was called from.\n", 
#&gt;                 "\n", "These functions should only be used rarely. These sort of non-local\n", 
#&gt;                 "gotos can be hard to reason about in casual code, though they can\n", 
#&gt;                 "sometimes be useful. Also, consider to use the condition system to\n", 
#&gt;                 "perform non-local jumps.\n"), "\n", list(list(
#&gt;                 "Life cycle"), list("\n", "\n", "\n", "The support for ", 
#&gt;                 list("frame"), " object is soft-deprecated.  Please pass\n", 
#&gt;                 "simple environments to ", list("return_from()"), 
#&gt;                 " and ", list("return_to()"), ".\n", "\n", "These functions are in the questioning lifecycle because we are\n", 
#&gt;                 "considering simpler alternatives.\n")), "\n", 
#&gt;             "\n", list("\n", "# Passing fn() evaluation frame to g():\n", 
#&gt;                 "fn &lt;- function() {\n", "  val &lt;- g(current_env())\n", 
#&gt;                 "  cat(\"g returned:\", val, \"\\n\")\n", "  \"normal return\"\n", 
#&gt;                 "}\n", "g &lt;- function(env) h(env)\n", "\n", "# Here we return from fn() with a new return value:\n", 
#&gt;                 "h &lt;- function(env) return_from(env, \"early return\")\n", 
#&gt;                 "fn()\n", "\n", "# Here we return to fn(). The call stack unwinds until the last frame\n", 
#&gt;                 "# called by fn(), which is g() in that case.\n", 
#&gt;                 "h &lt;- function(env) return_to(env, \"early return\")\n", 
#&gt;                 "fn()\n"), "\n", list("internal"), "\n"), rlang_backtrace_on_error.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/cnd-abort.R", "\n", 
#&gt;             list("rlang_backtrace_on_error"), "\n", list("rlang_backtrace_on_error"), 
#&gt;             "\n", list("add_backtrace"), "\n", list("Display backtrace on error"), 
#&gt;             "\n", list("\n", "Errors thrown with ", list(list(
#&gt;                 "abort()")), " automatically save a backtrace that\n", 
#&gt;                 "can be inspected by calling ", list(list("last_error()")), 
#&gt;                 ". Optionally, you can\n", "also display the backtrace alongside the error message by setting\n", 
#&gt;                 "the option ", list("rlang_backtrace_on_error"), 
#&gt;                 " to one of the following\n", "values:\n", list(
#&gt;                   "\n", list(), " ", list("\"reminder\""), ": Display a reminder that the backtrace can be\n", 
#&gt;                   "inspected by calling ", list(list("rlang::last_error()")), 
#&gt;                   ".\n", list(), " ", list("\"branch\""), ": Display a simplified backtrace.\n", 
#&gt;                   list(), " ", list("\"collapse\""), ": Display a collapsed backtrace tree.\n", 
#&gt;                   list(), " ", list("\"full\""), ": Display the full backtrace tree.\n"), 
#&gt;                 "\n"), "\n", list(list("Promote base errors to rlang errors"), 
#&gt;                 list("\n", "\n", "\n", "Call ", list("options(error = rlang::enframe)"), 
#&gt;                   " to instrument base\n", "errors with rlang features. This handler does two things:\n", 
#&gt;                   list("\n", list(), " It saves the base error as an rlang object. This allows you to\n", 
#&gt;                     "call ", list(list("last_error()")), " to print the backtrace or inspect its data.\n", 
#&gt;                     list(), " It prints the backtrace for the current error according to the\n", 
#&gt;                     list(list("rlang_backtrace_on_error")), " option.\n"), 
#&gt;                   "\n")), "\n", "\n", list("\n", "# Display a simplified backtrace on error for both base and rlang\n", 
#&gt;                 "# errors:\n", "\n", "# options(\n", "#   rlang_backtrace_on_error = \"branch\",\n", 
#&gt;                 "#   error = rlang::enframe\n", "# )\n", "# stop(\"foo\")\n"), 
#&gt;             "\n"), rst_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_abort"), "\n", list("rst_abort"), 
#&gt;             "\n", list("Jump to the abort restart"), "\n", list(
#&gt;                 "\n", "rst_abort()\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"questioning\")"), "\n", 
#&gt;                 "\n", "The abort restart is the only restart that is established at top\n", 
#&gt;                 "level. It is used by R as a top-level target, most notably when an\n", 
#&gt;                 "error is issued (see ", list(list("abort()")), 
#&gt;                 ") that no handler is able\n", "to deal with (see ", 
#&gt;                 list(list("with_handlers()")), ").\n"), "\n", 
#&gt;             list(list("Life cycle"), list("\n", "\n", "\n", "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# The `abort` restart is a bit special in that it is always\n", 
#&gt;                 "# registered in a R session. You will always find it on the restart\n", 
#&gt;                 "# stack because it is established at top level:\n", 
#&gt;                 "rst_list()\n", "\n", "# You can use the `above` restart to jump to top level without\n", 
#&gt;                 "# signalling an error:\n", list("\n", "fn &lt;- function() {\n", 
#&gt;                   "  cat(\"aborting...\\n\")\n", "  rst_abort()\n", 
#&gt;                   "  cat(\"This is never called\\n\")\n", "}\n", 
#&gt;                   "{\n", "  fn()\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# The `above` restart is the target that R uses to jump to top\n", 
#&gt;                 "# level when critical errors are signalled:\n", 
#&gt;                 list("\n", "{\n", "  abort(\"error\")\n", "  cat(\"This is never called\\n\")\n", 
#&gt;                   "}\n"), "\n", "\n", "# If another `abort` restart is specified, errors are signalled as\n", 
#&gt;                 "# usual but then control flow resumes with from the new restart:\n", 
#&gt;                 list("\n", "out &lt;- NULL\n", "{\n", "  out &lt;- with_restarts(abort(\"error\"), abort = function() \"restart!\")\n", 
#&gt;                   "  cat(\"This is called\\n\")\n", "}\n", "cat(\"`out` has now become:\", out, \"\\n\")\n"), 
#&gt;                 "\n"), "\n", list("\n", list(list("rst_jump()")), 
#&gt;                 ", ", list(list("abort()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), rst_list.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("rst_list"), "\n", list("rst_list"), "\n", 
#&gt;             list("rst_exists"), "\n", list("rst_jump"), "\n", 
#&gt;             list("rst_maybe_jump"), "\n", list("Restarts utilities"), 
#&gt;             "\n", list("\n", "rst_list()\n", "\n", "rst_exists(.restart)\n", 
#&gt;                 "\n", "rst_jump(.restart, ...)\n", "\n", "rst_maybe_jump(.restart, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".restart"), list("The name of a restart.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments passed on to the restart function. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restarts are named jumping points established by ", 
#&gt;                 list(list("with_restarts()")), ".\n", list("rst_list()"), 
#&gt;                 " returns the names of all restarts currently\n", 
#&gt;                 "established. ", list("rst_exists()"), " checks if a given restart is\n", 
#&gt;                 "established. ", list("rst_jump()"), " stops execution of the current function\n", 
#&gt;                 "and jumps to a restart point. If the restart does not exist, an\n", 
#&gt;                 "error is thrown.  ", list("rst_maybe_jump()"), 
#&gt;                 " first checks that a restart\n", "exists before jumping.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 list(list("with_restarts()")), "\n"), "\n", list(
#&gt;                 "internal"), "\n"), `scalar-type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("scalar-type-predicates"), "\n", list("scalar-type-predicates"), 
#&gt;             "\n", list("is_scalar_list"), "\n", list("is_scalar_atomic"), 
#&gt;             "\n", list("is_scalar_vector"), "\n", list("is_scalar_integer"), 
#&gt;             "\n", list("is_scalar_double"), "\n", list("is_scalar_character"), 
#&gt;             "\n", list("is_scalar_logical"), "\n", list("is_scalar_raw"), 
#&gt;             "\n", list("is_string"), "\n", list("is_scalar_bytes"), 
#&gt;             "\n", list("is_bool"), "\n", list("Scalar type predicates"), 
#&gt;             "\n", list("\n", "is_scalar_list(x)\n", "\n", "is_scalar_atomic(x)\n", 
#&gt;                 "\n", "is_scalar_vector(x)\n", "\n", "is_scalar_integer(x)\n", 
#&gt;                 "\n", "is_scalar_double(x)\n", "\n", "is_scalar_character(x, encoding = NULL)\n", 
#&gt;                 "\n", "is_scalar_logical(x)\n", "\n", "is_scalar_raw(x)\n", 
#&gt;                 "\n", "is_string(x, string = NULL)\n", "\n", 
#&gt;                 "is_scalar_bytes(x)\n", "\n", "is_bool(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("object to be tested.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n", "\n", list(list("string"), list("A string to compare to ", 
#&gt;                   list("x"), ". If a character vector,\n", "returns ", 
#&gt;                   list("TRUE"), " if at least one element is equal to ", 
#&gt;                   list("x"), ".")), "\n"), "\n", list("\n", "These predicates check for a given type and whether the vector is\n", 
#&gt;                 "\"scalar\", that is, of length 1.\n", "\n", 
#&gt;                 "In addition to the length check, ", list("is_string()"), 
#&gt;                 " and ", list("is_bool()"), "\n", "return ", 
#&gt;                 list("FALSE"), " if their input is missing. This is useful for\n", 
#&gt;                 "type-checking arguments, when your function expects a single string\n", 
#&gt;                 "or a single ", list("TRUE"), " or ", list("FALSE"), 
#&gt;                 ".\n"), "\n", list("\n", list("type-predicates"), 
#&gt;                 ", ", list("bare-type-predicates"), "\n"), "\n"), 
#&gt;         scoped_bindings.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/env-binding.R", 
#&gt;             "\n", list("scoped_bindings"), "\n", list("scoped_bindings"), 
#&gt;             "\n", list("with_bindings"), "\n", list("Temporarily change bindings of an environment"), 
#&gt;             "\n", list("\n", "scoped_bindings(..., .env = .frame, .frame = caller_env())\n", 
#&gt;                 "\n", "with_bindings(.expr, ..., .env = caller_env())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Pairs of names and values. These dots support splicing\n", 
#&gt;                 "(with value semantics) and name unquoting.")), 
#&gt;                 "\n", "\n", list(list(".env"), list("An environment.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The frame environment that determines the scope of\n", 
#&gt;                   "the temporary bindings. When that frame is popped from the call\n", 
#&gt;                   "stack, bindings are switched back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary bindings.")), 
#&gt;                 "\n"), "\n", list("\n", list("scoped_bindings()"), 
#&gt;                 " returns the values of old bindings\n", "invisibly; ", 
#&gt;                 list("with_bindings()"), " returns the value of ", 
#&gt;                 list("expr"), ".\n"), "\n", list("\n", list("\n", 
#&gt;                 list(), " ", list("scoped_bindings()"), " temporarily changes bindings in ", 
#&gt;                 list(".env"), " (which\n", "is by default the caller environment). The bindings are reset to\n", 
#&gt;                 "their original values when the current frame (or an arbitrary one\n", 
#&gt;                 "if you specify ", list(".frame"), ") goes out of scope.\n", 
#&gt;                 list(), " ", list("with_bindings()"), " evaluates ", 
#&gt;                 list("expr"), " with temporary bindings. When\n", 
#&gt;                 list("with_bindings()"), " returns, bindings are reset to their original\n", 
#&gt;                 "values. It is a simple wrapper around ", list(
#&gt;                   "scoped_bindings()"), ".\n"), "\n"), "\n", 
#&gt;             list("\n", "foo &lt;- \"foo\"\n", "bar &lt;- \"bar\"\n", 
#&gt;                 "\n", "# `foo` will be temporarily rebinded while executing `expr`\n", 
#&gt;                 "with_bindings(paste(foo, bar), foo = \"rebinded\")\n", 
#&gt;                 "paste(foo, bar)\n"), "\n"), scoped_env.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("scoped_env"), "\n", list("scoped_env"), 
#&gt;             "\n", list("is_scoped"), "\n", list("scoped_envs"), 
#&gt;             "\n", list("scoped_names"), "\n", list("Retired ", 
#&gt;                 list("scoped"), " functions"), "\n", list("\n", 
#&gt;                 "scoped_env(nm)\n", "\n", "is_scoped(nm)\n", 
#&gt;                 "\n", "scoped_envs()\n", "\n", "scoped_names()\n"), 
#&gt;             "\n", list("\n", list(list("nm"), list("The name of an environment attached to the search\n", 
#&gt;                 "path. Call ", list(list("base::search()")), 
#&gt;                 " to see what is currently on the path.")), "\n"), 
#&gt;             "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions are deprecated as of rlang 0.3.0. They are replaced\n", 
#&gt;                 "by ", list(list("is_attached()")), ", ...\n"), 
#&gt;             "\n", list("internal"), "\n"), scoped_options.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/state.R", "\n", 
#&gt;             list("scoped_options"), "\n", list("scoped_options"), 
#&gt;             "\n", list("with_options"), "\n", list("push_options"), 
#&gt;             "\n", list("peek_options"), "\n", list("peek_option"), 
#&gt;             "\n", list("Change global options"), "\n", list("\n", 
#&gt;                 "scoped_options(..., .frame = caller_env())\n", 
#&gt;                 "\n", "with_options(.expr, ...)\n", "\n", "push_options(...)\n", 
#&gt;                 "\n", "peek_options(...)\n", "\n", "peek_option(name)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("For ", list(
#&gt;                 "scoped_options()"), " and ", list("push_options()"), 
#&gt;                 ", named\n", "values defining new option values. For ", 
#&gt;                 list("peek_options()"), ", strings\n", "or character vectors of option names.")), 
#&gt;                 "\n", "\n", list(list(".frame"), list("The environment of a stack frame which defines the\n", 
#&gt;                   "scope of the temporary options. When the frame returns, the\n", 
#&gt;                   "options are set back to their original values.")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("An expression to evaluate with temporary options.")), 
#&gt;                 "\n", "\n", list(list("name"), list("An option name as string.")), 
#&gt;                 "\n"), "\n", list("\n", "For ", list("scoped_options()"), 
#&gt;                 " and ", list("push_options()"), ", the old option\n", 
#&gt;                 "values. ", list("peek_option()"), " returns the current value of an option\n", 
#&gt;                 "while the plural ", list("peek_options()"), 
#&gt;                 " returns a list of current\n", "option values.\n"), 
#&gt;             "\n", list("\n", list("\n", list(), " ", list("scoped_options()"), 
#&gt;                 " changes options for the duration of a stack\n", 
#&gt;                 "frame (by default the current one). Options are set back to their\n", 
#&gt;                 "old values when the frame returns.\n", list(), 
#&gt;                 " ", list("with_options()"), " changes options while an expression is\n", 
#&gt;                 "evaluated. Options are restored when the expression returns.\n", 
#&gt;                 list(), " ", list("push_options()"), " adds or changes options permanently.\n", 
#&gt;                 list(), " ", list("peek_option()"), " and ", 
#&gt;                 list("peek_options()"), " return option values. The\n", 
#&gt;                 "former returns the option directly while the latter returns a\n", 
#&gt;                 "list.\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", "\n", "These functions are experimental.\n")), 
#&gt;             "\n", "\n", list("\n", "# Store and retrieve a global option:\n", 
#&gt;                 "push_options(my_option = 10)\n", "peek_option(\"my_option\")\n", 
#&gt;                 "\n", "# Change the option temporarily:\n", "with_options(my_option = 100, peek_option(\"my_option\"))\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The scoped variant is useful within functions:\n", 
#&gt;                 "fn &lt;- function() {\n", "  scoped_options(my_option = 100)\n", 
#&gt;                 "  peek_option(\"my_option\")\n", "}\n", "fn()\n", 
#&gt;                 "peek_option(\"my_option\")\n", "\n", "# The plural peek returns a named list:\n", 
#&gt;                 "peek_options(\"my_option\")\n", "peek_options(\"my_option\", \"digits\")\n"), 
#&gt;             "\n", list("experimental"), "\n"), search_envs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/env-special.R", 
#&gt;             "\n", list("search_envs"), "\n", list("search_envs"), 
#&gt;             "\n", list("search_env"), "\n", list("pkg_env"), 
#&gt;             "\n", list("pkg_env_name"), "\n", list("is_attached"), 
#&gt;             "\n", list("base_env"), "\n", list("global_env"), 
#&gt;             "\n", list("Search path environments"), "\n", list(
#&gt;                 "\n", "search_envs()\n", "\n", "search_env(name)\n", 
#&gt;                 "\n", "pkg_env(pkg)\n", "\n", "pkg_env_name(pkg)\n", 
#&gt;                 "\n", "is_attached(x)\n", "\n", "base_env()\n", 
#&gt;                 "\n", "global_env()\n"), "\n", list("\n", list(
#&gt;                 list("name"), list("The name of an environment attached to the search\n", 
#&gt;                   "path. Call ", list(list("base::search()")), 
#&gt;                   " to get the names of environments\n", "currently attached to the search path. Note that the search name\n", 
#&gt;                   "of a package environment is prefixed with ", 
#&gt;                   list("\"package:\""), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("The name of a package.")), 
#&gt;                 "\n"), "\n", list("\n", "The search path is a chain of environments containing exported\n", 
#&gt;                 "functions of attached packages.\n", "\n", "The API includes:\n", 
#&gt;                 list("\n", list(), " ", list(list("base::search()")), 
#&gt;                   " to get the names of environments attached to the\n", 
#&gt;                   "search path.\n", list(), " ", list("search_envs()"), 
#&gt;                   " returns the environments on the search path as a\n", 
#&gt;                   "list.\n", list(), " ", list("pkg_env_name()"), 
#&gt;                   " takes a bare package name and prefixes it with\n", 
#&gt;                   list("\"package:\""), ". Attached package environments have search names of\n", 
#&gt;                   "the form ", list("package:name"), ".\n", list(), 
#&gt;                   " ", list("pkg_env()"), " takes a bare package name and returns the scoped\n", 
#&gt;                   "environment of packages if they are attached to the search path,\n", 
#&gt;                   "and throws an error otherwise. It is a shortcut for\n", 
#&gt;                   list("search_env(pkg_env_name(\"pkgname\"))"), 
#&gt;                   ".\n", list(), " ", list("is_attached()"), 
#&gt;                   " returns ", list("TRUE"), " when its argument (a search name\n", 
#&gt;                   "or a package environment) is attached to the search path.\n"), 
#&gt;                 "\n"), "\n", list(list("The search path"), list(
#&gt;                 "\n", "\n", "\n", "This chain of environments determines what objects are visible from\n", 
#&gt;                 "the global workspace. It contains the following elements:\n", 
#&gt;                 list("\n", list(), " The chain always starts with ", 
#&gt;                   list("global_env()"), " and finishes with\n", 
#&gt;                   list("base_env()"), " (technically, it finishes with the ", 
#&gt;                   list("empty_env()"), "\n", "which the base package environment inherits from).\n", 
#&gt;                   list(), " Each ", list(list("base::library()")), 
#&gt;                   " call attaches a new package environment to\n", 
#&gt;                   "the search path. Attached packages are associated with a ", 
#&gt;                   list("search name"), ".\n", list(), " In addition, any list, data frame, or environment can be attached\n", 
#&gt;                   "to the search path with ", list(list("base::attach()")), 
#&gt;                   ".\n"), "\n")), "\n", "\n", list("\n", "# List the search names of environments attached to the search path:\n", 
#&gt;                 "search()\n", "\n", "# Get the corresponding environments:\n", 
#&gt;                 "search_envs()\n", "\n", "# The global environment and the base package are always first and\n", 
#&gt;                 "# last in the chain, respectively:\n", "envs &lt;- search_envs()\n", 
#&gt;                 "envs[[1]]\n", "envs[[length(envs)]]\n", "\n", 
#&gt;                 "# These two environments have their own shortcuts:\n", 
#&gt;                 "global_env()\n", "base_env()\n", "\n", "# Packages appear in the search path with a special name. Use\n", 
#&gt;                 "# pkg_env_name() to create that name:\n", "pkg_env_name(\"rlang\")\n", 
#&gt;                 "search_env(pkg_env_name(\"rlang\"))\n", "\n", 
#&gt;                 "# Alternatively, get the scoped environment of a package with\n", 
#&gt;                 "# pkg_env():\n", "pkg_env(\"utils\")\n"), "\n", 
#&gt;             list("internal"), "\n"), seq2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("seq2"), "\n", list("seq2"), "\n", list("seq2_along"), 
#&gt;             "\n", list("Increasing sequence of integers in an interval"), 
#&gt;             "\n", list("\n", "seq2(from, to)\n", "\n", "seq2_along(from, x)\n"), 
#&gt;             "\n", list("\n", list(list("from"), list("The starting point of the sequence.")), 
#&gt;                 "\n", "\n", list(list("to"), list("The end point.")), 
#&gt;                 "\n", "\n", list(list("x"), list("A vector whose length is the end point.")), 
#&gt;                 "\n"), "\n", list("\n", "An integer vector containing a strictly increasing\n", 
#&gt;                 "sequence.\n"), "\n", list("\n", "These helpers take two endpoints and return the sequence of all\n", 
#&gt;                 "integers within that interval. For ", list("seq2_along()"), 
#&gt;                 ", the upper\n", "endpoint is taken from the length of a vector. Unlike\n", 
#&gt;                 list("base::seq()"), ", they return an empty vector if the starting point is\n", 
#&gt;                 "a larger integer than the end point.\n"), "\n", 
#&gt;             list("\n", "seq2(2, 10)\n", "seq2(10, 2)\n", "seq(10, 2)\n", 
#&gt;                 "\n", "seq2_along(10, letters)\n"), "\n"), set_attrs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("set_attrs"), "\n", list("set_attrs"), 
#&gt;             "\n", list("mut_attrs"), "\n", list("Add attributes to an object"), 
#&gt;             "\n", list("\n", "set_attrs(.x, ...)\n", "\n", "mut_attrs(.x, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("An object to decorate with attributes.")), 
#&gt;                 "\n", "\n", list(list("..."), list("A list of named attributes. These have ", 
#&gt;                   list("explicit splicing semantics"), ". Pass a single unnamed ", 
#&gt;                   list("NULL"), " argument to\n", "zap all attributes from ", 
#&gt;                   list(".x"), ".")), "\n"), "\n", list("\n", 
#&gt;                 list("set_attrs()"), " returns a modified ", 
#&gt;                 list("shallow copy"), "\n", "of ", list(".x"), 
#&gt;                 ". ", list("mut_attrs()"), " invisibly returns the original ", 
#&gt;                 list(".x"), "\n", "modified in place.\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list("set_attrs()"), " adds, changes, or zaps attributes of objects. Pass a\n", 
#&gt;                 "single unnamed ", list("NULL"), " argument to zap all attributes. For\n", 
#&gt;                 list("uncopyable"), " types, use ", list("mut_attrs()"), 
#&gt;                 ".\n"), "\n", list("\n", "Unlike ", list(list(
#&gt;                 "structure()")), ", these setters have no special handling of\n", 
#&gt;                 "internal attributes names like ", list(".Dim"), 
#&gt;                 ", ", list(".Dimnames"), " or ", list(".Names"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are deprecated since rlang 0.3.0.\n")), 
#&gt;             "\n", "\n", list("\n", "set_attrs(letters, names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "\n", "# Splice a list of attributes:\n", "attrs &lt;- list(attr = \"attr\", names = 1:26, class = \"my_chr\")\n", 
#&gt;                 "obj &lt;- set_attrs(letters, splice(attrs))\n", 
#&gt;                 "obj\n", "\n", "# Zap attributes by passing a single unnamed NULL argument:\n", 
#&gt;                 "set_attrs(obj, NULL)\n", "set_attrs(obj, !!! list(NULL))\n", 
#&gt;                 "\n", "# Note that set_attrs() never modifies objects in place:\n", 
#&gt;                 "obj\n", "\n", "# For uncopyable types, mut_attrs() lets you modify in place:\n", 
#&gt;                 "env &lt;- env()\n", "mut_attrs(env, foo = \"bar\")\n", 
#&gt;                 "env\n"), "\n", list("internal"), "\n"), set_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/expr.R", "\n", 
#&gt;             list("set_expr"), "\n", list("set_expr"), "\n", list(
#&gt;                 "get_expr"), "\n", list("Set and get an expression"), 
#&gt;             "\n", list("\n", "set_expr(x, value)\n", "\n", "get_expr(x, default = x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("An expression, closure, or one-sided formula. In addition,\n", 
#&gt;                 list("set_expr()"), " accept frames.")), "\n", 
#&gt;                 "\n", list(list("value"), list("An updated expression.")), 
#&gt;                 "\n", "\n", list(list("default"), list("A default expression to return when ", 
#&gt;                   list("x"), " is not an\n", "expression wrapper. Defaults to ", 
#&gt;                   list("x"), " itself.")), "\n"), "\n", list(
#&gt;                 "\n", "The updated original input for ", list(
#&gt;                   "set_expr()"), ". A raw\n", "expression for ", 
#&gt;                 list("get_expr()"), ".\n"), "\n", list("\n", 
#&gt;                 "These helpers are useful to make your function work generically\n", 
#&gt;                 "with quosures and raw expressions. First call ", 
#&gt;                 list("get_expr()"), " to\n", "extract an expression. Once you're done processing the expression,\n", 
#&gt;                 "call ", list("set_expr()"), " on the original object to update the expression.\n", 
#&gt;                 "You can return the result of ", list("set_expr()"), 
#&gt;                 ", either a formula or an\n", "expression depending on the input type. Note that ", 
#&gt;                 list("set_expr()"), " does\n", "not change its input, it creates a new object.\n"), 
#&gt;             "\n", list("\n", "f &lt;- ~foo(bar)\n", "e &lt;- quote(foo(bar))\n", 
#&gt;                 "frame &lt;- identity(identity(ctxt_frame()))\n", 
#&gt;                 "\n", "get_expr(f)\n", "get_expr(e)\n", "get_expr(frame)\n", 
#&gt;                 "\n", "set_expr(f, quote(baz))\n", "set_expr(e, quote(baz))\n"), 
#&gt;             "\n", list("\n", list(list("quo_get_expr()")), " and ", 
#&gt;                 list(list("quo_set_expr()")), " for versions of\n", 
#&gt;                 list(list("get_expr()")), " and ", list(list(
#&gt;                   "set_expr()")), " that only work on quosures.\n"), 
#&gt;             "\n"), set_names.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/attr.R", 
#&gt;             "\n", list("set_names"), "\n", list("set_names"), 
#&gt;             "\n", list("Set names of a vector"), "\n", list("\n", 
#&gt;                 "set_names(x, nm = x, ...)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("Vector to name.")), "\n", 
#&gt;                 "\n", list(list("nm, ..."), list("Vector of names, the same length as ", 
#&gt;                   list("x"), ".\n", "\n", "You can specify names in the following ways:\n", 
#&gt;                   list("\n", list(), " If you do nothing, ", 
#&gt;                     list("x"), " will be named with itself.\n", 
#&gt;                     list(), " If ", list("x"), " already has names, you can provide a function or formula\n", 
#&gt;                     "to transform the existing names. In that case, ", 
#&gt;                     list("..."), " is passed\n", "to the function.\n", 
#&gt;                     list(), " If ", list("nm"), " is ", list(
#&gt;                       "NULL"), ", the names are removed (if present).\n", 
#&gt;                     list(), " In all other cases, ", list("nm"), 
#&gt;                     " and ", list("..."), " are coerced to character.\n"))), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"stable\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "stats::setNames()")), ", with more features and\n", 
#&gt;                 "stricter argument checking.\n"), "\n", list(
#&gt;                 list("Life cycle"), list("\n", "\n", "\n", list(
#&gt;                   "set_names()"), " is stable and exported in purrr.\n")), 
#&gt;             "\n", "\n", list("\n", "set_names(1:4, c(\"a\", \"b\", \"c\", \"d\"))\n", 
#&gt;                 "set_names(1:4, letters[1:4])\n", "set_names(1:4, \"a\", \"b\", \"c\", \"d\")\n", 
#&gt;                 "\n", "# If the second argument is ommitted a vector is named with itself\n", 
#&gt;                 "set_names(letters[1:5])\n", "\n", "# Alternatively you can supply a function\n", 
#&gt;                 "set_names(1:10, ~ letters[seq_along(.)])\n", 
#&gt;                 "set_names(head(mtcars), toupper)\n", "\n", "# If the input vector is unnamed, it is first named after itself\n", 
#&gt;                 "# before the function is applied:\n", "set_names(letters, toupper)\n", 
#&gt;                 "\n", "# `...` is passed to the function:\n", 
#&gt;                 "set_names(head(mtcars), paste0, \"_foo\")\n"), 
#&gt;             "\n"), splice.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R", 
#&gt;             "\n", list("splice"), "\n", list("splice"), "\n", 
#&gt;             list("is_spliced"), "\n", list("is_spliced_bare"), 
#&gt;             "\n", list("dots_splice"), "\n", list("Splice lists"), 
#&gt;             "\n", list("\n", "splice(x)\n", "\n", "is_spliced(x)\n", 
#&gt;                 "\n", "is_spliced_bare(x)\n", "\n", "dots_splice(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n"), "\n", 
#&gt;             list("\n", list(list("x"), list("A list to splice.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Arguments to collect with ", 
#&gt;                   list("!!!"), " support.")), "\n", "\n", list(
#&gt;                   list(".ignore_empty"), list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                     "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                     ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                     ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", list("\n", list(), " ", list("splice"), 
#&gt;                   " marks an object to be spliced. It is equivalent to using\n", 
#&gt;                   list("!!!"), " in a function with ", list("tidy dots semantics"), 
#&gt;                   ".\n", list(), " ", list("dots_splice()"), 
#&gt;                   " is like ", list(list("dots_list()")), " but automatically splices\n", 
#&gt;                   "list inputs.\n"), "\n"), "\n", list(list("Standard splicing versus quoting splicing"), 
#&gt;                 list("\n", "\n", "\n", "The ", list("!!!"), " operator works differently in ", 
#&gt;                   list("standard"), " functions taking\n", "dots with ", 
#&gt;                   list("dots_list()"), " than in ", list("quoting"), 
#&gt;                   " functions taking dots\n", "with ", list(list(
#&gt;                     "enexprs()")), " or ", list(list("enquos()")), 
#&gt;                   ".\n", list("\n", list(), " In quoting functions ", 
#&gt;                     list("!!!"), " disaggregates its argument (let's call\n", 
#&gt;                     "it ", list("x"), ") into as many objects as there are elements in\n", 
#&gt;                     list("x"), ". E.g. ", list("quo(foo(!!! c(1, 2)))"), 
#&gt;                     " is completely equivalent to\n", list("quo(foo(1, 2))"), 
#&gt;                     ". The creation of those separate objects has an\n", 
#&gt;                     "overhead but is typically not important when manipulating calls\n", 
#&gt;                     "because function calls typically take a small number of\n", 
#&gt;                     "arguments.\n", list(), " In standard functions, disaggregating the spliced collection\n", 
#&gt;                     "would have a negative performance impact in cases where\n", 
#&gt;                     list("dots_list()"), " is used to build up data structures from user\n", 
#&gt;                     "inputs. To avoid this spliced inputs are marked with ", 
#&gt;                     list(list("splice()")), "\n", "and the final list is built with (the equivalent of)\n", 
#&gt;                     list("flatten_if(dots, is_spliced)"), ".\n"), 
#&gt;                   "\n", "\n", "Most of the time you should not care about the difference. However\n", 
#&gt;                   "if you use a standard function taking tidy dots within a quoting\n", 
#&gt;                   "function, the ", list("!!!"), " operator will disaggregate its argument because\n", 
#&gt;                   "the behaviour of the quasiquoting function has priority. You might\n", 
#&gt;                   "then observe some performance cost in edge cases. Here is one\n", 
#&gt;                   "example where this would happen:", list("purrr::rerun(10, dplyr::bind_rows(!!! x))\n"), 
#&gt;                   "\n", "\n", list("purrr::rerun()"), " is a quoting function and ", 
#&gt;                   list("dplyr::bind_rows()"), " is\n", "a standard function. Because ", 
#&gt;                   list("bind_rows()"), " is called ", list("inside"), 
#&gt;                   "\n", list("rerun()"), ", the list ", list(
#&gt;                     "x"), " will be disaggregated into a pairlist of\n", 
#&gt;                   "arguments. To avoid this you can use ", list(
#&gt;                     "splice()"), " instead:", list("purrr::rerun(10, dplyr::bind_rows(splice(x)))\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " ", list(
#&gt;                   "dots_splice()"), " is in the questioning stage. It is part of our\n", 
#&gt;                   "experiments with dots semantics. Compared to ", 
#&gt;                   list("dots_list()"), ",\n", list("dots_splice()"), 
#&gt;                   " automatically splices lists. We now lean towards\n", 
#&gt;                   "adopting a single type of dots semantics (those of ", 
#&gt;                   list("dots_list()"), ")\n", "where splicing is explicit.\n", 
#&gt;                   list(), " ", list("splice()"), " is in the questioning stage. It is not clear whether it is\n", 
#&gt;                   "really needed as there are other ways to avoid the performance\n", 
#&gt;                   "issue discussed above.\n"), "\n")), "\n", 
#&gt;             "\n", list("internal"), "\n"), stack.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack"), "\n", list("stack"), "\n", list(
#&gt;                 "global_frame"), "\n", list("current_frame"), 
#&gt;             "\n", list("ctxt_frame"), "\n", list("call_frame"), 
#&gt;             "\n", list("ctxt_depth"), "\n", list("call_depth"), 
#&gt;             "\n", list("ctxt_stack"), "\n", list("call_stack"), 
#&gt;             "\n", list("Call stack information"), "\n", list(
#&gt;                 "\n", "global_frame()\n", "\n", "current_frame()\n", 
#&gt;                 "\n", "ctxt_frame(n = 1)\n", "\n", "call_frame(n = 1, clean = TRUE)\n", 
#&gt;                 "\n", "ctxt_depth()\n", "\n", "call_depth()\n", 
#&gt;                 "\n", "ctxt_stack(n = NULL, trim = 0)\n", "\n", 
#&gt;                 "call_stack(n = NULL, clean = TRUE)\n"), "\n", 
#&gt;             list("\n", list(list("n"), list("The number of frames to go back in the stack.")), 
#&gt;                 "\n", "\n", list(list("clean"), list("Whether to post-process the call stack to clean\n", 
#&gt;                   "non-standard frames. If ", list("TRUE"), ", suboptimal call-stack entries by\n", 
#&gt;                   list(list("base::eval()")), " will be cleaned up: the duplicate frame created by\n", 
#&gt;                   list("eval()"), " is eliminated.")), "\n", 
#&gt;                 "\n", list(list("trim"), list("The number of layers of intervening frames to trim off\n", 
#&gt;                   "the stack. See ", list(list("stack_trim()")), 
#&gt;                   " and examples.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"deprecated\")"), "\n", 
#&gt;                 "\n", "The ", list("eval_"), " and ", list("call_"), 
#&gt;                 " families of functions provide a replacement\n", 
#&gt;                 "for the base R functions prefixed with ", list(
#&gt;                   "sys."), " (which are all about\n", "the context stack), as well as for ", 
#&gt;                 list(list("parent.frame()")), " (which is the\n", 
#&gt;                 "only base R function for querying the call stack). The context\n", 
#&gt;                 "stack includes all R-level evaluation contexts. It is linear in\n", 
#&gt;                 "terms of execution history but due to lazy evaluation it is\n", 
#&gt;                 "potentially nonlinear in terms of call history. The call stack\n", 
#&gt;                 "history, on the other hand, is homogenous.\n"), 
#&gt;             "\n", list("\n", list("ctxt_frame()"), " and ", list(
#&gt;                 "call_frame()"), " return a ", list("frame"), 
#&gt;                 " object\n", "containing the following fields: ", 
#&gt;                 list("expr"), " and ", list("env"), " (call expression\n", 
#&gt;                 "and evaluation environment), ", list("pos"), 
#&gt;                 " and ", list("caller_pos"), " (position of\n", 
#&gt;                 "current frame in the context stack and position of the caller), and\n", 
#&gt;                 list("fun"), " (function of the current frame). ", 
#&gt;                 list("ctxt_stack()"), " and\n", list("call_stack()"), 
#&gt;                 " return a list of all context or call frames on the\n", 
#&gt;                 "stack. Finally, ", list("ctxt_depth()"), " and ", 
#&gt;                 list("call_depth()"), " report the\n", "current context position or the number of calling frames on the\n", 
#&gt;                 "stack.\n", "\n", "The base R functions take two sorts of arguments to indicate which\n", 
#&gt;                 "frame to query: ", list("which"), " and ", list(
#&gt;                   "n"), ". The ", list("n"), " argument is\n", 
#&gt;                 "straightforward: it's the number of frames to go down the stack,\n", 
#&gt;                 "with ", list("n = 1"), " referring to the current context. The ", 
#&gt;                 list("which"), " argument\n", "is more complicated and changes meaning for values lower than 1.\n", 
#&gt;                 "For the sake of consistency, the rlang functions all take the\n", 
#&gt;                 "same kind of argument ", list("n"), ". This argument has a single meaning (the\n", 
#&gt;                 "number of frames to go down the stack) and cannot be lower than 1.\n", 
#&gt;                 "\n", "Note finally that ", list("parent.frame(1)"), 
#&gt;                 " corresponds to\n", list("call_frame(2)$env"), 
#&gt;                 ", as ", list("n = 1"), " always refers to the current\n", 
#&gt;                 "frame. This makes the ", list("_frame()"), " and ", 
#&gt;                 list("_stack()"), " functions\n", "consistent: ", 
#&gt;                 list("ctxt_frame(2)"), " is the same as ", list(
#&gt;                   "ctxt_stack()[[2]]"), ".\n", "Also, ", list(
#&gt;                   "ctxt_depth()"), " returns one more frame than\n", 
#&gt;                 list(list("base::sys.nframe()")), " because it counts the global frame. That is\n", 
#&gt;                 "consistent with the ", list("_stack()"), " functions which return the global\n", 
#&gt;                 "frame as well. This way, ", list("call_stack(call_depth())"), 
#&gt;                 " is the same as\n", list("global_frame()"), 
#&gt;                 ".\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", "These functions are soft-deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Expressions within arguments count as contexts\n", 
#&gt;                 "identity(identity(ctxt_depth())) # returns 2\n", 
#&gt;                 "\n", "# But they are not part of the call stack because arguments are\n", 
#&gt;                 "# evaluated within the calling function (or the global environment\n", 
#&gt;                 "# if called at top level)\n", "identity(identity(call_depth())) # returns 0\n", 
#&gt;                 "\n", "# The context stacks includes all intervening execution frames. The\n", 
#&gt;                 "# call stack doesn't:\n", "f &lt;- function(x) identity(x)\n", 
#&gt;                 "f(f(ctxt_stack()))\n", "f(f(call_stack()))\n", 
#&gt;                 "\n", "g &lt;- function(cmd) cmd()\n", "f(g(ctxt_stack))\n", 
#&gt;                 "f(g(call_stack))\n", "\n", "# The rlang _stack() functions return a list of frame\n", 
#&gt;                 "# objects. Use purrr::transpose() or index a field with\n", 
#&gt;                 "# purrr::map()'s to extract a particular field from a stack:\n", 
#&gt;                 "\n", "# stack &lt;- f(f(call_stack()))\n", "# purrr::map(stack, \"env\")\n", 
#&gt;                 "# purrr::transpose(stack)$expr\n", "\n", "# current_frame() is an alias for ctxt_frame(1)\n", 
#&gt;                 "fn &lt;- function() list(current = current_frame(), first = ctxt_frame(1))\n", 
#&gt;                 "fn()\n", "\n", "# While current_frame() is the top of the stack, global_frame() is\n", 
#&gt;                 "# the bottom:\n", "fn &lt;- function() {\n", "  n &lt;- ctxt_depth()\n", 
#&gt;                 "  ctxt_frame(n)\n", "}\n", "identical(fn(), global_frame())\n", 
#&gt;                 "\n", "\n", "# ctxt_stack() returns a stack with all intervening frames. You can\n", 
#&gt;                 "# trim layers of intervening frames with the trim argument:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "identity(identity(ctxt_stack(trim = 1)))\n", 
#&gt;                 "\n", "# ctxt_stack() is called within fn() with intervening frames:\n", 
#&gt;                 "fn &lt;- function(trim) identity(identity(ctxt_stack(trim = trim)))\n", 
#&gt;                 "fn(0)\n", "\n", "# We can trim the first layer of those:\n", 
#&gt;                 "fn(1)\n", "\n", "# The outside intervening frames (at the fn() call site) are still\n", 
#&gt;                 "# returned, but can be trimmed as well:\n", 
#&gt;                 "identity(identity(fn(1)))\n", "identity(identity(fn(2)))\n", 
#&gt;                 "\n", "g &lt;- function(trim) identity(identity(fn(trim)))\n", 
#&gt;                 "g(2)\n", "g(3)\n"), "\n", list("internal"), 
#&gt;             "\n"), stack_trim.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("stack_trim"), "\n", list("stack_trim"), 
#&gt;             "\n", list("Trim top call layers from the evaluation stack"), 
#&gt;             "\n", list("\n", "stack_trim(stack, n = 1)\n"), "\n", 
#&gt;             list("\n", list(list("stack"), list("An evaluation stack.")), 
#&gt;                 "\n", "\n", list(list("n"), list("The number of call frames (not eval frames) to trim off\n", 
#&gt;                   "the top of the stack. In other words, the number of layers of\n", 
#&gt;                   "intervening frames to trim.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", list(list("ctxt_stack()")), " can be tricky to use in real code because all\n", 
#&gt;                 "intervening frames are returned with the stack, including those at\n", 
#&gt;                 list("ctxt_stack()"), " own call site. ", list(
#&gt;                   "stack_trim()"), " makes it easy to\n", "remove layers of intervening calls.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated and replaced by ", 
#&gt;                 list(list("trace_back()")), ".\n")), "\n", "\n", 
#&gt;             list("\n", "# Intervening frames appear on the evaluation stack:\n", 
#&gt;                 "identity(identity(ctxt_stack()))\n", "\n", "# stack_trim() will trim the first n layers of calls:\n", 
#&gt;                 "stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "\n", "# Note that it also takes care of calls intervening at its own call\n", 
#&gt;                 "# site:\n", "identity(identity(\n", "  stack_trim(identity(identity(ctxt_stack())))\n", 
#&gt;                 "))\n", "\n", "# It is especially useful when used within a function that needs to\n", 
#&gt;                 "# inspect the evaluation stack but should nonetheless be callable\n", 
#&gt;                 "# within nested calls without side effects:\n", 
#&gt;                 "stack_util &lt;- function() {\n", "  # n = 2 means that two layers of intervening calls should be\n", 
#&gt;                 "  # removed: The layer at ctxt_stack()'s call site (including the\n", 
#&gt;                 "  # stack_trim() call), and the layer at stack_util()'s call.\n", 
#&gt;                 "  stack &lt;- stack_trim(ctxt_stack(), n = 2)\n", 
#&gt;                 "  stack\n", "}\n", "user_fn &lt;- function() {\n", 
#&gt;                 "  # A user calls your stack utility with intervening frames:\n", 
#&gt;                 "  identity(identity(stack_util()))\n", "}\n", 
#&gt;                 "# These intervening frames won't appear in the evaluation stack\n", 
#&gt;                 "identity(user_fn())\n"), "\n", list("internal"), 
#&gt;             "\n"), string.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-encoding.R", 
#&gt;             "\n", list("string"), "\n", list("string"), "\n", 
#&gt;             list("Create a string"), "\n", list("\n", "string(x, encoding = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A character vector or a vector or list of string-like\n", 
#&gt;                 "objects.")), "\n", "\n", list(list("encoding"), 
#&gt;                 list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "These base-type constructors allow more control over the creation\n", 
#&gt;                 "of strings in R. They take character vectors or string-like objects\n", 
#&gt;                 "(integerish or raw vectors), and optionally set the encoding. The\n", 
#&gt;                 "string version checks that the input contains a scalar string.\n"), 
#&gt;             "\n", list("\n", "# As everywhere in R, you can specify a string with Unicode\n", 
#&gt;                 "# escapes. The characters corresponding to Unicode codepoints will\n", 
#&gt;                 "# be encoded in UTF-8, and the string will be marked as UTF-8\n", 
#&gt;                 "# automatically:\n", "cafe &lt;- string(\"caf\\uE9\")\n", 
#&gt;                 "Encoding(cafe)\n", "as_bytes(cafe)\n", "\n", 
#&gt;                 "# In addition, string() provides useful conversions to let\n", 
#&gt;                 "# programmers control how the string is represented in memory. For\n", 
#&gt;                 "# encodings other than UTF-8, you'll need to supply the bytes in\n", 
#&gt;                 "# hexadecimal form. If it is a latin1 encoding, you can mark the\n", 
#&gt;                 "# string explicitly:\n", "cafe_latin1 &lt;- string(c(0x63, 0x61, 0x66, 0xE9), \"latin1\")\n", 
#&gt;                 "Encoding(cafe_latin1)\n", "as_bytes(cafe_latin1)\n"), 
#&gt;             "\n", list("internal"), "\n"), switch_type.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("switch_type"), "\n", list("switch_type"), 
#&gt;             "\n", list("coerce_type"), "\n", list("switch_class"), 
#&gt;             "\n", list("coerce_class"), "\n", list("Dispatch on base types"), 
#&gt;             "\n", list("\n", "switch_type(.x, ...)\n", "\n", 
#&gt;                 "coerce_type(.x, .to, ...)\n", "\n", "switch_class(.x, ...)\n", 
#&gt;                 "\n", "coerce_class(.x, .to, ...)\n"), "\n", 
#&gt;             list("\n", list(list(".x"), list("An object from which to dispatch.")), 
#&gt;                 "\n", "\n", list(list("..."), list("Named clauses. The names should be types as returned by\n", 
#&gt;                   list(list("type_of()")), ".")), "\n", "\n", 
#&gt;                 list(list(".to"), list("This is useful when you switchpatch within a coercing\n", 
#&gt;                   "function. If supplied, this should be a string indicating the\n", 
#&gt;                   "target type. A catch-all clause is then added to signal an error\n", 
#&gt;                   "stating the conversion failure. This type is prettified unless\n", 
#&gt;                   list(".to"), " inherits from the S3 class ", 
#&gt;                   list("\"AsIs\""), " (see ", list(list("base::I()")), 
#&gt;                   ").")), "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", list("switch_type()"), " is equivalent to\n", 
#&gt;                 list(list("switch"), "(", list("type_of"), "(x, ...))"), 
#&gt;                 ", while\n", list("switch_class()"), " switchpatches based on ", 
#&gt;                 list("class(x)"), ". The ", list("coerce_"), 
#&gt;                 "\n", "versions are intended for type conversion and provide a standard\n", 
#&gt;                 "error message when conversion fails.\n"), "\n", 
#&gt;             list("\n", "switch_type(3L,\n", "  double = \"foo\",\n", 
#&gt;                 "  integer = \"bar\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# Use the coerce_ version to get standardised error handling when no\n", 
#&gt;                 "# type matches:\n", "to_chr &lt;- function(x) {\n", 
#&gt;                 "  coerce_type(x, \"a chr\",\n", "    integer = as.character(x),\n", 
#&gt;                 "    double = as.character(x)\n", "  )\n", "}\n", 
#&gt;                 "to_chr(3L)\n", "\n", "# Strings have their own type:\n", 
#&gt;                 "switch_type(\"str\",\n", "  character = \"foo\",\n", 
#&gt;                 "  string = \"bar\",\n", "  \"default\"\n", ")\n", 
#&gt;                 "\n", "# Use a fallthrough clause if you need to dispatch on all character\n", 
#&gt;                 "# vectors, including strings:\n", "switch_type(\"str\",\n", 
#&gt;                 "  string = ,\n", "  character = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "\n", "# special and builtin functions are treated as primitive, since\n", 
#&gt;                 "# there is usually no reason to treat them differently:\n", 
#&gt;                 "switch_type(base::list,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n", "switch_type(base::`$`,\n", 
#&gt;                 "  primitive = \"foo\",\n", "  \"default\"\n", 
#&gt;                 ")\n", "\n", "# closures are not primitives:\n", 
#&gt;                 "switch_type(rlang::switch_type,\n", "  primitive = \"foo\",\n", 
#&gt;                 "  \"default\"\n", ")\n"), "\n", list("internal"), 
#&gt;             "\n"), sym.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/sym.R", "\n", 
#&gt;             list("sym"), "\n", list("sym"), "\n", list("syms"), 
#&gt;             "\n", list("Create a symbol or list of symbols"), 
#&gt;             "\n", list("\n", "sym(x)\n", "\n", "syms(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A string or list of strings.")), 
#&gt;                 "\n"), "\n", list("\n", "A symbol for ", list(
#&gt;                 "sym()"), " and a list of symbols for ", list(
#&gt;                 "syms()"), ".\n"), "\n", list("\n", "These functions take strings as input and turn them into symbols.\n"), 
#&gt;             "\n", list("\n", "# The empty string returns the missing argument:\n", 
#&gt;                 "sym(\"\")\n", "\n", "# This way sym() and as_string() are inverse of each other:\n", 
#&gt;                 "as_string(missing_arg())\n", "sym(as_string(missing_arg()))\n"), 
#&gt;             "\n"), `tidy-dots.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/dots.R, R/vec-new.R", 
#&gt;             "\n", list("tidy-dots"), "\n", list("tidy-dots"), 
#&gt;             "\n", list("dots_list"), "\n", list("list2"), "\n", 
#&gt;             list("Collect dots as lists"), "\n", list("\n", "dots_list(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"),\n", 
#&gt;                 "  .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\",\n", 
#&gt;                 "  \"error\"), .check_assign = FALSE)\n", "\n", 
#&gt;                 "list2(...)\n"), "\n", list("\n", list(list("..."), 
#&gt;                 list("Arguments to collect with ", list("!!!"), 
#&gt;                   " support.")), "\n", "\n", list(list(".ignore_empty"), 
#&gt;                 list("Whether to ignore empty arguments. Can be one\n", 
#&gt;                   "of ", list("\"trailing\""), ", ", list("\"none\""), 
#&gt;                   ", ", list("\"all\""), ". If ", list("\"trailing\""), 
#&gt;                   ", only the\n", "last argument is ignored if it is empty.")), 
#&gt;                 "\n", "\n", list(list(".preserve_empty"), list(
#&gt;                   "Whether to preserve the empty arguments that\n", 
#&gt;                   "were not ignored. If ", list("TRUE"), ", empty arguments are stored with\n", 
#&gt;                   list(list("missing_arg()")), " values. If ", 
#&gt;                   list("FALSE"), " (the default) an error is\n", 
#&gt;                   "thrown when an empty argument is detected.")), 
#&gt;                 "\n", "\n", list(list(".homonyms"), list("How to treat arguments with the same name. The\n", 
#&gt;                   "default, ", list("\"keep\""), ", preserves these arguments. Set ", 
#&gt;                   list(".homonyms"), " to\n", list("\"first\""), 
#&gt;                   " to only keep the first occurrences, to ", 
#&gt;                   list("\"last\""), " to keep\n", "the last occurrences, and to ", 
#&gt;                   list("\"error\""), " to raise an informative\n", 
#&gt;                   "error and indicate what arguments have duplicated names.")), 
#&gt;                 "\n", "\n", list(list(".check_assign"), list(
#&gt;                   "Whether to check for ", list("&lt;-"), " calls passed in\n", 
#&gt;                   "dots. When ", list("TRUE"), " and a ", list(
#&gt;                     "&lt;-"), " call is detected, a warning is\n", 
#&gt;                   "issued to advise users to use ", list("="), 
#&gt;                   " if they meant to match a\n", "function parameter, or wrap the ", 
#&gt;                   list("&lt;-"), " call in braces otherwise.\n", 
#&gt;                   "This ensures assignments are explicit.")), 
#&gt;                 "\n"), "\n", list("\n", "A list of arguments. This list is always named: unnamed\n", 
#&gt;                 "arguments are named with the empty string ", 
#&gt;                 list("\"\""), ".\n"), "\n", list("\n", list("list2()"), 
#&gt;                 " is equivalent to ", list("list(...)"), " with a few additional\n", 
#&gt;                 "features:\n", list("\n", list(), " You can splice other lists with the\n", 
#&gt;                   list("unquote-splice"), " ", list("!!!"), " operator.\n", 
#&gt;                   list(), " You can unquote names by using the ", 
#&gt;                   list("unquote"), "\n", "operator ", list("!!"), 
#&gt;                   " on the left-hand side of ", list(":="), ".\n", 
#&gt;                   list(), " Trailing commas are ignored, making it easier to copy and paste\n", 
#&gt;                   "arguments.\n"), "\n", "\n", "For lack of a better name, these features are collectively called\n", 
#&gt;                 "\"tidy dots\".\n", "\n", list("dots_list()"), 
#&gt;                 " is a lower-level version of ", list("list2()"), 
#&gt;                 " that offers\n", "additional parameters for dots capture.\n"), 
#&gt;             "\n", list("\n", "# Let's create a function that takes a variable number of arguments:\n", 
#&gt;                 "numeric &lt;- function(...) {\n", "  dots &lt;- list2(...)\n", 
#&gt;                 "  num &lt;- as.numeric(dots)\n", "  set_names(num, names(dots))\n", 
#&gt;                 "}\n", "numeric(1, 2, 3)\n", "\n", "# The main difference with list(...) is that list2(...) enables\n", 
#&gt;                 "# the `!!!` syntax to splice lists:\n", "x &lt;- list(2, 3)\n", 
#&gt;                 "numeric(1, !!! x, 4)\n", "\n", "# As well as unquoting of names:\n", 
#&gt;                 "nm &lt;- \"yup!\"\n", "numeric(!!nm := 1)\n", "\n", 
#&gt;                 "\n", "# One useful application of splicing is to work around exact and\n", 
#&gt;                 "# partial matching of arguments. Let's create a function taking\n", 
#&gt;                 "# named arguments and dots:\n", "fn &lt;- function(data, ...) {\n", 
#&gt;                 "  list2(...)\n", "}\n", "\n", "# You normally cannot pass an argument named `data` through the dots\n", 
#&gt;                 "# as it will match `fn`'s `data` argument. The splicing syntax\n", 
#&gt;                 "# provides a workaround:\n", "fn(\"wrong!\", data = letters)  # exact matching of `data`\n", 
#&gt;                 "fn(\"wrong!\", dat = letters)   # partial matching of `data`\n", 
#&gt;                 "fn(some_data, !!!list(data = letters))  # no matching\n", 
#&gt;                 "\n", "\n", "# Empty arguments trigger an error by default:\n", 
#&gt;                 "try(fn(, ))\n", "\n", "# You can choose to preserve empty arguments instead:\n", 
#&gt;                 "list3 &lt;- function(...) dots_list(..., .preserve_empty = TRUE)\n", 
#&gt;                 "\n", "# Note how the last empty argument is still ignored because\n", 
#&gt;                 "# `.ignore_empty` defaults to \"trailing\":\n", 
#&gt;                 "list3(, )\n", "\n", "# The list with preserved empty arguments is equivalent to:\n", 
#&gt;                 "list(missing_arg())\n", "\n", "\n", "# Arguments with duplicated names are kept by default:\n", 
#&gt;                 "list2(a = 1, a = 2, b = 3, b = 4, 5, 6)\n", 
#&gt;                 "\n", "# Use the `.homonyms` argument to keep only the first of these:\n", 
#&gt;                 "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"first\")\n", 
#&gt;                 "\n", "# Or the last:\n", "dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"last\")\n", 
#&gt;                 "\n", "# Or raise an informative error:\n", "try(dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"error\"))\n", 
#&gt;                 "\n", "\n", "# dots_list() can be configured to warn when a `&lt;-` call is\n", 
#&gt;                 "# detected:\n", "my_list &lt;- function(...) dots_list(..., .check_assign = TRUE)\n", 
#&gt;                 "my_list(a &lt;- 1)\n", "\n", "# There is no warning if the assignment is wrapped in braces.\n", 
#&gt;                 "# This requires users to be explicit about their intent:\n", 
#&gt;                 "my_list({ a &lt;- 1 })\n"), "\n", list("\n", list(
#&gt;                 list("exprs()")), " for extracting dots without evaluation.\n"), 
#&gt;             "\n"), `tidyeval-data.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval-tidy.R", 
#&gt;             "\n", list("data"), "\n", list("tidyeval-data"), 
#&gt;             "\n", list("tidyeval-data"), "\n", list(".data"), 
#&gt;             "\n", list("Data pronoun for tidy evaluation"), "\n", 
#&gt;             list("\n", ".data\n"), "\n", list("\n", "This pronoun allows you to be explicit when you refer to an object\n", 
#&gt;                 "inside the data. Referring to the ", list(".data"), 
#&gt;                 " pronoun rather than to\n", "the original data frame has several advantages:\n", 
#&gt;                 list("\n", list(), " It makes it easy to refer to column names stored as strings. If\n", 
#&gt;                   list("var"), " contains the column ", list(
#&gt;                     "\"height\""), ", the pronoun will subset that\n", 
#&gt;                   "column:", list("var &lt;- \"height\"\n", "dplyr::summarise(df, mean(.data[[var]]))\n"), 
#&gt;                   "\n", "\n", "The index variable ", list("var"), 
#&gt;                   " is ", list("unquoted"), ", which\n", "ensures a column named ", 
#&gt;                   list("var"), " in the data frame cannot mask it.\n", 
#&gt;                   "This makes the pronoun safe to use in functions and packages.\n", 
#&gt;                   list(), " Sometimes a computation is not about the whole data but about a\n", 
#&gt;                   "subset. For example if you supply a grouped data frame to a dplyr\n", 
#&gt;                   "verb, the ", list(".data"), " pronoun contains the group subset.\n", 
#&gt;                   list(), " It lets dplyr know that you're referring to a column from the\n", 
#&gt;                   "data which is helpful to generate correct queries when the source\n", 
#&gt;                   "is a database.\n"), "\n", "\n", "The ", list(
#&gt;                   ".data"), " object exported here is useful to import in your\n", 
#&gt;                 "package namespace to avoid a ", list("R CMD check"), 
#&gt;                 " note when referring to\n", "objects from the data mask.\n"), 
#&gt;             "\n", list("datasets"), "\n"), trace_back.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/trace.R", "\n", 
#&gt;             list("trace_back"), "\n", list("trace_back"), "\n", 
#&gt;             list("trace_length"), "\n", list("Capture a backtrace"), 
#&gt;             "\n", list("\n", "trace_back(top = NULL, bottom = NULL)\n", 
#&gt;                 "\n", "trace_length(trace)\n"), "\n", list("\n", 
#&gt;                 list(list("top"), list("The first frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the top of the backtrace tree and\n", 
#&gt;                   "represents the oldest call in the backtrace.\n", 
#&gt;                   "\n", "This is needed in particular when you call ", 
#&gt;                   list("trace_back()"), "\n", "indirectly or from a larger context, for example in tests or\n", 
#&gt;                   "inside an RMarkdown document where you don't want all of the\n", 
#&gt;                   "knitr evaluation mechanisms to appear in the backtrace.")), 
#&gt;                 "\n", "\n", list(list("bottom"), list("The last frame environment to be included in the\n", 
#&gt;                   "backtrace. This becomes the rightmost leaf of the backtrace tree\n", 
#&gt;                   "and represents the youngest call in the backtrace.\n", 
#&gt;                   "\n", "Set this when you would like to capture a backtrace without the\n", 
#&gt;                   "capture context.\n", "\n", "Can also be an integer that will be passed to ", 
#&gt;                   list(list("caller_env()")), ".")), "\n", "\n", 
#&gt;                 list(list("trace"), list("A backtrace created by ", 
#&gt;                   list("trace_back()"), ".")), "\n"), "\n", list(
#&gt;                 "\n", "A backtrace captures the sequence of calls that lead to the current\n", 
#&gt;                 "function, sometimes called the call stack. Because of lazy\n", 
#&gt;                 "evaluation, the call stack in R is actually a tree, which the\n", 
#&gt;                 list("summary()"), " method of this object will reveal.\n"), 
#&gt;             "\n", list("\n", list("trace_length()"), " returns the number of frames in a backtrace.\n"), 
#&gt;             "\n", list("\n", "# Trim backtraces automatically (this improves the generated\n", 
#&gt;                 "# documentation for the rlang website and the same trick can be\n", 
#&gt;                 "# useful within knitr documents):\n", "options(rlang_trace_top_env = current_env())\n", 
#&gt;                 "\n", "f &lt;- function() g()\n", "g &lt;- function() h()\n", 
#&gt;                 "h &lt;- function() trace_back()\n", "\n", "# When no lazy evaluation is involved the backtrace is linear\n", 
#&gt;                 "# (i.e. every call has only one child)\n", "f()\n", 
#&gt;                 "\n", "# Lazy evaluation introduces a tree like structure\n", 
#&gt;                 "identity(identity(f()))\n", "identity(try(f()))\n", 
#&gt;                 "try(identity(f()))\n", "\n", "# When printing, you can request to simplify this tree to only show\n", 
#&gt;                 "# the direct sequence of calls that lead to `trace_back()`\n", 
#&gt;                 "x &lt;- try(identity(f()))\n", "x\n", "print(x, simplify = \"branch\")\n", 
#&gt;                 "\n", "# With a little cunning you can also use it to capture the\n", 
#&gt;                 "# tree from within a base NSE function\n", "x &lt;- NULL\n", 
#&gt;                 "with(mtcars, {x &lt;&lt;- f(); 10})\n", "x\n", "\n", 
#&gt;                 "\n", "# Restore default top env for next example\n", 
#&gt;                 "options(rlang_trace_top_env = NULL)\n", "\n", 
#&gt;                 "# When code is executed indirectly, i.e. via source or within an\n", 
#&gt;                 "# RMarkdown document, you'll tend to get a lot of guff at the beginning\n", 
#&gt;                 "# related to the execution environment:\n", 
#&gt;                 "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n", "\n", "# To automatically strip this off, specify which frame should be\n", 
#&gt;                 "# the top of the backtrace. This will automatically trim off calls\n", 
#&gt;                 "# prior to that frame:\n", "top &lt;- current_env()\n", 
#&gt;                 "h &lt;- function() trace_back(top)\n", "\n", "conn &lt;- textConnection(\"summary(f())\")\n", 
#&gt;                 "source(conn, echo = TRUE, local = TRUE)\n", 
#&gt;                 "close(conn)\n"), "\n"), `type-predicates.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/types.R", "\n", 
#&gt;             list("type-predicates"), "\n", list("type-predicates"), 
#&gt;             "\n", list("is_list"), "\n", list("is_atomic"), "\n", 
#&gt;             list("is_vector"), "\n", list("is_integer"), "\n", 
#&gt;             list("is_double"), "\n", list("is_character"), "\n", 
#&gt;             list("is_logical"), "\n", list("is_raw"), "\n", list(
#&gt;                 "is_bytes"), "\n", list("is_null"), "\n", list(
#&gt;                 "Type predicates"), "\n", list("\n", "is_list(x, n = NULL)\n", 
#&gt;                 "\n", "is_atomic(x, n = NULL)\n", "\n", "is_vector(x, n = NULL)\n", 
#&gt;                 "\n", "is_integer(x, n = NULL)\n", "\n", "is_double(x, n = NULL, finite = NULL)\n", 
#&gt;                 "\n", "is_character(x, n = NULL, encoding = NULL)\n", 
#&gt;                 "\n", "is_logical(x, n = NULL)\n", "\n", "is_raw(x, n = NULL)\n", 
#&gt;                 "\n", "is_bytes(x, n = NULL)\n", "\n", "is_null(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("Object to be tested.")), 
#&gt;                 "\n", "\n", list(list("n"), list("Expected length of a vector.")), 
#&gt;                 "\n", "\n", list(list("finite"), list("Whether all values of the vector are finite. The\n", 
#&gt;                   "non-finite values are ", list("NA"), ", ", 
#&gt;                   list("Inf"), ", ", list("-Inf"), " and ", list(
#&gt;                     "NaN"), ". Setting this\n", "to something other than ", 
#&gt;                   list("NULL"), " can be expensive because the whole\n", 
#&gt;                   "vector needs to be traversed and checked.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("Defunct as of rlang 0.4.0.")), 
#&gt;                 "\n"), "\n", list("\n", "These type predicates aim to make type testing in R more\n", 
#&gt;                 "consistent. They are wrappers around ", list(
#&gt;                   list("base::typeof()")), ", so operate\n", 
#&gt;                 "at a level beneath S3/S4 etc.\n"), "\n", list(
#&gt;                 "\n", "Compared to base R functions:\n", list(
#&gt;                   "\n", list(), " The predicates for vectors include the ", 
#&gt;                   list("n"), " argument for\n", "pattern-matching on the vector length.\n", 
#&gt;                   list(), " Unlike ", list("is.atomic()"), ", ", 
#&gt;                   list("is_atomic()"), " does not return ", list(
#&gt;                     "TRUE"), " for\n", list("NULL"), ".\n", list(), 
#&gt;                   " Unlike ", list("is.vector()"), ", ", list(
#&gt;                     "is_vector()"), " tests if an object is an\n", 
#&gt;                   "atomic vector or a list. ", list("is.vector"), 
#&gt;                   " checks for the presence of\n", "attributes (other than name).\n"), 
#&gt;                 "\n"), "\n", list("\n", list("bare-type-predicates"), 
#&gt;                 " ", list("scalar-type-predicates"), "\n"), "\n"), 
#&gt;         type_of.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("type_of"), "\n", list("type_of"), "\n", 
#&gt;             list("Base type of an object"), "\n", list("\n", 
#&gt;                 "type_of(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An R object.")), "\n"), "\n", list("\n", 
#&gt;                 list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", list("rlang:::lifecycle(\"experimental\")"), 
#&gt;                 "\n", "\n", "This is equivalent to ", list(list(
#&gt;                   "base::typeof()")), " with a few differences that\n", 
#&gt;                 "make dispatching easier:\n", list("\n", list(), 
#&gt;                   " The type of one-sided formulas is \"quote\".\n", 
#&gt;                   list(), " The type of character vectors of length 1 is \"string\".\n", 
#&gt;                   list(), " The type of special and builtin functions is \"primitive\".\n"), 
#&gt;                 "\n"), "\n", list(list("Life cycle"), list("\n", 
#&gt;                 "\n", "\n", list("type_of()"), " is an experimental function. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "type_of(10L)\n", "\n", "# Quosures are treated as a new base type but not formulas:\n", 
#&gt;                 "type_of(quo(10L))\n", "type_of(~10L)\n", "\n", 
#&gt;                 "# Compare to base::typeof():\n", "typeof(quo(10L))\n", 
#&gt;                 "\n", "# Strings are treated as a new base type:\n", 
#&gt;                 "type_of(letters)\n", "type_of(letters[[1]])\n", 
#&gt;                 "\n", "# This is a bit inconsistent with the core language tenet that data\n", 
#&gt;                 "# types are vectors. However, treating strings as a different\n", 
#&gt;                 "# scalar type is quite helpful for switching on function inputs\n", 
#&gt;                 "# since so many arguments expect strings:\n", 
#&gt;                 "switch_type(\"foo\", character = abort(\"vector!\"), string = \"result\")\n", 
#&gt;                 "\n", "# Special and builtin primitives are both treated as primitives.\n", 
#&gt;                 "# That's because it is often irrelevant which type of primitive an\n", 
#&gt;                 "# input is:\n", "typeof(list)\n", "typeof(`$`)\n", 
#&gt;                 "type_of(list)\n", "type_of(`$`)\n"), "\n", list(
#&gt;                 "internal"), "\n"), vec_poke_n.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec.R", "\n", 
#&gt;             list("vec_poke_n"), "\n", list("vec_poke_n"), "\n", 
#&gt;             list("vec_poke_range"), "\n", list("Poke values into a vector"), 
#&gt;             "\n", list("\n", "vec_poke_n(x, start, y, from = 1L, n = length(y))\n", 
#&gt;                 "\n", "vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("The destination vector.")), 
#&gt;                 "\n", "\n", list(list("start"), list("The index indicating where to start modifying ", 
#&gt;                   list("x"), ".")), "\n", "\n", list(list("y"), 
#&gt;                   list("The source vector.")), "\n", "\n", list(
#&gt;                   list("from"), list("The index indicating where to start copying from ", 
#&gt;                     list("y"), ".")), "\n", "\n", list(list("n"), 
#&gt;                   list("How many elements should be copied from ", 
#&gt;                     list("y"), " to ", list("x"), ".")), "\n", 
#&gt;                 "\n", list(list("to"), list("The index indicating the end of the range to copy from ", 
#&gt;                   list("y"), ".")), "\n"), "\n", list("\n", list(
#&gt;                 "rlang:::lifecycle(\"experimental\")"), "\n", 
#&gt;                 "\n", "These tools are for R experts only. They copy elements from ", 
#&gt;                 list("y"), "\n", "into ", list("x"), " by mutation. You should only do this if you own ", 
#&gt;                 list("x"), ",\n", "i.e. if you have created it or if you are certain that it doesn't\n", 
#&gt;                 "exist in any other context. Otherwise you might create unintended\n", 
#&gt;                 "side effects that have undefined consequences.\n"), 
#&gt;             "\n", list("internal"), "\n"), `vector-coercion.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("vector-coercion"), "\n", list("vector-coercion"), 
#&gt;             "\n", list("as_logical"), "\n", list("as_integer"), 
#&gt;             "\n", list("as_double"), "\n", list("as_complex"), 
#&gt;             "\n", list("as_character"), "\n", list("as_list"), 
#&gt;             "\n", list("Coerce an object to a base type"), "\n", 
#&gt;             list("\n", "as_logical(x)\n", "\n", "as_integer(x)\n", 
#&gt;                 "\n", "as_double(x)\n", "\n", "as_complex(x)\n", 
#&gt;                 "\n", "as_character(x, encoding = NULL)\n", "\n", 
#&gt;                 "as_list(x)\n"), "\n", list("\n", list(list("x"), 
#&gt;                 list("An object to coerce to a base type.")), 
#&gt;                 "\n", "\n", list(list("encoding"), list("If non-null, set an encoding mark. This is only\n", 
#&gt;                   "declarative, no encoding conversion is performed.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"soft-deprecated\")"), 
#&gt;                 "\n", "\n", "These are equivalent to the base functions (e.g. ", 
#&gt;                 list(list("as.logical()")), ",\n", list(list(
#&gt;                   "as.list()")), ", etc), but perform coercion rather than conversion.\n", 
#&gt;                 "This means they are not generic and will not call S3 conversion\n", 
#&gt;                 "methods. They only attempt to coerce the base type of their\n", 
#&gt;                 "input. In addition, they have stricter implicit coercion rules and\n", 
#&gt;                 "will never attempt any kind of parsing. E.g. they will not try to\n", 
#&gt;                 "figure out if a character vector represents integers or booleans.\n", 
#&gt;                 "Finally, they treat attributes consistently, unlike the base R\n", 
#&gt;                 "functions: all attributes except names are removed.\n"), 
#&gt;             "\n", list(list("Lifecycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are deprecated in favour of ", 
#&gt;                 list("vctrs::vec_cast()"), ".\n")), "\n", "\n", 
#&gt;             list(list("Coercion to logical and numeric atomic vectors"), 
#&gt;                 list("\n", "\n", list("\n", list(), " To logical vectors: Integer and integerish double vectors. See\n", 
#&gt;                   list(list("is_integerish()")), ".\n", list(), 
#&gt;                   " To integer vectors: Logical and integerish double vectors.\n", 
#&gt;                   list(), " To double vectors: Logical and integer vectors.\n", 
#&gt;                   list(), " To complex vectors: Logical, integer and double vectors.\n"), 
#&gt;                   "\n")), "\n", "\n", list(list("Coercion to character vectors"), 
#&gt;                 list("\n", "\n", "\n", list("as_character()"), 
#&gt;                   " and ", list("as_string()"), " have an optional ", 
#&gt;                   list("encoding"), "\n", "argument to specify the encoding. R uses this information for\n", 
#&gt;                   "internal handling of strings and character vectors. Note that this\n", 
#&gt;                   "is only declarative, no encoding conversion is attempted.\n", 
#&gt;                   "\n", "Note that only ", list("as_string()"), 
#&gt;                   " can coerce symbols to a scalar\n", "character vector. This makes the code more explicit and adds an\n", 
#&gt;                   "extra type check.\n")), "\n", "\n", list(list(
#&gt;                 "Coercion to lists"), list("\n", "\n", "\n", 
#&gt;                 list("as_list()"), " only coerces vector and dictionary types (environments\n", 
#&gt;                 "are an example of dictionary type). Unlike ", 
#&gt;                 list(list("base::as.list()")), ",\n", list("as_list()"), 
#&gt;                 " removes all attributes except names.\n")), 
#&gt;             "\n", "\n", list(list("Effects of removing attributes"), 
#&gt;                 list("\n", "\n", "\n", "A technical side-effect of removing the attributes of the input is\n", 
#&gt;                   "that the underlying objects has to be copied. This has no\n", 
#&gt;                   "performance implications in the case of lists because this is a\n", 
#&gt;                   "shallow copy: only the list structure is copied, not the contents\n", 
#&gt;                   "(see ", list(list("duplicate()")), "). However, be aware that atomic vectors\n", 
#&gt;                   "containing large amounts of data will have to be copied.\n", 
#&gt;                   "\n", "In general, any attribute modification creates a copy, which is why\n", 
#&gt;                   "it is better to avoid using attributes with heavy atomic vectors.\n", 
#&gt;                   "Uncopyable objects like environments and symbols are an exception\n", 
#&gt;                   "to this rule: in this case, attributes modification happens in\n", 
#&gt;                   "place and has side-effects.\n")), "\n", "\n", 
#&gt;             list("\n", "# Coercing atomic vectors removes attributes with both base R and rlang:\n", 
#&gt;                 "x &lt;- structure(TRUE, class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.logical(x)\n", "\n", "# But coercing lists preserves attributes in base R but not rlang:\n", 
#&gt;                 "l &lt;- structure(list(TRUE), class = \"foo\", bar = \"baz\")\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# Implicit conversions are performed in base R but not rlang:\n", 
#&gt;                 "as.logical(l)\n", list("\n", "as_logical(l)\n"), 
#&gt;                 "\n", "\n", "# Conversion methods are bypassed, making the result of the\n", 
#&gt;                 "# coercion more predictable:\n", "as.list.foo &lt;- function(x) \"wrong\"\n", 
#&gt;                 "as.list(l)\n", "as_list(l)\n", "\n", "# The input is never parsed. E.g. character vectors of numbers are\n", 
#&gt;                 "# not converted to numeric types:\n", "as.integer(\"33\")\n", 
#&gt;                 list("\n", "as_integer(\"33\")\n"), "\n", "\n", 
#&gt;                 "\n", "# With base R tools there is no way to convert an environment to a\n", 
#&gt;                 "# list without either triggering method dispatch, or changing the\n", 
#&gt;                 "# original environment. as_list() makes it easy:\n", 
#&gt;                 "x &lt;- structure(as_environment(mtcars[1:2]), class = \"foobar\")\n", 
#&gt;                 "as.list.foobar &lt;- function(x) abort(\"dont call me\")\n", 
#&gt;                 "as_list(x)\n"), "\n", list("internal"), "\n"), 
#&gt;         `vector-construction.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/vec-new.R", 
#&gt;             "\n", list("vector-construction"), "\n", list("vector-construction"), 
#&gt;             "\n", list("lgl"), "\n", list("int"), "\n", list(
#&gt;                 "dbl"), "\n", list("cpl"), "\n", list("chr"), 
#&gt;             "\n", list("bytes"), "\n", list("ll"), "\n", list(
#&gt;                 "Create vectors"), "\n", list("\n", "lgl(...)\n", 
#&gt;                 "\n", "int(...)\n", "\n", "dbl(...)\n", "\n", 
#&gt;                 "cpl(...)\n", "\n", "chr(...)\n", "\n", "bytes(...)\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("Components of the new vector. Bare lists and explicitly\n", 
#&gt;                 "spliced lists are spliced.")), "\n"), "\n", 
#&gt;             list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "The atomic vector constructors are equivalent to ", 
#&gt;                 list(list("c()")), " but:\n", list("\n", list(), 
#&gt;                   " They allow you to be more explicit about the output\n", 
#&gt;                   "type. Implicit coercions (e.g. from integer to logical) follow\n", 
#&gt;                   "the rules described in ", list("vector-coercion"), 
#&gt;                   ".\n", list(), " They use ", list("tidy dots"), 
#&gt;                   " and thus support splicing with ", list("!!!"), 
#&gt;                   ".\n"), "\n"), "\n", list(list("Life cycle"), 
#&gt;                 list("\n", "\n", list("\n", list(), " All the abbreviated constructors such as ", 
#&gt;                   list("lgl()"), " will probably be\n", "moved to the vctrs package at some point. This is why they are\n", 
#&gt;                   "marked as questioning.\n", list(), " Automatic splicing is soft-deprecated and will trigger a warning\n", 
#&gt;                   "in a future version. Please splice explicitly with ", 
#&gt;                   list("!!!"), ".\n"), "\n")), "\n", "\n", list(
#&gt;                 "\n", "# These constructors are like a typed version of c():\n", 
#&gt;                 "c(TRUE, FALSE)\n", "lgl(TRUE, FALSE)\n", "\n", 
#&gt;                 "# They follow a restricted set of coercion rules:\n", 
#&gt;                 "int(TRUE, FALSE, 20)\n", "\n", "# Lists can be spliced:\n", 
#&gt;                 "dbl(10, !!! list(1, 2L), TRUE)\n", "\n", "\n", 
#&gt;                 "# They splice names a bit differently than c(). The latter\n", 
#&gt;                 "# automatically composes inner and outer names:\n", 
#&gt;                 "c(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "\n", "# On the other hand, rlang's ctors use the inner names and issue a\n", 
#&gt;                 "# warning to inform the user that the outer names are ignored:\n", 
#&gt;                 "dbl(a = c(A = 10), b = c(B = 20, C = 30))\n", 
#&gt;                 "dbl(a = c(1, 2))\n", "\n", "# As an exception, it is allowed to provide an outer name when the\n", 
#&gt;                 "# inner vector is an unnamed scalar atomic:\n", 
#&gt;                 "dbl(a = 1)\n", "\n", "# Spliced lists behave the same way:\n", 
#&gt;                 "dbl(!!! list(a = 1))\n", "dbl(!!! list(a = c(A = 1)))\n", 
#&gt;                 "\n", "# bytes() accepts integerish inputs\n", 
#&gt;                 "bytes(1:10)\n", "bytes(0x01, 0xff, c(0x03, 0x05), list(10, 20, 30L))\n"), 
#&gt;             "\n"), `vector-old-ctors.Rd` = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lifecycle-retired.R", 
#&gt;             "\n", list("node"), "\n", list("node"), "\n", list(
#&gt;                 "vector-old-ctors"), "\n", list("lgl_len"), "\n", 
#&gt;             list("int_len"), "\n", list("dbl_len"), "\n", list(
#&gt;                 "chr_len"), "\n", list("cpl_len"), "\n", list(
#&gt;                 "raw_len"), "\n", list("bytes_len"), "\n", list(
#&gt;                 "list_len"), "\n", list("lgl_along"), "\n", list(
#&gt;                 "int_along"), "\n", list("dbl_along"), "\n", 
#&gt;             list("chr_along"), "\n", list("cpl_along"), "\n", 
#&gt;             list("raw_along"), "\n", list("bytes_along"), "\n", 
#&gt;             list("list_along"), "\n", list("Retired vector construction by length"), 
#&gt;             "\n", list("\n", "node(car, cdr = NULL)\n", "\n", 
#&gt;                 "lgl_len(.n)\n", "\n", "int_len(.n)\n", "\n", 
#&gt;                 "dbl_len(.n)\n", "\n", "chr_len(.n)\n", "\n", 
#&gt;                 "cpl_len(.n)\n", "\n", "raw_len(.n)\n", "\n", 
#&gt;                 "bytes_len(.n)\n", "\n", "list_len(.n)\n", "\n", 
#&gt;                 "lgl_along(.x)\n", "\n", "int_along(.x)\n", "\n", 
#&gt;                 "dbl_along(.x)\n", "\n", "chr_along(.x)\n", "\n", 
#&gt;                 "cpl_along(.x)\n", "\n", "raw_along(.x)\n", "\n", 
#&gt;                 "bytes_along(.x)\n", "\n", "list_along(.x)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("A vector.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"deprecated\")"), 
#&gt;                 "\n", "\n", "These functions were deprecated and renamed with ", 
#&gt;                 list("new_"), " prefix in\n", "rlang 0.2.0. This is for consistency with other non-variadic object\n", 
#&gt;                 "constructors.\n"), "\n", list("internal"), "\n"), 
#&gt;         with_abort.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-entrace.R", 
#&gt;             "\n", list("with_abort"), "\n", list("with_abort"), 
#&gt;             "\n", list("Promote all errors to rlang errors"), 
#&gt;             "\n", list("\n", "with_abort(expr, classes = \"error\")\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("An expression run in a context where errors are\n", 
#&gt;                 "promoted to rlang errors.")), "\n", "\n", list(
#&gt;                 list("classes"), list("Character vector of condition classes that should be\n", 
#&gt;                   "promoted to rlang errors.")), "\n"), "\n", 
#&gt;             list("\n", list("with_abort()"), " promotes conditions as if they were thrown with\n", 
#&gt;                 list(list("abort()")), ". These errors embed a ", 
#&gt;                 list("backtrace"), ". They are\n", "particularly suitable to be set as ", 
#&gt;                 list("parent errors"), " (see ", list("parent"), 
#&gt;                 "\n", "argument of ", list(list("abort()")), 
#&gt;                 ").\n"), "\n", list("\n", list("with_abort()"), 
#&gt;                 " installs a ", list("calling handler"), " for errors and\n", 
#&gt;                 "rethrows non-rlang errors with ", list(list(
#&gt;                   "abort()")), ". However, error handlers\n", 
#&gt;                 "installed ", list("within"), " ", list("with_abort()"), 
#&gt;                 " have priority. For this reason,\n", "you should use ", 
#&gt;                 list(list("tryCatch()")), " and ", list("exiting"), 
#&gt;                 " handlers outside\n", list("with_abort()"), 
#&gt;                 " rather than inside.\n"), "\n", list("\n", "# with_abort() automatically casts simple errors thrown by stop()\n", 
#&gt;                 "# to rlang errors. It is is handy for rethrowing low level\n", 
#&gt;                 "# errors. The backtraces are then segmented between the low level\n", 
#&gt;                 "# and high level contexts.\n", "f &lt;- function() g()\n", 
#&gt;                 "g &lt;- function() stop(\"Low level error\")\n", 
#&gt;                 "\n", "high_level &lt;- function() {\n", "  with_handlers(\n", 
#&gt;                 "    with_abort(f()),\n", "    error = ~ abort(\"High level error\", parent = .)\n", 
#&gt;                 "  )\n", "}\n"), "\n"), with_env.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/eval.R", 
#&gt;             "\n", list("with_env"), "\n", list("with_env"), "\n", 
#&gt;             list("locally"), "\n", list("Evaluate an expression within a given environment"), 
#&gt;             "\n", list("\n", "with_env(env, expr)\n", "\n", "locally(expr)\n"), 
#&gt;             "\n", list("\n", list(list("env"), list("An environment within which to evaluate ", 
#&gt;                 list("expr"), ". Can be\n", "an object with a ", 
#&gt;                 list(list("get_env()")), " method.")), "\n", 
#&gt;                 "\n", list(list("expr"), list("An expression to evaluate.")), 
#&gt;                 "\n"), "\n", list("\n", "These functions evaluate ", 
#&gt;                 list("expr"), " within a given environment (", 
#&gt;                 list("env"), "\n", "for ", list("with_env()"), 
#&gt;                 ", or the child of the current environment for\n", 
#&gt;                 list("locally"), "). They rely on ", list(list(
#&gt;                   "eval_bare()")), " which features a lighter\n", 
#&gt;                 "evaluation mechanism than base R ", list(list(
#&gt;                   "base::eval()")), ", and which also has\n", 
#&gt;                 "some subtle implications when evaluting stack sensitive functions\n", 
#&gt;                 "(see help for ", list(list("eval_bare()")), 
#&gt;                 ").\n"), "\n", list("\n", list("locally()"), 
#&gt;                 " is equivalent to the base function\n", list(
#&gt;                   list("base::local()")), " but it produces a much cleaner\n", 
#&gt;                 "evaluation stack, and has stack-consistent semantics. It is thus\n", 
#&gt;                 "more suited for experimenting with the R language.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "These functions are experimental. Expect API changes.\n")), 
#&gt;             "\n", "\n", list("\n", "# with_env() is handy to create formulas with a given environment:\n", 
#&gt;                 "env &lt;- child_env(\"rlang\")\n", "f &lt;- with_env(env, ~new_formula())\n", 
#&gt;                 "identical(f_env(f), env)\n", "\n", "# Or functions with a given enclosure:\n", 
#&gt;                 "fn &lt;- with_env(env, function() NULL)\n", "identical(get_env(fn), env)\n", 
#&gt;                 "\n", "\n", "# Unlike eval() it doesn't create duplicates on the evaluation\n", 
#&gt;                 "# stack. You can thus use it e.g. to create non-local returns:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g(current_env())\n", 
#&gt;                 "  \"normal return\"\n", "}\n", "g &lt;- function(env) {\n", 
#&gt;                 "  with_env(env, return(\"early return\"))\n", 
#&gt;                 "}\n", "fn()\n", "\n", "\n", "# Since env is passed to as_environment(), it can be any object with an\n", 
#&gt;                 "# as_environment() method. For strings, the pkg_env() is returned:\n", 
#&gt;                 "with_env(\"base\", ~mtcars)\n", "\n", "# This can be handy to put dictionaries in scope:\n", 
#&gt;                 "with_env(mtcars, cyl)\n"), "\n", list("internal"), 
#&gt;             "\n"), with_handlers.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-handlers.R", 
#&gt;             "\n", list("with_handlers"), "\n", list("with_handlers"), 
#&gt;             "\n", list("calling"), "\n", list("Establish handlers on the stack"), 
#&gt;             "\n", list("\n", "with_handlers(.expr, ...)\n", "\n", 
#&gt;                 "calling(handler)\n"), "\n", list("\n", list(
#&gt;                 list(".expr"), list("An expression to execute in a context where new\n", 
#&gt;                   "handlers are established. The underscored version takes a quoted\n", 
#&gt;                   "expression or a quoted formula.")), "\n", 
#&gt;                 "\n", list(list("..."), list("Named handlers. These should be functions of one\n", 
#&gt;                   "argument. These handlers are treated as exiting by default. Use\n", 
#&gt;                   list(list("calling()")), " to specify a calling handler. These dots support\n", 
#&gt;                   list("tidy dots"), " features and are passed to ", 
#&gt;                   list(list("as_function()")), "\n", "to enable the formula shortcut for lambda functions.")), 
#&gt;                 "\n", "\n", list(list("handler"), list("A handler function that takes a condition as\n", 
#&gt;                   "argument. This is passed to ", list(list("as_function()")), 
#&gt;                   " and can thus be a\n", "formula describing a lambda function.")), 
#&gt;                 "\n"), "\n", list("\n", "Condition handlers are functions established on the evaluation\n", 
#&gt;                 "stack (see ", list(list("ctxt_stack()")), ") that are called by R when a condition is\n", 
#&gt;                 "signalled (see ", list(list("cnd_signal()")), 
#&gt;                 " and ", list(list("abort()")), " for two common signal\n", 
#&gt;                 "functions). They come in two types:\n", list(
#&gt;                   "\n", list(), " Exiting handlers aborts all code currently run between\n", 
#&gt;                   list("with_handlers()"), " and the point where the condition has been\n", 
#&gt;                   "raised. ", list("with_handlers()"), " passes the return value of the handler\n", 
#&gt;                   "to its caller.\n", list(), " Calling handlers, which are executed from inside the signalling\n", 
#&gt;                   "functions. Their return values are ignored, only their side\n", 
#&gt;                   "effects matters. Valid side effects are writing a log message, or\n", 
#&gt;                   "jumping out of the signalling context by ", 
#&gt;                   list("invoking a restart"), " or using ", list(
#&gt;                     list("return_from()")), ". If the raised\n", 
#&gt;                   "condition was an error, this interrupts the aborting process.\n", 
#&gt;                   "\n", "If a calling handler returns normally, it effectively declines to\n", 
#&gt;                   "handle the condition and other handlers on the stack (calling or\n", 
#&gt;                   "exiting) are given a chance to handle the condition.\n"), 
#&gt;                 "\n", "\n", "Handlers are exiting by default, use ", 
#&gt;                 list(list("calling()")), " to create a\n", "calling handler.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", " ", list(
#&gt;                 "exiting()"), " is soft-deprecated as of rlang\n", 
#&gt;                 "0.4.0 because ", list(list("with_handlers()")), 
#&gt;                 " now treats handlers as exiting by\n", "default.\n")), 
#&gt;             "\n", "\n", list("\n", "# Signal a condition with signal():\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"called?\\n\")\n", 
#&gt;                 "  \"fn() return value\"\n", "}\n", "g &lt;- function() {\n", 
#&gt;                 "  h()\n", "  cat(\"called?\\n\")\n", "}\n", 
#&gt;                 "h &lt;- function() {\n", "  signal(\"A foobar condition occurred\", \"foo\")\n", 
#&gt;                 "  cat(\"called?\\n\")\n", "}\n", "\n", "# Exiting handlers jump to with_handlers() before being\n", 
#&gt;                 "# executed. Their return value is handed over:\n", 
#&gt;                 "handler &lt;- function(c) \"handler return value\"\n", 
#&gt;                 "with_handlers(fn(), foo = handler)\n", "\n", 
#&gt;                 "# Calling handlers are called in turn and their return value is\n", 
#&gt;                 "# ignored. Returning just means they are declining to take charge of\n", 
#&gt;                 "# the condition. However, they can produce side-effects such as\n", 
#&gt;                 "# displaying a message:\n", "some_handler &lt;- function(c) cat(\"some handler!\\n\")\n", 
#&gt;                 "other_handler &lt;- function(c) cat(\"other handler!\\n\")\n", 
#&gt;                 "with_handlers(fn(), foo = calling(some_handler), foo = calling(other_handler))\n", 
#&gt;                 "\n", "# If a calling handler jumps to an earlier context, it takes\n", 
#&gt;                 "# charge of the condition and no other handler gets a chance to\n", 
#&gt;                 "# deal with it. The canonical way of transferring control is by\n", 
#&gt;                 "# jumping to a restart. See with_restarts() and restarting()\n", 
#&gt;                 "# documentation for more on this:\n", "exiting_handler &lt;- function(c) rst_jump(\"rst_foo\")\n", 
#&gt;                 "fn2 &lt;- function() {\n", "  with_restarts(g(), rst_foo = function() \"restart value\")\n", 
#&gt;                 "}\n", "with_handlers(fn2(), foo = calling(exiting_handler), foo = calling(other_handler))\n"), 
#&gt;             "\n"), with_restarts.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cnd-restarts.R", 
#&gt;             "\n", list("with_restarts"), "\n", list("with_restarts"), 
#&gt;             "\n", list("Establish a restart point on the stack"), 
#&gt;             "\n", list("\n", "with_restarts(.expr, ...)\n"), 
#&gt;             "\n", list("\n", list(list(".expr"), list("An expression to execute with new restarts established\n", 
#&gt;                 "on the stack. This argument is passed by expression and supports\n", 
#&gt;                 list("unquoting"), ". It is evaluated in a context where\n", 
#&gt;                 "restarts are established.")), "\n", "\n", list(
#&gt;                 list("..."), list("Named restart functions. The name is taken as the\n", 
#&gt;                   "restart name and the function is executed after the jump. These\n", 
#&gt;                   "dots support ", list("tidy dots"), " features.")), 
#&gt;                 "\n"), "\n", list("\n", list("rlang:::lifecycle(\"questioning\")"), 
#&gt;                 "\n", "\n", "Restart points are named functions that are established with\n", 
#&gt;                 list("with_restarts()"), ". Once established, you can interrupt the normal\n", 
#&gt;                 "execution of R code, jump to the restart, and resume execution from\n", 
#&gt;                 "there. Each restart is established along with a restart function\n", 
#&gt;                 "that is executed after the jump and that provides a return value\n", 
#&gt;                 "from the establishing point (i.e., a return value for\n", 
#&gt;                 list("with_restarts()"), ").\n"), "\n", list(
#&gt;                 "\n", "Restarts are not the only way of jumping to a previous call frame\n", 
#&gt;                 "(see ", list(list("return_from()")), " or ", 
#&gt;                 list(list("return_to()")), "). However, they have the\n", 
#&gt;                 "advantage of being callable by name once established.\n"), 
#&gt;             "\n", list(list("Life cycle"), list("\n", "\n", "\n", 
#&gt;                 "All the restart functions are in the questioning stage. It is not\n", 
#&gt;                 "clear yet whether we want to recommend restarts as a style of\n", 
#&gt;                 "programming in R.\n")), "\n", "\n", list("\n", 
#&gt;                 "# Restarts are not the only way to jump to a previous frame, but\n", 
#&gt;                 "# they have the advantage of being callable by name:\n", 
#&gt;                 "fn &lt;- function() with_restarts(g(), my_restart = function() \"returned\")\n", 
#&gt;                 "g &lt;- function() h()\n", "h &lt;- function() { rst_jump(\"my_restart\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "# Whereas a non-local return requires to manually pass the calling\n", 
#&gt;                 "# frame to the return function:\n", "fn &lt;- function() g(current_env())\n", 
#&gt;                 "g &lt;- function(env) h(env)\n", "h &lt;- function(env) { return_from(env, \"returned\"); \"not returned\" }\n", 
#&gt;                 "fn()\n", "\n", "\n", "# rst_maybe_jump() checks that a restart exists before trying to jump:\n", 
#&gt;                 "fn &lt;- function() {\n", "  g()\n", "  cat(\"will this be called?\\n\")\n", 
#&gt;                 "}\n", "g &lt;- function() {\n", "  rst_maybe_jump(\"my_restart\")\n", 
#&gt;                 "  cat(\"will this be called?\\n\")\n", "}\n", 
#&gt;                 "\n", "# Here no restart are on the stack:\n", 
#&gt;                 "fn()\n", "\n", "# If a restart point called `my_restart` was established on the\n", 
#&gt;                 "# stack before calling fn(), the control flow will jump there:\n", 
#&gt;                 "rst &lt;- function() {\n", "  cat(\"restarting...\\n\")\n", 
#&gt;                 "  \"return value\"\n", "}\n", "with_restarts(fn(), my_restart = rst)\n", 
#&gt;                 "\n", "\n", "# Restarts are particularly useful to provide alternative default\n", 
#&gt;                 "# values when the normal output cannot be computed:\n", 
#&gt;                 "\n", "fn &lt;- function(valid_input) {\n", "  if (valid_input) {\n", 
#&gt;                 "    return(\"normal value\")\n", "  }\n", "\n", 
#&gt;                 "  # We decide to return the empty string \"\" as default value. An\n", 
#&gt;                 "  # altenative strategy would be to signal an error. In any case,\n", 
#&gt;                 "  # we want to provide a way for the caller to get a different\n", 
#&gt;                 "  # output. For this purpose, we provide two restart functions that\n", 
#&gt;                 "  # returns alternative defaults:\n", "  restarts &lt;- list(\n", 
#&gt;                 "    rst_empty_chr = function() character(0),\n", 
#&gt;                 "    rst_null = function() NULL\n", "  )\n", 
#&gt;                 "\n", "  with_restarts(splice(restarts), .expr = {\n", 
#&gt;                 "\n", "    # Signal a typed condition to let the caller know that we are\n", 
#&gt;                 "    # about to return an empty string as default value:\n", 
#&gt;                 "    cnd_signal(\"default_empty_string\")\n", 
#&gt;                 "\n", "    # If no jump to with_restarts, return default value:\n", 
#&gt;                 "    \"\"\n", "  })\n", "}\n", "\n", "# Normal value for valid input:\n", 
#&gt;                 "fn(TRUE)\n", "\n", "# Default value for bad input:\n", 
#&gt;                 "fn(FALSE)\n", "\n", "# Change the default value if you need an empty character vector by\n", 
#&gt;                 "# defining a calling handler that jumps to the restart. It has to\n", 
#&gt;                 "# be calling because exiting handlers jump to the place where they\n", 
#&gt;                 "# are established before being executed, and the restart is not\n", 
#&gt;                 "# defined anymore at that point:\n", "rst_handler &lt;- calling(function(c) rst_jump(\"rst_empty_chr\"))\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = rst_handler)\n", 
#&gt;                 "\n", "# You can use restarting() to create restarting handlers easily:\n", 
#&gt;                 "with_handlers(fn(FALSE), default_empty_string = restarting(\"rst_null\"))\n"), 
#&gt;             "\n", list("\n", list(list("return_from()")), " and ", 
#&gt;                 list(list("return_to()")), " for a more flexible way\n", 
#&gt;                 "of performing a non-local jump to an arbitrary call frame.\n"), 
#&gt;             "\n", list("internal"), "\n"), wref_key.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/weakref.R", "\n", 
#&gt;             list("wref_key"), "\n", list("wref_key"), "\n", list(
#&gt;                 "wref_value"), "\n", list("Get key/value from a weak reference object"), 
#&gt;             "\n", list("\n", "wref_key(x)\n", "\n", "wref_value(x)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A weak reference object.")), 
#&gt;                 "\n"), "\n", list("\n", "Get key/value from a weak reference object\n"), 
#&gt;             "\n", list("\n", list(list("is_weakref()")), " and ", 
#&gt;                 list(list("new_weakref()")), ".\n"), "\n"), zap.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/s3.R", "\n", list(
#&gt;                 "zap"), "\n", list("zap"), "\n", list("is_zap"), 
#&gt;             "\n", list("Create zap objects"), "\n", list("\n", 
#&gt;                 "zap()\n", "\n", "is_zap(x)\n"), "\n", list("\n", 
#&gt;                 list(list("x"), list("An object to test.")), 
#&gt;                 "\n"), "\n", list("\n", list("zap()"), " creates a sentinel object that indicates that an object\n", 
#&gt;                 "should be removed. For instance, named zaps instruct ", 
#&gt;                 list(list("env_bind()")), "\n", "and ", list(
#&gt;                   list("call_modify()")), " to remove those objects from the environment or\n", 
#&gt;                 "the call.\n", "\n", "The advantage of zap objects is that they unambiguously signal the\n", 
#&gt;                 "intent of removing an object. Sentinels like ", 
#&gt;                 list("NULL"), " or\n", list(list("missing_arg()")), 
#&gt;                 " are ambiguous because they represent valid R\n", 
#&gt;                 "objects.\n"), "\n", list("\n", "# Create one zap object:\n", 
#&gt;                 "zap()\n", "\n", "# Create a list of zaps:\n", 
#&gt;                 "rep(list(zap()), 3)\n", "rep_named(c(\"foo\", \"bar\"), list(zap()))\n"), 
#&gt;             "\n")), source = list(abort.Rd = c("R/cnd-abort.R", 
#&gt;     "R/cnd-signal.R"), are_na.Rd = "R/vec-na.R", arg_match.Rd = "R/arg.R", 
#&gt;         as_box.Rd = "R/s3.R", as_bytes.Rd = "R/utils-encoding.R", 
#&gt;         as_data_mask.Rd = "R/eval-tidy.R", as_env.Rd = "R/lifecycle-retired.R", 
#&gt;         as_environment.Rd = "R/env.R", as_function.Rd = "R/fn.R", 
#&gt;         as_label.Rd = "R/deparse.R", as_name.Rd = "R/deparse.R", 
#&gt;         as_overscope.Rd = "R/lifecycle-retired.R", as_pairlist.Rd = "R/node.R", 
#&gt;         as_quosure.Rd = "R/quo.R", as_string.Rd = "R/sym.R", 
#&gt;         as_utf8_character.Rd = "R/utils-encoding.R", `bare-type-predicates.Rd` = "R/types.R", 
#&gt;         box.Rd = "R/s3.R", call2.Rd = "R/call.R", call_args.Rd = "R/call.R", 
#&gt;         call_fn.Rd = "R/call.R", call_inspect.Rd = "R/stack.R", 
#&gt;         call_modify.Rd = "R/call.R", call_name.Rd = "R/call.R", 
#&gt;         call_standardise.Rd = "R/call.R", caller_env.Rd = "R/env-special.R", 
#&gt;         caller_fn.Rd = "R/stack.R", caller_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         catch_cnd.Rd = "R/cnd-handlers.R", chr_unserialise_unicode.Rd = "R/utils-encoding.R", 
#&gt;         cnd.Rd = c("R/cnd-error.R", "R/cnd.R"), cnd_message.Rd = "R/cnd-message.R", 
#&gt;         cnd_muffle.Rd = "R/cnd-handlers.R", cnd_signal.Rd = "R/cnd-signal.R", 
#&gt;         cnd_type.Rd = "R/cnd.R", done.Rd = "R/s3.R", dots_definitions.Rd = "R/dots.R", 
#&gt;         dots_n.Rd = "R/dots.R", dots_values.Rd = "R/dots.R", 
#&gt;         duplicate.Rd = "R/sexp.R", empty_env.Rd = "R/env-special.R", 
#&gt;         entrace.Rd = "R/cnd-entrace.R", env.Rd = "R/env.R", env_bind.Rd = "R/env-binding.R", 
#&gt;         env_bind_exprs.Rd = "R/lifecycle-retired.R", env_binding_are_active.Rd = "R/env-binding.R", 
#&gt;         env_binding_lock.Rd = "R/env-binding.R", env_bury.Rd = "R/env-binding.R", 
#&gt;         env_clone.Rd = "R/env.R", env_depth.Rd = "R/env.R", env_get.Rd = "R/env-binding.R", 
#&gt;         env_has.Rd = "R/env-binding.R", env_inherits.Rd = "R/env.R", 
#&gt;         env_lock.Rd = "R/env.R", env_name.Rd = "R/env-special.R", 
#&gt;         env_names.Rd = "R/env-binding.R", env_parent.Rd = "R/env.R", 
#&gt;         env_poke.Rd = "R/env-binding.R", env_print.Rd = "R/env.R", 
#&gt;         env_unbind.Rd = "R/env-binding.R", env_unlock.Rd = "R/env.R", 
#&gt;         eval_bare.Rd = "R/eval.R", eval_tidy.Rd = "R/eval-tidy.R", 
#&gt;         exec.Rd = "R/eval.R", exiting.Rd = "R/lifecycle-retired.R", 
#&gt;         expr_interp.Rd = "R/quasiquotation.R", expr_label.Rd = "R/expr.R", 
#&gt;         expr_print.Rd = "R/expr.R", exprs_auto_name.Rd = "R/quotation.R", 
#&gt;         f_rhs.Rd = "R/formula.R", f_text.Rd = "R/formula.R", 
#&gt;         flatten.Rd = "R/vec-squash.R", fn_body.Rd = "R/fn.R", 
#&gt;         fn_env.Rd = "R/fn.R", fn_fmls.Rd = "R/fn.R", frame_position.Rd = "R/lifecycle-retired.R", 
#&gt;         friendly_type.Rd = "R/types.R", get_env.Rd = "R/env.R", 
#&gt;         has_length.Rd = "R/attr.R", has_name.Rd = "R/attr.R", 
#&gt;         inherits_any.Rd = "R/s3.R", invoke.Rd = "R/eval.R", is_call.Rd = "R/call.R", 
#&gt;         is_callable.Rd = "R/call.R", is_condition.Rd = "R/cnd.R", 
#&gt;         is_copyable.Rd = "R/types.R", is_empty.Rd = "R/types.R", 
#&gt;         is_env.Rd = "R/lifecycle-retired.R", is_environment.Rd = "R/types.R", 
#&gt;         is_expr.Rd = "R/lifecycle-retired.R", is_expression.Rd = "R/expr.R", 
#&gt;         is_formula.Rd = "R/formula.R", is_frame.Rd = "R/lifecycle-retired.R", 
#&gt;         is_function.Rd = "R/fn.R", is_installed.Rd = "R/env-special.R", 
#&gt;         is_integerish.Rd = "R/types.R", is_interactive.Rd = "R/state.R", 
#&gt;         is_lang.Rd = "R/lifecycle-retired.R", is_named.Rd = "R/attr.R", 
#&gt;         is_namespace.Rd = "R/env-special.R", is_pairlist.Rd = "R/node.R", 
#&gt;         is_reference.Rd = "R/types.R", is_stack.Rd = "R/lifecycle-retired.R", 
#&gt;         is_symbol.Rd = "R/sym.R", is_true.Rd = "R/types.R", is_weakref.Rd = "R/weakref.R", 
#&gt;         lang.Rd = "R/lifecycle-retired.R", lang_head.Rd = "R/lifecycle-retired.R", 
#&gt;         lang_modify.Rd = "R/lifecycle-retired.R", last_error.Rd = "R/cnd-abort.R", 
#&gt;         lifecycle.Rd = "R/lifecycle.R", missing.Rd = "R/vec-na.R", 
#&gt;         missing_arg.Rd = "R/arg.R", mut_node_car.Rd = "R/lifecycle-retired.R", 
#&gt;         names2.Rd = "R/attr.R", `new-vector-along-retired.Rd` = "R/lifecycle-retired.R", 
#&gt;         `new-vector.Rd` = "R/vec-new.R", new_call.Rd = "R/node.R", 
#&gt;         new_formula.Rd = "R/formula.R", new_function.Rd = "R/fn.R", 
#&gt;         new_node.Rd = "R/node.R", new_quosures.Rd = "R/quo.R", 
#&gt;         new_weakref.Rd = "R/weakref.R", ns_env.Rd = "R/env-special.R", 
#&gt;         `op-definition.Rd` = "R/operators.R", `op-get-attr.Rd` = "R/operators.R", 
#&gt;         `op-na-default.Rd` = "R/operators.R", `op-null-default.Rd` = "R/operators.R", 
#&gt;         overscope_eval_next.Rd = "R/lifecycle-retired.R", pairlist2.Rd = "R/call.R", 
#&gt;         parse_expr.Rd = "R/parse.R", parse_quosure.Rd = "R/lifecycle-retired.R", 
#&gt;         prepend.Rd = "R/lifecycle-retired.R", prim_name.Rd = "R/fn.R", 
#&gt;         quasiquotation.Rd = "R/quasiquotation.R", quo_expr.Rd = "R/lifecycle-retired.R", 
#&gt;         quo_label.Rd = "R/quo.R", quo_squash.Rd = "R/quo.R", 
#&gt;         quosure.Rd = "R/quo.R", quotation.Rd = "R/quotation.R", 
#&gt;         rep_along.Rd = "R/vec-new.R", restarting.Rd = "R/cnd-handlers.R", 
#&gt;         return_from.Rd = "R/stack.R", rlang_backtrace_on_error.Rd = "R/cnd-abort.R", 
#&gt;         rst_abort.Rd = "R/cnd-restarts.R", rst_list.Rd = "R/cnd-restarts.R", 
#&gt;         `scalar-type-predicates.Rd` = "R/types.R", scoped_bindings.Rd = "R/env-binding.R", 
#&gt;         scoped_env.Rd = "R/lifecycle-retired.R", scoped_options.Rd = "R/state.R", 
#&gt;         search_envs.Rd = "R/env-special.R", seq2.Rd = "R/vec.R", 
#&gt;         set_attrs.Rd = "R/lifecycle-retired.R", set_expr.Rd = "R/expr.R", 
#&gt;         set_names.Rd = "R/attr.R", splice.Rd = "R/dots.R", stack.Rd = "R/lifecycle-retired.R", 
#&gt;         stack_trim.Rd = "R/lifecycle-retired.R", string.Rd = "R/utils-encoding.R", 
#&gt;         switch_type.Rd = "R/lifecycle-retired.R", sym.Rd = "R/sym.R", 
#&gt;         `tidy-dots.Rd` = c("R/dots.R", "R/vec-new.R"), `tidyeval-data.Rd` = "R/eval-tidy.R", 
#&gt;         trace_back.Rd = "R/trace.R", `type-predicates.Rd` = "R/types.R", 
#&gt;         type_of.Rd = "R/lifecycle-retired.R", vec_poke_n.Rd = "R/vec.R", 
#&gt;         `vector-coercion.Rd` = "R/lifecycle-retired.R", `vector-construction.Rd` = "R/vec-new.R", 
#&gt;         `vector-old-ctors.Rd` = "R/lifecycle-retired.R", with_abort.Rd = "R/cnd-entrace.R", 
#&gt;         with_env.Rd = "R/eval.R", with_handlers.Rd = "R/cnd-handlers.R", 
#&gt;         with_restarts.Rd = "R/cnd-restarts.R", wref_key.Rd = "R/weakref.R", 
#&gt;         zap.Rd = "R/s3.R"), concepts = list(abort.Rd = character(0), 
#&gt;         are_na.Rd = character(0), arg_match.Rd = character(0), 
#&gt;         as_box.Rd = character(0), as_bytes.Rd = character(0), 
#&gt;         as_data_mask.Rd = character(0), as_env.Rd = character(0), 
#&gt;         as_environment.Rd = character(0), as_function.Rd = character(0), 
#&gt;         as_label.Rd = character(0), as_name.Rd = character(0), 
#&gt;         as_overscope.Rd = character(0), as_pairlist.Rd = character(0), 
#&gt;         as_quosure.Rd = character(0), as_string.Rd = character(0), 
#&gt;         as_utf8_character.Rd = character(0), `bare-type-predicates.Rd` = character(0), 
#&gt;         box.Rd = character(0), call2.Rd = character(0), call_args.Rd = character(0), 
#&gt;         call_fn.Rd = character(0), call_inspect.Rd = character(0), 
#&gt;         call_modify.Rd = character(0), call_name.Rd = character(0), 
#&gt;         call_standardise.Rd = character(0), caller_env.Rd = character(0), 
#&gt;         caller_fn.Rd = character(0), caller_frame.Rd = character(0), 
#&gt;         catch_cnd.Rd = character(0), chr_unserialise_unicode.Rd = character(0), 
#&gt;         cnd.Rd = character(0), cnd_message.Rd = character(0), 
#&gt;         cnd_muffle.Rd = character(0), cnd_signal.Rd = character(0), 
#&gt;         cnd_type.Rd = character(0), done.Rd = character(0), dots_definitions.Rd = character(0), 
#&gt;         dots_n.Rd = character(0), dots_values.Rd = character(0), 
#&gt;         duplicate.Rd = character(0), empty_env.Rd = character(0), 
#&gt;         entrace.Rd = character(0), env.Rd = character(0), env_bind.Rd = character(0), 
#&gt;         env_bind_exprs.Rd = character(0), env_binding_are_active.Rd = character(0), 
#&gt;         env_binding_lock.Rd = character(0), env_bury.Rd = character(0), 
#&gt;         env_clone.Rd = character(0), env_depth.Rd = character(0), 
#&gt;         env_get.Rd = character(0), env_has.Rd = character(0), 
#&gt;         env_inherits.Rd = character(0), env_lock.Rd = character(0), 
#&gt;         env_name.Rd = character(0), env_names.Rd = character(0), 
#&gt;         env_parent.Rd = character(0), env_poke.Rd = character(0), 
#&gt;         env_print.Rd = character(0), env_unbind.Rd = character(0), 
#&gt;         env_unlock.Rd = character(0), eval_bare.Rd = character(0), 
#&gt;         eval_tidy.Rd = character(0), exec.Rd = character(0), 
#&gt;         exiting.Rd = character(0), expr_interp.Rd = character(0), 
#&gt;         expr_label.Rd = character(0), expr_print.Rd = character(0), 
#&gt;         exprs_auto_name.Rd = character(0), f_rhs.Rd = character(0), 
#&gt;         f_text.Rd = character(0), flatten.Rd = character(0), 
#&gt;         fn_body.Rd = character(0), fn_env.Rd = character(0), 
#&gt;         fn_fmls.Rd = character(0), frame_position.Rd = character(0), 
#&gt;         friendly_type.Rd = character(0), get_env.Rd = character(0), 
#&gt;         has_length.Rd = character(0), has_name.Rd = character(0), 
#&gt;         inherits_any.Rd = character(0), invoke.Rd = character(0), 
#&gt;         is_call.Rd = character(0), is_callable.Rd = character(0), 
#&gt;         is_condition.Rd = character(0), is_copyable.Rd = character(0), 
#&gt;         is_empty.Rd = character(0), is_env.Rd = character(0), 
#&gt;         is_environment.Rd = character(0), is_expr.Rd = character(0), 
#&gt;         is_expression.Rd = character(0), is_formula.Rd = character(0), 
#&gt;         is_frame.Rd = character(0), is_function.Rd = character(0), 
#&gt;         is_installed.Rd = character(0), is_integerish.Rd = character(0), 
#&gt;         is_interactive.Rd = character(0), is_lang.Rd = character(0), 
#&gt;         is_named.Rd = character(0), is_namespace.Rd = character(0), 
#&gt;         is_pairlist.Rd = character(0), is_reference.Rd = character(0), 
#&gt;         is_stack.Rd = character(0), is_symbol.Rd = character(0), 
#&gt;         is_true.Rd = character(0), is_weakref.Rd = character(0), 
#&gt;         lang.Rd = character(0), lang_head.Rd = character(0), 
#&gt;         lang_modify.Rd = character(0), last_error.Rd = character(0), 
#&gt;         lifecycle.Rd = character(0), missing.Rd = character(0), 
#&gt;         missing_arg.Rd = character(0), mut_node_car.Rd = character(0), 
#&gt;         names2.Rd = character(0), `new-vector-along-retired.Rd` = character(0), 
#&gt;         `new-vector.Rd` = character(0), new_call.Rd = character(0), 
#&gt;         new_formula.Rd = character(0), new_function.Rd = character(0), 
#&gt;         new_node.Rd = character(0), new_quosures.Rd = character(0), 
#&gt;         new_weakref.Rd = character(0), ns_env.Rd = character(0), 
#&gt;         `op-definition.Rd` = character(0), `op-get-attr.Rd` = character(0), 
#&gt;         `op-na-default.Rd` = character(0), `op-null-default.Rd` = character(0), 
#&gt;         overscope_eval_next.Rd = character(0), pairlist2.Rd = character(0), 
#&gt;         parse_expr.Rd = character(0), parse_quosure.Rd = character(0), 
#&gt;         prepend.Rd = character(0), prim_name.Rd = character(0), 
#&gt;         quasiquotation.Rd = character(0), quo_expr.Rd = character(0), 
#&gt;         quo_label.Rd = character(0), quo_squash.Rd = character(0), 
#&gt;         quosure.Rd = character(0), quotation.Rd = character(0), 
#&gt;         rep_along.Rd = character(0), restarting.Rd = character(0), 
#&gt;         return_from.Rd = character(0), rlang_backtrace_on_error.Rd = character(0), 
#&gt;         rst_abort.Rd = character(0), rst_list.Rd = character(0), 
#&gt;         `scalar-type-predicates.Rd` = character(0), scoped_bindings.Rd = character(0), 
#&gt;         scoped_env.Rd = character(0), scoped_options.Rd = character(0), 
#&gt;         search_envs.Rd = character(0), seq2.Rd = character(0), 
#&gt;         set_attrs.Rd = character(0), set_expr.Rd = character(0), 
#&gt;         set_names.Rd = character(0), splice.Rd = character(0), 
#&gt;         stack.Rd = character(0), stack_trim.Rd = character(0), 
#&gt;         string.Rd = character(0), switch_type.Rd = character(0), 
#&gt;         sym.Rd = character(0), `tidy-dots.Rd` = character(0), 
#&gt;         `tidyeval-data.Rd` = character(0), trace_back.Rd = character(0), 
#&gt;         `type-predicates.Rd` = character(0), type_of.Rd = character(0), 
#&gt;         vec_poke_n.Rd = character(0), `vector-coercion.Rd` = character(0), 
#&gt;         `vector-construction.Rd` = character(0), `vector-old-ctors.Rd` = character(0), 
#&gt;         with_abort.Rd = character(0), with_env.Rd = character(0), 
#&gt;         with_handlers.Rd = character(0), with_restarts.Rd = character(0), 
#&gt;         wref_key.Rd = character(0), zap.Rd = character(0)), internal = c(FALSE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, 
#&gt;     TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, 
#&gt;     TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, 
#&gt;     FALSE, FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, 
#&gt;     FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, 
#&gt;     TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, 
#&gt;     FALSE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, 
#&gt;     FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE, TRUE, 
#&gt;     FALSE, TRUE, FALSE, FALSE)), tutorials = list(name = character(0), 
#&gt;         file_out = character(0), title = character(0), pagetitle = character(0), 
#&gt;         url = character(0)), vignettes = list(name = character(0), 
#&gt;         file_in = character(0), file_out = character(0), title = character(0)), 
#&gt;     topic_index = c(`:=` = "quasiquotation", `!!` = "quasiquotation", 
#&gt;     `!!!` = "quasiquotation", .data = "tidyeval-data", `{{` = "quasiquotation", 
#&gt;     `{{}}` = "quasiquotation", `%@%` = "op-get-attr", `%@%&lt;-` = "op-get-attr", 
#&gt;     `%|%` = "op-na-default", `%||%` = "op-null-default", abort = "abort", 
#&gt;     add_backtrace = "rlang_backtrace_on_error", are_na = "are_na", 
#&gt;     arg_match = "arg_match", as_box = "as_box", as_box_if = "as_box", 
#&gt;     as_bytes = "as_bytes", as_character = "vector-coercion", 
#&gt;     as_closure = "as_function", as_complex = "vector-coercion", 
#&gt;     as_data_mask = "as_data_mask", as_data_pronoun = "as_data_mask", 
#&gt;     as_double = "vector-coercion", as_env = "as_env", as_environment = "as_environment", 
#&gt;     as_function = "as_function", as_integer = "vector-coercion", 
#&gt;     as_label = "as_label", as_list = "vector-coercion", as_logical = "vector-coercion", 
#&gt;     as_name = "as_name", as_overscope = "as_overscope", as_pairlist = "as_pairlist", 
#&gt;     as_quosure = "as_quosure", as_quosures = "new_quosures", 
#&gt;     as_string = "as_string", as_utf8_character = "as_utf8_character", 
#&gt;     `bare-type-predicates` = "bare-type-predicates", base_env = "search_envs", 
#&gt;     box = "box", bytes = "vector-construction", bytes_along = "vector-old-ctors", 
#&gt;     bytes_len = "vector-old-ctors", call_args = "call_args", 
#&gt;     call_args_names = "call_args", call_depth = "stack", call_fn = "call_fn", 
#&gt;     call_frame = "stack", call_inspect = "call_inspect", call_modify = "call_modify", 
#&gt;     call_name = "call_name", call_ns = "call_name", call_stack = "stack", 
#&gt;     call_standardise = "call_standardise", call2 = "call2", caller_env = "caller_env", 
#&gt;     caller_fn = "caller_fn", caller_frame = "caller_frame", calling = "with_handlers", 
#&gt;     catch_cnd = "catch_cnd", child_env = "env", chr = "vector-construction", 
#&gt;     chr_along = "vector-old-ctors", chr_len = "vector-old-ctors", 
#&gt;     chr_unserialise_unicode = "chr_unserialise_unicode", cnd = "cnd", 
#&gt;     cnd_bullets = "cnd_message", cnd_entrace = "entrace", cnd_issue = "cnd_message", 
#&gt;     cnd_message = "cnd_message", cnd_muffle = "cnd_muffle", cnd_signal = "cnd_signal", 
#&gt;     cnd_type = "cnd_type", coerce_class = "switch_type", coerce_type = "switch_type", 
#&gt;     cpl = "vector-construction", cpl_along = "vector-old-ctors", 
#&gt;     cpl_len = "vector-old-ctors", ctxt_depth = "stack", ctxt_frame = "stack", 
#&gt;     ctxt_stack = "stack", current_env = "caller_env", current_fn = "caller_fn", 
#&gt;     current_frame = "stack", dbl = "vector-construction", dbl_along = "vector-old-ctors", 
#&gt;     dbl_len = "vector-old-ctors", done = "done", dots_definitions = "dots_definitions", 
#&gt;     dots_list = "tidy-dots", dots_n = "dots_n", dots_splice = "splice", 
#&gt;     dots_values = "dots_values", duplicate = "duplicate", empty_env = "empty_env", 
#&gt;     enexpr = "quotation", enexprs = "quotation", enquo = "quotation", 
#&gt;     enquos = "quotation", ensym = "quotation", ensyms = "quotation", 
#&gt;     entrace = "entrace", env = "env", env_bind = "env_bind", 
#&gt;     env_bind_active = "env_bind", env_bind_exprs = "env_bind_exprs", 
#&gt;     env_bind_fns = "env_bind_exprs", env_bind_lazy = "env_bind", 
#&gt;     env_binding_are_active = "env_binding_are_active", env_binding_are_lazy = "env_binding_are_active", 
#&gt;     env_binding_are_locked = "env_binding_lock", env_binding_lock = "env_binding_lock", 
#&gt;     env_binding_unlock = "env_binding_lock", env_bury = "env_bury", 
#&gt;     env_clone = "env_clone", env_depth = "env_depth", env_get = "env_get", 
#&gt;     env_get_list = "env_get", env_has = "env_has", env_inherits = "env_inherits", 
#&gt;     env_is_locked = "env_lock", env_label = "env_name", env_length = "env_names", 
#&gt;     env_lock = "env_lock", env_name = "env_name", env_names = "env_names", 
#&gt;     env_parent = "env_parent", env_parents = "env_parent", env_poke = "env_poke", 
#&gt;     env_poke_parent = "get_env", env_print = "env_print", env_tail = "env_parent", 
#&gt;     env_unbind = "env_unbind", env_unlock = "env_unlock", error_cnd = "cnd", 
#&gt;     eval_bare = "eval_bare", eval_tidy = "eval_tidy", exec = "exec", 
#&gt;     exiting = "exiting", expr = "quotation", expr_deparse = "expr_print", 
#&gt;     expr_interp = "expr_interp", expr_label = "expr_label", expr_name = "expr_label", 
#&gt;     expr_print = "expr_print", expr_text = "expr_label", exprs = "quotation", 
#&gt;     exprs_auto_name = "exprs_auto_name", f_env = "f_rhs", `f_env&lt;-` = "f_rhs", 
#&gt;     f_label = "f_text", f_lhs = "f_rhs", `f_lhs&lt;-` = "f_rhs", 
#&gt;     f_name = "f_text", f_rhs = "f_rhs", `f_rhs&lt;-` = "f_rhs", 
#&gt;     f_text = "f_text", flatten = "flatten", flatten_chr = "flatten", 
#&gt;     flatten_cpl = "flatten", flatten_dbl = "flatten", flatten_if = "flatten", 
#&gt;     flatten_int = "flatten", flatten_lgl = "flatten", flatten_raw = "flatten", 
#&gt;     fn_body = "fn_body", `fn_body&lt;-` = "fn_body", fn_env = "fn_env", 
#&gt;     `fn_env&lt;-` = "fn_env", fn_fmls = "fn_fmls", fn_fmls_names = "fn_fmls", 
#&gt;     `fn_fmls_names&lt;-` = "fn_fmls", fn_fmls_syms = "fn_fmls", 
#&gt;     `fn_fmls&lt;-` = "fn_fmls", format_bullets = "cnd_message", 
#&gt;     frame_position = "frame_position", friendly_type = "friendly_type", 
#&gt;     get_env = "get_env", get_expr = "set_expr", global_env = "search_envs", 
#&gt;     global_frame = "stack", has_length = "has_length", has_name = "has_name", 
#&gt;     have_name = "is_named", inform = "abort", inherits_all = "inherits_any", 
#&gt;     inherits_any = "inherits_any", inherits_only = "inherits_any", 
#&gt;     int = "vector-construction", int_along = "vector-old-ctors", 
#&gt;     int_len = "vector-old-ctors", interrupt = "abort", invoke = "invoke", 
#&gt;     is_atomic = "type-predicates", is_attached = "search_envs", 
#&gt;     is_bare_atomic = "bare-type-predicates", is_bare_bytes = "bare-type-predicates", 
#&gt;     is_bare_character = "bare-type-predicates", is_bare_double = "bare-type-predicates", 
#&gt;     is_bare_env = "is_env", is_bare_environment = "is_environment", 
#&gt;     is_bare_formula = "is_formula", is_bare_integer = "bare-type-predicates", 
#&gt;     is_bare_integerish = "is_integerish", is_bare_list = "bare-type-predicates", 
#&gt;     is_bare_logical = "bare-type-predicates", is_bare_numeric = "bare-type-predicates", 
#&gt;     is_bare_raw = "bare-type-predicates", is_bare_string = "bare-type-predicates", 
#&gt;     is_bare_vector = "bare-type-predicates", is_binary_lang = "is_lang", 
#&gt;     is_bool = "scalar-type-predicates", is_box = "box", is_bytes = "type-predicates", 
#&gt;     is_call = "is_call", is_call_stack = "is_stack", is_callable = "is_callable", 
#&gt;     is_character = "type-predicates", is_chr_na = "are_na", is_closure = "is_function", 
#&gt;     is_condition = "is_condition", is_copyable = "is_copyable", 
#&gt;     is_cpl_na = "are_na", is_dbl_na = "are_na", is_definition = "op-definition", 
#&gt;     is_dictionaryish = "is_named", is_done_box = "done", is_double = "type-predicates", 
#&gt;     is_empty = "is_empty", is_env = "is_env", is_environment = "is_environment", 
#&gt;     is_eval_stack = "is_stack", is_expr = "is_expr", is_expression = "is_expression", 
#&gt;     is_false = "is_true", is_formula = "is_formula", is_formulaish = "op-definition", 
#&gt;     is_frame = "is_frame", is_function = "is_function", is_installed = "is_installed", 
#&gt;     is_int_na = "are_na", is_integer = "type-predicates", is_integerish = "is_integerish", 
#&gt;     is_interactive = "is_interactive", is_lambda = "as_function", 
#&gt;     is_lang = "is_lang", is_lgl_na = "are_na", is_list = "type-predicates", 
#&gt;     is_logical = "type-predicates", is_missing = "missing_arg", 
#&gt;     is_na = "are_na", is_named = "is_named", is_namespace = "is_namespace", 
#&gt;     is_node = "is_pairlist", is_node_list = "is_pairlist", is_null = "type-predicates", 
#&gt;     is_pairlist = "is_pairlist", is_primitive = "is_function", 
#&gt;     is_primitive_eager = "is_function", is_primitive_lazy = "is_function", 
#&gt;     is_quosure = "quosure", is_quosures = "new_quosures", is_raw = "type-predicates", 
#&gt;     is_reference = "is_reference", is_scalar_atomic = "scalar-type-predicates", 
#&gt;     is_scalar_bytes = "scalar-type-predicates", is_scalar_character = "scalar-type-predicates", 
#&gt;     is_scalar_double = "scalar-type-predicates", is_scalar_integer = "scalar-type-predicates", 
#&gt;     is_scalar_integerish = "is_integerish", is_scalar_list = "scalar-type-predicates", 
#&gt;     is_scalar_logical = "scalar-type-predicates", is_scalar_raw = "scalar-type-predicates", 
#&gt;     is_scalar_vector = "scalar-type-predicates", is_scoped = "scoped_env", 
#&gt;     is_spliced = "splice", is_spliced_bare = "splice", is_stack = "is_stack", 
#&gt;     is_string = "scalar-type-predicates", is_symbol = "is_symbol", 
#&gt;     is_symbolic = "is_expression", is_syntactic_literal = "is_expression", 
#&gt;     is_true = "is_true", is_unary_lang = "is_lang", is_vector = "type-predicates", 
#&gt;     is_weakref = "is_weakref", is_zap = "zap", lang = "lang", 
#&gt;     lang_args = "lang_modify", lang_args_names = "lang_modify", 
#&gt;     lang_fn = "lang_modify", lang_head = "lang_head", lang_modify = "lang_modify", 
#&gt;     lang_name = "lang_modify", lang_standardise = "lang_modify", 
#&gt;     lang_tail = "lang_head", last_error = "last_error", last_trace = "last_error", 
#&gt;     lgl = "vector-construction", lgl_along = "vector-old-ctors", 
#&gt;     lgl_len = "vector-old-ctors", lifecycle = "lifecycle", list_along = "vector-old-ctors", 
#&gt;     list_len = "vector-old-ctors", list2 = "tidy-dots", ll = "vector-construction", 
#&gt;     locally = "with_env", maybe_missing = "missing_arg", message_cnd = "cnd", 
#&gt;     missing = "missing", missing_arg = "missing_arg", modify = "prepend", 
#&gt;     mut_attrs = "set_attrs", mut_node_caar = "mut_node_car", 
#&gt;     mut_node_cadr = "mut_node_car", mut_node_car = "mut_node_car", 
#&gt;     mut_node_cdar = "mut_node_car", mut_node_cddr = "mut_node_car", 
#&gt;     mut_node_cdr = "mut_node_car", mut_node_tag = "mut_node_car", 
#&gt;     na_chr = "missing", na_cpl = "missing", na_dbl = "missing", 
#&gt;     na_int = "missing", na_lgl = "missing", names2 = "names2", 
#&gt;     new_box = "box", new_call = "new_call", new_character = "new-vector", 
#&gt;     new_character_along = "new-vector-along-retired", new_complex = "new-vector", 
#&gt;     new_complex_along = "new-vector-along-retired", new_data_mask = "as_data_mask", 
#&gt;     new_definition = "op-definition", new_double = "new-vector", 
#&gt;     new_double_along = "new-vector-along-retired", new_environment = "env", 
#&gt;     new_formula = "new_formula", new_function = "new_function", 
#&gt;     new_integer = "new-vector", new_integer_along = "new-vector-along-retired", 
#&gt;     new_language = "lang", new_list = "new-vector", new_list_along = "new-vector-along-retired", 
#&gt;     new_logical = "new-vector", new_logical_along = "new-vector-along-retired", 
#&gt;     new_node = "new_node", new_overscope = "as_overscope", new_quosure = "as_quosure", 
#&gt;     new_quosures = "new_quosures", new_raw = "new-vector", new_raw_along = "new-vector-along-retired", 
#&gt;     new_weakref = "new_weakref", `new-vector` = "new-vector", 
#&gt;     `new-vector-along-retired` = "new-vector-along-retired", 
#&gt;     node = "vector-old-ctors", node_caar = "new_node", node_cadr = "new_node", 
#&gt;     node_car = "new_node", node_cdar = "new_node", node_cddr = "new_node", 
#&gt;     node_cdr = "new_node", node_poke_caar = "new_node", node_poke_cadr = "new_node", 
#&gt;     node_poke_car = "new_node", node_poke_cdar = "new_node", 
#&gt;     node_poke_cddr = "new_node", node_poke_cdr = "new_node", 
#&gt;     node_poke_tag = "new_node", node_tag = "new_node", ns_env = "ns_env", 
#&gt;     ns_env_name = "ns_env", ns_imports_env = "ns_env", `op-definition` = "op-definition", 
#&gt;     `op-get-attr` = "op-get-attr", `op-na-default` = "op-na-default", 
#&gt;     `op-null-default` = "op-null-default", overscope_clean = "as_overscope", 
#&gt;     overscope_eval_next = "overscope_eval_next", pairlist2 = "pairlist2", 
#&gt;     parse_expr = "parse_expr", parse_exprs = "parse_expr", parse_quo = "parse_expr", 
#&gt;     parse_quos = "parse_expr", parse_quosure = "parse_quosure", 
#&gt;     parse_quosures = "parse_quosure", peek_option = "scoped_options", 
#&gt;     peek_options = "scoped_options", pkg_env = "search_envs", 
#&gt;     pkg_env_name = "search_envs", prepend = "prepend", prim_name = "prim_name", 
#&gt;     push_options = "scoped_options", qq_show = "quasiquotation", 
#&gt;     quasiquotation = "quasiquotation", quo = "quotation", quo_expr = "quo_expr", 
#&gt;     quo_get_env = "quosure", quo_get_expr = "quosure", quo_is_call = "quosure", 
#&gt;     quo_is_lang = "is_lang", quo_is_missing = "quosure", quo_is_null = "quosure", 
#&gt;     quo_is_symbol = "quosure", quo_is_symbolic = "quosure", quo_label = "quo_label", 
#&gt;     quo_name = "quo_label", quo_set_env = "quosure", quo_set_expr = "quosure", 
#&gt;     quo_squash = "quo_squash", quo_text = "quo_label", quos = "quotation", 
#&gt;     quos_auto_name = "exprs_auto_name", quosure = "quosure", 
#&gt;     quotation = "quotation", raw_along = "vector-old-ctors", 
#&gt;     raw_len = "vector-old-ctors", rep_along = "rep_along", rep_named = "rep_along", 
#&gt;     restarting = "restarting", return_from = "return_from", return_to = "return_from", 
#&gt;     rlang_backtrace_on_error = "rlang_backtrace_on_error", rst_abort = "rst_abort", 
#&gt;     rst_exists = "rst_list", rst_jump = "rst_list", rst_list = "rst_list", 
#&gt;     rst_maybe_jump = "rst_list", `scalar-type-predicates` = "scalar-type-predicates", 
#&gt;     scoped_bindings = "scoped_bindings", scoped_env = "scoped_env", 
#&gt;     scoped_envs = "scoped_env", scoped_interactive = "is_interactive", 
#&gt;     scoped_names = "scoped_env", scoped_options = "scoped_options", 
#&gt;     search_env = "search_envs", search_envs = "search_envs", 
#&gt;     seq2 = "seq2", seq2_along = "seq2", set_attrs = "set_attrs", 
#&gt;     set_env = "get_env", set_expr = "set_expr", set_names = "set_names", 
#&gt;     signal = "abort", splice = "splice", squash = "flatten", 
#&gt;     squash_chr = "flatten", squash_cpl = "flatten", squash_dbl = "flatten", 
#&gt;     squash_if = "flatten", squash_int = "flatten", squash_lgl = "flatten", 
#&gt;     squash_raw = "flatten", stack = "stack", stack_trim = "stack_trim", 
#&gt;     string = "string", switch_class = "switch_type", switch_type = "switch_type", 
#&gt;     sym = "sym", syms = "sym", `tidy-dots` = "tidy-dots", `tidyeval-data` = "tidyeval-data", 
#&gt;     trace_back = "trace_back", trace_length = "trace_back", type_of = "type_of", 
#&gt;     `type-predicates` = "type-predicates", unbox = "box", UQ = "quasiquotation", 
#&gt;     UQS = "quasiquotation", vec_poke_n = "vec_poke_n", vec_poke_range = "vec_poke_n", 
#&gt;     `vector-coercion` = "vector-coercion", `vector-construction` = "vector-construction", 
#&gt;     `vector-old-ctors` = "vector-old-ctors", warn = "abort", 
#&gt;     warning_cnd = "cnd", with_abort = "with_abort", with_bindings = "scoped_bindings", 
#&gt;     with_env = "with_env", with_handlers = "with_handlers", with_interactive = "is_interactive", 
#&gt;     with_options = "scoped_options", with_restarts = "with_restarts", 
#&gt;     wref_key = "wref_key", wref_value = "wref_key", zap = "zap"
#&gt;     ), article_index = character(0)), examples = TRUE, run_dont_run = FALSE, 
#&gt;     seed = 1014, lazy = FALSE, override = list(destination = "/tmp/RtmpGSP0ZP/file4f58692244b4"), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE)
#&gt; 
#&gt; [[13]]
#&gt; pkgdown::build_site(...)
#&gt; 
#&gt; [[14]]
#&gt; build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, lazy = lazy, override = override, preview = preview, 
#&gt;     devel = devel)
#&gt; 
#&gt; [[15]]
#&gt; build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, override = override, preview = FALSE, devel = devel)
#&gt; 
#&gt; [[16]]
#&gt; purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, 
#&gt;     examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[17]]
#&gt; .f(.x[[i]], ...)
#&gt; 
#&gt; [[18]]
#&gt; data_reference_topic(topic, pkg, examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[19]]
#&gt; run_examples(tags$tag_examples[[1]], env = new.env(parent = globalenv()), 
#&gt;     topic = tools::file_path_sans_ext(topic$file_in), run_examples = examples, 
#&gt;     run_dont_run = run_dont_run)
#&gt; 
#&gt; [[20]]
#&gt; highlight_examples(code, topic, env = env)
#&gt; 
#&gt; [[21]]
#&gt; evaluate::evaluate(x, child_env(env), new_device = TRUE)
#&gt; 
#&gt; [[22]]
#&gt; evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
#&gt;     debug = debug, last = i == length(out), use_try = stop_on_error != 
#&gt;         2L, keep_warning = keep_warning, keep_message = keep_message, 
#&gt;     output_handler = output_handler, include_timing = include_timing)
#&gt; 
#&gt; [[23]]
#&gt; timing_fn(handle(ev &lt;- withCallingHandlers(withVisible(eval(expr, 
#&gt;     envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)))
#&gt; 
#&gt; [[24]]
#&gt; handle(ev &lt;- withCallingHandlers(withVisible(eval(expr, envir, 
#&gt;     enclos)), warning = wHandler, error = eHandler, message = mHandler))
#&gt; 
#&gt; [[25]]
#&gt; try(f, silent = TRUE)
#&gt; 
#&gt; [[26]]
#&gt; tryCatch(expr, error = function(e) {
#&gt;     call &lt;- conditionCall(e)
#&gt;     if (!is.null(call)) {
#&gt;         if (identical(call[[1L]], quote(doTryCatch))) 
#&gt;             call &lt;- sys.call(-4L)
#&gt;         dcall &lt;- deparse(call)[1L]
#&gt;         prefix &lt;- paste("Error in", dcall, ": ")
#&gt;         LONG &lt;- 75L
#&gt;         sm &lt;- strsplit(conditionMessage(e), "\n")[[1L]]
#&gt;         w &lt;- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
#&gt;         if (is.na(w)) 
#&gt;             w &lt;- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
#&gt;                 type = "b")
#&gt;         if (w &gt; LONG) 
#&gt;             prefix &lt;- paste0(prefix, "\n  ")
#&gt;     }
#&gt;     else prefix &lt;- "Error : "
#&gt;     msg &lt;- paste0(prefix, conditionMessage(e), "\n")
#&gt;     .Internal(seterrmessage(msg[1L]))
#&gt;     if (!silent &amp;&amp; isTRUE(getOption("show.error.messages"))) {
#&gt;         cat(msg, file = outFile)
#&gt;         .Internal(printDeferredWarnings())
#&gt;     }
#&gt;     invisible(structure(msg, class = "try-error", condition = e))
#&gt; })
#&gt; 
#&gt; [[27]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[28]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[29]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[30]]
#&gt; withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler, 
#&gt;     error = eHandler, message = mHandler)
#&gt; 
#&gt; [[31]]
#&gt; withVisible(eval(expr, envir, enclos))
#&gt; 
#&gt; [[32]]
#&gt; eval(expr, envir, enclos)
#&gt; 
#&gt; [[33]]
#&gt; eval(expr, envir, enclos)
#&gt; 
#&gt; [[34]]
#&gt; do.call(fn, list(mtcars))
#&gt; 
#&gt; [[35]]
#&gt; (function(...) sys.calls())(list(mpg = c(21, 21, 22.8, 21.4, 
#&gt; 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 
#&gt; 10.4, 14.7, 32.4, 30.4, 33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 
#&gt; 26, 30.4, 15.8, 19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 
#&gt; 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 
#&gt; 8, 6, 8, 4), disp = c(160, 160, 108, 258, 360, 225, 360, 146.7, 
#&gt; 140.8, 167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440, 78.7, 
#&gt; 75.7, 71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1, 351, 
#&gt; 145, 301, 121), hp = c(110, 110, 93, 110, 175, 105, 245, 62, 
#&gt; 95, 123, 123, 180, 180, 180, 205, 215, 230, 66, 52, 65, 97, 150, 
#&gt; 150, 245, 175, 66, 91, 113, 264, 175, 335, 109), drat = c(3.9, 
#&gt; 3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92, 3.07, 
#&gt; 3.07, 3.07, 2.93, 3, 3.23, 4.08, 4.93, 4.22, 3.7, 2.76, 3.15, 
#&gt; 3.73, 3.08, 4.08, 4.43, 3.77, 4.22, 3.62, 3.54, 4.11), wt = c(2.62, 
#&gt; 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, 3.15, 3.44, 3.44, 
#&gt; 4.07, 3.73, 3.78, 5.25, 5.424, 5.345, 2.2, 1.615, 1.835, 2.465, 
#&gt; 3.52, 3.435, 3.84, 3.845, 1.935, 2.14, 1.513, 3.17, 2.77, 3.57, 
#&gt; 2.78), qsec = c(16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 
#&gt; 20, 22.9, 18.3, 18.9, 17.4, 17.6, 18, 17.98, 17.82, 17.42, 19.47, 
#&gt; 18.52, 19.9, 20.01, 16.87, 17.3, 15.41, 17.05, 18.9, 16.7, 16.9, 
#&gt; 14.5, 15.5, 14.6, 18.6), vs = c(0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 
#&gt; 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 
#&gt; 1), am = c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
#&gt; 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1), gear = c(4, 4, 
#&gt; 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 
#&gt; 3, 3, 4, 5, 5, 5, 5, 5, 4), carb = c(4, 4, 1, 1, 2, 1, 4, 2, 
#&gt; 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, 2, 2, 4, 
#&gt; 6, 8, 2)))
#&gt; </div><div class='input'>

<span class='co'># Specify the function name either by supplying a string</span>
<span class='co'># identifying the function (it should be visible in .env):</span>
<span class='fu'>invoke</span>(<span class='st'>"call_inspect"</span>, <span class='no'>letters</span>)</div><div class='output co'>#&gt; call_inspect(`1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, 
#&gt;     `11`, `12`, `13`, `14`, `15`, `16`, `17`, `18`, `19`, `20`, 
#&gt;     `21`, `22`, `23`, `24`, `25`, `26`)</div><div class='input'>
<span class='co'># Or by changing the .bury argument, with which you can also change</span>
<span class='co'># the argument prefix:</span>
<span class='fu'>invoke</span>(<span class='no'>call_inspect</span>, <span class='no'>mtcars</span>, <span class='kw'>.bury</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span>(<span class='st'>"inspect!"</span>, <span class='st'>"col"</span>))</div><div class='output co'>#&gt; `inspect!`(mpg = col1, cyl = col2, disp = col3, hp = col4, drat = col5, 
#&gt;     wt = col6, qsec = col7, vs = col8, am = col9, gear = col10, 
#&gt;     carb = col11)</div></span></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      <li><a href="#details">Details</a></li>
      <li><a href="#life-cycle">Life cycle</a></li>
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Lionel Henry, <a href='http://hadley.nz'>Hadley Wickham</a>.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


